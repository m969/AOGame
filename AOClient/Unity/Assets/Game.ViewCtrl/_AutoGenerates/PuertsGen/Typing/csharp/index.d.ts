
    declare namespace CS {
    //keep type incompatibility / 此属性保持类型不兼容
    const __keep_incompatibility: unique symbol;
    interface $Ref<T> {
        value: T
    }
    namespace System {
        interface Array$1<T> extends System.Array {
            get_Item(index: number):T;
            set_Item(index: number, value: T):void;
        }
    }
    type $Task<T> = System.Threading.Tasks.Task$1<T>
    namespace System {
        class Object
        {
            protected [__keep_incompatibility]: never;
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public GetHashCode () : number
            public GetType () : System.Type
            public ToString () : string
            public static ReferenceEquals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        class ValueType extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class Void extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        interface IFormattable
        {
        }
        interface IEquatable$1<T>
        {
        }
        class Single extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
        }
        interface ISpanFormattable
        {
        }
        interface IComparable
        {
        }
        interface IComparable$1<T>
        {
        }
        interface IConvertible
        {
        }
        class Boolean extends System.ValueType implements System.IComparable, System.IComparable$1<boolean>, System.IConvertible, System.IEquatable$1<boolean>
        {
            protected [__keep_incompatibility]: never;
        }
        class Int32 extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
        }
        class String extends System.Object implements System.ICloneable, System.IComparable, System.IComparable$1<string>, System.IConvertible, System.Collections.Generic.IEnumerable$1<number>, System.Collections.IEnumerable, System.IEquatable$1<string>
        {
            protected [__keep_incompatibility]: never;
        }
        interface String {
            GetLongHashCode () : bigint;
            Mode ($mode: number) : number;
            ToBytes () : System.Collections.Generic.IEnumerable$1<number>;
            ToByteArray () : System.Array$1<number>;
            ToUtf8 () : System.Array$1<number>;
            HexToBytes () : System.Array$1<number>;
            Fmt (...args: any[]) : string;
        }
        interface ICloneable
        {
        }
        class Char extends System.ValueType implements System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
        }
        class Array extends System.Object implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.ICloneable, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList
        {
            protected [__keep_incompatibility]: never;
            public get LongLength(): bigint;
            public get IsFixedSize(): boolean;
            public get IsReadOnly(): boolean;
            public get IsSynchronized(): boolean;
            public get SyncRoot(): any;
            public get Length(): number;
            public get Rank(): number;
            public static CreateInstance ($elementType: System.Type, ...lengths: bigint[]) : System.Array
            public CopyTo ($array: System.Array, $index: number) : void
            public Clone () : any
            public static BinarySearch ($array: System.Array, $value: any) : number
            public static Copy ($sourceArray: System.Array, $destinationArray: System.Array, $length: bigint) : void
            public static Copy ($sourceArray: System.Array, $sourceIndex: bigint, $destinationArray: System.Array, $destinationIndex: bigint, $length: bigint) : void
            public CopyTo ($array: System.Array, $index: bigint) : void
            public GetLongLength ($dimension: number) : bigint
            public GetValue ($index: bigint) : any
            public GetValue ($index1: bigint, $index2: bigint) : any
            public GetValue ($index1: bigint, $index2: bigint, $index3: bigint) : any
            public GetValue (...indices: bigint[]) : any
            public static BinarySearch ($array: System.Array, $index: number, $length: number, $value: any) : number
            public static BinarySearch ($array: System.Array, $value: any, $comparer: System.Collections.IComparer) : number
            public static BinarySearch ($array: System.Array, $index: number, $length: number, $value: any, $comparer: System.Collections.IComparer) : number
            public static IndexOf ($array: System.Array, $value: any) : number
            public static IndexOf ($array: System.Array, $value: any, $startIndex: number) : number
            public static IndexOf ($array: System.Array, $value: any, $startIndex: number, $count: number) : number
            public static LastIndexOf ($array: System.Array, $value: any) : number
            public static LastIndexOf ($array: System.Array, $value: any, $startIndex: number) : number
            public static LastIndexOf ($array: System.Array, $value: any, $startIndex: number, $count: number) : number
            public static Reverse ($array: System.Array) : void
            public static Reverse ($array: System.Array, $index: number, $length: number) : void
            public SetValue ($value: any, $index: bigint) : void
            public SetValue ($value: any, $index1: bigint, $index2: bigint) : void
            public SetValue ($value: any, $index1: bigint, $index2: bigint, $index3: bigint) : void
            public SetValue ($value: any, ...indices: bigint[]) : void
            public static Sort ($array: System.Array) : void
            public static Sort ($array: System.Array, $index: number, $length: number) : void
            public static Sort ($array: System.Array, $comparer: System.Collections.IComparer) : void
            public static Sort ($array: System.Array, $index: number, $length: number, $comparer: System.Collections.IComparer) : void
            public static Sort ($keys: System.Array, $items: System.Array) : void
            public static Sort ($keys: System.Array, $items: System.Array, $comparer: System.Collections.IComparer) : void
            public static Sort ($keys: System.Array, $items: System.Array, $index: number, $length: number) : void
            public static Sort ($keys: System.Array, $items: System.Array, $index: number, $length: number, $comparer: System.Collections.IComparer) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public GetLength ($dimension: number) : number
            public GetLowerBound ($dimension: number) : number
            public GetValue (...indices: number[]) : any
            public SetValue ($value: any, ...indices: number[]) : void
            public GetUpperBound ($dimension: number) : number
            public GetValue ($index: number) : any
            public GetValue ($index1: number, $index2: number) : any
            public GetValue ($index1: number, $index2: number, $index3: number) : any
            public SetValue ($value: any, $index: number) : void
            public SetValue ($value: any, $index1: number, $index2: number) : void
            public SetValue ($value: any, $index1: number, $index2: number, $index3: number) : void
            public static CreateInstance ($elementType: System.Type, $length: number) : System.Array
            public static CreateInstance ($elementType: System.Type, $length1: number, $length2: number) : System.Array
            public static CreateInstance ($elementType: System.Type, $length1: number, $length2: number, $length3: number) : System.Array
            public static CreateInstance ($elementType: System.Type, ...lengths: number[]) : System.Array
            public static CreateInstance ($elementType: System.Type, $lengths: System.Array$1<number>, $lowerBounds: System.Array$1<number>) : System.Array
            public static Clear ($array: System.Array, $index: number, $length: number) : void
            public static Copy ($sourceArray: System.Array, $destinationArray: System.Array, $length: number) : void
            public static Copy ($sourceArray: System.Array, $sourceIndex: number, $destinationArray: System.Array, $destinationIndex: number, $length: number) : void
            public static ConstrainedCopy ($sourceArray: System.Array, $sourceIndex: number, $destinationArray: System.Array, $destinationIndex: number, $length: number) : void
            public Initialize () : void
        }
        class Enum extends System.ValueType implements System.IFormattable, System.IComparable, System.IConvertible
        {
            protected [__keep_incompatibility]: never;
        }
        class Exception extends System.Object implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
        }
        interface IFormatProvider
        {
        }
        class Delegate extends System.Object implements System.Runtime.Serialization.ISerializable, System.ICloneable
        {
            protected [__keep_incompatibility]: never;
            public get Method(): System.Reflection.MethodInfo;
            public get Target(): any;
            public static CreateDelegate ($type: System.Type, $firstArgument: any, $method: System.Reflection.MethodInfo, $throwOnBindFailure: boolean) : Function
            public static CreateDelegate ($type: System.Type, $firstArgument: any, $method: System.Reflection.MethodInfo) : Function
            public static CreateDelegate ($type: System.Type, $method: System.Reflection.MethodInfo, $throwOnBindFailure: boolean) : Function
            public static CreateDelegate ($type: System.Type, $method: System.Reflection.MethodInfo) : Function
            public static CreateDelegate ($type: System.Type, $target: any, $method: string) : Function
            public static CreateDelegate ($type: System.Type, $target: System.Type, $method: string, $ignoreCase: boolean, $throwOnBindFailure: boolean) : Function
            public static CreateDelegate ($type: System.Type, $target: System.Type, $method: string) : Function
            public static CreateDelegate ($type: System.Type, $target: System.Type, $method: string, $ignoreCase: boolean) : Function
            public static CreateDelegate ($type: System.Type, $target: any, $method: string, $ignoreCase: boolean, $throwOnBindFailure: boolean) : Function
            public static CreateDelegate ($type: System.Type, $target: any, $method: string, $ignoreCase: boolean) : Function
            public DynamicInvoke (...args: any[]) : any
            public Clone () : any
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public GetInvocationList () : System.Array$1<Function>
            public static Combine ($a: Function, $b: Function) : Function
            public static Combine (...delegates: Function[]) : Function
            public static Remove ($source: Function, $value: Function) : Function
            public static RemoveAll ($source: Function, $value: Function) : Function
            public static op_Equality ($d1: Function, $d2: Function) : boolean
            public static op_Inequality ($d1: Function, $d2: Function) : boolean
        }
        interface MulticastDelegate
        { 
        (...args:any[]) : any; 
        Invoke?: (...args:any[]) => any;
        }
        var MulticastDelegate: { new (func: (...args:any[]) => any): MulticastDelegate; }
        interface Converter$2<TInput, TOutput>
        { 
        (input: TInput) : TOutput; 
        Invoke?: (input: TInput) => TOutput;
        }
        interface Predicate$1<T>
        { 
        (obj: T) : boolean; 
        Invoke?: (obj: T) => boolean;
        }
        interface Action$1<T>
        { 
        (obj: T) : void; 
        Invoke?: (obj: T) => void;
        }
        interface IDisposable
        {
        }
        interface Comparison$1<T>
        { 
        (x: T, y: T) : number; 
        Invoke?: (x: T, y: T) => number;
        }
        class Double extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
        }
        class Type extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._Type, System.Reflection.ICustomAttributeProvider, System.Reflection.IReflect
        {
            protected [__keep_incompatibility]: never;
            public static Delimiter : number
            public static EmptyTypes : System.Array$1<System.Type>
            public static Missing : any
            public static FilterAttribute : System.Reflection.MemberFilter
            public static FilterName : System.Reflection.MemberFilter
            public static FilterNameIgnoreCase : System.Reflection.MemberFilter
            public get IsSerializable(): boolean;
            public get ContainsGenericParameters(): boolean;
            public get IsVisible(): boolean;
            public get MemberType(): System.Reflection.MemberTypes;
            public get Namespace(): string;
            public get AssemblyQualifiedName(): string;
            public get FullName(): string;
            public get Assembly(): System.Reflection.Assembly;
            public get Module(): System.Reflection.Module;
            public get IsNested(): boolean;
            public get DeclaringType(): System.Type;
            public get DeclaringMethod(): System.Reflection.MethodBase;
            public get ReflectedType(): System.Type;
            public get UnderlyingSystemType(): System.Type;
            public get IsTypeDefinition(): boolean;
            public get IsArray(): boolean;
            public get IsByRef(): boolean;
            public get IsPointer(): boolean;
            public get IsConstructedGenericType(): boolean;
            public get IsGenericParameter(): boolean;
            public get IsGenericTypeParameter(): boolean;
            public get IsGenericMethodParameter(): boolean;
            public get IsGenericType(): boolean;
            public get IsGenericTypeDefinition(): boolean;
            public get IsVariableBoundArray(): boolean;
            public get IsByRefLike(): boolean;
            public get HasElementType(): boolean;
            public get GenericTypeArguments(): System.Array$1<System.Type>;
            public get GenericParameterPosition(): number;
            public get GenericParameterAttributes(): System.Reflection.GenericParameterAttributes;
            public get Attributes(): System.Reflection.TypeAttributes;
            public get IsAbstract(): boolean;
            public get IsImport(): boolean;
            public get IsSealed(): boolean;
            public get IsSpecialName(): boolean;
            public get IsClass(): boolean;
            public get IsNestedAssembly(): boolean;
            public get IsNestedFamANDAssem(): boolean;
            public get IsNestedFamily(): boolean;
            public get IsNestedFamORAssem(): boolean;
            public get IsNestedPrivate(): boolean;
            public get IsNestedPublic(): boolean;
            public get IsNotPublic(): boolean;
            public get IsPublic(): boolean;
            public get IsAutoLayout(): boolean;
            public get IsExplicitLayout(): boolean;
            public get IsLayoutSequential(): boolean;
            public get IsAnsiClass(): boolean;
            public get IsAutoClass(): boolean;
            public get IsUnicodeClass(): boolean;
            public get IsCOMObject(): boolean;
            public get IsContextful(): boolean;
            public get IsEnum(): boolean;
            public get IsMarshalByRef(): boolean;
            public get IsPrimitive(): boolean;
            public get IsValueType(): boolean;
            public get IsSignatureType(): boolean;
            public get IsSecurityCritical(): boolean;
            public get IsSecuritySafeCritical(): boolean;
            public get IsSecurityTransparent(): boolean;
            public get StructLayoutAttribute(): System.Runtime.InteropServices.StructLayoutAttribute;
            public get TypeInitializer(): System.Reflection.ConstructorInfo;
            public get TypeHandle(): System.RuntimeTypeHandle;
            public get GUID(): System.Guid;
            public get BaseType(): System.Type;
            public static get DefaultBinder(): System.Reflection.Binder;
            public get IsInterface(): boolean;
            public IsEnumDefined ($value: any) : boolean
            public GetEnumName ($value: any) : string
            public GetEnumNames () : System.Array$1<string>
            public FindInterfaces ($filter: System.Reflection.TypeFilter, $filterCriteria: any) : System.Array$1<System.Type>
            public FindMembers ($memberType: System.Reflection.MemberTypes, $bindingAttr: System.Reflection.BindingFlags, $filter: System.Reflection.MemberFilter, $filterCriteria: any) : System.Array$1<System.Reflection.MemberInfo>
            public IsSubclassOf ($c: System.Type) : boolean
            public IsAssignableFrom ($c: System.Type) : boolean
            public GetType () : System.Type
            public GetElementType () : System.Type
            public GetArrayRank () : number
            public GetGenericTypeDefinition () : System.Type
            public GetGenericArguments () : System.Array$1<System.Type>
            public GetGenericParameterConstraints () : System.Array$1<System.Type>
            public GetConstructor ($types: System.Array$1<System.Type>) : System.Reflection.ConstructorInfo
            public GetConstructor ($bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.ConstructorInfo
            public GetConstructor ($bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.ConstructorInfo
            public GetConstructors () : System.Array$1<System.Reflection.ConstructorInfo>
            public GetConstructors ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.ConstructorInfo>
            public GetEvent ($name: string) : System.Reflection.EventInfo
            public GetEvent ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.EventInfo
            public GetEvents () : System.Array$1<System.Reflection.EventInfo>
            public GetEvents ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.EventInfo>
            public GetField ($name: string) : System.Reflection.FieldInfo
            public GetField ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.FieldInfo
            public GetFields () : System.Array$1<System.Reflection.FieldInfo>
            public GetFields ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.FieldInfo>
            public GetMember ($name: string) : System.Array$1<System.Reflection.MemberInfo>
            public GetMember ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            public GetMember ($name: string, $type: System.Reflection.MemberTypes, $bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            public GetMembers () : System.Array$1<System.Reflection.MemberInfo>
            public GetMembers ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MemberInfo>
            public GetMethod ($name: string) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $types: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $genericParameterCount: number, $types: System.Array$1<System.Type>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $genericParameterCount: number, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $genericParameterCount: number, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethod ($name: string, $genericParameterCount: number, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $callConvention: System.Reflection.CallingConventions, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.MethodInfo
            public GetMethods () : System.Array$1<System.Reflection.MethodInfo>
            public GetMethods ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.MethodInfo>
            public GetNestedType ($name: string) : System.Type
            public GetNestedType ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Type
            public GetNestedTypes () : System.Array$1<System.Type>
            public GetNestedTypes ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Type>
            public GetProperty ($name: string) : System.Reflection.PropertyInfo
            public GetProperty ($name: string, $bindingAttr: System.Reflection.BindingFlags) : System.Reflection.PropertyInfo
            public GetProperty ($name: string, $returnType: System.Type) : System.Reflection.PropertyInfo
            public GetProperty ($name: string, $types: System.Array$1<System.Type>) : System.Reflection.PropertyInfo
            public GetProperty ($name: string, $returnType: System.Type, $types: System.Array$1<System.Type>) : System.Reflection.PropertyInfo
            public GetProperty ($name: string, $returnType: System.Type, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.PropertyInfo
            public GetProperty ($name: string, $bindingAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $returnType: System.Type, $types: System.Array$1<System.Type>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>) : System.Reflection.PropertyInfo
            public GetProperties () : System.Array$1<System.Reflection.PropertyInfo>
            public GetProperties ($bindingAttr: System.Reflection.BindingFlags) : System.Array$1<System.Reflection.PropertyInfo>
            public GetDefaultMembers () : System.Array$1<System.Reflection.MemberInfo>
            public static GetTypeHandle ($o: any) : System.RuntimeTypeHandle
            public static GetTypeArray ($args: System.Array$1<any>) : System.Array$1<System.Type>
            public static GetTypeCode ($type: System.Type) : System.TypeCode
            public static GetTypeFromCLSID ($clsid: System.Guid) : System.Type
            public static GetTypeFromCLSID ($clsid: System.Guid, $throwOnError: boolean) : System.Type
            public static GetTypeFromCLSID ($clsid: System.Guid, $server: string) : System.Type
            public static GetTypeFromProgID ($progID: string) : System.Type
            public static GetTypeFromProgID ($progID: string, $throwOnError: boolean) : System.Type
            public static GetTypeFromProgID ($progID: string, $server: string) : System.Type
            public InvokeMember ($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>) : any
            public InvokeMember ($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>, $culture: System.Globalization.CultureInfo) : any
            public InvokeMember ($name: string, $invokeAttr: System.Reflection.BindingFlags, $binder: System.Reflection.Binder, $target: any, $args: System.Array$1<any>, $modifiers: System.Array$1<System.Reflection.ParameterModifier>, $culture: System.Globalization.CultureInfo, $namedParameters: System.Array$1<string>) : any
            public GetInterface ($name: string) : System.Type
            public GetInterface ($name: string, $ignoreCase: boolean) : System.Type
            public GetInterfaces () : System.Array$1<System.Type>
            public GetInterfaceMap ($interfaceType: System.Type) : System.Reflection.InterfaceMapping
            public IsInstanceOfType ($o: any) : boolean
            public IsEquivalentTo ($other: System.Type) : boolean
            public GetEnumUnderlyingType () : System.Type
            public GetEnumValues () : System.Array
            public MakeArrayType () : System.Type
            public MakeArrayType ($rank: number) : System.Type
            public MakeByRefType () : System.Type
            public MakeGenericType (...typeArguments: System.Type[]) : System.Type
            public MakePointerType () : System.Type
            public static MakeGenericMethodParameter ($position: number) : System.Type
            public Equals ($o: any) : boolean
            public Equals ($o: System.Type) : boolean
            public static GetTypeFromHandle ($handle: System.RuntimeTypeHandle) : System.Type
            public static GetType ($typeName: string, $throwOnError: boolean, $ignoreCase: boolean) : System.Type
            public static GetType ($typeName: string, $throwOnError: boolean) : System.Type
            public static GetType ($typeName: string) : System.Type
            public static GetType ($typeName: string, $assemblyResolver: System.Func$2<System.Reflection.AssemblyName, System.Reflection.Assembly>, $typeResolver: System.Func$4<System.Reflection.Assembly, string, boolean, System.Type>) : System.Type
            public static GetType ($typeName: string, $assemblyResolver: System.Func$2<System.Reflection.AssemblyName, System.Reflection.Assembly>, $typeResolver: System.Func$4<System.Reflection.Assembly, string, boolean, System.Type>, $throwOnError: boolean) : System.Type
            public static GetType ($typeName: string, $assemblyResolver: System.Func$2<System.Reflection.AssemblyName, System.Reflection.Assembly>, $typeResolver: System.Func$4<System.Reflection.Assembly, string, boolean, System.Type>, $throwOnError: boolean, $ignoreCase: boolean) : System.Type
            public static op_Equality ($left: System.Type, $right: System.Type) : boolean
            public static op_Inequality ($left: System.Type, $right: System.Type) : boolean
            public static ReflectionOnlyGetType ($typeName: string, $throwIfNotFound: boolean, $ignoreCase: boolean) : System.Type
            public static GetTypeFromCLSID ($clsid: System.Guid, $server: string, $throwOnError: boolean) : System.Type
            public static GetTypeFromProgID ($progID: string, $server: string, $throwOnError: boolean) : System.Type
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        interface Type {
            HasImplementedRawGeneric ($generic: System.Type) : boolean;
        }
        class UInt64 extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<bigint>, System.IConvertible, System.IEquatable$1<bigint>
        {
            protected [__keep_incompatibility]: never;
        }
        class Int64 extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<bigint>, System.IConvertible, System.IEquatable$1<bigint>
        {
            protected [__keep_incompatibility]: never;
        }
        class Attribute extends System.Object implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
        }
        class RuntimeTypeHandle extends System.ValueType implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
        }
        enum TypeCode
        { Empty = 0, Object = 1, DBNull = 2, Boolean = 3, Char = 4, SByte = 5, Byte = 6, Int16 = 7, UInt16 = 8, Int32 = 9, UInt32 = 10, Int64 = 11, UInt64 = 12, Single = 13, Double = 14, Decimal = 15, DateTime = 16, String = 18 }
        class Guid extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<System.Guid>, System.IEquatable$1<System.Guid>
        {
            protected [__keep_incompatibility]: never;
        }
        interface Func$2<T, TResult>
        { 
        (arg: T) : TResult; 
        Invoke?: (arg: T) => TResult;
        }
        interface Func$4<T1, T2, T3, TResult>
        { 
        (arg1: T1, arg2: T2, arg3: T3) : TResult; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3) => TResult;
        }
        class UInt32 extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
        }
        interface IAsyncResult
        {
        }
        interface AsyncCallback
        { 
        (ar: System.IAsyncResult) : void; 
        Invoke?: (ar: System.IAsyncResult) => void;
        }
        var AsyncCallback: { new (func: (ar: System.IAsyncResult) => void): AsyncCallback; }
        class IntPtr extends System.ValueType implements System.Runtime.Serialization.ISerializable, System.IEquatable$1<System.IntPtr>
        {
            protected [__keep_incompatibility]: never;
        }
        class SByte extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
        }
        class Int16 extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
        }
        class Byte extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
        }
        interface Byte {
            ToHex () : string;
        }
        class MarshalByRefObject extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        interface IAsyncDisposable
        {
        }
        class Nullable$1<T> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        interface Func$1<TResult>
        { 
        () : TResult; 
        Invoke?: () => TResult;
        }
        interface Action
        { 
        () : void; 
        Invoke?: () => void;
        }
        var Action: { new (func: () => void): Action; }
        interface Action$2<T1, T2>
        { 
        (arg1: T1, arg2: T2) : void; 
        Invoke?: (arg1: T1, arg2: T2) => void;
        }
        class DateTime extends System.ValueType implements System.IFormattable, System.Runtime.Serialization.ISerializable, System.ISpanFormattable, System.IComparable, System.IComparable$1<Date>, System.IConvertible, System.IEquatable$1<Date>
        {
            protected [__keep_incompatibility]: never;
        }
        class UInt16 extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<number>, System.IConvertible, System.IEquatable$1<number>
        {
            protected [__keep_incompatibility]: never;
        }
        class SystemException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
        }
        interface Action$3<T1, T2, T3>
        { 
        (arg1: T1, arg2: T2, arg3: T3) : void; 
        Invoke?: (arg1: T1, arg2: T2, arg3: T3) => void;
        }
        class ValueTuple$2<T1, T2> extends System.ValueType implements System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.Runtime.CompilerServices.ITuple, System.IComparable, System.IComparable$1<System.ValueTuple$2<T1, T2>>, System.IValueTupleInternal, System.IEquatable$1<System.ValueTuple$2<T1, T2>>
        {
            protected [__keep_incompatibility]: never;
        }
        interface IValueTupleInternal extends System.Runtime.CompilerServices.ITuple
        {
        }
        class EventArgs extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class TimeSpan extends System.ValueType implements System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<System.TimeSpan>, System.IEquatable$1<System.TimeSpan>
        {
            protected [__keep_incompatibility]: never;
        }
        class Decimal extends System.ValueType implements System.Runtime.Serialization.IDeserializationCallback, System.IFormattable, System.ISpanFormattable, System.IComparable, System.IComparable$1<System.Decimal>, System.IConvertible, System.IEquatable$1<System.Decimal>
        {
            protected [__keep_incompatibility]: never;
        }
        class ArraySegment$1<T> extends System.ValueType implements System.Collections.Generic.IReadOnlyList$1<T>, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IList$1<T>, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Collections.Generic.ICollection$1<T>
        {
            protected [__keep_incompatibility]: never;
        }
        interface EventHandler$1<TEventArgs>
        { 
        (sender: any, e: TEventArgs) : void; 
        Invoke?: (sender: any, e: TEventArgs) => void;
        }
        interface Func$3<T1, T2, TResult>
        { 
        (arg1: T1, arg2: T2) : TResult; 
        Invoke?: (arg1: T1, arg2: T2) => TResult;
        }
        class ApplicationException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine {
        /** Class containing methods to ease debugging while developing a game.
        */
        class Debug extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Get default debug logger.
            */
            public static get unityLogger(): UnityEngine.ILogger;
            /** Reports whether the development console is visible. The development console cannot be made to appear using:
            */
            public static get developerConsoleVisible(): boolean;
            public static set developerConsoleVisible(value: boolean);
            /** In the Build Settings dialog there is a check box called "Development Build".
            */
            public static get isDebugBuild(): boolean;
            /** Draws a line between specified start and end points.
            * @param start Point in world space where the line should start.
            * @param end Point in world space where the line should end.
            * @param color Color of the line.
            * @param duration How long the line should be visible for.
            * @param depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawLine ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number) : void
            /** Draws a line between specified start and end points.
            * @param start Point in world space where the line should start.
            * @param end Point in world space where the line should end.
            * @param color Color of the line.
            * @param duration How long the line should be visible for.
            * @param depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawLine ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $color: UnityEngine.Color) : void
            /** Draws a line between specified start and end points.
            * @param start Point in world space where the line should start.
            * @param end Point in world space where the line should end.
            * @param color Color of the line.
            * @param duration How long the line should be visible for.
            * @param depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawLine ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3) : void
            /** Draws a line between specified start and end points.
            * @param start Point in world space where the line should start.
            * @param end Point in world space where the line should end.
            * @param color Color of the line.
            * @param duration How long the line should be visible for.
            * @param depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawLine ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number, $depthTest: boolean) : void
            /** Draws a line from start to start + dir in world coordinates.
            * @param start Point in world space where the ray should start.
            * @param dir Direction and length of the ray.
            * @param color Color of the drawn line.
            * @param duration How long the line will be visible for (in seconds).
            * @param depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawRay ($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number) : void
            /** Draws a line from start to start + dir in world coordinates.
            * @param start Point in world space where the ray should start.
            * @param dir Direction and length of the ray.
            * @param color Color of the drawn line.
            * @param duration How long the line will be visible for (in seconds).
            * @param depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawRay ($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3, $color: UnityEngine.Color) : void
            /** Draws a line from start to start + dir in world coordinates.
            * @param start Point in world space where the ray should start.
            * @param dir Direction and length of the ray.
            * @param color Color of the drawn line.
            * @param duration How long the line will be visible for (in seconds).
            * @param depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawRay ($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3) : void
            /** Draws a line from start to start + dir in world coordinates.
            * @param start Point in world space where the ray should start.
            * @param dir Direction and length of the ray.
            * @param color Color of the drawn line.
            * @param duration How long the line will be visible for (in seconds).
            * @param depthTest Determines whether objects closer to the camera obscure the line.
            */
            public static DrawRay ($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number, $depthTest: boolean) : void
            public static Break () : void
            public static DebugBreak () : void
            /** Logs a message to the Unity Console.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public static Log ($message: any) : void
            /** Logs a message to the Unity Console.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public static Log ($message: any, $context: UnityEngine.Object) : void
            /** Logs a formatted message to the Unity Console.
            * @param format A composite format string.
            * @param args Format arguments.
            * @param context Object to which the message applies.
            * @param logType Type of message e.g. warn or error etc.
            * @param logOptions Option flags to treat the log message special.
            */
            public static LogFormat ($format: string, ...args: any[]) : void
            /** Logs a formatted message to the Unity Console.
            * @param format A composite format string.
            * @param args Format arguments.
            * @param context Object to which the message applies.
            * @param logType Type of message e.g. warn or error etc.
            * @param logOptions Option flags to treat the log message special.
            */
            public static LogFormat ($context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** Logs a formatted message to the Unity Console.
            * @param format A composite format string.
            * @param args Format arguments.
            * @param context Object to which the message applies.
            * @param logType Type of message e.g. warn or error etc.
            * @param logOptions Option flags to treat the log message special.
            */
            public static LogFormat ($logType: UnityEngine.LogType, $logOptions: UnityEngine.LogOption, $context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** A variant of Debug.Log that logs an error message to the console.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public static LogError ($message: any) : void
            /** A variant of Debug.Log that logs an error message to the console.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public static LogError ($message: any, $context: UnityEngine.Object) : void
            /** Logs a formatted error message to the Unity console.
            * @param format A composite format string.
            * @param args Format arguments.
            * @param context Object to which the message applies.
            */
            public static LogErrorFormat ($format: string, ...args: any[]) : void
            /** Logs a formatted error message to the Unity console.
            * @param format A composite format string.
            * @param args Format arguments.
            * @param context Object to which the message applies.
            */
            public static LogErrorFormat ($context: UnityEngine.Object, $format: string, ...args: any[]) : void
            public static ClearDeveloperConsole () : void
            /** A variant of Debug.Log that logs an error message to the console.
            * @param context Object to which the message applies.
            * @param exception Runtime Exception.
            */
            public static LogException ($exception: System.Exception) : void
            /** A variant of Debug.Log that logs an error message to the console.
            * @param context Object to which the message applies.
            * @param exception Runtime Exception.
            */
            public static LogException ($exception: System.Exception, $context: UnityEngine.Object) : void
            /** A variant of Debug.Log that logs a warning message to the console.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public static LogWarning ($message: any) : void
            /** A variant of Debug.Log that logs a warning message to the console.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public static LogWarning ($message: any, $context: UnityEngine.Object) : void
            /** Logs a formatted warning message to the Unity Console.
            * @param format A composite format string.
            * @param args Format arguments.
            * @param context Object to which the message applies.
            */
            public static LogWarningFormat ($format: string, ...args: any[]) : void
            /** Logs a formatted warning message to the Unity Console.
            * @param format A composite format string.
            * @param args Format arguments.
            * @param context Object to which the message applies.
            */
            public static LogWarningFormat ($context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** Assert a condition and logs an error message to the Unity console on failure.
            * @param condition Condition you expect to be true.
            * @param context Object to which the message applies.
            * @param message String or object to be converted to string representation for display.
            */
            public static Assert ($condition: boolean) : void
            /** Assert a condition and logs an error message to the Unity console on failure.
            * @param condition Condition you expect to be true.
            * @param context Object to which the message applies.
            * @param message String or object to be converted to string representation for display.
            */
            public static Assert ($condition: boolean, $context: UnityEngine.Object) : void
            /** Assert a condition and logs an error message to the Unity console on failure.
            * @param condition Condition you expect to be true.
            * @param context Object to which the message applies.
            * @param message String or object to be converted to string representation for display.
            */
            public static Assert ($condition: boolean, $message: any) : void
            public static Assert ($condition: boolean, $message: string) : void
            /** Assert a condition and logs an error message to the Unity console on failure.
            * @param condition Condition you expect to be true.
            * @param context Object to which the message applies.
            * @param message String or object to be converted to string representation for display.
            */
            public static Assert ($condition: boolean, $message: any, $context: UnityEngine.Object) : void
            public static Assert ($condition: boolean, $message: string, $context: UnityEngine.Object) : void
            /** Assert a condition and logs a formatted error message to the Unity console on failure.
            * @param condition Condition you expect to be true.
            * @param format A composite format string.
            * @param args Format arguments.
            * @param context Object to which the message applies.
            */
            public static AssertFormat ($condition: boolean, $format: string, ...args: any[]) : void
            /** Assert a condition and logs a formatted error message to the Unity console on failure.
            * @param condition Condition you expect to be true.
            * @param format A composite format string.
            * @param args Format arguments.
            * @param context Object to which the message applies.
            */
            public static AssertFormat ($condition: boolean, $context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** A variant of Debug.Log that logs an assertion message to the console.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public static LogAssertion ($message: any) : void
            /** A variant of Debug.Log that logs an assertion message to the console.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public static LogAssertion ($message: any, $context: UnityEngine.Object) : void
            /** Logs a formatted assertion message to the Unity console.
            * @param format A composite format string.
            * @param args Format arguments.
            * @param context Object to which the message applies.
            */
            public static LogAssertionFormat ($format: string, ...args: any[]) : void
            /** Logs a formatted assertion message to the Unity console.
            * @param format A composite format string.
            * @param args Format arguments.
            * @param context Object to which the message applies.
            */
            public static LogAssertionFormat ($context: UnityEngine.Object, $format: string, ...args: any[]) : void
            public constructor ()
        }
        interface ILogger extends UnityEngine.ILogHandler
        {
            /** Set Logger.ILogHandler.
            */
            logHandler : UnityEngine.ILogHandler
            /** To runtime toggle debug logging [ON/OFF].
            */
            logEnabled : boolean
            /** To selective enable debug log message.
            */
            filterLogType : UnityEngine.LogType
            /** Check logging is enabled based on the LogType.
            * @returns Retrun true in case logs of LogType will be logged otherwise returns false. 
            */
            IsLogTypeAllowed ($logType: UnityEngine.LogType) : boolean
            /** Logs message to the Unity Console using default logger.
            */
            Log ($logType: UnityEngine.LogType, $message: any) : void
            /** Logs message to the Unity Console using default logger.
            */
            Log ($logType: UnityEngine.LogType, $message: any, $context: UnityEngine.Object) : void
            /** Logs message to the Unity Console using default logger.
            */
            Log ($logType: UnityEngine.LogType, $tag: string, $message: any) : void
            /** Logs message to the Unity Console using default logger.
            */
            Log ($logType: UnityEngine.LogType, $tag: string, $message: any, $context: UnityEngine.Object) : void
            /** Logs message to the Unity Console using default logger.
            */
            Log ($message: any) : void
            /** Logs message to the Unity Console using default logger.
            */
            Log ($tag: string, $message: any) : void
            /** Logs message to the Unity Console using default logger.
            */
            Log ($tag: string, $message: any, $context: UnityEngine.Object) : void
            /** A variant of Logger.Log that logs an warning message.
            */
            LogWarning ($tag: string, $message: any) : void
            /** A variant of Logger.Log that logs an warning message.
            */
            LogWarning ($tag: string, $message: any, $context: UnityEngine.Object) : void
            /** A variant of ILogger.Log that logs an error message.
            */
            LogError ($tag: string, $message: any) : void
            /** A variant of ILogger.Log that logs an error message.
            */
            LogError ($tag: string, $message: any, $context: UnityEngine.Object) : void
            /** Logs a formatted message.
            */
            LogFormat ($logType: UnityEngine.LogType, $format: string, ...args: any[]) : void
            /** A variant of ILogger.Log that logs an exception message.
            */
            LogException ($exception: System.Exception) : void
            /** Logs a formatted message.
            * @param logType The type of the log message.
            * @param context Object to which the message applies.
            * @param format A composite format string.
            * @param args Format arguments.
            */
            LogFormat ($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** A variant of ILogHandler.LogFormat that logs an exception message.
            * @param exception Runtime Exception.
            * @param context Object to which the message applies.
            */
            LogException ($exception: System.Exception, $context: UnityEngine.Object) : void
        }
        interface ILogHandler
        {
            /** Logs a formatted message.
            * @param logType The type of the log message.
            * @param context Object to which the message applies.
            * @param format A composite format string.
            * @param args Format arguments.
            */
            LogFormat ($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]) : void
            /** A variant of ILogHandler.LogFormat that logs an exception message.
            * @param exception Runtime Exception.
            * @param context Object to which the message applies.
            */
            LogException ($exception: System.Exception, $context: UnityEngine.Object) : void
        }
        /** Representation of 3D vectors and points.
        */
        class Vector3 extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Vector3>
        {
            protected [__keep_incompatibility]: never;
            public static kEpsilon : number
            public static kEpsilonNormalSqrt : number
            /** X component of the vector.
            */
            public x : number
            /** Y component of the vector.
            */
            public y : number
            /** Z component of the vector.
            */
            public z : number
            /** Returns this vector with a magnitude of 1 (Read Only).
            */
            public get normalized(): UnityEngine.Vector3;
            /** Returns the length of this vector (Read Only).
            */
            public get magnitude(): number;
            /** Returns the squared length of this vector (Read Only).
            */
            public get sqrMagnitude(): number;
            /** Shorthand for writing Vector3(0, 0, 0).
            */
            public static get zero(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(1, 1, 1).
            */
            public static get one(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(0, 0, 1).
            */
            public static get forward(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(0, 0, -1).
            */
            public static get back(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(0, 1, 0).
            */
            public static get up(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(0, -1, 0).
            */
            public static get down(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(-1, 0, 0).
            */
            public static get left(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(1, 0, 0).
            */
            public static get right(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity).
            */
            public static get positiveInfinity(): UnityEngine.Vector3;
            /** Shorthand for writing Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity).
            */
            public static get negativeInfinity(): UnityEngine.Vector3;
            /** Spherically interpolates between two vectors.
            */
            public static Slerp ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number) : UnityEngine.Vector3
            /** Spherically interpolates between two vectors.
            */
            public static SlerpUnclamped ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number) : UnityEngine.Vector3
            /** Makes vectors normalized and orthogonal to each other.
            */
            public static OrthoNormalize ($normal: $Ref<UnityEngine.Vector3>, $tangent: $Ref<UnityEngine.Vector3>) : void
            /** Makes vectors normalized and orthogonal to each other.
            */
            public static OrthoNormalize ($normal: $Ref<UnityEngine.Vector3>, $tangent: $Ref<UnityEngine.Vector3>, $binormal: $Ref<UnityEngine.Vector3>) : void
            /** Rotates a vector current towards target.
            * @param current The vector being managed.
            * @param target The vector.
            * @param maxRadiansDelta The maximum angle in radians allowed for this rotation.
            * @param maxMagnitudeDelta The maximum allowed change in vector magnitude for this rotation.
            * @returns The location that RotateTowards generates. 
            */
            public static RotateTowards ($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $maxRadiansDelta: number, $maxMagnitudeDelta: number) : UnityEngine.Vector3
            /** Linearly interpolates between two points.
            * @param a Start value, returned when t = 0.
            * @param b End value, returned when t = 1.
            * @param t Value used to interpolate between a and b.
            * @returns Interpolated value, equals to a + (b - a) * t. 
            */
            public static Lerp ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number) : UnityEngine.Vector3
            /** Linearly interpolates between two vectors.
            */
            public static LerpUnclamped ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number) : UnityEngine.Vector3
            /** Calculate a position between the points specified by current and target, moving no farther than the distance specified by maxDistanceDelta.
            * @param current The position to move from.
            * @param target The position to move towards.
            * @param maxDistanceDelta Distance to move current per call.
            * @returns The new position. 
            */
            public static MoveTowards ($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $maxDistanceDelta: number) : UnityEngine.Vector3
            /** Gradually changes a vector towards a desired goal over time.
            * @param current The current position.
            * @param target The position we are trying to reach.
            * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param maxSpeed Optionally allows you to clamp the maximum speed.
            * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number, $maxSpeed: number) : UnityEngine.Vector3
            /** Gradually changes a vector towards a desired goal over time.
            * @param current The current position.
            * @param target The position we are trying to reach.
            * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param maxSpeed Optionally allows you to clamp the maximum speed.
            * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number) : UnityEngine.Vector3
            /** Gradually changes a vector towards a desired goal over time.
            * @param current The current position.
            * @param target The position we are trying to reach.
            * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param maxSpeed Optionally allows you to clamp the maximum speed.
            * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number, $maxSpeed: number, $deltaTime: number) : UnityEngine.Vector3
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Set x, y and z components of an existing Vector3.
            */
            public Set ($newX: number, $newY: number, $newZ: number) : void
            /** Multiplies two vectors component-wise.
            */
            public static Scale ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Multiplies every component of this vector by the same component of scale.
            */
            public Scale ($scale: UnityEngine.Vector3) : void
            /** Cross Product of two vectors.
            */
            public static Cross ($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Returns true if the given vector is exactly equal to this vector.
            */
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Vector3) : boolean
            /** Reflects a vector off the plane defined by a normal.
            */
            public static Reflect ($inDirection: UnityEngine.Vector3, $inNormal: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Makes this vector have a magnitude of 1.
            */
            public static Normalize ($value: UnityEngine.Vector3) : UnityEngine.Vector3
            public Normalize () : void
            /** Dot Product of two vectors.
            */
            public static Dot ($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3) : number
            /** Projects a vector onto another vector.
            */
            public static Project ($vector: UnityEngine.Vector3, $onNormal: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Projects a vector onto a plane defined by a normal orthogonal to the plane.
            * @param planeNormal The direction from the vector towards the plane.
            * @param vector The location of the vector above the plane.
            * @returns The location of the vector on the plane. 
            */
            public static ProjectOnPlane ($vector: UnityEngine.Vector3, $planeNormal: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Calculates the angle between vectors from and.
            * @param from The vector from which the angular difference is measured.
            * @param to The vector to which the angular difference is measured.
            * @returns The angle in degrees between the two vectors. 
            */
            public static Angle ($from: UnityEngine.Vector3, $to: UnityEngine.Vector3) : number
            /** Calculates the signed angle between vectors from and to in relation to axis.
            * @param from The vector from which the angular difference is measured.
            * @param to The vector to which the angular difference is measured.
            * @param axis A vector around which the other vectors are rotated.
            * @returns Returns the signed angle between from and to in degrees. 
            */
            public static SignedAngle ($from: UnityEngine.Vector3, $to: UnityEngine.Vector3, $axis: UnityEngine.Vector3) : number
            /** Returns the distance between a and b.
            */
            public static Distance ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3) : number
            /** Returns a copy of vector with its magnitude clamped to maxLength.
            */
            public static ClampMagnitude ($vector: UnityEngine.Vector3, $maxLength: number) : UnityEngine.Vector3
            public static Magnitude ($vector: UnityEngine.Vector3) : number
            public static SqrMagnitude ($vector: UnityEngine.Vector3) : number
            /** Returns a vector that is made from the smallest components of two vectors.
            */
            public static Min ($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Returns a vector that is made from the largest components of two vectors.
            */
            public static Max ($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3) : UnityEngine.Vector3
            public static op_Addition ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3) : UnityEngine.Vector3
            public static op_Subtraction ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3) : UnityEngine.Vector3
            public static op_UnaryNegation ($a: UnityEngine.Vector3) : UnityEngine.Vector3
            public static op_Multiply ($a: UnityEngine.Vector3, $d: number) : UnityEngine.Vector3
            public static op_Multiply ($d: number, $a: UnityEngine.Vector3) : UnityEngine.Vector3
            public static op_Division ($a: UnityEngine.Vector3, $d: number) : UnityEngine.Vector3
            public static op_Equality ($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3) : boolean
            public static op_Inequality ($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3) : boolean
            public ToString () : string
            /** Returns a formatted string for this vector.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this vector.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($x: number, $y: number, $z: number)
            public constructor ($x: number, $y: number)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** Representation of RGBA colors.
        */
        class Color extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Color>
        {
            protected [__keep_incompatibility]: never;
            /** Red component of the color.
            */
            public r : number
            /** Green component of the color.
            */
            public g : number
            /** Blue component of the color.
            */
            public b : number
            /** Alpha component of the color (0 is transparent, 1 is opaque).
            */
            public a : number
            /** Solid red. RGBA is (1, 0, 0, 1).
            */
            public static get red(): UnityEngine.Color;
            /** Solid green. RGBA is (0, 1, 0, 1).
            */
            public static get green(): UnityEngine.Color;
            /** Solid blue. RGBA is (0, 0, 1, 1).
            */
            public static get blue(): UnityEngine.Color;
            /** Solid white. RGBA is (1, 1, 1, 1).
            */
            public static get white(): UnityEngine.Color;
            /** Solid black. RGBA is (0, 0, 0, 1).
            */
            public static get black(): UnityEngine.Color;
            /** Yellow. RGBA is (1, 0.92, 0.016, 1), but the color is nice to look at!
            */
            public static get yellow(): UnityEngine.Color;
            /** Cyan. RGBA is (0, 1, 1, 1).
            */
            public static get cyan(): UnityEngine.Color;
            /** Magenta. RGBA is (1, 0, 1, 1).
            */
            public static get magenta(): UnityEngine.Color;
            /** Gray. RGBA is (0.5, 0.5, 0.5, 1).
            */
            public static get gray(): UnityEngine.Color;
            /** English spelling for gray. RGBA is the same (0.5, 0.5, 0.5, 1).
            */
            public static get grey(): UnityEngine.Color;
            /** Completely transparent. RGBA is (0, 0, 0, 0).
            */
            public static get clear(): UnityEngine.Color;
            /** The grayscale value of the color. (Read Only)
            */
            public get grayscale(): number;
            /** A linear value of an sRGB color.
            */
            public get linear(): UnityEngine.Color;
            /** A version of the color that has had the gamma curve applied.
            */
            public get gamma(): UnityEngine.Color;
            /** Returns the maximum color component value: Max(r,g,b).
            */
            public get maxColorComponent(): number;
            public ToString () : string
            /** Returns a formatted string of this color.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string of this color.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Color) : boolean
            public static op_Addition ($a: UnityEngine.Color, $b: UnityEngine.Color) : UnityEngine.Color
            public static op_Subtraction ($a: UnityEngine.Color, $b: UnityEngine.Color) : UnityEngine.Color
            public static op_Multiply ($a: UnityEngine.Color, $b: UnityEngine.Color) : UnityEngine.Color
            public static op_Multiply ($a: UnityEngine.Color, $b: number) : UnityEngine.Color
            public static op_Multiply ($b: number, $a: UnityEngine.Color) : UnityEngine.Color
            public static op_Division ($a: UnityEngine.Color, $b: number) : UnityEngine.Color
            public static op_Equality ($lhs: UnityEngine.Color, $rhs: UnityEngine.Color) : boolean
            public static op_Inequality ($lhs: UnityEngine.Color, $rhs: UnityEngine.Color) : boolean
            /** Linearly interpolates between colors a and b by t.
            * @param a Color a.
            * @param b Color b.
            * @param t Float for combining a and b.
            */
            public static Lerp ($a: UnityEngine.Color, $b: UnityEngine.Color, $t: number) : UnityEngine.Color
            /** Linearly interpolates between colors a and b by t.
            */
            public static LerpUnclamped ($a: UnityEngine.Color, $b: UnityEngine.Color, $t: number) : UnityEngine.Color
            public static op_Implicit ($c: UnityEngine.Color) : UnityEngine.Vector4
            public static op_Implicit ($v: UnityEngine.Vector4) : UnityEngine.Color
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Calculates the hue, saturation and value of an RGB input color.
            * @param rgbColor An input color.
            * @param H Output variable for hue.
            * @param S Output variable for saturation.
            * @param V Output variable for value.
            */
            public static RGBToHSV ($rgbColor: UnityEngine.Color, $H: $Ref<number>, $S: $Ref<number>, $V: $Ref<number>) : void
            /** Creates an RGB colour from HSV input.
            * @param H Hue [0..1].
            * @param S Saturation [0..1].
            * @param V Brightness value [0..1].
            * @param hdr Output HDR colours. If true, the returned colour will not be clamped to [0..1].
            * @returns An opaque colour with HSV matching the input. 
            */
            public static HSVToRGB ($H: number, $S: number, $V: number) : UnityEngine.Color
            /** Creates an RGB colour from HSV input.
            * @param H Hue [0..1].
            * @param S Saturation [0..1].
            * @param V Brightness value [0..1].
            * @param hdr Output HDR colours. If true, the returned colour will not be clamped to [0..1].
            * @returns An opaque colour with HSV matching the input. 
            */
            public static HSVToRGB ($H: number, $S: number, $V: number, $hdr: boolean) : UnityEngine.Color
            public constructor ($r: number, $g: number, $b: number, $a: number)
            public constructor ($r: number, $g: number, $b: number)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** Base class for all objects Unity can reference.
        */
        class Object extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The name of the object.
            */
            public get name(): string;
            public set name(value: string);
            /** Should the object be hidden, saved with the Scene or modifiable by the user?
            */
            public get hideFlags(): UnityEngine.HideFlags;
            public set hideFlags(value: UnityEngine.HideFlags);
            public GetInstanceID () : number
            public static op_Implicit ($exists: UnityEngine.Object) : boolean
            /** Clones the object original and returns the clone.
            * @param original An existing object that you want to make a copy of.
            * @param position Position for the new object.
            * @param rotation Orientation of the new object.
            * @param parent Parent that will be assigned to the new object.
            * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
            * @returns The instantiated clone. 
            */
            public static Instantiate ($original: UnityEngine.Object, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : UnityEngine.Object
            /** Clones the object original and returns the clone.
            * @param original An existing object that you want to make a copy of.
            * @param position Position for the new object.
            * @param rotation Orientation of the new object.
            * @param parent Parent that will be assigned to the new object.
            * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
            * @returns The instantiated clone. 
            */
            public static Instantiate ($original: UnityEngine.Object, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $parent: UnityEngine.Transform) : UnityEngine.Object
            /** Clones the object original and returns the clone.
            * @param original An existing object that you want to make a copy of.
            * @param position Position for the new object.
            * @param rotation Orientation of the new object.
            * @param parent Parent that will be assigned to the new object.
            * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
            * @returns The instantiated clone. 
            */
            public static Instantiate ($original: UnityEngine.Object) : UnityEngine.Object
            /** Clones the object original and returns the clone.
            * @param original An existing object that you want to make a copy of.
            * @param position Position for the new object.
            * @param rotation Orientation of the new object.
            * @param parent Parent that will be assigned to the new object.
            * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
            * @returns The instantiated clone. 
            */
            public static Instantiate ($original: UnityEngine.Object, $parent: UnityEngine.Transform) : UnityEngine.Object
            /** Clones the object original and returns the clone.
            * @param original An existing object that you want to make a copy of.
            * @param position Position for the new object.
            * @param rotation Orientation of the new object.
            * @param parent Parent that will be assigned to the new object.
            * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
            * @returns The instantiated clone. 
            */
            public static Instantiate ($original: UnityEngine.Object, $parent: UnityEngine.Transform, $instantiateInWorldSpace: boolean) : UnityEngine.Object
            public static Instantiate ($original: UnityEngine.Object, $parent: UnityEngine.Transform, $worldPositionStays: boolean) : UnityEngine.Object
            /** Removes a GameObject, component or asset.
            * @param obj The object to destroy.
            * @param t The optional amount of time to delay before destroying the object.
            */
            public static Destroy ($obj: UnityEngine.Object, $t: number) : void
            /** Removes a GameObject, component or asset.
            * @param obj The object to destroy.
            * @param t The optional amount of time to delay before destroying the object.
            */
            public static Destroy ($obj: UnityEngine.Object) : void
            /** Destroys the object obj immediately. You are strongly recommended to use Destroy instead.
            * @param obj Object to be destroyed.
            * @param allowDestroyingAssets Set to true to allow assets to be destroyed.
            */
            public static DestroyImmediate ($obj: UnityEngine.Object, $allowDestroyingAssets: boolean) : void
            /** Destroys the object obj immediately. You are strongly recommended to use Destroy instead.
            * @param obj Object to be destroyed.
            * @param allowDestroyingAssets Set to true to allow assets to be destroyed.
            */
            public static DestroyImmediate ($obj: UnityEngine.Object) : void
            /** Gets a list of all loaded objects of Type type.
            * @param type The type of object to find.
            * @param includeInactive If true, components attached to inactive GameObjects are also included.
            * @returns The array of objects found matching the type specified. 
            */
            public static FindObjectsOfType ($type: System.Type) : System.Array$1<UnityEngine.Object>
            /** Gets a list of all loaded objects of Type type.
            * @param type The type of object to find.
            * @param includeInactive If true, components attached to inactive GameObjects are also included.
            * @returns The array of objects found matching the type specified. 
            */
            public static FindObjectsOfType ($type: System.Type, $includeInactive: boolean) : System.Array$1<UnityEngine.Object>
            /** Retrieves a list of all loaded objects of Type type.
            * @param type The type of object to find.
            * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
            * @param sortMode Whether and how to sort the returned array. Not sorting the array makes this function run significantly faster.
            * @returns The array of objects found matching the type specified. 
            */
            public static FindObjectsByType ($type: System.Type, $sortMode: UnityEngine.FindObjectsSortMode) : System.Array$1<UnityEngine.Object>
            /** Retrieves a list of all loaded objects of Type type.
            * @param type The type of object to find.
            * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
            * @param sortMode Whether and how to sort the returned array. Not sorting the array makes this function run significantly faster.
            * @returns The array of objects found matching the type specified. 
            */
            public static FindObjectsByType ($type: System.Type, $findObjectsInactive: UnityEngine.FindObjectsInactive, $sortMode: UnityEngine.FindObjectsSortMode) : System.Array$1<UnityEngine.Object>
            /** Do not destroy the target Object when loading a new Scene.
            * @param target An Object not destroyed on Scene change.
            */
            public static DontDestroyOnLoad ($target: UnityEngine.Object) : void
            /** Returns the first active loaded object of Type type.
            * @param type The type of object to find.
            * @returns Object The first active loaded object that matches the specified type. It returns null if no Object matches the type. 
            */
            public static FindObjectOfType ($type: System.Type) : UnityEngine.Object
            /** Retrieves the first active loaded object of Type type.
            * @param type The type of object to find.
            * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
            * @returns Returns the first active loaded object that matches the specified type. If no object matches the specified type, returns null. 
            */
            public static FindFirstObjectByType ($type: System.Type) : UnityEngine.Object
            /** Retrieves any active loaded object of Type type.
            * @param type The type of object to find.
            * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
            * @returns Returns an arbitrary active loaded object that matches the specified type. If no object matches the specified type, returns null. 
            */
            public static FindAnyObjectByType ($type: System.Type) : UnityEngine.Object
            /** Returns the first active loaded object of Type type.
            * @param type The type of object to find.
            * @returns Object The first active loaded object that matches the specified type. It returns null if no Object matches the type. 
            */
            public static FindObjectOfType ($type: System.Type, $includeInactive: boolean) : UnityEngine.Object
            /** Retrieves the first active loaded object of Type type.
            * @param type The type of object to find.
            * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
            * @returns Returns the first active loaded object that matches the specified type. If no object matches the specified type, returns null. 
            */
            public static FindFirstObjectByType ($type: System.Type, $findObjectsInactive: UnityEngine.FindObjectsInactive) : UnityEngine.Object
            /** Retrieves any active loaded object of Type type.
            * @param type The type of object to find.
            * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
            * @returns Returns an arbitrary active loaded object that matches the specified type. If no object matches the specified type, returns null. 
            */
            public static FindAnyObjectByType ($type: System.Type, $findObjectsInactive: UnityEngine.FindObjectsInactive) : UnityEngine.Object
            public static op_Equality ($x: UnityEngine.Object, $y: UnityEngine.Object) : boolean
            public static op_Inequality ($x: UnityEngine.Object, $y: UnityEngine.Object) : boolean
            public constructor ()
        }
        /** The type of the log message in Debug.unityLogger.Log or delegate registered with Application.RegisterLogCallback.
        */
        enum LogType
        { Error = 0, Assert = 1, Warning = 2, Log = 3, Exception = 4 }
        /** Option flags for specifying special treatment of a log message.
        */
        enum LogOption
        { None = 0, NoStacktrace = 1 }
        /** Provides an interface to get time information from Unity.
        */
        class Time extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The time at the beginning of this frame (Read Only).
            */
            public static get time(): number;
            /** The double precision time at the beginning of this frame (Read Only). This is the time in seconds since the start of the game.
            */
            public static get timeAsDouble(): number;
            /** The time since this frame started (Read Only). This is the time in seconds since the last non-additive scene has finished loading.
            */
            public static get timeSinceLevelLoad(): number;
            /** The double precision time since this frame started (Read Only). This is the time in seconds since the last non-additive scene has finished loading.
            */
            public static get timeSinceLevelLoadAsDouble(): number;
            /** The interval in seconds from the last frame to the current one (Read Only).
            */
            public static get deltaTime(): number;
            /** The time since the last MonoBehaviour.FixedUpdate started (Read Only). This is the time in seconds since the start of the game.
            */
            public static get fixedTime(): number;
            /** The double precision time since the last MonoBehaviour.FixedUpdate started (Read Only). This is the time in seconds since the start of the game.
            */
            public static get fixedTimeAsDouble(): number;
            /** The timeScale-independent time for this frame (Read Only). This is the time in seconds since the start of the game.
            */
            public static get unscaledTime(): number;
            /** The double precision timeScale-independent time for this frame (Read Only). This is the time in seconds since the start of the game.
            */
            public static get unscaledTimeAsDouble(): number;
            /** The timeScale-independent time at the beginning of the last MonoBehaviour.FixedUpdate phase (Read Only). This is the time in seconds since the start of the game.
            */
            public static get fixedUnscaledTime(): number;
            /** The double precision timeScale-independent time at the beginning of the last MonoBehaviour.FixedUpdate (Read Only). This is the time in seconds since the start of the game.
            */
            public static get fixedUnscaledTimeAsDouble(): number;
            /** The timeScale-independent interval in seconds from the last frame to the current one (Read Only).
            */
            public static get unscaledDeltaTime(): number;
            /** The timeScale-independent interval in seconds from the last MonoBehaviour.FixedUpdate phase to the current one (Read Only).
            */
            public static get fixedUnscaledDeltaTime(): number;
            /** The interval in seconds at which physics and other fixed frame rate updates (like MonoBehaviour's MonoBehaviour.FixedUpdate) are performed.
            */
            public static get fixedDeltaTime(): number;
            public static set fixedDeltaTime(value: number);
            /** The maximum value of Time.deltaTime in any given frame. This is a time in seconds that limits the increase of Time.time between two frames.
            */
            public static get maximumDeltaTime(): number;
            public static set maximumDeltaTime(value: number);
            /** A smoothed out Time.deltaTime (Read Only).
            */
            public static get smoothDeltaTime(): number;
            /** The maximum time a frame can spend on particle updates. If the frame takes longer than this, then updates are split into multiple smaller updates.
            */
            public static get maximumParticleDeltaTime(): number;
            public static set maximumParticleDeltaTime(value: number);
            /** The scale at which time passes.
            */
            public static get timeScale(): number;
            public static set timeScale(value: number);
            /** The total number of frames since the start of the game (Read Only).
            */
            public static get frameCount(): number;
            public static get renderedFrameCount(): number;
            /** The real time in seconds since the game started (Read Only).
            */
            public static get realtimeSinceStartup(): number;
            /** The real time in seconds since the game started (Read Only). Double precision version of Time.realtimeSinceStartup. 
            */
            public static get realtimeSinceStartupAsDouble(): number;
            /** Slows your application’s playback time to allow Unity to save screenshots in between frames.
            */
            public static get captureDeltaTime(): number;
            public static set captureDeltaTime(value: number);
            /** The reciprocal of Time.captureDeltaTime.
            */
            public static get captureFramerate(): number;
            public static set captureFramerate(value: number);
            /** Returns true if called inside a fixed time step callback (like MonoBehaviour's MonoBehaviour.FixedUpdate), otherwise returns false.
            */
            public static get inFixedTimeStep(): boolean;
            public constructor ()
        }
        /** Base class for everything attached to a GameObject.
        */
        class Component extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The Transform attached to this GameObject.
            */
            public get transform(): UnityEngine.Transform;
            /** The game object this component is attached to. A component is always attached to a game object.
            */
            public get gameObject(): UnityEngine.GameObject;
            /** The tag of this game object.
            */
            public get tag(): string;
            public set tag(value: string);
            /** The non-generic version of this method.
            * @param type The type of Component to retrieve.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponent ($type: System.Type) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param type The type of component to search for.
            * @param component The output argument that will contain the component or null.
            * @returns Returns true if the component is found, false otherwise. 
            */
            public TryGetComponent ($type: System.Type, $component: $Ref<UnityEngine.Component>) : boolean
            /** The string-based version of this method.
            * @param type The name of the type of Component to get.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponent ($type: string) : UnityEngine.Component
            /** This is the non-generic version of this method.
            * @param t The type of component to search for.
            * @param includeInactive Whether to include inactive child GameObjects in the search.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponentInChildren ($t: System.Type, $includeInactive: boolean) : UnityEngine.Component
            /** This is the non-generic version of this method.
            * @param t The type of component to search for.
            * @param includeInactive Whether to include inactive child GameObjects in the search.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponentInChildren ($t: System.Type) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param t The type of component to search for.
            * @param includeInactive Whether to include inactive child GameObjects in the search.
            * @returns An array of all found components matching the specified type. 
            */
            public GetComponentsInChildren ($t: System.Type, $includeInactive: boolean) : System.Array$1<UnityEngine.Component>
            public GetComponentsInChildren ($t: System.Type) : System.Array$1<UnityEngine.Component>
            /** The non-generic version of this method.
            * @param t The type of component to search for.
            * @param includeInactive Whether to include inactive parent GameObjects in the search.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponentInParent ($t: System.Type, $includeInactive: boolean) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param t The type of component to search for.
            * @param includeInactive Whether to include inactive parent GameObjects in the search.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponentInParent ($t: System.Type) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param t The type of component to search for.
            * @param includeInactive Whether to include inactive parent GameObjects in the search.
            * @returns An array of all found components matching the specified type. 
            */
            public GetComponentsInParent ($t: System.Type, $includeInactive: boolean) : System.Array$1<UnityEngine.Component>
            public GetComponentsInParent ($t: System.Type) : System.Array$1<UnityEngine.Component>
            /** The non-generic version of this method.
            * @param type The type of component to search for.
            * @returns An array containing all matching components of type type. 
            */
            public GetComponents ($type: System.Type) : System.Array$1<UnityEngine.Component>
            public GetComponents ($type: System.Type, $results: System.Collections.Generic.List$1<UnityEngine.Component>) : void
            /** Checks the GameObject's tag against the defined tag.
            * @param tag The tag to compare.
            * @returns Returns true if GameObject has same tag. Returns false otherwise. 
            */
            public CompareTag ($tag: string) : boolean
            /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
            * @param methodName Name of method to call.
            * @param value Optional parameter value for the method.
            * @param options Should an error be raised if the method does not exist on the target object?
            */
            public SendMessageUpwards ($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
            * @param methodName Name of method to call.
            * @param value Optional parameter value for the method.
            * @param options Should an error be raised if the method does not exist on the target object?
            */
            public SendMessageUpwards ($methodName: string, $value: any) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
            * @param methodName Name of method to call.
            * @param value Optional parameter value for the method.
            * @param options Should an error be raised if the method does not exist on the target object?
            */
            public SendMessageUpwards ($methodName: string) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
            * @param methodName Name of method to call.
            * @param value Optional parameter value for the method.
            * @param options Should an error be raised if the method does not exist on the target object?
            */
            public SendMessageUpwards ($methodName: string, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object.
            * @param methodName Name of the method to call.
            * @param value Optional parameter for the method.
            * @param options Should an error be raised if the target object doesn't implement the method for the message?
            */
            public SendMessage ($methodName: string, $value: any) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object.
            * @param methodName Name of the method to call.
            * @param value Optional parameter for the method.
            * @param options Should an error be raised if the target object doesn't implement the method for the message?
            */
            public SendMessage ($methodName: string) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object.
            * @param methodName Name of the method to call.
            * @param value Optional parameter for the method.
            * @param options Should an error be raised if the target object doesn't implement the method for the message?
            */
            public SendMessage ($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object.
            * @param methodName Name of the method to call.
            * @param value Optional parameter for the method.
            * @param options Should an error be raised if the target object doesn't implement the method for the message?
            */
            public SendMessage ($methodName: string, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
            * @param methodName Name of the method to call.
            * @param parameter Optional parameter to pass to the method (can be any value).
            * @param options Should an error be raised if the method does not exist for a given target object?
            */
            public BroadcastMessage ($methodName: string, $parameter: any, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
            * @param methodName Name of the method to call.
            * @param parameter Optional parameter to pass to the method (can be any value).
            * @param options Should an error be raised if the method does not exist for a given target object?
            */
            public BroadcastMessage ($methodName: string, $parameter: any) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
            * @param methodName Name of the method to call.
            * @param parameter Optional parameter to pass to the method (can be any value).
            * @param options Should an error be raised if the method does not exist for a given target object?
            */
            public BroadcastMessage ($methodName: string) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
            * @param methodName Name of the method to call.
            * @param parameter Optional parameter to pass to the method (can be any value).
            * @param options Should an error be raised if the method does not exist for a given target object?
            */
            public BroadcastMessage ($methodName: string, $options: UnityEngine.SendMessageOptions) : void
            public constructor ()
        }
        /** Position, rotation and scale of an object.
        */
        class Transform extends UnityEngine.Component implements System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            /** The world space position of the Transform.
            */
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            /** Position of the transform relative to the parent transform.
            */
            public get localPosition(): UnityEngine.Vector3;
            public set localPosition(value: UnityEngine.Vector3);
            /** The rotation as Euler angles in degrees.
            */
            public get eulerAngles(): UnityEngine.Vector3;
            public set eulerAngles(value: UnityEngine.Vector3);
            /** The rotation as Euler angles in degrees relative to the parent transform's rotation.
            */
            public get localEulerAngles(): UnityEngine.Vector3;
            public set localEulerAngles(value: UnityEngine.Vector3);
            /** The red axis of the transform in world space.
            */
            public get right(): UnityEngine.Vector3;
            public set right(value: UnityEngine.Vector3);
            /** The green axis of the transform in world space.
            */
            public get up(): UnityEngine.Vector3;
            public set up(value: UnityEngine.Vector3);
            /** Returns a normalized vector representing the blue axis of the transform in world space.
            */
            public get forward(): UnityEngine.Vector3;
            public set forward(value: UnityEngine.Vector3);
            /** A Quaternion that stores the rotation of the Transform in world space.
            */
            public get rotation(): UnityEngine.Quaternion;
            public set rotation(value: UnityEngine.Quaternion);
            /** The rotation of the transform relative to the transform rotation of the parent.
            */
            public get localRotation(): UnityEngine.Quaternion;
            public set localRotation(value: UnityEngine.Quaternion);
            /** The scale of the transform relative to the GameObjects parent.
            */
            public get localScale(): UnityEngine.Vector3;
            public set localScale(value: UnityEngine.Vector3);
            /** The parent of the transform.
            */
            public get parent(): UnityEngine.Transform;
            public set parent(value: UnityEngine.Transform);
            /** Matrix that transforms a point from world space into local space (Read Only).
            */
            public get worldToLocalMatrix(): UnityEngine.Matrix4x4;
            /** Matrix that transforms a point from local space into world space (Read Only).
            */
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            /** Returns the topmost transform in the hierarchy.
            */
            public get root(): UnityEngine.Transform;
            /** The number of children the parent Transform has.
            */
            public get childCount(): number;
            /** The global scale of the object (Read Only).
            */
            public get lossyScale(): UnityEngine.Vector3;
            /** Has the transform changed since the last time the flag was set to 'false'?
            */
            public get hasChanged(): boolean;
            public set hasChanged(value: boolean);
            /** The transform capacity of the transform's hierarchy data structure.
            */
            public get hierarchyCapacity(): number;
            public set hierarchyCapacity(value: number);
            /** The number of transforms in the transform's hierarchy data structure.
            */
            public get hierarchyCount(): number;
            /** Set the parent of the transform.
            * @param parent The parent Transform to use.
            * @param worldPositionStays If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.
            */
            public SetParent ($p: UnityEngine.Transform) : void
            /** Set the parent of the transform.
            * @param parent The parent Transform to use.
            * @param worldPositionStays If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.
            */
            public SetParent ($parent: UnityEngine.Transform, $worldPositionStays: boolean) : void
            /** Sets the world space position and rotation of the Transform component.
            */
            public SetPositionAndRotation ($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            /** Sets the position and rotation of the Transform component in local space (i.e. relative to its parent transform).
            */
            public SetLocalPositionAndRotation ($localPosition: UnityEngine.Vector3, $localRotation: UnityEngine.Quaternion) : void
            /** Gets the position and rotation of the Transform component in world space.
            */
            public GetPositionAndRotation ($position: $Ref<UnityEngine.Vector3>, $rotation: $Ref<UnityEngine.Quaternion>) : void
            /** Gets the position and rotation of the Transform component in local space (that is, relative to its parent transform).
            */
            public GetLocalPositionAndRotation ($localPosition: $Ref<UnityEngine.Vector3>, $localRotation: $Ref<UnityEngine.Quaternion>) : void
            /** Moves the transform in the direction and distance of translation.
            */
            public Translate ($translation: UnityEngine.Vector3, $relativeTo: UnityEngine.Space) : void
            /** Moves the transform in the direction and distance of translation.
            */
            public Translate ($translation: UnityEngine.Vector3) : void
            /** Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
            */
            public Translate ($x: number, $y: number, $z: number, $relativeTo: UnityEngine.Space) : void
            /** Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
            */
            public Translate ($x: number, $y: number, $z: number) : void
            /** Moves the transform in the direction and distance of translation.
            */
            public Translate ($translation: UnityEngine.Vector3, $relativeTo: UnityEngine.Transform) : void
            /** Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
            */
            public Translate ($x: number, $y: number, $z: number, $relativeTo: UnityEngine.Transform) : void
            /** Applies a rotation of eulerAngles.z degrees around the z-axis, eulerAngles.x degrees around the x-axis, and eulerAngles.y degrees around the y-axis (in that order).
            * @param eulers The rotation to apply in euler angles.
            * @param relativeTo Determines whether to rotate the GameObject either locally to  the GameObject or relative to the Scene in world space.
            */
            public Rotate ($eulers: UnityEngine.Vector3, $relativeTo: UnityEngine.Space) : void
            /** Applies a rotation of eulerAngles.z degrees around the z-axis, eulerAngles.x degrees around the x-axis, and eulerAngles.y degrees around the y-axis (in that order).
            * @param eulers The rotation to apply in euler angles.
            */
            public Rotate ($eulers: UnityEngine.Vector3) : void
            /** The implementation of this method applies a rotation of zAngle degrees around the z axis, xAngle degrees around the x axis, and yAngle degrees around the y axis (in that order).
            * @param relativeTo Determines whether to rotate the GameObject either locally to the GameObject or relative to the Scene in world space.
            * @param xAngle Degrees to rotate the GameObject around the X axis.
            * @param yAngle Degrees to rotate the GameObject around the Y axis.
            * @param zAngle Degrees to rotate the GameObject around the Z axis.
            */
            public Rotate ($xAngle: number, $yAngle: number, $zAngle: number, $relativeTo: UnityEngine.Space) : void
            /** The implementation of this method applies a rotation of zAngle degrees around the z axis, xAngle degrees around the x axis, and yAngle degrees around the y axis (in that order).
            * @param xAngle Degrees to rotate the GameObject around the X axis.
            * @param yAngle Degrees to rotate the GameObject around the Y axis.
            * @param zAngle Degrees to rotate the GameObject around the Z axis.
            */
            public Rotate ($xAngle: number, $yAngle: number, $zAngle: number) : void
            /** Rotates the object around the given axis by the number of degrees defined by the given angle.
            * @param angle The degrees of rotation to apply.
            * @param axis The axis to apply rotation to.
            * @param relativeTo Determines whether to rotate the GameObject either locally to the GameObject or relative to the Scene in world space.
            */
            public Rotate ($axis: UnityEngine.Vector3, $angle: number, $relativeTo: UnityEngine.Space) : void
            /** Rotates the object around the given axis by the number of degrees defined by the given angle.
            * @param axis The axis to apply rotation to.
            * @param angle The degrees of rotation to apply.
            */
            public Rotate ($axis: UnityEngine.Vector3, $angle: number) : void
            /** Rotates the transform about axis passing through point in world coordinates by angle degrees.
            */
            public RotateAround ($point: UnityEngine.Vector3, $axis: UnityEngine.Vector3, $angle: number) : void
            /** Rotates the transform so the forward vector points at target's current position.
            * @param target Object to point towards.
            * @param worldUp Vector specifying the upward direction.
            */
            public LookAt ($target: UnityEngine.Transform, $worldUp: UnityEngine.Vector3) : void
            /** Rotates the transform so the forward vector points at target's current position.
            * @param target Object to point towards.
            * @param worldUp Vector specifying the upward direction.
            */
            public LookAt ($target: UnityEngine.Transform) : void
            /** Rotates the transform so the forward vector points at worldPosition.
            * @param worldPosition Point to look at.
            * @param worldUp Vector specifying the upward direction.
            */
            public LookAt ($worldPosition: UnityEngine.Vector3, $worldUp: UnityEngine.Vector3) : void
            /** Rotates the transform so the forward vector points at worldPosition.
            * @param worldPosition Point to look at.
            * @param worldUp Vector specifying the upward direction.
            */
            public LookAt ($worldPosition: UnityEngine.Vector3) : void
            /** Transforms direction from local space to world space.
            */
            public TransformDirection ($direction: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms direction x, y, z from local space to world space.
            */
            public TransformDirection ($x: number, $y: number, $z: number) : UnityEngine.Vector3
            /** Transforms a direction from world space to local space. The opposite of Transform.TransformDirection.
            */
            public InverseTransformDirection ($direction: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms the direction x, y, z from world space to local space. The opposite of Transform.TransformDirection.
            */
            public InverseTransformDirection ($x: number, $y: number, $z: number) : UnityEngine.Vector3
            /** Transforms vector from local space to world space.
            */
            public TransformVector ($vector: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms vector x, y, z from local space to world space.
            */
            public TransformVector ($x: number, $y: number, $z: number) : UnityEngine.Vector3
            /** Transforms a vector from world space to local space. The opposite of Transform.TransformVector.
            */
            public InverseTransformVector ($vector: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms the vector x, y, z from world space to local space. The opposite of Transform.TransformVector.
            */
            public InverseTransformVector ($x: number, $y: number, $z: number) : UnityEngine.Vector3
            /** Transforms position from local space to world space.
            */
            public TransformPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms the position x, y, z from local space to world space.
            */
            public TransformPoint ($x: number, $y: number, $z: number) : UnityEngine.Vector3
            /** Transforms position from world space to local space.
            */
            public InverseTransformPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms the position x, y, z from world space to local space. The opposite of Transform.TransformPoint.
            */
            public InverseTransformPoint ($x: number, $y: number, $z: number) : UnityEngine.Vector3
            public DetachChildren () : void
            public SetAsFirstSibling () : void
            public SetAsLastSibling () : void
            /** Sets the sibling index.
            * @param index Index to set.
            */
            public SetSiblingIndex ($index: number) : void
            public GetSiblingIndex () : number
            /** Finds a child by name n and returns it.
            * @param n Name of child to be found.
            * @returns The found child transform. Null if child with matching name isn't found. 
            */
            public Find ($n: string) : UnityEngine.Transform
            /** Is this transform a child of parent?
            */
            public IsChildOf ($parent: UnityEngine.Transform) : boolean
            public GetEnumerator () : System.Collections.IEnumerator
            /** Returns a transform child by index.
            * @param index Index of the child transform to return. Must be smaller than Transform.childCount.
            * @returns Transform child by index. 
            */
            public GetChild ($index: number) : UnityEngine.Transform
        }
        /** Quaternions are used to represent rotations.
        */
        class Quaternion extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Quaternion>
        {
            protected [__keep_incompatibility]: never;
            /** X component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
            */
            public x : number
            /** Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
            */
            public y : number
            /** Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
            */
            public z : number
            /** W component of the Quaternion. Do not directly modify quaternions.
            */
            public w : number
            public static kEpsilon : number
            /** The identity rotation (Read Only).
            */
            public static get identity(): UnityEngine.Quaternion;
            /** Returns or sets the euler angle representation of the rotation.
            */
            public get eulerAngles(): UnityEngine.Vector3;
            public set eulerAngles(value: UnityEngine.Vector3);
            /** Returns this quaternion with a magnitude of 1 (Read Only).
            */
            public get normalized(): UnityEngine.Quaternion;
            /** Creates a rotation which rotates from fromDirection to toDirection.
            */
            public static FromToRotation ($fromDirection: UnityEngine.Vector3, $toDirection: UnityEngine.Vector3) : UnityEngine.Quaternion
            /** Returns the Inverse of rotation.
            */
            public static Inverse ($rotation: UnityEngine.Quaternion) : UnityEngine.Quaternion
            /** Spherically interpolates between quaternions a and b by ratio t. The parameter t is clamped to the range [0, 1].
            * @param a Start value, returned when t = 0.
            * @param b End value, returned when t = 1.
            * @param t Interpolation ratio.
            * @returns A quaternion spherically interpolated between quaternions a and b. 
            */
            public static Slerp ($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number) : UnityEngine.Quaternion
            /** Spherically interpolates between a and b by t. The parameter t is not clamped.
            */
            public static SlerpUnclamped ($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number) : UnityEngine.Quaternion
            /** Interpolates between a and b by t and normalizes the result afterwards. The parameter t is clamped to the range [0, 1].
            * @param a Start value, returned when t = 0.
            * @param b End value, returned when t = 1.
            * @param t Interpolation ratio.
            * @returns A quaternion interpolated between quaternions a and b. 
            */
            public static Lerp ($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number) : UnityEngine.Quaternion
            /** Interpolates between a and b by t and normalizes the result afterwards. The parameter t is not clamped.
            */
            public static LerpUnclamped ($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number) : UnityEngine.Quaternion
            /** Creates a rotation which rotates angle degrees around axis.
            */
            public static AngleAxis ($angle: number, $axis: UnityEngine.Vector3) : UnityEngine.Quaternion
            /** Creates a rotation with the specified forward and upwards directions.
            * @param forward The direction to look in.
            * @param upwards The vector that defines in which direction up is.
            */
            public static LookRotation ($forward: UnityEngine.Vector3, $upwards: UnityEngine.Vector3) : UnityEngine.Quaternion
            /** Creates a rotation with the specified forward and upwards directions.
            * @param forward The direction to look in.
            * @param upwards The vector that defines in which direction up is.
            */
            public static LookRotation ($forward: UnityEngine.Vector3) : UnityEngine.Quaternion
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Set x, y, z and w components of an existing Quaternion.
            */
            public Set ($newX: number, $newY: number, $newZ: number, $newW: number) : void
            public static op_Multiply ($lhs: UnityEngine.Quaternion, $rhs: UnityEngine.Quaternion) : UnityEngine.Quaternion
            public static op_Multiply ($rotation: UnityEngine.Quaternion, $point: UnityEngine.Vector3) : UnityEngine.Vector3
            public static op_Equality ($lhs: UnityEngine.Quaternion, $rhs: UnityEngine.Quaternion) : boolean
            public static op_Inequality ($lhs: UnityEngine.Quaternion, $rhs: UnityEngine.Quaternion) : boolean
            /** The dot product between two rotations.
            */
            public static Dot ($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion) : number
            /** Creates a rotation with the specified forward and upwards directions.
            * @param view The direction to look in.
            * @param up The vector that defines in which direction up is.
            */
            public SetLookRotation ($view: UnityEngine.Vector3) : void
            /** Creates a rotation with the specified forward and upwards directions.
            * @param view The direction to look in.
            * @param up The vector that defines in which direction up is.
            */
            public SetLookRotation ($view: UnityEngine.Vector3, $up: UnityEngine.Vector3) : void
            /** Returns the angle in degrees between two rotations a and b.
            */
            public static Angle ($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion) : number
            /** Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis; applied in that order.
            */
            public static Euler ($x: number, $y: number, $z: number) : UnityEngine.Quaternion
            /** Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis.
            */
            public static Euler ($euler: UnityEngine.Vector3) : UnityEngine.Quaternion
            /** Converts a rotation to angle-axis representation (angles in degrees).
            */
            public ToAngleAxis ($angle: $Ref<number>, $axis: $Ref<UnityEngine.Vector3>) : void
            /** Creates a rotation which rotates from fromDirection to toDirection.
            */
            public SetFromToRotation ($fromDirection: UnityEngine.Vector3, $toDirection: UnityEngine.Vector3) : void
            /** Rotates a rotation from towards to.
            */
            public static RotateTowards ($from: UnityEngine.Quaternion, $to: UnityEngine.Quaternion, $maxDegreesDelta: number) : UnityEngine.Quaternion
            /** Converts this quaternion to one with the same orientation but with a magnitude of 1.
            */
            public static Normalize ($q: UnityEngine.Quaternion) : UnityEngine.Quaternion
            public Normalize () : void
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Quaternion) : boolean
            public ToString () : string
            /** Returns a formatted string for this quaternion.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this quaternion.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($x: number, $y: number, $z: number, $w: number)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** A standard 4x4 transformation matrix.
        */
        class Matrix4x4 extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Matrix4x4>
        {
            protected [__keep_incompatibility]: never;
            public m00 : number
            public m10 : number
            public m20 : number
            public m30 : number
            public m01 : number
            public m11 : number
            public m21 : number
            public m31 : number
            public m02 : number
            public m12 : number
            public m22 : number
            public m32 : number
            public m03 : number
            public m13 : number
            public m23 : number
            public m33 : number
            /** Attempts to get a rotation quaternion from this matrix.
            */
            public get rotation(): UnityEngine.Quaternion;
            /** Attempts to get a scale value from the matrix. (Read Only)
            */
            public get lossyScale(): UnityEngine.Vector3;
            /** Checks whether this is an identity matrix. (Read Only)
            */
            public get isIdentity(): boolean;
            /** The determinant of the matrix. (Read Only)
            */
            public get determinant(): number;
            /** This property takes a projection matrix and returns the six plane coordinates that define a projection frustum.
            */
            public get decomposeProjection(): UnityEngine.FrustumPlanes;
            /** The inverse of this matrix. (Read Only)
            */
            public get inverse(): UnityEngine.Matrix4x4;
            /** Returns the transpose of this matrix (Read Only).
            */
            public get transpose(): UnityEngine.Matrix4x4;
            /** Returns a matrix with all elements set to zero (Read Only).
            */
            public static get zero(): UnityEngine.Matrix4x4;
            /** Returns the identity matrix (Read Only).
            */
            public static get identity(): UnityEngine.Matrix4x4;
            public ValidTRS () : boolean
            public static Determinant ($m: UnityEngine.Matrix4x4) : number
            /** Creates a translation, rotation and scaling matrix.
            */
            public static TRS ($pos: UnityEngine.Vector3, $q: UnityEngine.Quaternion, $s: UnityEngine.Vector3) : UnityEngine.Matrix4x4
            /** Sets this matrix to a translation, rotation and scaling matrix.
            */
            public SetTRS ($pos: UnityEngine.Vector3, $q: UnityEngine.Quaternion, $s: UnityEngine.Vector3) : void
            /** Computes the inverse of a 3D affine matrix.
            * @param input Input matrix to invert.
            * @param result The result of the inversion. Equal to the input matrix if the function fails.
            * @returns Returns true and a valid result if the function succeeds, false and a copy of the input matrix if the function fails. 
            */
            public static Inverse3DAffine ($input: UnityEngine.Matrix4x4, $result: $Ref<UnityEngine.Matrix4x4>) : boolean
            public static Inverse ($m: UnityEngine.Matrix4x4) : UnityEngine.Matrix4x4
            public static Transpose ($m: UnityEngine.Matrix4x4) : UnityEngine.Matrix4x4
            /** Create an orthogonal projection matrix.
            * @param left Left-side x-coordinate.
            * @param right Right-side x-coordinate.
            * @param bottom Bottom y-coordinate.
            * @param top Top y-coordinate.
            * @param zNear Near depth clipping plane value.
            * @param zFar Far depth clipping plane value.
            * @returns The projection matrix. 
            */
            public static Ortho ($left: number, $right: number, $bottom: number, $top: number, $zNear: number, $zFar: number) : UnityEngine.Matrix4x4
            /** Create a perspective projection matrix.
            * @param fov Vertical field-of-view in degrees.
            * @param aspect Aspect ratio (width divided by height).
            * @param zNear Near depth clipping plane value.
            * @param zFar Far depth clipping plane value.
            * @returns The projection matrix. 
            */
            public static Perspective ($fov: number, $aspect: number, $zNear: number, $zFar: number) : UnityEngine.Matrix4x4
            /** Create a "look at" matrix.
            * @param from The source point.
            * @param to The target point.
            * @param up The vector describing the up direction (typically Vector3.up).
            * @returns The resulting transformation matrix. 
            */
            public static LookAt ($from: UnityEngine.Vector3, $to: UnityEngine.Vector3, $up: UnityEngine.Vector3) : UnityEngine.Matrix4x4
            /** This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.
            * @param left The X coordinate of the left side of the near projection plane in view space.
            * @param right The X coordinate of the right side of the near projection plane in view space.
            * @param bottom The Y coordinate of the bottom side of the near projection plane in view space.
            * @param top The Y coordinate of the top side of the near projection plane in view space.
            * @param zNear Z distance to the near plane from the origin in view space.
            * @param zFar Z distance to the far plane from the origin in view space.
            * @param frustumPlanes Frustum planes struct that contains the view space coordinates of that define a viewing frustum.
            * @returns A projection matrix with a viewing frustum defined by the plane coordinates passed in. 
            */
            public static Frustum ($left: number, $right: number, $bottom: number, $top: number, $zNear: number, $zFar: number) : UnityEngine.Matrix4x4
            /** This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.
            * @param left The X coordinate of the left side of the near projection plane in view space.
            * @param right The X coordinate of the right side of the near projection plane in view space.
            * @param bottom The Y coordinate of the bottom side of the near projection plane in view space.
            * @param top The Y coordinate of the top side of the near projection plane in view space.
            * @param zNear Z distance to the near plane from the origin in view space.
            * @param zFar Z distance to the far plane from the origin in view space.
            * @param frustumPlanes Frustum planes struct that contains the view space coordinates of that define a viewing frustum.
            * @returns A projection matrix with a viewing frustum defined by the plane coordinates passed in. 
            */
            public static Frustum ($fp: UnityEngine.FrustumPlanes) : UnityEngine.Matrix4x4
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Matrix4x4) : boolean
            public static op_Multiply ($lhs: UnityEngine.Matrix4x4, $rhs: UnityEngine.Matrix4x4) : UnityEngine.Matrix4x4
            public static op_Multiply ($lhs: UnityEngine.Matrix4x4, $vector: UnityEngine.Vector4) : UnityEngine.Vector4
            public static op_Equality ($lhs: UnityEngine.Matrix4x4, $rhs: UnityEngine.Matrix4x4) : boolean
            public static op_Inequality ($lhs: UnityEngine.Matrix4x4, $rhs: UnityEngine.Matrix4x4) : boolean
            /** Get a column of the matrix.
            */
            public GetColumn ($index: number) : UnityEngine.Vector4
            /** Returns a row of the matrix.
            */
            public GetRow ($index: number) : UnityEngine.Vector4
            public GetPosition () : UnityEngine.Vector3
            /** Sets a column of the matrix.
            */
            public SetColumn ($index: number, $column: UnityEngine.Vector4) : void
            /** Sets a row of the matrix.
            */
            public SetRow ($index: number, $row: UnityEngine.Vector4) : void
            /** Transforms a position by this matrix (generic).
            */
            public MultiplyPoint ($point: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms a position by this matrix (fast).
            */
            public MultiplyPoint3x4 ($point: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms a direction by this matrix.
            */
            public MultiplyVector ($vector: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Returns a plane that is transformed in space.
            */
            public TransformPlane ($plane: UnityEngine.Plane) : UnityEngine.Plane
            /** Creates a scaling matrix.
            */
            public static Scale ($vector: UnityEngine.Vector3) : UnityEngine.Matrix4x4
            /** Creates a translation matrix.
            */
            public static Translate ($vector: UnityEngine.Vector3) : UnityEngine.Matrix4x4
            /** Creates a rotation matrix.
            */
            public static Rotate ($q: UnityEngine.Quaternion) : UnityEngine.Matrix4x4
            public ToString () : string
            /** Returns a formatted string for this matrix.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this matrix.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($column0: UnityEngine.Vector4, $column1: UnityEngine.Vector4, $column2: UnityEngine.Vector4, $column3: UnityEngine.Vector4)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** The coordinate space in which to operate.
        */
        enum Space
        { World = 0, Self = 1 }
        /** Base class for all entities in Unity Scenes.
        */
        class GameObject extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The Transform attached to this GameObject.
            */
            public get transform(): UnityEngine.Transform;
            /** The layer the GameObject is in.
            */
            public get layer(): number;
            public set layer(value: number);
            /** The local active state of this GameObject. (Read Only)
            */
            public get activeSelf(): boolean;
            /** Defines whether the GameObject is active in the Scene.
            */
            public get activeInHierarchy(): boolean;
            /** Gets and sets the GameObject's StaticEditorFlags.
            */
            public get isStatic(): boolean;
            public set isStatic(value: boolean);
            /** The tag of this game object.
            */
            public get tag(): string;
            public set tag(value: string);
            /** Scene that the GameObject is part of.
            */
            public get scene(): UnityEngine.SceneManagement.Scene;
            /** Scene culling mask Unity uses to determine which scene to render the GameObject in.
            */
            public get sceneCullingMask(): bigint;
            public get gameObject(): UnityEngine.GameObject;
            /** Creates a game object with a primitive mesh renderer and appropriate collider.
            * @param type The type of primitive object to create.
            */
            public static CreatePrimitive ($type: UnityEngine.PrimitiveType) : UnityEngine.GameObject
            /** The non-generic version of this method.
            * @param type The type of Component to search for.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponent ($type: System.Type) : UnityEngine.Component
            /** The string-based version of this method.
            * @param type The name of the type of Component to search for.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponent ($type: string) : UnityEngine.Component
            /** This is the non-generic version of this method.
            * @param type The type of Component to retrieve.
            * @param includeInactive Whether to include inactive child GameObjects in the search.
            * @returns A component of the matching type, if found. 
            */
            public GetComponentInChildren ($type: System.Type, $includeInactive: boolean) : UnityEngine.Component
            /** This is the non-generic version of this method.
            * @param type The type of Component to retrieve.
            * @param includeInactive Whether to include inactive child GameObjects in the search.
            * @returns A component of the matching type, if found. 
            */
            public GetComponentInChildren ($type: System.Type) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param type The type of component to search for.
            * @param includeInactive Whether to include inactive parent GameObjects in the search.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponentInParent ($type: System.Type, $includeInactive: boolean) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param type The type of component to search for.
            * @param includeInactive Whether to include inactive parent GameObjects in the search.
            * @returns A Component of the matching type, otherwise null if no Component is found. 
            */
            public GetComponentInParent ($type: System.Type) : UnityEngine.Component
            /** The non-generic version of this method.
            * @param type The type of component to search for.
            * @returns An array containing all matching components of type type. 
            */
            public GetComponents ($type: System.Type) : System.Array$1<UnityEngine.Component>
            public GetComponents ($type: System.Type, $results: System.Collections.Generic.List$1<UnityEngine.Component>) : void
            /** The non-generic version of this method.
            * @param type The type of component to search for.
            * @param includeInactive Whether to include inactive child GameObjects in the search.
            * @returns An array of all found components matching the specified type. 
            */
            public GetComponentsInChildren ($type: System.Type) : System.Array$1<UnityEngine.Component>
            /** The non-generic version of this method.
            * @param type The type of component to search for.
            * @param includeInactive Whether to include inactive child GameObjects in the search.
            * @returns An array of all found components matching the specified type. 
            */
            public GetComponentsInChildren ($type: System.Type, $includeInactive: boolean) : System.Array$1<UnityEngine.Component>
            public GetComponentsInParent ($type: System.Type) : System.Array$1<UnityEngine.Component>
            /** The non-generic version of this method.
            * @param type The type of component to search for.
            * @param includeInactive Whether to include inactive parent GameObjects in the search.
            * @returns An array of all found components matching the specified type. 
            */
            public GetComponentsInParent ($type: System.Type, $includeInactive: boolean) : System.Array$1<UnityEngine.Component>
            /** The non-generic version of this method.
            * @param type The type of component to search for.
            * @param component The output argument that will contain the component or null.
            * @returns Returns true if the component is found, false otherwise. 
            */
            public TryGetComponent ($type: System.Type, $component: $Ref<UnityEngine.Component>) : boolean
            /** Returns one active GameObject tagged tag. Returns null if no GameObject was found.
            * @param tag The tag to search for.
            */
            public static FindWithTag ($tag: string) : UnityEngine.GameObject
            public SendMessageUpwards ($methodName: string, $options: UnityEngine.SendMessageOptions) : void
            public SendMessage ($methodName: string, $options: UnityEngine.SendMessageOptions) : void
            public BroadcastMessage ($methodName: string, $options: UnityEngine.SendMessageOptions) : void
            /** Adds a component class of type componentType to the game object. C# Users can use a generic version.
            */
            public AddComponent ($componentType: System.Type) : UnityEngine.Component
            /** ActivatesDeactivates the GameObject, depending on the given true or false/ value.
            * @param value Activate or deactivate the object, where true activates the GameObject and false deactivates the GameObject.
            */
            public SetActive ($value: boolean) : void
            /** Is this game object tagged with tag ?
            * @param tag The tag to compare.
            */
            public CompareTag ($tag: string) : boolean
            public static FindGameObjectWithTag ($tag: string) : UnityEngine.GameObject
            /** Returns an array of active GameObjects tagged tag. Returns empty array if no GameObject was found.
            * @param tag The name of the tag to search GameObjects for.
            */
            public static FindGameObjectsWithTag ($tag: string) : System.Array$1<UnityEngine.GameObject>
            /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
            * @param methodName The name of the method to call.
            * @param value An optional parameter value to pass to the called method.
            * @param options Should an error be raised if the method doesn't exist on the target object?
            */
            public SendMessageUpwards ($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
            * @param methodName The name of the method to call.
            * @param value An optional parameter value to pass to the called method.
            * @param options Should an error be raised if the method doesn't exist on the target object?
            */
            public SendMessageUpwards ($methodName: string, $value: any) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
            * @param methodName The name of the method to call.
            * @param value An optional parameter value to pass to the called method.
            * @param options Should an error be raised if the method doesn't exist on the target object?
            */
            public SendMessageUpwards ($methodName: string) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object.
            * @param methodName The name of the method to call.
            * @param value An optional parameter value to pass to the called method.
            * @param options Should an error be raised if the method doesn't exist on the target object?
            */
            public SendMessage ($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object.
            * @param methodName The name of the method to call.
            * @param value An optional parameter value to pass to the called method.
            * @param options Should an error be raised if the method doesn't exist on the target object?
            */
            public SendMessage ($methodName: string, $value: any) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object.
            * @param methodName The name of the method to call.
            * @param value An optional parameter value to pass to the called method.
            * @param options Should an error be raised if the method doesn't exist on the target object?
            */
            public SendMessage ($methodName: string) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
            */
            public BroadcastMessage ($methodName: string, $parameter: any, $options: UnityEngine.SendMessageOptions) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
            */
            public BroadcastMessage ($methodName: string, $parameter: any) : void
            /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
            */
            public BroadcastMessage ($methodName: string) : void
            /** Finds a GameObject by name and returns it.
            */
            public static Find ($name: string) : UnityEngine.GameObject
            public constructor ($name: string)
            public constructor ()
            public constructor ($name: string, ...components: System.Type[])
        }
        /** Options for how to send a message.
        */
        enum SendMessageOptions
        { RequireReceiver = 0, DontRequireReceiver = 1 }
        /** The various primitives that can be created using the GameObject.CreatePrimitive function.
        */
        enum PrimitiveType
        { Sphere = 0, Capsule = 1, Cylinder = 2, Cube = 3, Plane = 4, Quad = 5 }
        /** Options to specify if and how to sort objects returned by a function.
        */
        enum FindObjectsSortMode
        { None = 0, InstanceID = 1 }
        /** Options to control whether object find functions return inactive objects.
        */
        enum FindObjectsInactive
        { Exclude = 0, Include = 1 }
        /** Bit mask that controls object destruction, saving and visibility in inspectors.
        */
        enum HideFlags
        { None = 0, HideInHierarchy = 1, HideInInspector = 2, DontSaveInEditor = 4, NotEditable = 8, DontSaveInBuild = 16, DontUnloadUnusedAsset = 32, DontSave = 52, HideAndDontSave = 61 }
        /** Script interface for ParticleSystem. Unity's powerful and versatile particle system implementation.
        */
        class ParticleSystem extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Determines whether the Particle System is playing.
            */
            public get isPlaying(): boolean;
            /** Determines whether the Particle System is emitting particles. A Particle System may stop emitting when its emission module has finished, it has been paused or if the system has been stopped using ParticleSystem.Stop|Stop with the ParticleSystemStopBehavior.StopEmitting|StopEmitting flag. Resume emitting by calling ParticleSystem.Play|Play.
            */
            public get isEmitting(): boolean;
            /** Determines whether the Particle System is in the stopped state.
            */
            public get isStopped(): boolean;
            /** Determines whether the Particle System is paused.
            */
            public get isPaused(): boolean;
            /** The current number of particles (Read Only). The number doesn't include particles of child Particle Systems
            */
            public get particleCount(): number;
            /** Playback position in seconds.
            */
            public get time(): number;
            public set time(value: number);
            /** Override the random seed used for the Particle System emission.
            */
            public get randomSeed(): number;
            public set randomSeed(value: number);
            /** Controls whether the Particle System uses an automatically-generated random number to seed the random number generator.
            */
            public get useAutoRandomSeed(): boolean;
            public set useAutoRandomSeed(value: boolean);
            /** Does this system support Procedural Simulation?
            */
            public get proceduralSimulationSupported(): boolean;
            /** Access the main Particle System settings.
            */
            public get main(): UnityEngine.ParticleSystem.MainModule;
            /** Script interface for the EmissionModule of a Particle System.
            */
            public get emission(): UnityEngine.ParticleSystem.EmissionModule;
            /** Script interface for the ShapeModule of a Particle System. 
            */
            public get shape(): UnityEngine.ParticleSystem.ShapeModule;
            /** Script interface for the VelocityOverLifetimeModule of a Particle System.
            */
            public get velocityOverLifetime(): UnityEngine.ParticleSystem.VelocityOverLifetimeModule;
            /** Script interface for the LimitVelocityOverLifetimeModule of a Particle System. .
            */
            public get limitVelocityOverLifetime(): UnityEngine.ParticleSystem.LimitVelocityOverLifetimeModule;
            /** Script interface for the InheritVelocityModule of a Particle System.
            */
            public get inheritVelocity(): UnityEngine.ParticleSystem.InheritVelocityModule;
            /** Script interface for the Particle System Lifetime By Emitter Speed module.
            */
            public get lifetimeByEmitterSpeed(): UnityEngine.ParticleSystem.LifetimeByEmitterSpeedModule;
            /** Script interface for the ForceOverLifetimeModule of a Particle System.
            */
            public get forceOverLifetime(): UnityEngine.ParticleSystem.ForceOverLifetimeModule;
            /** Script interface for the ColorOverLifetimeModule of a Particle System.
            */
            public get colorOverLifetime(): UnityEngine.ParticleSystem.ColorOverLifetimeModule;
            /** Script interface for the ColorByLifetimeModule of a Particle System.
            */
            public get colorBySpeed(): UnityEngine.ParticleSystem.ColorBySpeedModule;
            /** Script interface for the SizeOverLifetimeModule of a Particle System. 
            */
            public get sizeOverLifetime(): UnityEngine.ParticleSystem.SizeOverLifetimeModule;
            /** Script interface for the SizeBySpeedModule of a Particle System.
            */
            public get sizeBySpeed(): UnityEngine.ParticleSystem.SizeBySpeedModule;
            /** Script interface for the RotationOverLifetimeModule of a Particle System.
            */
            public get rotationOverLifetime(): UnityEngine.ParticleSystem.RotationOverLifetimeModule;
            /** Script interface for the RotationBySpeedModule of a Particle System.
            */
            public get rotationBySpeed(): UnityEngine.ParticleSystem.RotationBySpeedModule;
            /** Script interface for the ExternalForcesModule of a Particle System.
            */
            public get externalForces(): UnityEngine.ParticleSystem.ExternalForcesModule;
            /** Script interface for the NoiseModule of a Particle System.
            */
            public get noise(): UnityEngine.ParticleSystem.NoiseModule;
            /** Script interface for the CollisionModule of a Particle System.
            */
            public get collision(): UnityEngine.ParticleSystem.CollisionModule;
            /** Script interface for the TriggerModule of a Particle System.
            */
            public get trigger(): UnityEngine.ParticleSystem.TriggerModule;
            /** Script interface for the SubEmittersModule of a Particle System.
            */
            public get subEmitters(): UnityEngine.ParticleSystem.SubEmittersModule;
            /** Script interface for the TextureSheetAnimationModule of a Particle System.
            */
            public get textureSheetAnimation(): UnityEngine.ParticleSystem.TextureSheetAnimationModule;
            /** Script interface for the LightsModule of a Particle System.
            */
            public get lights(): UnityEngine.ParticleSystem.LightsModule;
            /** Script interface for the TrailsModule of a Particle System.
            */
            public get trails(): UnityEngine.ParticleSystem.TrailModule;
            /** Script interface for the CustomDataModule of a Particle System.
            */
            public get customData(): UnityEngine.ParticleSystem.CustomDataModule;
            public SetParticles ($particles: System.Array$1<UnityEngine.ParticleSystem.Particle>, $size: number, $offset: number) : void
            public SetParticles ($particles: System.Array$1<UnityEngine.ParticleSystem.Particle>, $size: number) : void
            public SetParticles ($particles: System.Array$1<UnityEngine.ParticleSystem.Particle>) : void
            public SetParticles ($particles: Unity.Collections.NativeArray$1<UnityEngine.ParticleSystem.Particle>, $size: number, $offset: number) : void
            public SetParticles ($particles: Unity.Collections.NativeArray$1<UnityEngine.ParticleSystem.Particle>, $size: number) : void
            public SetParticles ($particles: Unity.Collections.NativeArray$1<UnityEngine.ParticleSystem.Particle>) : void
            public GetParticles ($particles: System.Array$1<UnityEngine.ParticleSystem.Particle>, $size: number, $offset: number) : number
            public GetParticles ($particles: System.Array$1<UnityEngine.ParticleSystem.Particle>, $size: number) : number
            public GetParticles ($particles: System.Array$1<UnityEngine.ParticleSystem.Particle>) : number
            public GetParticles ($particles: Unity.Collections.NativeArray$1<UnityEngine.ParticleSystem.Particle>, $size: number, $offset: number) : number
            public GetParticles ($particles: Unity.Collections.NativeArray$1<UnityEngine.ParticleSystem.Particle>, $size: number) : number
            public GetParticles ($particles: Unity.Collections.NativeArray$1<UnityEngine.ParticleSystem.Particle>) : number
            public SetCustomParticleData ($customData: System.Collections.Generic.List$1<UnityEngine.Vector4>, $streamIndex: UnityEngine.ParticleSystemCustomData) : void
            public GetCustomParticleData ($customData: System.Collections.Generic.List$1<UnityEngine.Vector4>, $streamIndex: UnityEngine.ParticleSystemCustomData) : number
            public GetPlaybackState () : UnityEngine.ParticleSystem.PlaybackState
            public SetPlaybackState ($playbackState: UnityEngine.ParticleSystem.PlaybackState) : void
            public GetTrails () : UnityEngine.ParticleSystem.Trails
            public GetTrails ($trailData: $Ref<UnityEngine.ParticleSystem.Trails>) : number
            public SetTrails ($trailData: UnityEngine.ParticleSystem.Trails) : void
            /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it.
            * @param t Time period in seconds to advance the ParticleSystem simulation by. If restart is true, the ParticleSystem will be reset to 0 time, and then advanced by this value. If restart is false, the ParticleSystem simulation will be advanced in time from its current state by this value.
            * @param withChildren Fast-forward all child Particle Systems as well.
            * @param restart Restart and start from the beginning.
            * @param fixedTimeStep Only update the system at fixed intervals, based on the value in "Fixed Time" in the Time options.
            */
            public Simulate ($t: number, $withChildren: boolean, $restart: boolean, $fixedTimeStep: boolean) : void
            /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it.
            * @param t Time period in seconds to advance the ParticleSystem simulation by. If restart is true, the ParticleSystem will be reset to 0 time, and then advanced by this value. If restart is false, the ParticleSystem simulation will be advanced in time from its current state by this value.
            * @param withChildren Fast-forward all child Particle Systems as well.
            * @param restart Restart and start from the beginning.
            * @param fixedTimeStep Only update the system at fixed intervals, based on the value in "Fixed Time" in the Time options.
            */
            public Simulate ($t: number, $withChildren: boolean, $restart: boolean) : void
            /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it.
            * @param t Time period in seconds to advance the ParticleSystem simulation by. If restart is true, the ParticleSystem will be reset to 0 time, and then advanced by this value. If restart is false, the ParticleSystem simulation will be advanced in time from its current state by this value.
            * @param withChildren Fast-forward all child Particle Systems as well.
            * @param restart Restart and start from the beginning.
            * @param fixedTimeStep Only update the system at fixed intervals, based on the value in "Fixed Time" in the Time options.
            */
            public Simulate ($t: number, $withChildren: boolean) : void
            /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it.
            * @param t Time period in seconds to advance the ParticleSystem simulation by. If restart is true, the ParticleSystem will be reset to 0 time, and then advanced by this value. If restart is false, the ParticleSystem simulation will be advanced in time from its current state by this value.
            * @param withChildren Fast-forward all child Particle Systems as well.
            * @param restart Restart and start from the beginning.
            * @param fixedTimeStep Only update the system at fixed intervals, based on the value in "Fixed Time" in the Time options.
            */
            public Simulate ($t: number) : void
            /** Starts the Particle System.
            * @param withChildren Play all child Particle Systems as well.
            */
            public Play ($withChildren: boolean) : void
            public Play () : void
            /** Pauses the system so no new particles are emitted and the existing particles are not updated.
            * @param withChildren Pause all child Particle Systems as well.
            */
            public Pause ($withChildren: boolean) : void
            public Pause () : void
            /** Stops playing the Particle System using the supplied stop behaviour.
            * @param withChildren Stop all child Particle Systems as well.
            * @param stopBehavior Stop emitting or stop emitting and clear the system.
            */
            public Stop ($withChildren: boolean, $stopBehavior: UnityEngine.ParticleSystemStopBehavior) : void
            /** Stops playing the Particle System using the supplied stop behaviour.
            * @param withChildren Stop all child Particle Systems as well.
            * @param stopBehavior Stop emitting or stop emitting and clear the system.
            */
            public Stop ($withChildren: boolean) : void
            public Stop () : void
            /** Remove all particles in the Particle System.
            * @param withChildren Clear all child Particle Systems as well.
            */
            public Clear ($withChildren: boolean) : void
            public Clear () : void
            /** Does the Particle System contain any live particles, or will it produce more?
            * @param withChildren Check all child Particle Systems as well.
            * @returns True if the Particle System contains live particles or is still creating new particles. False if the Particle System has stopped emitting particles and all particles are dead. 
            */
            public IsAlive ($withChildren: boolean) : boolean
            public IsAlive () : boolean
            /** Emit count particles immediately.
            * @param count Number of particles to emit.
            */
            public Emit ($count: number) : void
            public Emit ($emitParams: UnityEngine.ParticleSystem.EmitParams, $count: number) : void
            /** Triggers the specified sub emitter on all particles of the Particle System.
            * @param subEmitterIndex Index of the sub emitter to trigger.
            */
            public TriggerSubEmitter ($subEmitterIndex: number) : void
            public TriggerSubEmitter ($subEmitterIndex: number, $particle: $Ref<UnityEngine.ParticleSystem.Particle>) : void
            public TriggerSubEmitter ($subEmitterIndex: number, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>) : void
            public static ResetPreMappedBufferMemory () : void
            /** Limits the amount of graphics memory Unity reserves for efficient rendering of Particle Systems.
            * @param vertexBuffersCount The maximum number of cached vertex buffers.
            * @param indexBuffersCount The maximum number of cached index buffers.
            */
            public static SetMaximumPreMappedBufferCounts ($vertexBuffersCount: number, $indexBuffersCount: number) : void
            public AllocateAxisOfRotationAttribute () : void
            public AllocateMeshIndexAttribute () : void
            /** Ensures that the ParticleSystemJobs.ParticleSystemJobData.customData1|customData1 and ParticleSystemJobs.ParticleSystemJobData.customData1|customData2 particle attribute arrays are allocated.
            * @param stream The custom data stream to allocate.
            */
            public AllocateCustomDataAttribute ($stream: UnityEngine.ParticleSystemCustomData) : void
            public constructor ()
        }
        /** Script interface for ParticleSystem. Unity's powerful and versatile particle system implementation.
        */
        interface ParticleSystem {
            /** Safe array size for use with ParticleSystem.GetCollisionEvents.
            */
            GetSafeCollisionEventSize () : number;
            GetCollisionEvents ($go: UnityEngine.GameObject, $collisionEvents: System.Collections.Generic.List$1<UnityEngine.ParticleCollisionEvent>) : number;
            /** Safe array size for use with ParticleSystem.GetTriggerParticles.
            * @param ps Particle system.
            * @param type Type of trigger to return size for.
            * @returns Number of particles with this trigger event type. 
            */
            GetSafeTriggerParticlesSize ($type: UnityEngine.ParticleSystemTriggerEventType) : number;
            GetTriggerParticles ($type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>) : number;
            GetTriggerParticles ($type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>, $colliderData: $Ref<UnityEngine.ParticleSystem.ColliderData>) : number;
            SetTriggerParticles ($type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>, $offset: number, $count: number) : void;
            SetTriggerParticles ($type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>) : void;
        }
        /** Representation of RGBA colors in 32 bit format.
        */
        class Color32 extends System.ValueType implements System.IFormattable
        {
            protected [__keep_incompatibility]: never;
            /** Red component of the color.
            */
            public r : number
            /** Green component of the color.
            */
            public g : number
            /** Blue component of the color.
            */
            public b : number
            /** Alpha component of the color.
            */
            public a : number
            public static op_Implicit ($c: UnityEngine.Color) : UnityEngine.Color32
            public static op_Implicit ($c: UnityEngine.Color32) : UnityEngine.Color
            /** Linearly interpolates between colors a and b by t.
            */
            public static Lerp ($a: UnityEngine.Color32, $b: UnityEngine.Color32, $t: number) : UnityEngine.Color32
            /** Linearly interpolates between colors a and b by t.
            */
            public static LerpUnclamped ($a: UnityEngine.Color32, $b: UnityEngine.Color32, $t: number) : UnityEngine.Color32
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            public ToString () : string
            /** Returns a formatted string for this color.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this color.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($r: number, $g: number, $b: number, $a: number)
            public constructor ()
        }
        /** The space to simulate particles in.
        */
        enum ParticleSystemSimulationSpace
        { Local = 0, World = 1, Custom = 2 }
        /** Control how particle systems apply transform scale.
        */
        enum ParticleSystemScalingMode
        { Hierarchy = 0, Local = 1, Shape = 2 }
        /** Representation of four-dimensional vectors.
        */
        class Vector4 extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Vector4>
        {
            protected [__keep_incompatibility]: never;
            public static kEpsilon : number
            /** X component of the vector.
            */
            public x : number
            /** Y component of the vector.
            */
            public y : number
            /** Z component of the vector.
            */
            public z : number
            /** W component of the vector.
            */
            public w : number
            /** Returns this vector with a magnitude of 1 (Read Only).
            */
            public get normalized(): UnityEngine.Vector4;
            /** Returns the length of this vector (Read Only).
            */
            public get magnitude(): number;
            /** Returns the squared length of this vector (Read Only).
            */
            public get sqrMagnitude(): number;
            /** Shorthand for writing Vector4(0,0,0,0).
            */
            public static get zero(): UnityEngine.Vector4;
            /** Shorthand for writing Vector4(1,1,1,1).
            */
            public static get one(): UnityEngine.Vector4;
            /** Shorthand for writing Vector4(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity).
            */
            public static get positiveInfinity(): UnityEngine.Vector4;
            /** Shorthand for writing Vector4(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity).
            */
            public static get negativeInfinity(): UnityEngine.Vector4;
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Set x, y, z and w components of an existing Vector4.
            */
            public Set ($newX: number, $newY: number, $newZ: number, $newW: number) : void
            /** Linearly interpolates between two vectors.
            */
            public static Lerp ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4, $t: number) : UnityEngine.Vector4
            /** Linearly interpolates between two vectors.
            */
            public static LerpUnclamped ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4, $t: number) : UnityEngine.Vector4
            /** Moves a point current towards target.
            */
            public static MoveTowards ($current: UnityEngine.Vector4, $target: UnityEngine.Vector4, $maxDistanceDelta: number) : UnityEngine.Vector4
            /** Multiplies two vectors component-wise.
            */
            public static Scale ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4) : UnityEngine.Vector4
            /** Multiplies every component of this vector by the same component of scale.
            */
            public Scale ($scale: UnityEngine.Vector4) : void
            /** Returns true if the given vector is exactly equal to this vector.
            */
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Vector4) : boolean
            public static Normalize ($a: UnityEngine.Vector4) : UnityEngine.Vector4
            public Normalize () : void
            /** Dot Product of two vectors.
            */
            public static Dot ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4) : number
            /** Projects a vector onto another vector.
            */
            public static Project ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4) : UnityEngine.Vector4
            /** Returns the distance between a and b.
            */
            public static Distance ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4) : number
            public static Magnitude ($a: UnityEngine.Vector4) : number
            /** Returns a vector that is made from the smallest components of two vectors.
            */
            public static Min ($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4) : UnityEngine.Vector4
            /** Returns a vector that is made from the largest components of two vectors.
            */
            public static Max ($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4) : UnityEngine.Vector4
            public static op_Addition ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4) : UnityEngine.Vector4
            public static op_Subtraction ($a: UnityEngine.Vector4, $b: UnityEngine.Vector4) : UnityEngine.Vector4
            public static op_UnaryNegation ($a: UnityEngine.Vector4) : UnityEngine.Vector4
            public static op_Multiply ($a: UnityEngine.Vector4, $d: number) : UnityEngine.Vector4
            public static op_Multiply ($d: number, $a: UnityEngine.Vector4) : UnityEngine.Vector4
            public static op_Division ($a: UnityEngine.Vector4, $d: number) : UnityEngine.Vector4
            public static op_Equality ($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4) : boolean
            public static op_Inequality ($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4) : boolean
            public static op_Implicit ($v: UnityEngine.Vector3) : UnityEngine.Vector4
            public static op_Implicit ($v: UnityEngine.Vector4) : UnityEngine.Vector3
            public static op_Implicit ($v: UnityEngine.Vector2) : UnityEngine.Vector4
            public static op_Implicit ($v: UnityEngine.Vector4) : UnityEngine.Vector2
            public ToString () : string
            /** Returns a formatted string for this vector.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this vector.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public static SqrMagnitude ($a: UnityEngine.Vector4) : number
            public SqrMagnitude () : number
            public constructor ($x: number, $y: number, $z: number, $w: number)
            public constructor ($x: number, $y: number, $z: number)
            public constructor ($x: number, $y: number)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** Which stream of custom particle data to set.
        */
        enum ParticleSystemCustomData
        { Custom1 = 0, Custom2 = 1 }
        /** The behavior to apply when calling ParticleSystem.Stop|Stop.
        */
        enum ParticleSystemStopBehavior
        { StopEmittingAndClear = 0, StopEmitting = 1 }
        /** Behaviours are Components that can be enabled or disabled.
        */
        class Behaviour extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Enabled Behaviours are Updated, disabled Behaviours are not.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** Reports whether a GameObject and its associated Behaviour is active and enabled.
            */
            public get isActiveAndEnabled(): boolean;
            public constructor ()
        }
        /** Element that can be used for screen rendering.
        */
        class Canvas extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Is the Canvas in World or Overlay mode?
            */
            public get renderMode(): UnityEngine.RenderMode;
            public set renderMode(value: UnityEngine.RenderMode);
            /** Is this the root Canvas?
            */
            public get isRootCanvas(): boolean;
            /** Get the render rect for the Canvas.
            */
            public get pixelRect(): UnityEngine.Rect;
            /** Used to scale the entire canvas, while still making it fit the screen. Only applies with renderMode is Screen Space.
            */
            public get scaleFactor(): number;
            public set scaleFactor(value: number);
            /** The number of pixels per unit that is considered the default.
            */
            public get referencePixelsPerUnit(): number;
            public set referencePixelsPerUnit(value: number);
            /** Allows for nested canvases to override pixelPerfect settings inherited from parent canvases.
            */
            public get overridePixelPerfect(): boolean;
            public set overridePixelPerfect(value: boolean);
            /** Force elements in the canvas to be aligned with pixels. Only applies with renderMode is Screen Space.
            */
            public get pixelPerfect(): boolean;
            public set pixelPerfect(value: boolean);
            /** How far away from the camera is the Canvas generated.
            */
            public get planeDistance(): number;
            public set planeDistance(value: number);
            /** The render order in which the canvas is being emitted to the Scene. (Read Only)
            */
            public get renderOrder(): number;
            /** Override the sorting of canvas.
            */
            public get overrideSorting(): boolean;
            public set overrideSorting(value: boolean);
            /** Canvas' order within a sorting layer.
            */
            public get sortingOrder(): number;
            public set sortingOrder(value: number);
            /** For Overlay mode, display index on which the UI canvas will appear.
            */
            public get targetDisplay(): number;
            public set targetDisplay(value: number);
            /** Unique ID of the Canvas' sorting layer.
            */
            public get sortingLayerID(): number;
            public set sortingLayerID(value: number);
            /** Cached calculated value based upon SortingLayerID.
            */
            public get cachedSortingLayerValue(): number;
            /** Get or set the mask of additional shader channels to be used when creating the Canvas mesh.
            */
            public get additionalShaderChannels(): UnityEngine.AdditionalCanvasShaderChannels;
            public set additionalShaderChannels(value: UnityEngine.AdditionalCanvasShaderChannels);
            /** Name of the Canvas' sorting layer.
            */
            public get sortingLayerName(): string;
            public set sortingLayerName(value: string);
            /** Returns the Canvas closest to root, by checking through each parent and returning the last canvas found. If no other canvas is found then the canvas will return itself.
            */
            public get rootCanvas(): UnityEngine.Canvas;
            /** Returns the canvas display size based on the selected render mode and target display.
            */
            public get renderingDisplaySize(): UnityEngine.Vector2;
            /** Camera used for sizing the Canvas when in Screen Space - Camera. Also used as the Camera that events will be sent through for a World Space Canvas.
            */
            public get worldCamera(): UnityEngine.Camera;
            public set worldCamera(value: UnityEngine.Camera);
            /** The normalized grid size that the canvas will split the renderable area into.
            */
            public get normalizedSortingGridSize(): number;
            public set normalizedSortingGridSize(value: number);
            public static add_preWillRenderCanvases ($value: UnityEngine.Canvas.WillRenderCanvases) : void
            public static remove_preWillRenderCanvases ($value: UnityEngine.Canvas.WillRenderCanvases) : void
            public static add_willRenderCanvases ($value: UnityEngine.Canvas.WillRenderCanvases) : void
            public static remove_willRenderCanvases ($value: UnityEngine.Canvas.WillRenderCanvases) : void
            public static GetDefaultCanvasMaterial () : UnityEngine.Material
            public static GetETC1SupportedCanvasMaterial () : UnityEngine.Material
            public static ForceUpdateCanvases () : void
            public constructor ()
        }
        /** RenderMode for the Canvas.
        */
        enum RenderMode
        { ScreenSpaceOverlay = 0, ScreenSpaceCamera = 1, WorldSpace = 2 }
        /** A 2D Rectangle defined by X and Y position, width and height.
        */
        class Rect extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Rect>
        {
            protected [__keep_incompatibility]: never;
            /** Shorthand for writing new Rect(0,0,0,0).
            */
            public static get zero(): UnityEngine.Rect;
            /** The X coordinate of the rectangle.
            */
            public get x(): number;
            public set x(value: number);
            /** The Y coordinate of the rectangle.
            */
            public get y(): number;
            public set y(value: number);
            /** The X and Y position of the rectangle.
            */
            public get position(): UnityEngine.Vector2;
            public set position(value: UnityEngine.Vector2);
            /** The position of the center of the rectangle.
            */
            public get center(): UnityEngine.Vector2;
            public set center(value: UnityEngine.Vector2);
            /** The position of the minimum corner of the rectangle.
            */
            public get min(): UnityEngine.Vector2;
            public set min(value: UnityEngine.Vector2);
            /** The position of the maximum corner of the rectangle.
            */
            public get max(): UnityEngine.Vector2;
            public set max(value: UnityEngine.Vector2);
            /** The width of the rectangle, measured from the X position.
            */
            public get width(): number;
            public set width(value: number);
            /** The height of the rectangle, measured from the Y position.
            */
            public get height(): number;
            public set height(value: number);
            /** The width and height of the rectangle.
            */
            public get size(): UnityEngine.Vector2;
            public set size(value: UnityEngine.Vector2);
            /** The minimum X coordinate of the rectangle.
            */
            public get xMin(): number;
            public set xMin(value: number);
            /** The minimum Y coordinate of the rectangle.
            */
            public get yMin(): number;
            public set yMin(value: number);
            /** The maximum X coordinate of the rectangle.
            */
            public get xMax(): number;
            public set xMax(value: number);
            /** The maximum Y coordinate of the rectangle.
            */
            public get yMax(): number;
            public set yMax(value: number);
            /** Creates a rectangle from min/max coordinate values.
            * @param xmin The minimum X coordinate.
            * @param ymin The minimum Y coordinate.
            * @param xmax The maximum X coordinate.
            * @param ymax The maximum Y coordinate.
            * @returns A rectangle matching the specified coordinates. 
            */
            public static MinMaxRect ($xmin: number, $ymin: number, $xmax: number, $ymax: number) : UnityEngine.Rect
            /** Set components of an existing Rect.
            */
            public Set ($x: number, $y: number, $width: number, $height: number) : void
            /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
            * @param point Point to test.
            * @param allowInverse Does the test allow the Rect's width and height to be negative?
            * @returns True if the point lies within the specified rectangle. 
            */
            public Contains ($point: UnityEngine.Vector2) : boolean
            /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
            * @param point Point to test.
            * @param allowInverse Does the test allow the Rect's width and height to be negative?
            * @returns True if the point lies within the specified rectangle. 
            */
            public Contains ($point: UnityEngine.Vector3) : boolean
            /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
            * @param point Point to test.
            * @param allowInverse Does the test allow the Rect's width and height to be negative?
            * @returns True if the point lies within the specified rectangle. 
            */
            public Contains ($point: UnityEngine.Vector3, $allowInverse: boolean) : boolean
            /** Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
            * @param other Other rectangle to test overlapping with.
            * @param allowInverse Does the test allow the widths and heights of the Rects to be negative?
            */
            public Overlaps ($other: UnityEngine.Rect) : boolean
            /** Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
            * @param other Other rectangle to test overlapping with.
            * @param allowInverse Does the test allow the widths and heights of the Rects to be negative?
            */
            public Overlaps ($other: UnityEngine.Rect, $allowInverse: boolean) : boolean
            /** Returns a point inside a rectangle, given normalized coordinates.
            * @param rectangle Rectangle to get a point inside.
            * @param normalizedRectCoordinates Normalized coordinates to get a point for.
            */
            public static NormalizedToPoint ($rectangle: UnityEngine.Rect, $normalizedRectCoordinates: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Returns the normalized coordinates cooresponding the the point.
            * @param rectangle Rectangle to get normalized coordinates inside.
            * @param point A point inside the rectangle to get normalized coordinates for.
            */
            public static PointToNormalized ($rectangle: UnityEngine.Rect, $point: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_Inequality ($lhs: UnityEngine.Rect, $rhs: UnityEngine.Rect) : boolean
            public static op_Equality ($lhs: UnityEngine.Rect, $rhs: UnityEngine.Rect) : boolean
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Rect) : boolean
            public ToString () : string
            /** Returns a formatted string for this Rect.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this Rect.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($x: number, $y: number, $width: number, $height: number)
            public constructor ($position: UnityEngine.Vector2, $size: UnityEngine.Vector2)
            public constructor ($source: UnityEngine.Rect)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** Enum mask of possible shader channel properties that can also be included when the Canvas mesh is created.
        */
        enum AdditionalCanvasShaderChannels
        { None = 0, TexCoord1 = 1, TexCoord2 = 2, TexCoord3 = 4, Normal = 8, Tangent = 16 }
        /** Representation of 2D vectors and points.
        */
        class Vector2 extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Vector2>
        {
            protected [__keep_incompatibility]: never;
            /** X component of the vector.
            */
            public x : number
            /** Y component of the vector.
            */
            public y : number
            public static kEpsilon : number
            public static kEpsilonNormalSqrt : number
            /** Returns this vector with a magnitude of 1 (Read Only).
            */
            public get normalized(): UnityEngine.Vector2;
            /** Returns the length of this vector (Read Only).
            */
            public get magnitude(): number;
            /** Returns the squared length of this vector (Read Only).
            */
            public get sqrMagnitude(): number;
            /** Shorthand for writing Vector2(0, 0).
            */
            public static get zero(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(1, 1).
            */
            public static get one(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(0, 1).
            */
            public static get up(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(0, -1).
            */
            public static get down(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(-1, 0).
            */
            public static get left(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(1, 0).
            */
            public static get right(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(float.PositiveInfinity, float.PositiveInfinity).
            */
            public static get positiveInfinity(): UnityEngine.Vector2;
            /** Shorthand for writing Vector2(float.NegativeInfinity, float.NegativeInfinity).
            */
            public static get negativeInfinity(): UnityEngine.Vector2;
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Set x and y components of an existing Vector2.
            */
            public Set ($newX: number, $newY: number) : void
            /** Linearly interpolates between vectors a and b by t.
            */
            public static Lerp ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2, $t: number) : UnityEngine.Vector2
            /** Linearly interpolates between vectors a and b by t.
            */
            public static LerpUnclamped ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2, $t: number) : UnityEngine.Vector2
            /** Moves a point current towards target.
            */
            public static MoveTowards ($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $maxDistanceDelta: number) : UnityEngine.Vector2
            /** Multiplies two vectors component-wise.
            */
            public static Scale ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Multiplies every component of this vector by the same component of scale.
            */
            public Scale ($scale: UnityEngine.Vector2) : void
            public Normalize () : void
            public ToString () : string
            /** Returns a formatted string for this vector.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this vector.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            /** Returns true if the given vector is exactly equal to this vector.
            */
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Vector2) : boolean
            /** Reflects a vector off the vector defined by a normal.
            */
            public static Reflect ($inDirection: UnityEngine.Vector2, $inNormal: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Returns the 2D vector perpendicular to this 2D vector. The result is always rotated 90-degrees in a counter-clockwise direction for a 2D coordinate system where the positive Y axis goes up.
            * @param inDirection The input direction.
            * @returns The perpendicular direction. 
            */
            public static Perpendicular ($inDirection: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Dot Product of two vectors.
            */
            public static Dot ($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2) : number
            /** Gets the unsigned angle in degrees between from and to.
            * @param from The vector from which the angular difference is measured.
            * @param to The vector to which the angular difference is measured.
            * @returns The unsigned angle in degrees between the two vectors. 
            */
            public static Angle ($from: UnityEngine.Vector2, $to: UnityEngine.Vector2) : number
            /** Gets the signed angle in degrees between from and to.
            * @param from The vector from which the angular difference is measured.
            * @param to The vector to which the angular difference is measured.
            * @returns The signed angle in degrees between the two vectors. 
            */
            public static SignedAngle ($from: UnityEngine.Vector2, $to: UnityEngine.Vector2) : number
            /** Returns the distance between a and b.
            */
            public static Distance ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2) : number
            /** Returns a copy of vector with its magnitude clamped to maxLength.
            */
            public static ClampMagnitude ($vector: UnityEngine.Vector2, $maxLength: number) : UnityEngine.Vector2
            public static SqrMagnitude ($a: UnityEngine.Vector2) : number
            public SqrMagnitude () : number
            /** Returns a vector that is made from the smallest components of two vectors.
            */
            public static Min ($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Returns a vector that is made from the largest components of two vectors.
            */
            public static Max ($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Gradually changes a vector towards a desired goal over time.
            * @param current The current position.
            * @param target The position we are trying to reach.
            * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param maxSpeed Optionally allows you to clamp the maximum speed.
            * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number, $maxSpeed: number) : UnityEngine.Vector2
            /** Gradually changes a vector towards a desired goal over time.
            * @param current The current position.
            * @param target The position we are trying to reach.
            * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param maxSpeed Optionally allows you to clamp the maximum speed.
            * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number) : UnityEngine.Vector2
            /** Gradually changes a vector towards a desired goal over time.
            * @param current The current position.
            * @param target The position we are trying to reach.
            * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param maxSpeed Optionally allows you to clamp the maximum speed.
            * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number, $maxSpeed: number, $deltaTime: number) : UnityEngine.Vector2
            public static op_Addition ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_Subtraction ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_Multiply ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_Division ($a: UnityEngine.Vector2, $b: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_UnaryNegation ($a: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_Multiply ($a: UnityEngine.Vector2, $d: number) : UnityEngine.Vector2
            public static op_Multiply ($d: number, $a: UnityEngine.Vector2) : UnityEngine.Vector2
            public static op_Division ($a: UnityEngine.Vector2, $d: number) : UnityEngine.Vector2
            public static op_Equality ($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2) : boolean
            public static op_Inequality ($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2) : boolean
            public static op_Implicit ($v: UnityEngine.Vector3) : UnityEngine.Vector2
            public static op_Implicit ($v: UnityEngine.Vector2) : UnityEngine.Vector3
            public constructor ($x: number, $y: number)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** A Camera is a device through which the player views the world.
        */
        class Camera extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Delegate that you can use to execute custom code before a Camera culls the scene.
            */
            public static onPreCull : UnityEngine.Camera.CameraCallback
            /** Delegate that you can use to execute custom code before a Camera renders the scene.
            */
            public static onPreRender : UnityEngine.Camera.CameraCallback
            /** Delegate that you can use to execute custom code after a Camera renders the scene.
            */
            public static onPostRender : UnityEngine.Camera.CameraCallback
            /** The distance of the near clipping plane from the the Camera, in world units.
            */
            public get nearClipPlane(): number;
            public set nearClipPlane(value: number);
            /** The distance of the far clipping plane from the Camera, in world units.
            */
            public get farClipPlane(): number;
            public set farClipPlane(value: number);
            /** The vertical field of view of the Camera, in degrees.
            */
            public get fieldOfView(): number;
            public set fieldOfView(value: number);
            /** The rendering path that should be used, if possible.
            */
            public get renderingPath(): UnityEngine.RenderingPath;
            public set renderingPath(value: UnityEngine.RenderingPath);
            /** The rendering path that is currently being used (Read Only).
            */
            public get actualRenderingPath(): UnityEngine.RenderingPath;
            /** High dynamic range rendering.
            */
            public get allowHDR(): boolean;
            public set allowHDR(value: boolean);
            /** MSAA rendering.
            */
            public get allowMSAA(): boolean;
            public set allowMSAA(value: boolean);
            /** Dynamic Resolution Scaling.
            */
            public get allowDynamicResolution(): boolean;
            public set allowDynamicResolution(value: boolean);
            /** Should camera rendering be forced into a RenderTexture.
            */
            public get forceIntoRenderTexture(): boolean;
            public set forceIntoRenderTexture(value: boolean);
            /** Camera's half-size when in orthographic mode.
            */
            public get orthographicSize(): number;
            public set orthographicSize(value: number);
            /** Is the camera orthographic (true) or perspective (false)?
            */
            public get orthographic(): boolean;
            public set orthographic(value: boolean);
            /** Opaque object sorting mode.
            */
            public get opaqueSortMode(): UnityEngine.Rendering.OpaqueSortMode;
            public set opaqueSortMode(value: UnityEngine.Rendering.OpaqueSortMode);
            /** Transparent object sorting mode.
            */
            public get transparencySortMode(): UnityEngine.TransparencySortMode;
            public set transparencySortMode(value: UnityEngine.TransparencySortMode);
            /** An axis that describes the direction along which the distances of objects are measured for the purpose of sorting.
            */
            public get transparencySortAxis(): UnityEngine.Vector3;
            public set transparencySortAxis(value: UnityEngine.Vector3);
            /** Camera's depth in the camera rendering order.
            */
            public get depth(): number;
            public set depth(value: number);
            /** The aspect ratio (width divided by height).
            */
            public get aspect(): number;
            public set aspect(value: number);
            /** Get the world-space speed of the camera (Read Only).
            */
            public get velocity(): UnityEngine.Vector3;
            /** This is used to render parts of the Scene selectively.
            */
            public get cullingMask(): number;
            public set cullingMask(value: number);
            /** Mask to select which layers can trigger events on the camera.
            */
            public get eventMask(): number;
            public set eventMask(value: number);
            /** How to perform per-layer culling for a Camera.
            */
            public get layerCullSpherical(): boolean;
            public set layerCullSpherical(value: boolean);
            /** Identifies what kind of camera this is, using the CameraType enum.
            */
            public get cameraType(): UnityEngine.CameraType;
            public set cameraType(value: UnityEngine.CameraType);
            /** Sets the culling mask used to determine which objects from which Scenes to draw.
            See EditorSceneManager.SetSceneCullingMask.
            */
            public get overrideSceneCullingMask(): bigint;
            public set overrideSceneCullingMask(value: bigint);
            /** Per-layer culling distances.
            */
            public get layerCullDistances(): System.Array$1<number>;
            public set layerCullDistances(value: System.Array$1<number>);
            /** Whether or not the Camera will use occlusion culling during rendering.
            */
            public get useOcclusionCulling(): boolean;
            public set useOcclusionCulling(value: boolean);
            /** Sets a custom matrix for the camera to use for all culling queries.
            */
            public get cullingMatrix(): UnityEngine.Matrix4x4;
            public set cullingMatrix(value: UnityEngine.Matrix4x4);
            /** The color with which the screen will be cleared.
            */
            public get backgroundColor(): UnityEngine.Color;
            public set backgroundColor(value: UnityEngine.Color);
            /** How the camera clears the background.
            */
            public get clearFlags(): UnityEngine.CameraClearFlags;
            public set clearFlags(value: UnityEngine.CameraClearFlags);
            /** How and if camera generates a depth texture.
            */
            public get depthTextureMode(): UnityEngine.DepthTextureMode;
            public set depthTextureMode(value: UnityEngine.DepthTextureMode);
            /** Should the camera clear the stencil buffer after the deferred light pass?
            */
            public get clearStencilAfterLightingPass(): boolean;
            public set clearStencilAfterLightingPass(value: boolean);
            /** Enable usePhysicalProperties to use physical camera properties to compute the field of view and the frustum.
            */
            public get usePhysicalProperties(): boolean;
            public set usePhysicalProperties(value: boolean);
            /** The size of the camera sensor, expressed in millimeters.
            */
            public get sensorSize(): UnityEngine.Vector2;
            public set sensorSize(value: UnityEngine.Vector2);
            /** The lens offset of the camera. The lens shift is relative to the sensor size. For example, a lens shift of 0.5 offsets the sensor by half its horizontal size.
            */
            public get lensShift(): UnityEngine.Vector2;
            public set lensShift(value: UnityEngine.Vector2);
            /** The camera focal length, expressed in millimeters. To use this property, enable UsePhysicalProperties.
            */
            public get focalLength(): number;
            public set focalLength(value: number);
            /** There are two gates for a camera, the sensor gate and the resolution gate. The physical camera sensor gate is defined by the sensorSize property, the resolution gate is defined by the render target area.
            */
            public get gateFit(): UnityEngine.Camera.GateFitMode;
            public set gateFit(value: UnityEngine.Camera.GateFitMode);
            /** Where on the screen is the camera rendered in normalized coordinates.
            */
            public get rect(): UnityEngine.Rect;
            public set rect(value: UnityEngine.Rect);
            /** Where on the screen is the camera rendered in pixel coordinates.
            */
            public get pixelRect(): UnityEngine.Rect;
            public set pixelRect(value: UnityEngine.Rect);
            /** How wide is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).
            */
            public get pixelWidth(): number;
            /** How tall is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).
            */
            public get pixelHeight(): number;
            /** How wide is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).
            */
            public get scaledPixelWidth(): number;
            /** How tall is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).
            */
            public get scaledPixelHeight(): number;
            /** Destination render texture.
            */
            public get targetTexture(): UnityEngine.RenderTexture;
            public set targetTexture(value: UnityEngine.RenderTexture);
            /** Gets the temporary RenderTexture target for this Camera.
            */
            public get activeTexture(): UnityEngine.RenderTexture;
            /** Set the target display for this Camera.
            */
            public get targetDisplay(): number;
            public set targetDisplay(value: number);
            /** Matrix that transforms from camera space to world space (Read Only).
            */
            public get cameraToWorldMatrix(): UnityEngine.Matrix4x4;
            /** Matrix that transforms from world to camera space.
            */
            public get worldToCameraMatrix(): UnityEngine.Matrix4x4;
            public set worldToCameraMatrix(value: UnityEngine.Matrix4x4);
            /** Set a custom projection matrix.
            */
            public get projectionMatrix(): UnityEngine.Matrix4x4;
            public set projectionMatrix(value: UnityEngine.Matrix4x4);
            /** Get or set the raw projection matrix with no camera offset (no jittering).
            */
            public get nonJitteredProjectionMatrix(): UnityEngine.Matrix4x4;
            public set nonJitteredProjectionMatrix(value: UnityEngine.Matrix4x4);
            /** Should the jittered matrix be used for transparency rendering?
            */
            public get useJitteredProjectionMatrixForTransparentRendering(): boolean;
            public set useJitteredProjectionMatrixForTransparentRendering(value: boolean);
            /** Get the view projection matrix used on the last frame.
            */
            public get previousViewProjectionMatrix(): UnityEngine.Matrix4x4;
            /** The first enabled Camera component that is tagged "MainCamera" (Read Only).
            */
            public static get main(): UnityEngine.Camera;
            /** The camera we are currently rendering with, for low-level render control only (Read Only).
            */
            public static get current(): UnityEngine.Camera;
            /** If not null, the camera will only render the contents of the specified Scene.
            */
            public get scene(): UnityEngine.SceneManagement.Scene;
            public set scene(value: UnityEngine.SceneManagement.Scene);
            /** Stereoscopic rendering.
            */
            public get stereoEnabled(): boolean;
            /** The distance between the virtual eyes. Use this to query or set the current eye separation. Note that most VR devices provide this value, in which case setting the value will have no effect.
            */
            public get stereoSeparation(): number;
            public set stereoSeparation(value: number);
            /** Distance to a point where virtual eyes converge.
            */
            public get stereoConvergence(): number;
            public set stereoConvergence(value: number);
            /** Determines whether the stereo view matrices are suitable to allow for a single pass cull.
            */
            public get areVRStereoViewMatricesWithinSingleCullTolerance(): boolean;
            /** Defines which eye of a VR display the Camera renders into.
            */
            public get stereoTargetEye(): UnityEngine.StereoTargetEyeMask;
            public set stereoTargetEye(value: UnityEngine.StereoTargetEyeMask);
            /** Returns the eye that is currently rendering.
            If called when stereo is not enabled it will return Camera.MonoOrStereoscopicEye.Mono.
            If called during a camera rendering callback such as OnRenderImage it will return the currently rendering eye.
            If called outside of a rendering callback and stereo is enabled, it will return the default eye which is Camera.MonoOrStereoscopicEye.Left.
            */
            public get stereoActiveEye(): UnityEngine.Camera.MonoOrStereoscopicEye;
            /** The number of cameras in the current Scene.
            */
            public static get allCamerasCount(): number;
            /** Returns all enabled cameras in the Scene.
            */
            public static get allCameras(): System.Array$1<UnityEngine.Camera>;
            public get sceneViewFilterMode(): UnityEngine.Camera.SceneViewFilterMode;
            /** Number of command buffers set up on this camera (Read Only).
            */
            public get commandBufferCount(): number;
            public Reset () : void
            public ResetTransparencySortSettings () : void
            public ResetAspect () : void
            public ResetCullingMatrix () : void
            /** Make the camera render with shader replacement.
            */
            public SetReplacementShader ($shader: UnityEngine.Shader, $replacementTag: string) : void
            public ResetReplacementShader () : void
            public GetGateFittedFieldOfView () : number
            public GetGateFittedLensShift () : UnityEngine.Vector2
            /** Sets the Camera to render to the chosen buffers of one or more RenderTextures.
            * @param colorBuffer The RenderBuffer(s) to which color information will be rendered.
            * @param depthBuffer The RenderBuffer to which depth information will be rendered.
            */
            public SetTargetBuffers ($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer) : void
            /** Sets the Camera to render to the chosen buffers of one or more RenderTextures.
            * @param colorBuffer The RenderBuffer(s) to which color information will be rendered.
            * @param depthBuffer The RenderBuffer to which depth information will be rendered.
            */
            public SetTargetBuffers ($colorBuffer: System.Array$1<UnityEngine.RenderBuffer>, $depthBuffer: UnityEngine.RenderBuffer) : void
            public ResetWorldToCameraMatrix () : void
            public ResetProjectionMatrix () : void
            /** Calculates and returns oblique near-plane projection matrix.
            * @param clipPlane Vector4 that describes a clip plane.
            * @returns Oblique near-plane projection matrix. 
            */
            public CalculateObliqueMatrix ($clipPlane: UnityEngine.Vector4) : UnityEngine.Matrix4x4
            public WorldToScreenPoint ($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye) : UnityEngine.Vector3
            public WorldToViewportPoint ($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye) : UnityEngine.Vector3
            public ViewportToWorldPoint ($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye) : UnityEngine.Vector3
            public ScreenToWorldPoint ($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye) : UnityEngine.Vector3
            /** Transforms position from world space into screen space.
            * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
            */
            public WorldToScreenPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms position from world space into viewport space.
            * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
            */
            public WorldToViewportPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms position from viewport space into world space.
            * @param position The 3d vector in Viewport space.
            * @returns The 3d vector in World space. 
            */
            public ViewportToWorldPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms a point from screen space into world space, where world space is defined as the coordinate system at the very top of your game's hierarchy.
            * @param position A screen space position (often mouse x, y), plus a z position for depth (for example, a camera clipping plane).
            * @param eye By default, Camera.MonoOrStereoscopicEye.Mono. Can be set to Camera.MonoOrStereoscopicEye.Left or Camera.MonoOrStereoscopicEye.Right for use in stereoscopic rendering (e.g., for VR).
            * @returns The worldspace point created by converting the screen space point at the provided distance z from the camera plane. 
            */
            public ScreenToWorldPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms position from screen space into viewport space.
            */
            public ScreenToViewportPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Transforms position from viewport space into screen space.
            */
            public ViewportToScreenPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            public ViewportPointToRay ($pos: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye) : UnityEngine.Ray
            /** Returns a ray going from camera through a viewport point.
            * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
            */
            public ViewportPointToRay ($pos: UnityEngine.Vector3) : UnityEngine.Ray
            public ScreenPointToRay ($pos: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye) : UnityEngine.Ray
            /** Returns a ray going from camera through a screen point.
            * @param pos A 3D point, with the x and y coordinates containing a 2D screenspace point in pixels. The lower left pixel of the screen is (0,0). The upper right pixel of the screen is (screen width in pixels - 1, screen height in pixels - 1). Unity ignores the z coordinate.
            * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
            */
            public ScreenPointToRay ($pos: UnityEngine.Vector3) : UnityEngine.Ray
            public CalculateFrustumCorners ($viewport: UnityEngine.Rect, $z: number, $eye: UnityEngine.Camera.MonoOrStereoscopicEye, $outCorners: System.Array$1<UnityEngine.Vector3>) : void
            public static CalculateProjectionMatrixFromPhysicalProperties ($output: $Ref<UnityEngine.Matrix4x4>, $focalLength: number, $sensorSize: UnityEngine.Vector2, $lensShift: UnityEngine.Vector2, $nearClip: number, $farClip: number, $gateFitParameters?: UnityEngine.Camera.GateFitParameters) : void
            /** Converts focal length to field of view.
            * @param focalLength Focal length in millimeters.
            * @param sensorSize Sensor size in millimeters. Use the sensor height to get the vertical field of view. Use the sensor width to get the horizontal field of view.
            * @returns field of view in degrees. 
            */
            public static FocalLengthToFieldOfView ($focalLength: number, $sensorSize: number) : number
            /** Converts field of view to focal length. Use either sensor height and vertical field of view or sensor width and horizontal field of view.
            * @param fieldOfView field of view in degrees.
            * @param sensorSize Sensor size in millimeters.
            * @returns Focal length in millimeters. 
            */
            public static FieldOfViewToFocalLength ($fieldOfView: number, $sensorSize: number) : number
            /** Converts the horizontal field of view (FOV) to the vertical FOV, based on the value of the aspect ratio parameter.
            * @param horizontalFOV The horizontal FOV value in degrees.
            * @param aspectRatio The aspect ratio value used for the conversion
            */
            public static HorizontalToVerticalFieldOfView ($horizontalFieldOfView: number, $aspectRatio: number) : number
            /** Converts the vertical field of view (FOV) to the horizontal FOV, based on the value of the aspect ratio parameter.
            * @param verticalFieldOfView The vertical FOV value in degrees.
            * @param aspectRatio The aspect ratio value used for the conversion
            */
            public static VerticalToHorizontalFieldOfView ($verticalFieldOfView: number, $aspectRatio: number) : number
            public GetStereoNonJitteredProjectionMatrix ($eye: UnityEngine.Camera.StereoscopicEye) : UnityEngine.Matrix4x4
            public GetStereoViewMatrix ($eye: UnityEngine.Camera.StereoscopicEye) : UnityEngine.Matrix4x4
            public CopyStereoDeviceProjectionMatrixToNonJittered ($eye: UnityEngine.Camera.StereoscopicEye) : void
            public GetStereoProjectionMatrix ($eye: UnityEngine.Camera.StereoscopicEye) : UnityEngine.Matrix4x4
            public SetStereoProjectionMatrix ($eye: UnityEngine.Camera.StereoscopicEye, $matrix: UnityEngine.Matrix4x4) : void
            public ResetStereoProjectionMatrices () : void
            public SetStereoViewMatrix ($eye: UnityEngine.Camera.StereoscopicEye, $matrix: UnityEngine.Matrix4x4) : void
            public ResetStereoViewMatrices () : void
            /** Fills an array of Camera with the current cameras in the Scene, without allocating a new array.
            * @param cameras An array to be filled up with cameras currently in the Scene.
            */
            public static GetAllCameras ($cameras: System.Array$1<UnityEngine.Camera>) : number
            /** Render into a static cubemap from this camera.
            * @param cubemap The cube map to render to.
            * @param faceMask A bitmask which determines which of the six faces are rendered to.
            * @returns False if rendering fails, else true. 
            */
            public RenderToCubemap ($cubemap: UnityEngine.Cubemap, $faceMask: number) : boolean
            public RenderToCubemap ($cubemap: UnityEngine.Cubemap) : boolean
            /** Render into a cubemap from this camera.
            * @param faceMask A bitfield indicating which cubemap faces should be rendered into.
            * @param cubemap The texture to render to.
            * @returns False if rendering fails, else true. 
            */
            public RenderToCubemap ($cubemap: UnityEngine.RenderTexture, $faceMask: number) : boolean
            public RenderToCubemap ($cubemap: UnityEngine.RenderTexture) : boolean
            public RenderToCubemap ($cubemap: UnityEngine.RenderTexture, $faceMask: number, $stereoEye: UnityEngine.Camera.MonoOrStereoscopicEye) : boolean
            public Render () : void
            /** Render the camera with shader replacement.
            */
            public RenderWithShader ($shader: UnityEngine.Shader, $replacementTag: string) : void
            public RenderDontRestore () : void
            public SubmitRenderRequests ($renderRequests: System.Collections.Generic.List$1<UnityEngine.Camera.RenderRequest>) : void
            public static SetupCurrent ($cur: UnityEngine.Camera) : void
            /** Makes this camera's settings match other camera.
            * @param other Copy camera settings to the other camera.
            */
            public CopyFrom ($other: UnityEngine.Camera) : void
            /** Remove command buffers from execution at a specified place.
            * @param evt When to execute the command buffer during rendering.
            */
            public RemoveCommandBuffers ($evt: UnityEngine.Rendering.CameraEvent) : void
            public RemoveAllCommandBuffers () : void
            /** Add a command buffer to be executed at a specified place.
            * @param evt When to execute the command buffer during rendering.
            * @param buffer The buffer to execute.
            */
            public AddCommandBuffer ($evt: UnityEngine.Rendering.CameraEvent, $buffer: UnityEngine.Rendering.CommandBuffer) : void
            /** Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
            * @param evt The point during the graphics processing at which this command buffer should commence on the GPU.
            * @param buffer The buffer to execute.
            * @param queueType The desired async compute queue type to execute the buffer on.
            */
            public AddCommandBufferAsync ($evt: UnityEngine.Rendering.CameraEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType) : void
            /** Remove command buffer from execution at a specified place.
            * @param evt When to execute the command buffer during rendering.
            * @param buffer The buffer to execute.
            */
            public RemoveCommandBuffer ($evt: UnityEngine.Rendering.CameraEvent, $buffer: UnityEngine.Rendering.CommandBuffer) : void
            /** Get command buffers to be executed at a specified place.
            * @param evt When to execute the command buffer during rendering.
            * @returns Array of command buffers. 
            */
            public GetCommandBuffers ($evt: UnityEngine.Rendering.CameraEvent) : System.Array$1<UnityEngine.Rendering.CommandBuffer>
            /** Get culling parameters for a camera.
            * @param cullingParameters Resultant culling parameters.
            * @param stereoAware Generate single-pass stereo aware culling parameters.
            * @returns Flag indicating whether culling parameters are valid. 
            */
            public TryGetCullingParameters ($cullingParameters: $Ref<UnityEngine.Rendering.ScriptableCullingParameters>) : boolean
            /** Get culling parameters for a camera.
            * @param cullingParameters Resultant culling parameters.
            * @param stereoAware Generate single-pass stereo aware culling parameters.
            * @returns Flag indicating whether culling parameters are valid. 
            */
            public TryGetCullingParameters ($stereoAware: boolean, $cullingParameters: $Ref<UnityEngine.Rendering.ScriptableCullingParameters>) : boolean
            public constructor ()
        }
        /** The material class.
        */
        class Material extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The shader used by the material.
            */
            public get shader(): UnityEngine.Shader;
            public set shader(value: UnityEngine.Shader);
            /** The main color of the Material.
            */
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            /** The main texture.
            */
            public get mainTexture(): UnityEngine.Texture;
            public set mainTexture(value: UnityEngine.Texture);
            /** The offset of the main texture.
            */
            public get mainTextureOffset(): UnityEngine.Vector2;
            public set mainTextureOffset(value: UnityEngine.Vector2);
            /** The scale of the main texture.
            */
            public get mainTextureScale(): UnityEngine.Vector2;
            public set mainTextureScale(value: UnityEngine.Vector2);
            /** Render queue of this material.
            */
            public get renderQueue(): number;
            public set renderQueue(value: number);
            /** An array containing the local shader keywords that are currently enabled for this material.
            */
            public get enabledKeywords(): System.Array$1<UnityEngine.Rendering.LocalKeyword>;
            public set enabledKeywords(value: System.Array$1<UnityEngine.Rendering.LocalKeyword>);
            /** Defines how the material should interact with lightmaps and lightprobes.
            */
            public get globalIlluminationFlags(): UnityEngine.MaterialGlobalIlluminationFlags;
            public set globalIlluminationFlags(value: UnityEngine.MaterialGlobalIlluminationFlags);
            /** Gets and sets whether the Double Sided Global Illumination setting is enabled for this material.
            */
            public get doubleSidedGI(): boolean;
            public set doubleSidedGI(value: boolean);
            /** Gets and sets whether GPU instancing is enabled for this material.
            */
            public get enableInstancing(): boolean;
            public set enableInstancing(value: boolean);
            /** How many passes are in this material (Read Only).
            */
            public get passCount(): number;
            /** An array containing names of the local shader keywords that are currently enabled for this material.
            */
            public get shaderKeywords(): System.Array$1<string>;
            public set shaderKeywords(value: System.Array$1<string>);
            /** Checks if the ShaderLab file assigned to the Material has a property with the given name.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasProperty ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a property with the given name.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasProperty ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Float property with the given name. This also works with the Float Array property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasFloat ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Float property with the given name. This also works with the Float Array property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasFloat ($nameID: number) : boolean
            /** This method is deprecated. Use HasFloat or HasInteger instead.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasInt ($name: string) : boolean
            /** This method is deprecated. Use HasFloat or HasInteger instead.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasInt ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has an Integer property with the given name.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasInteger ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has an Integer property with the given name.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasInteger ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Texture property with the given name.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasTexture ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Texture property with the given name.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasTexture ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Matrix property with the given name. This also works with the Matrix Array property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasMatrix ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Matrix property with the given name. This also works with the Matrix Array property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasMatrix ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Vector property with the given name. This also works with the Vector Array property.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasVector ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Vector property with the given name. This also works with the Vector Array property.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasVector ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Color property with the given name.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasColor ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a Color property with the given name.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasColor ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a ComputeBuffer property with the given name.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasBuffer ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a ComputeBuffer property with the given name.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasBuffer ($nameID: number) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a ConstantBuffer property with the given name.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasConstantBuffer ($name: string) : boolean
            /** Checks if the ShaderLab file assigned to the Material has a ConstantBuffer property with the given name.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
            */
            public HasConstantBuffer ($nameID: number) : boolean
            /** Enables a local shader keyword for this material.
            * @param keyword The name of the Rendering.LocalKeyword to enable.
            */
            public EnableKeyword ($keyword: string) : void
            /** Disables a local shader keyword for this material.
            * @param keyword The name of the Rendering.LocalKeyword to disable.
            */
            public DisableKeyword ($keyword: string) : void
            /** Checks whether a local shader keyword is enabled for this material.
            * @param keyword The name of the Rendering.LocalKeyword to check.
            * @returns Returns true if a Rendering.LocalKeyword with the given name is enabled  for this material. 
            */
            public IsKeywordEnabled ($keyword: string) : boolean
            /** Enables a local shader keyword for this material.
            * @param keyword The name of the Rendering.LocalKeyword to enable.
            */
            public EnableKeyword ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : void
            /** Disables a local shader keyword for this material.
            * @param keyword The name of the Rendering.LocalKeyword to disable.
            */
            public DisableKeyword ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : void
            /** Sets the state of a local shader keyword for this material.
            * @param keyword The Rendering.LocalKeyword to enable or disable.
            * @param value The desired keyword state.
            */
            public SetKeyword ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>, $value: boolean) : void
            /** Checks whether a local shader keyword is enabled for this material.
            * @param keyword The name of the Rendering.LocalKeyword to check.
            * @returns Returns true if a Rendering.LocalKeyword with the given name is enabled  for this material. 
            */
            public IsKeywordEnabled ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : boolean
            /** Enables or disables a Shader pass on a per-Material level.
            * @param passName Shader pass name (case insensitive).
            * @param enabled Flag indicating whether this Shader pass should be enabled.
            */
            public SetShaderPassEnabled ($passName: string, $enabled: boolean) : void
            /** Checks whether a given Shader pass is enabled on this Material.
            * @param passName Shader pass name (case insensitive).
            * @returns True if the Shader pass is enabled. 
            */
            public GetShaderPassEnabled ($passName: string) : boolean
            /** Returns the name of the shader pass at index pass.
            */
            public GetPassName ($pass: number) : string
            /** Returns the index of the pass passName.
            */
            public FindPass ($passName: string) : number
            /** Sets an override tag/value on the material.
            * @param tag Name of the tag to set.
            * @param val Name of the value to set. Empty string to clear the override flag.
            */
            public SetOverrideTag ($tag: string, $val: string) : void
            /** Get the value of material's shader tag.
            */
            public GetTag ($tag: string, $searchFallbacks: boolean, $defaultValue: string) : string
            /** Get the value of material's shader tag.
            */
            public GetTag ($tag: string, $searchFallbacks: boolean) : string
            /** Interpolate properties between two materials.
            */
            public Lerp ($start: UnityEngine.Material, $end: UnityEngine.Material, $t: number) : void
            /** Activate the given pass for rendering.
            * @param pass Shader pass number to setup.
            * @returns If false is returned, no rendering should be done. 
            */
            public SetPass ($pass: number) : boolean
            /** Copy properties from other material into this material.
            */
            public CopyPropertiesFromMaterial ($mat: UnityEngine.Material) : void
            /** Copies properties, keyword states and settings from mat to this material, but only if they exist in both materials.
            * @param mat The Material to copy from.
            */
            public CopyMatchingPropertiesFromMaterial ($mat: UnityEngine.Material) : void
            public ComputeCRC () : number
            public GetTexturePropertyNames () : System.Array$1<string>
            public GetTexturePropertyNameIDs () : System.Array$1<number>
            public GetTexturePropertyNames ($outNames: System.Collections.Generic.List$1<string>) : void
            public GetTexturePropertyNameIDs ($outNames: System.Collections.Generic.List$1<number>) : void
            /** This method is deprecated. Use SetFloat or SetInteger instead.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param value Integer value to set.
            * @param name Property name, e.g. "_SrcBlend".
            */
            public SetInt ($name: string, $value: number) : void
            /** This method is deprecated. Use SetFloat or SetInteger instead.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param value Integer value to set.
            * @param name Property name, e.g. "_SrcBlend".
            */
            public SetInt ($nameID: number, $value: number) : void
            /** Sets a named float value.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param value Float value to set.
            * @param name Property name, e.g. "_Glossiness".
            */
            public SetFloat ($name: string, $value: number) : void
            /** Sets a named float value.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param value Float value to set.
            * @param name Property name, e.g. "_Glossiness".
            */
            public SetFloat ($nameID: number, $value: number) : void
            /** Sets a named integer value.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param value Integer value to set.
            * @param name Property name, e.g. "_SrcBlend".
            */
            public SetInteger ($name: string, $value: number) : void
            /** Sets a named integer value.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param value Integer value to set.
            * @param name Property name, e.g. "_SrcBlend".
            */
            public SetInteger ($nameID: number, $value: number) : void
            /** Sets a color value.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name, e.g. "_Color".
            * @param value Color value to set.
            */
            public SetColor ($name: string, $value: UnityEngine.Color) : void
            /** Sets a color value.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name, e.g. "_Color".
            * @param value Color value to set.
            */
            public SetColor ($nameID: number, $value: UnityEngine.Color) : void
            /** Sets a named vector value.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name, e.g. "_WaveAndDistance".
            * @param value Vector value to set.
            */
            public SetVector ($name: string, $value: UnityEngine.Vector4) : void
            /** Sets a named vector value.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name, e.g. "_WaveAndDistance".
            * @param value Vector value to set.
            */
            public SetVector ($nameID: number, $value: UnityEngine.Vector4) : void
            /** Sets a named matrix for the shader.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name, e.g. "_CubemapRotation".
            * @param value Matrix value to set.
            */
            public SetMatrix ($name: string, $value: UnityEngine.Matrix4x4) : void
            /** Sets a named matrix for the shader.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name, e.g. "_CubemapRotation".
            * @param value Matrix value to set.
            */
            public SetMatrix ($nameID: number, $value: UnityEngine.Matrix4x4) : void
            /** Sets a named texture.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name, e.g. "_MainTex".
            * @param value Texture to set.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($name: string, $value: UnityEngine.Texture) : void
            /** Sets a named texture.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name, e.g. "_MainTex".
            * @param value Texture to set.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($nameID: number, $value: UnityEngine.Texture) : void
            /** Sets a named texture.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name, e.g. "_MainTex".
            * @param value Texture to set.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($name: string, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Sets a named texture.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name, e.g. "_MainTex".
            * @param value Texture to set.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($nameID: number, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Sets a named buffer value.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name.
            * @param value The ComputeBuffer or GraphicsBuffer value to set.
            */
            public SetBuffer ($name: string, $value: UnityEngine.ComputeBuffer) : void
            /** Sets a named buffer value.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name.
            * @param value The ComputeBuffer or GraphicsBuffer value to set.
            */
            public SetBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer) : void
            /** Sets a named buffer value.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name.
            * @param value The ComputeBuffer or GraphicsBuffer value to set.
            */
            public SetBuffer ($name: string, $value: UnityEngine.GraphicsBuffer) : void
            /** Sets a named buffer value.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name.
            * @param value The ComputeBuffer or GraphicsBuffer value to set.
            */
            public SetBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
            * @param name The name of the constant buffer to override.
            * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
            * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            * @param nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($name: string, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
            * @param name The name of the constant buffer to override.
            * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
            * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            * @param nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
            * @param name The name of the constant buffer to override.
            * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
            * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            * @param nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($name: string, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
            * @param name The name of the constant buffer to override.
            * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
            * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            * @param nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            public SetFloatArray ($name: string, $values: System.Collections.Generic.List$1<number>) : void
            public SetFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            /** Sets a float array property.
            * @param name Property name.
            * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param values Array of values to set.
            */
            public SetFloatArray ($name: string, $values: System.Array$1<number>) : void
            /** Sets a float array property.
            * @param name Property name.
            * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
            * @param values Array of values to set.
            */
            public SetFloatArray ($nameID: number, $values: System.Array$1<number>) : void
            public SetColorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Color>) : void
            public SetColorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Color>) : void
            /** Sets a color array property.
            * @param name Property name.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param values Array of values to set.
            */
            public SetColorArray ($name: string, $values: System.Array$1<UnityEngine.Color>) : void
            /** Sets a color array property.
            * @param name Property name.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param values Array of values to set.
            */
            public SetColorArray ($nameID: number, $values: System.Array$1<UnityEngine.Color>) : void
            public SetVectorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public SetVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** Sets a vector array property.
            * @param name Property name.
            * @param values Array of values to set.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            */
            public SetVectorArray ($name: string, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Sets a vector array property.
            * @param name Property name.
            * @param values Array of values to set.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            */
            public SetVectorArray ($nameID: number, $values: System.Array$1<UnityEngine.Vector4>) : void
            public SetMatrixArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public SetMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            /** Sets a matrix array property.
            * @param name Property name.
            * @param values Array of values to set.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            */
            public SetMatrixArray ($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Sets a matrix array property.
            * @param name Property name.
            * @param values Array of values to set.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            */
            public SetMatrixArray ($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** This method is deprecated. Use GetFloat or GetInteger instead.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetInt ($name: string) : number
            /** This method is deprecated. Use GetFloat or GetInteger instead.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetInt ($nameID: number) : number
            /** Get a named float value.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetFloat ($name: string) : number
            /** Get a named float value.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetFloat ($nameID: number) : number
            /** Get a named integer value.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetInteger ($name: string) : number
            /** Get a named integer value.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetInteger ($nameID: number) : number
            /** Get a named color value.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetColor ($name: string) : UnityEngine.Color
            /** Get a named color value.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetColor ($nameID: number) : UnityEngine.Color
            /** Get a named vector value.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetVector ($name: string) : UnityEngine.Vector4
            /** Get a named vector value.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetVector ($nameID: number) : UnityEngine.Vector4
            /** Get a named matrix value from the shader.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetMatrix ($name: string) : UnityEngine.Matrix4x4
            /** Get a named matrix value from the shader.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetMatrix ($nameID: number) : UnityEngine.Matrix4x4
            /** Get a named texture.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetTexture ($name: string) : UnityEngine.Texture
            /** Get a named texture.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetTexture ($nameID: number) : UnityEngine.Texture
            /** Get a named float array.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            */
            public GetFloatArray ($name: string) : System.Array$1<number>
            /** Get a named float array.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            */
            public GetFloatArray ($nameID: number) : System.Array$1<number>
            /** Get a named color array.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetColorArray ($name: string) : System.Array$1<UnityEngine.Color>
            /** Get a named color array.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetColorArray ($nameID: number) : System.Array$1<UnityEngine.Color>
            /** Get a named vector array.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            */
            public GetVectorArray ($name: string) : System.Array$1<UnityEngine.Vector4>
            /** Get a named vector array.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            */
            public GetVectorArray ($nameID: number) : System.Array$1<UnityEngine.Vector4>
            /** Get a named matrix array.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            */
            public GetMatrixArray ($name: string) : System.Array$1<UnityEngine.Matrix4x4>
            /** Get a named matrix array.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            */
            public GetMatrixArray ($nameID: number) : System.Array$1<UnityEngine.Matrix4x4>
            public GetFloatArray ($name: string, $values: System.Collections.Generic.List$1<number>) : void
            public GetFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            public GetColorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Color>) : void
            public GetColorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Color>) : void
            public GetVectorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public GetVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public GetMatrixArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public GetMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            /** Sets the placement offset of a given texture. The name parameter is defined in the shader. This method creates a new Material instance.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name The name of the texture property as defined in the shader. For example: "_MainTex".
            * @param value Texture placement offset.
            */
            public SetTextureOffset ($name: string, $value: UnityEngine.Vector2) : void
            /** Sets the placement offset of a given texture. The name parameter is defined in the shader. This method creates a new Material instance.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name The name of the texture property as defined in the shader. For example: "_MainTex".
            * @param value Texture placement offset.
            */
            public SetTextureOffset ($nameID: number, $value: UnityEngine.Vector2) : void
            /** Sets the placement scale of texture propertyName.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name, e.g. "_MainTex".
            * @param value Texture placement scale.
            */
            public SetTextureScale ($name: string, $value: UnityEngine.Vector2) : void
            /** Sets the placement scale of texture propertyName.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Property name, e.g. "_MainTex".
            * @param value Texture placement scale.
            */
            public SetTextureScale ($nameID: number, $value: UnityEngine.Vector2) : void
            /** Gets the placement offset of texture propertyName.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetTextureOffset ($name: string) : UnityEngine.Vector2
            /** Gets the placement offset of texture propertyName.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetTextureOffset ($nameID: number) : UnityEngine.Vector2
            /** Gets the placement scale of texture propertyName.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetTextureScale ($name: string) : UnityEngine.Vector2
            /** Gets the placement scale of texture propertyName.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetTextureScale ($nameID: number) : UnityEngine.Vector2
            public constructor ($shader: UnityEngine.Shader)
            public constructor ($source: UnityEngine.Material)
            public constructor ()
        }
        /** MonoBehaviour is the base class from which every Unity script derives.
        */
        class MonoBehaviour extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Disabling this lets you skip the GUI layout phase.
            */
            public get useGUILayout(): boolean;
            public set useGUILayout(value: boolean);
            public IsInvoking () : boolean
            public CancelInvoke () : void
            /** Invokes the method methodName in time seconds.
            */
            public Invoke ($methodName: string, $time: number) : void
            /** Invokes the method methodName in time seconds, then repeatedly every repeatRate seconds.
            */
            public InvokeRepeating ($methodName: string, $time: number, $repeatRate: number) : void
            /** Cancels all Invoke calls with name methodName on this behaviour.
            */
            public CancelInvoke ($methodName: string) : void
            /** Is any invoke on methodName pending?
            */
            public IsInvoking ($methodName: string) : boolean
            /** Starts a coroutine named methodName.
            */
            public StartCoroutine ($methodName: string) : UnityEngine.Coroutine
            /** Starts a coroutine named methodName.
            */
            public StartCoroutine ($methodName: string, $value: any) : UnityEngine.Coroutine
            /** Starts a Coroutine.
            */
            public StartCoroutine ($routine: System.Collections.IEnumerator) : UnityEngine.Coroutine
            /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
            * @param methodName Name of coroutine.
            * @param routine Name of the function in code, including coroutines.
            */
            public StopCoroutine ($routine: System.Collections.IEnumerator) : void
            /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
            * @param methodName Name of coroutine.
            * @param routine Name of the function in code, including coroutines.
            */
            public StopCoroutine ($routine: UnityEngine.Coroutine) : void
            /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
            * @param methodName Name of coroutine.
            * @param routine Name of the function in code, including coroutines.
            */
            public StopCoroutine ($methodName: string) : void
            public StopAllCoroutines () : void
            /** Logs message to the Unity Console (identical to Debug.Log).
            */
            public static print ($message: any) : void
            public constructor ()
        }
        /** Base class for all yield instructions.
        */
        class YieldInstruction extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** MonoBehaviour.StartCoroutine returns a Coroutine. Instances of this class are only used to reference these coroutines, and do not hold any exposed properties or functions.
        */
        class Coroutine extends UnityEngine.YieldInstruction
        {
            protected [__keep_incompatibility]: never;
        }
        /** Asynchronous operation coroutine.
        */
        class AsyncOperation extends UnityEngine.YieldInstruction
        {
            protected [__keep_incompatibility]: never;
            /** Has the operation finished? (Read Only)
            */
            public get isDone(): boolean;
            /** What's the operation's progress. (Read Only)
            */
            public get progress(): number;
            /** Priority lets you tweak in which order async operation calls will be performed.
            */
            public get priority(): number;
            public set priority(value: number);
            /** Allow Scenes to be activated as soon as it is ready.
            */
            public get allowSceneActivation(): boolean;
            public set allowSceneActivation(value: boolean);
            public add_completed ($value: System.Action$1<UnityEngine.AsyncOperation>) : void
            public remove_completed ($value: System.Action$1<UnityEngine.AsyncOperation>) : void
            public constructor ()
        }
        /** Asynchronous operation coroutine.
        */
        interface AsyncOperation {
            GetAwaiter () : ET.ETTask;
        }
        interface ICanvasRaycastFilter
        {
            /** Given a point and a camera is the raycast valid.
            * @param sp Screen position.
            * @param eventCamera Raycast camera.
            * @returns Valid. 
            */
            IsRaycastLocationValid ($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera) : boolean
        }
        interface ISerializationCallbackReceiver
        {
            OnBeforeSerialize () : void
            OnAfterDeserialize () : void
        }
        /** Interface to control the Mecanim animation system.
        */
        class Animator extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Returns true if the current rig is optimizable with AnimatorUtility.OptimizeTransformHierarchy.
            */
            public get isOptimizable(): boolean;
            /** Returns true if the current rig is humanoid, false if it is generic.
            */
            public get isHuman(): boolean;
            /** Returns true if the current rig has root motion.
            */
            public get hasRootMotion(): boolean;
            /** Returns the scale of the current Avatar for a humanoid rig, (1 by default if the rig is generic).
            */
            public get humanScale(): number;
            /** Returns whether the animator is initialized successfully.
            */
            public get isInitialized(): boolean;
            /** Gets the avatar delta position for the last evaluated frame.
            */
            public get deltaPosition(): UnityEngine.Vector3;
            /** Gets the avatar delta rotation for the last evaluated frame.
            */
            public get deltaRotation(): UnityEngine.Quaternion;
            /** Gets the avatar velocity  for the last evaluated frame.
            */
            public get velocity(): UnityEngine.Vector3;
            /** Gets the avatar angular velocity for the last evaluated frame.
            */
            public get angularVelocity(): UnityEngine.Vector3;
            /** The root position, the position of the game object.
            */
            public get rootPosition(): UnityEngine.Vector3;
            public set rootPosition(value: UnityEngine.Vector3);
            /** The root rotation, the rotation of the game object.
            */
            public get rootRotation(): UnityEngine.Quaternion;
            public set rootRotation(value: UnityEngine.Quaternion);
            /** Should root motion be applied?
            */
            public get applyRootMotion(): boolean;
            public set applyRootMotion(value: boolean);
            /** Specifies the update mode of the Animator.
            */
            public get updateMode(): UnityEngine.AnimatorUpdateMode;
            public set updateMode(value: UnityEngine.AnimatorUpdateMode);
            /** Returns true if the object has a transform hierarchy.
            */
            public get hasTransformHierarchy(): boolean;
            /** The current gravity weight based on current animations that are played.
            */
            public get gravityWeight(): number;
            /** The position of the body center of mass.
            */
            public get bodyPosition(): UnityEngine.Vector3;
            public set bodyPosition(value: UnityEngine.Vector3);
            /** The rotation of the body center of mass.
            */
            public get bodyRotation(): UnityEngine.Quaternion;
            public set bodyRotation(value: UnityEngine.Quaternion);
            /** Automatic stabilization of feet during transition and blending.
            */
            public get stabilizeFeet(): boolean;
            public set stabilizeFeet(value: boolean);
            /** Returns the number of layers in the controller.
            */
            public get layerCount(): number;
            /** The AnimatorControllerParameter list used by the animator. (Read Only)
            */
            public get parameters(): System.Array$1<UnityEngine.AnimatorControllerParameter>;
            /** Returns the number of parameters in the controller.
            */
            public get parameterCount(): number;
            /** Blends pivot point between body center of mass and feet pivot.
            */
            public get feetPivotActive(): number;
            public set feetPivotActive(value: number);
            /** Gets the pivot weight.
            */
            public get pivotWeight(): number;
            /** Get the current position of the pivot.
            */
            public get pivotPosition(): UnityEngine.Vector3;
            /** If automatic matching is active.
            */
            public get isMatchingTarget(): boolean;
            /** The playback speed of the Animator. 1 is normal playback speed.
            */
            public get speed(): number;
            public set speed(value: number);
            /** Returns the position of the target specified by SetTarget.
            */
            public get targetPosition(): UnityEngine.Vector3;
            /** Returns the rotation of the target specified by SetTarget.
            */
            public get targetRotation(): UnityEngine.Quaternion;
            /** Controls culling of this Animator component.
            */
            public get cullingMode(): UnityEngine.AnimatorCullingMode;
            public set cullingMode(value: UnityEngine.AnimatorCullingMode);
            /** Sets the playback position in the recording buffer.
            */
            public get playbackTime(): number;
            public set playbackTime(value: number);
            /** Start time of the first frame of the buffer relative to the frame at which StartRecording was called.
            */
            public get recorderStartTime(): number;
            public set recorderStartTime(value: number);
            /** End time of the recorded clip relative to when StartRecording was called.
            */
            public get recorderStopTime(): number;
            public set recorderStopTime(value: number);
            /** Gets the mode of the Animator recorder.
            */
            public get recorderMode(): UnityEngine.AnimatorRecorderMode;
            /** The runtime representation of AnimatorController that controls the Animator.
            */
            public get runtimeAnimatorController(): UnityEngine.RuntimeAnimatorController;
            public set runtimeAnimatorController(value: UnityEngine.RuntimeAnimatorController);
            /** Returns true if Animator has any playables assigned to it.
            */
            public get hasBoundPlayables(): boolean;
            /** Gets/Sets the current Avatar.
            */
            public get avatar(): UnityEngine.Avatar;
            public set avatar(value: UnityEngine.Avatar);
            /** The PlayableGraph created by the Animator.
            */
            public get playableGraph(): UnityEngine.Playables.PlayableGraph;
            /** Additional layers affects the center of mass.
            */
            public get layersAffectMassCenter(): boolean;
            public set layersAffectMassCenter(value: boolean);
            /** Get left foot bottom height.
            */
            public get leftFeetBottomHeight(): number;
            /** Get right foot bottom height.
            */
            public get rightFeetBottomHeight(): number;
            public get logWarnings(): boolean;
            public set logWarnings(value: boolean);
            /** Sets whether the Animator sends events of type AnimationEvent.
            */
            public get fireEvents(): boolean;
            public set fireEvents(value: boolean);
            /** Controls the behaviour of the Animator component when a GameObject is disabled.
            */
            public get keepAnimatorStateOnDisable(): boolean;
            public set keepAnimatorStateOnDisable(value: boolean);
            /** Specifies whether playable graph values are reset or preserved when the Animator is disabled.
            */
            public get writeDefaultValuesOnDisable(): boolean;
            public set writeDefaultValuesOnDisable(value: boolean);
            /** Returns the value of the given float parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @returns The value of the parameter. 
            */
            public GetFloat ($name: string) : number
            /** Returns the value of the given float parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @returns The value of the parameter. 
            */
            public GetFloat ($id: number) : number
            /** Send float values to the Animator to affect transitions.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @param value The new parameter value.
            * @param dampTime The damper total time.
            * @param deltaTime The delta time to give to the damper.
            */
            public SetFloat ($name: string, $value: number) : void
            /** Send float values to the Animator to affect transitions.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @param value The new parameter value.
            * @param dampTime The damper total time.
            * @param deltaTime The delta time to give to the damper.
            */
            public SetFloat ($name: string, $value: number, $dampTime: number, $deltaTime: number) : void
            /** Send float values to the Animator to affect transitions.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @param value The new parameter value.
            * @param dampTime The damper total time.
            * @param deltaTime The delta time to give to the damper.
            */
            public SetFloat ($id: number, $value: number) : void
            /** Send float values to the Animator to affect transitions.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @param value The new parameter value.
            * @param dampTime The damper total time.
            * @param deltaTime The delta time to give to the damper.
            */
            public SetFloat ($id: number, $value: number, $dampTime: number, $deltaTime: number) : void
            /** Returns the value of the given boolean parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @returns The value of the parameter. 
            */
            public GetBool ($name: string) : boolean
            /** Returns the value of the given boolean parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @returns The value of the parameter. 
            */
            public GetBool ($id: number) : boolean
            /** Sets the value of the given boolean parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @param value The new parameter value.
            */
            public SetBool ($name: string, $value: boolean) : void
            /** Sets the value of the given boolean parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @param value The new parameter value.
            */
            public SetBool ($id: number, $value: boolean) : void
            /** Returns the value of the given integer parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @returns The value of the parameter. 
            */
            public GetInteger ($name: string) : number
            /** Returns the value of the given integer parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @returns The value of the parameter. 
            */
            public GetInteger ($id: number) : number
            /** Sets the value of the given integer parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @param value The new parameter value.
            */
            public SetInteger ($name: string, $value: number) : void
            /** Sets the value of the given integer parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @param value The new parameter value.
            */
            public SetInteger ($id: number, $value: number) : void
            /** Sets the value of the given trigger parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            */
            public SetTrigger ($name: string) : void
            /** Sets the value of the given trigger parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            */
            public SetTrigger ($id: number) : void
            /** Resets the value of the given trigger parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            */
            public ResetTrigger ($name: string) : void
            /** Resets the value of the given trigger parameter.
            * @param name The parameter name.
            * @param id The parameter ID.
            */
            public ResetTrigger ($id: number) : void
            /** Returns true if the parameter is controlled by a curve, false otherwise.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @returns True if the parameter is controlled by a curve, false otherwise. 
            */
            public IsParameterControlledByCurve ($name: string) : boolean
            /** Returns true if the parameter is controlled by a curve, false otherwise.
            * @param name The parameter name.
            * @param id The parameter ID.
            * @returns True if the parameter is controlled by a curve, false otherwise. 
            */
            public IsParameterControlledByCurve ($id: number) : boolean
            /** Gets the position of an IK goal.
            * @param goal The AvatarIKGoal that is queried.
            * @returns Return the current position of this IK goal in world space. 
            */
            public GetIKPosition ($goal: UnityEngine.AvatarIKGoal) : UnityEngine.Vector3
            /** Sets the position of an IK goal.
            * @param goal The AvatarIKGoal that is set.
            * @param goalPosition The position in world space.
            */
            public SetIKPosition ($goal: UnityEngine.AvatarIKGoal, $goalPosition: UnityEngine.Vector3) : void
            /** Gets the rotation of an IK goal.
            * @param goal The AvatarIKGoal that is is queried.
            */
            public GetIKRotation ($goal: UnityEngine.AvatarIKGoal) : UnityEngine.Quaternion
            /** Sets the rotation of an IK goal.
            * @param goal The AvatarIKGoal that is set.
            * @param goalRotation The rotation in world space.
            */
            public SetIKRotation ($goal: UnityEngine.AvatarIKGoal, $goalRotation: UnityEngine.Quaternion) : void
            /** Gets the translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal).
            * @param goal The AvatarIKGoal that is queried.
            */
            public GetIKPositionWeight ($goal: UnityEngine.AvatarIKGoal) : number
            /** Sets the translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal).
            * @param goal The AvatarIKGoal that is set.
            * @param value The translative weight.
            */
            public SetIKPositionWeight ($goal: UnityEngine.AvatarIKGoal, $value: number) : void
            /** Gets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal).
            * @param goal The AvatarIKGoal that is queried.
            */
            public GetIKRotationWeight ($goal: UnityEngine.AvatarIKGoal) : number
            /** Sets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal).
            * @param goal The AvatarIKGoal that is set.
            * @param value The rotational weight.
            */
            public SetIKRotationWeight ($goal: UnityEngine.AvatarIKGoal, $value: number) : void
            /** Gets the position of an IK hint.
            * @param hint The AvatarIKHint that is queried.
            * @returns Return the current position of this IK hint in world space. 
            */
            public GetIKHintPosition ($hint: UnityEngine.AvatarIKHint) : UnityEngine.Vector3
            /** Sets the position of an IK hint.
            * @param hint The AvatarIKHint that is set.
            * @param hintPosition The position in world space.
            */
            public SetIKHintPosition ($hint: UnityEngine.AvatarIKHint, $hintPosition: UnityEngine.Vector3) : void
            /** Gets the translative weight of an IK Hint (0 = at the original animation before IK, 1 = at the hint).
            * @param hint The AvatarIKHint that is queried.
            * @returns Return translative weight. 
            */
            public GetIKHintPositionWeight ($hint: UnityEngine.AvatarIKHint) : number
            /** Sets the translative weight of an IK hint (0 = at the original animation before IK, 1 = at the hint).
            * @param hint The AvatarIKHint that is set.
            * @param value The translative weight.
            */
            public SetIKHintPositionWeight ($hint: UnityEngine.AvatarIKHint, $value: number) : void
            /** Sets the look at position.
            * @param lookAtPosition The position to lookAt.
            */
            public SetLookAtPosition ($lookAtPosition: UnityEngine.Vector3) : void
            /** Set look at weights.
            * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
            * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
            * @param headWeight (0-1) determines how much the head is involved in the LookAt.
            * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
            * @param clampWeight (0-1) 0.0 means the character is unrestrained in motion. 1.0 means the character is clamped (look at becomes impossible). 0.5 means the character is able to move on half of the possible range (180 degrees).
            */
            public SetLookAtWeight ($weight: number) : void
            /** Set look at weights.
            * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
            * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
            * @param headWeight (0-1) determines how much the head is involved in the LookAt.
            * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
            * @param clampWeight (0-1) 0.0 means the character is unrestrained in motion. 1.0 means the character is clamped (look at becomes impossible). 0.5 means the character is able to move on half of the possible range (180 degrees).
            */
            public SetLookAtWeight ($weight: number, $bodyWeight: number) : void
            /** Set look at weights.
            * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
            * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
            * @param headWeight (0-1) determines how much the head is involved in the LookAt.
            * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
            * @param clampWeight (0-1) 0.0 means the character is unrestrained in motion. 1.0 means the character is clamped (look at becomes impossible). 0.5 means the character is able to move on half of the possible range (180 degrees).
            */
            public SetLookAtWeight ($weight: number, $bodyWeight: number, $headWeight: number) : void
            /** Set look at weights.
            * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
            * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
            * @param headWeight (0-1) determines how much the head is involved in the LookAt.
            * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
            * @param clampWeight (0-1) 0.0 means the character is unrestrained in motion. 1.0 means the character is clamped (look at becomes impossible). 0.5 means the character is able to move on half of the possible range (180 degrees).
            */
            public SetLookAtWeight ($weight: number, $bodyWeight: number, $headWeight: number, $eyesWeight: number) : void
            /** Set look at weights.
            * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
            * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
            * @param headWeight (0-1) determines how much the head is involved in the LookAt.
            * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
            * @param clampWeight (0-1) 0.0 means the character is unrestrained in motion. 1.0 means the character is clamped (look at becomes impossible). 0.5 means the character is able to move on half of the possible range (180 degrees).
            */
            public SetLookAtWeight ($weight: number, $bodyWeight: number, $headWeight: number, $eyesWeight: number, $clampWeight: number) : void
            /** Sets local rotation of a human bone during a IK pass.
            * @param humanBoneId The human bone Id.
            * @param rotation The local rotation.
            */
            public SetBoneLocalRotation ($humanBoneId: UnityEngine.HumanBodyBones, $rotation: UnityEngine.Quaternion) : void
            public GetBehaviours ($fullPathHash: number, $layerIndex: number) : System.Array$1<UnityEngine.StateMachineBehaviour>
            /** Returns the layer name.
            * @param layerIndex The layer index.
            * @returns The layer name. 
            */
            public GetLayerName ($layerIndex: number) : string
            /** Returns the index of the layer with the given name.
            * @param layerName The layer name.
            * @returns The layer index. 
            */
            public GetLayerIndex ($layerName: string) : number
            /** Returns the weight of the layer at the specified index.
            * @param layerIndex The layer index.
            * @returns The layer weight. 
            */
            public GetLayerWeight ($layerIndex: number) : number
            /** Sets the weight of the layer at the given index.
            * @param layerIndex The layer index.
            * @param weight The new layer weight.
            */
            public SetLayerWeight ($layerIndex: number, $weight: number) : void
            /** Returns an AnimatorStateInfo with the information on the current state.
            * @param layerIndex The layer index.
            * @returns An AnimatorStateInfo with the information on the current state. 
            */
            public GetCurrentAnimatorStateInfo ($layerIndex: number) : UnityEngine.AnimatorStateInfo
            /** Returns an AnimatorStateInfo with the information on the next state.
            * @param layerIndex The layer index.
            * @returns An AnimatorStateInfo with the information on the next state. 
            */
            public GetNextAnimatorStateInfo ($layerIndex: number) : UnityEngine.AnimatorStateInfo
            /** Returns an AnimatorTransitionInfo with the informations on the current transition.
            * @param layerIndex The layer's index.
            * @returns An AnimatorTransitionInfo with the informations on the current transition. 
            */
            public GetAnimatorTransitionInfo ($layerIndex: number) : UnityEngine.AnimatorTransitionInfo
            /** Returns the number of AnimatorClipInfo in the current state.
            * @param layerIndex The layer index.
            * @returns The number of AnimatorClipInfo in the current state. 
            */
            public GetCurrentAnimatorClipInfoCount ($layerIndex: number) : number
            /** Returns the number of AnimatorClipInfo in the next state.
            * @param layerIndex The layer index.
            * @returns The number of AnimatorClipInfo in the next state. 
            */
            public GetNextAnimatorClipInfoCount ($layerIndex: number) : number
            /** Returns an array of all the AnimatorClipInfo in the current state of the given layer.
            * @param layerIndex The layer index.
            * @returns An array of all the AnimatorClipInfo in the current state. 
            */
            public GetCurrentAnimatorClipInfo ($layerIndex: number) : System.Array$1<UnityEngine.AnimatorClipInfo>
            /** Returns an array of all the AnimatorClipInfo in the next state of the given layer.
            * @param layerIndex The layer index.
            * @returns An array of all the AnimatorClipInfo in the next state. 
            */
            public GetNextAnimatorClipInfo ($layerIndex: number) : System.Array$1<UnityEngine.AnimatorClipInfo>
            public GetCurrentAnimatorClipInfo ($layerIndex: number, $clips: System.Collections.Generic.List$1<UnityEngine.AnimatorClipInfo>) : void
            public GetNextAnimatorClipInfo ($layerIndex: number, $clips: System.Collections.Generic.List$1<UnityEngine.AnimatorClipInfo>) : void
            /** Returns true if there is a transition on the given layer, false otherwise.
            * @param layerIndex The layer index.
            * @returns True if there is a transition on the given layer, false otherwise. 
            */
            public IsInTransition ($layerIndex: number) : boolean
            /** See AnimatorController.parameters.
            */
            public GetParameter ($index: number) : UnityEngine.AnimatorControllerParameter
            public MatchTarget ($matchPosition: UnityEngine.Vector3, $matchRotation: UnityEngine.Quaternion, $targetBodyPart: UnityEngine.AvatarTarget, $weightMask: UnityEngine.MatchTargetWeightMask, $startNormalizedTime: number) : void
            /** Automatically adjust the GameObject position and rotation.
            * @param matchPosition The position we want the body part to reach.
            * @param matchRotation The rotation in which we want the body part to be.
            * @param targetBodyPart The body part that is involved in the match.
            * @param weightMask Structure that contains weights for matching position and rotation.
            * @param startNormalizedTime Start time within the animation clip (0 - beginning of clip, 1 - end of clip).
            * @param targetNormalizedTime End time within the animation clip (0 - beginning of clip, 1 - end of clip), values greater than 1 can be set to trigger a match after a certain number of loops. Ex: 2.3 means at 30% of 2nd loop.
            * @param completeMatch Allows you to specify what should happen if the MatchTarget function is interrupted. A value of true causes the GameObject to immediately move to the matchPosition if interrupted. A value of false causes the GameObject to stay at its current position if interrupted.
            */
            public MatchTarget ($matchPosition: UnityEngine.Vector3, $matchRotation: UnityEngine.Quaternion, $targetBodyPart: UnityEngine.AvatarTarget, $weightMask: UnityEngine.MatchTargetWeightMask, $startNormalizedTime: number, $targetNormalizedTime: number) : void
            public MatchTarget ($matchPosition: UnityEngine.Vector3, $matchRotation: UnityEngine.Quaternion, $targetBodyPart: UnityEngine.AvatarTarget, $weightMask: UnityEngine.MatchTargetWeightMask, $startNormalizedTime: number, $targetNormalizedTime: number, $completeMatch: boolean) : void
            public InterruptMatchTarget () : void
            /** Interrupts the automatic target matching.
            */
            public InterruptMatchTarget ($completeMatch: boolean) : void
            public CrossFadeInFixedTime ($stateName: string, $fixedTransitionDuration: number) : void
            public CrossFadeInFixedTime ($stateName: string, $fixedTransitionDuration: number, $layer: number) : void
            public CrossFadeInFixedTime ($stateName: string, $fixedTransitionDuration: number, $layer: number, $fixedTimeOffset: number) : void
            /** Creates a crossfade from the current state to any other state using times in seconds.
            * @param stateName The name of the state.
            * @param stateHashName The hash name of the state.
            * @param fixedTransitionDuration The duration of the transition (in seconds).
            * @param layer The layer where the crossfade occurs.
            * @param fixedTimeOffset The time of the state (in seconds).
            * @param normalizedTransitionTime The time of the transition (normalized).
            */
            public CrossFadeInFixedTime ($stateName: string, $fixedTransitionDuration: number, $layer: number, $fixedTimeOffset: number, $normalizedTransitionTime: number) : void
            public CrossFadeInFixedTime ($stateHashName: number, $fixedTransitionDuration: number, $layer: number, $fixedTimeOffset: number) : void
            public CrossFadeInFixedTime ($stateHashName: number, $fixedTransitionDuration: number, $layer: number) : void
            public CrossFadeInFixedTime ($stateHashName: number, $fixedTransitionDuration: number) : void
            /** Creates a crossfade from the current state to any other state using times in seconds.
            * @param stateName The name of the state.
            * @param stateHashName The hash name of the state.
            * @param fixedTransitionDuration The duration of the transition (in seconds).
            * @param layer The layer where the crossfade occurs.
            * @param fixedTimeOffset The time of the state (in seconds).
            * @param normalizedTransitionTime The time of the transition (normalized).
            */
            public CrossFadeInFixedTime ($stateHashName: number, $fixedTransitionDuration: number, $layer: number, $fixedTimeOffset: number, $normalizedTransitionTime: number) : void
            public WriteDefaultValues () : void
            public CrossFade ($stateName: string, $normalizedTransitionDuration: number, $layer: number, $normalizedTimeOffset: number) : void
            public CrossFade ($stateName: string, $normalizedTransitionDuration: number, $layer: number) : void
            public CrossFade ($stateName: string, $normalizedTransitionDuration: number) : void
            /** Creates a crossfade from the current state to any other state using normalized times.
            * @param stateName The name of the state.
            * @param stateHashName The hash name of the state.
            * @param normalizedTransitionDuration The duration of the transition (normalized).
            * @param layer The layer where the crossfade occurs.
            * @param normalizedTimeOffset The time of the state (normalized).
            * @param normalizedTransitionTime The time of the transition (normalized).
            */
            public CrossFade ($stateName: string, $normalizedTransitionDuration: number, $layer: number, $normalizedTimeOffset: number, $normalizedTransitionTime: number) : void
            /** Creates a crossfade from the current state to any other state using normalized times.
            * @param stateName The name of the state.
            * @param stateHashName The hash name of the state.
            * @param normalizedTransitionDuration The duration of the transition (normalized).
            * @param layer The layer where the crossfade occurs.
            * @param normalizedTimeOffset The time of the state (normalized).
            * @param normalizedTransitionTime The time of the transition (normalized).
            */
            public CrossFade ($stateHashName: number, $normalizedTransitionDuration: number, $layer: number, $normalizedTimeOffset: number, $normalizedTransitionTime: number) : void
            public CrossFade ($stateHashName: number, $normalizedTransitionDuration: number, $layer: number, $normalizedTimeOffset: number) : void
            public CrossFade ($stateHashName: number, $normalizedTransitionDuration: number, $layer: number) : void
            public CrossFade ($stateHashName: number, $normalizedTransitionDuration: number) : void
            public PlayInFixedTime ($stateName: string, $layer: number) : void
            public PlayInFixedTime ($stateName: string) : void
            /** Plays a state.
            * @param stateName The state name.
            * @param stateNameHash The state hash name. If stateNameHash is 0, it changes the current state time.
            * @param layer The layer index. If layer is -1, it plays the first state with the given state name or hash.
            * @param fixedTime The time offset (in seconds).
            */
            public PlayInFixedTime ($stateName: string, $layer: number, $fixedTime: number) : void
            /** Plays a state.
            * @param stateName The state name.
            * @param stateNameHash The state hash name. If stateNameHash is 0, it changes the current state time.
            * @param layer The layer index. If layer is -1, it plays the first state with the given state name or hash.
            * @param fixedTime The time offset (in seconds).
            */
            public PlayInFixedTime ($stateNameHash: number, $layer: number, $fixedTime: number) : void
            public PlayInFixedTime ($stateNameHash: number, $layer: number) : void
            public PlayInFixedTime ($stateNameHash: number) : void
            public Play ($stateName: string, $layer: number) : void
            public Play ($stateName: string) : void
            /** Plays a state.
            * @param stateName The state name.
            * @param stateNameHash The state hash name. If stateNameHash is 0, it changes the current state time.
            * @param layer The layer index. If layer is -1, it plays the first state with the given state name or hash.
            * @param normalizedTime The time offset between zero and one.
            */
            public Play ($stateName: string, $layer: number, $normalizedTime: number) : void
            /** Plays a state.
            * @param stateName The state name.
            * @param stateNameHash The state hash name. If stateNameHash is 0, it changes the current state time.
            * @param layer The layer index. If layer is -1, it plays the first state with the given state name or hash.
            * @param normalizedTime The time offset between zero and one.
            */
            public Play ($stateNameHash: number, $layer: number, $normalizedTime: number) : void
            public Play ($stateNameHash: number, $layer: number) : void
            public Play ($stateNameHash: number) : void
            /** Sets an AvatarTarget and a targetNormalizedTime for the current state.
            * @param targetIndex The avatar body part that is queried.
            * @param targetNormalizedTime The current state Time that is queried.
            */
            public SetTarget ($targetIndex: UnityEngine.AvatarTarget, $targetNormalizedTime: number) : void
            /** Returns Transform mapped to this human bone id. Returns null if the animator is disabled, if it does not have a human description, or if the bone id is invalid.
            * @param humanBoneId The human bone that is queried, see enum HumanBodyBones for a list of possible values.
            */
            public GetBoneTransform ($humanBoneId: UnityEngine.HumanBodyBones) : UnityEngine.Transform
            public StartPlayback () : void
            public StopPlayback () : void
            /** Sets the animator in recording mode, and allocates a circular buffer of size frameCount.
            * @param frameCount The number of frames (updates) that will be recorded. If frameCount is 0, the recording will continue until the user calls StopRecording. The maximum value for frameCount is 10000.
            */
            public StartRecording ($frameCount: number) : void
            public StopRecording () : void
            /** Returns true if the state exists in this layer, false otherwise.
            * @param layerIndex The layer index.
            * @param stateID The state ID.
            * @returns True if the state exists in this layer, false otherwise. 
            */
            public HasState ($layerIndex: number, $stateID: number) : boolean
            /** Generates an parameter id from a string.
            * @param name The string to convert to Id.
            */
            public static StringToHash ($name: string) : number
            /** Evaluates the animator based on deltaTime.
            * @param deltaTime The time delta.
            */
            public Update ($deltaTime: number) : void
            public Rebind () : void
            public ApplyBuiltinRootMotion () : void
            public constructor ()
        }
        /** Interface for on-screen keyboards. Only native iPhone, Android, and Windows Store Apps are supported.
        */
        class TouchScreenKeyboard extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Is touch screen keyboard supported.
            */
            public static get isSupported(): boolean;
            /** Checks if the text within an input field can be selected and modified while TouchScreenKeyboard is open.
            * @returns Returns true when you are able to select and modify the input field, returns false otherwise. 
            */
            public static get isInPlaceEditingAllowed(): boolean;
            /** Returns the text displayed by the input field of the keyboard.
            */
            public get text(): string;
            public set text(value: string);
            /** Will text input field above the keyboard be hidden when the keyboard is on screen?
            */
            public static get hideInput(): boolean;
            public static set hideInput(value: boolean);
            /** Is the keyboard visible or sliding into the position on the screen?
            */
            public get active(): boolean;
            public set active(value: boolean);
            /** Returns the status of the on-screen keyboard. (Read Only)
            */
            public get status(): UnityEngine.TouchScreenKeyboard.Status;
            /** How many characters the keyboard input field is limited to. 0 = infinite.
            */
            public get characterLimit(): number;
            public set characterLimit(value: number);
            /** Specifies whether the TouchScreenKeyboard supports the selection property. (Read Only)
            */
            public get canGetSelection(): boolean;
            /** Specifies whether the TouchScreenKeyboard supports the selection property. (Read Only)
            */
            public get canSetSelection(): boolean;
            /** Gets or sets the character range of the selected text within the string currently being edited.
            */
            public get selection(): UnityEngine.RangeInt;
            public set selection(value: UnityEngine.RangeInt);
            /** Returns the TouchScreenKeyboardType of the keyboard.
            */
            public get type(): UnityEngine.TouchScreenKeyboardType;
            /** Specified on which display the on-screen keyboard will appear.
            */
            public get targetDisplay(): number;
            public set targetDisplay(value: number);
            /** Returns portion of the screen which is covered by the keyboard.
            */
            public static get area(): UnityEngine.Rect;
            /** Returns true whenever any keyboard is visible on the screen.
            */
            public static get visible(): boolean;
            /** Opens the native keyboard provided by OS on the screen.
            * @param text Text to edit.
            * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param autocorrection Is autocorrection applied?
            * @param multiline Can more than one line of text be entered?
            * @param secure Is the text masked (for passwords, etc)?
            * @param alert Is the keyboard opened in alert mode?
            * @param textPlaceholder Text to be used if no other text is present.
            * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $characterLimit: number) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param text Text to edit.
            * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param autocorrection Is autocorrection applied?
            * @param multiline Can more than one line of text be entered?
            * @param secure Is the text masked (for passwords, etc)?
            * @param alert Is the keyboard opened in alert mode?
            * @param textPlaceholder Text to be used if no other text is present.
            * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param text Text to edit.
            * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param autocorrection Is autocorrection applied?
            * @param multiline Can more than one line of text be entered?
            * @param secure Is the text masked (for passwords, etc)?
            * @param alert Is the keyboard opened in alert mode?
            * @param textPlaceholder Text to be used if no other text is present.
            * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param text Text to edit.
            * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param autocorrection Is autocorrection applied?
            * @param multiline Can more than one line of text be entered?
            * @param secure Is the text masked (for passwords, etc)?
            * @param alert Is the keyboard opened in alert mode?
            * @param textPlaceholder Text to be used if no other text is present.
            * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param text Text to edit.
            * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param autocorrection Is autocorrection applied?
            * @param multiline Can more than one line of text be entered?
            * @param secure Is the text masked (for passwords, etc)?
            * @param alert Is the keyboard opened in alert mode?
            * @param textPlaceholder Text to be used if no other text is present.
            * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param text Text to edit.
            * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param autocorrection Is autocorrection applied?
            * @param multiline Can more than one line of text be entered?
            * @param secure Is the text masked (for passwords, etc)?
            * @param alert Is the keyboard opened in alert mode?
            * @param textPlaceholder Text to be used if no other text is present.
            * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param text Text to edit.
            * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param autocorrection Is autocorrection applied?
            * @param multiline Can more than one line of text be entered?
            * @param secure Is the text masked (for passwords, etc)?
            * @param alert Is the keyboard opened in alert mode?
            * @param textPlaceholder Text to be used if no other text is present.
            * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType) : UnityEngine.TouchScreenKeyboard
            /** Opens the native keyboard provided by OS on the screen.
            * @param text Text to edit.
            * @param keyboardType Type of keyboard (eg, any text, numbers only, etc).
            * @param autocorrection Is autocorrection applied?
            * @param multiline Can more than one line of text be entered?
            * @param secure Is the text masked (for passwords, etc)?
            * @param alert Is the keyboard opened in alert mode?
            * @param textPlaceholder Text to be used if no other text is present.
            * @param characterLimit How many characters the keyboard input field is limited to. 0 = infinite. (Android and iOS only)
            */
            public static Open ($text: string) : UnityEngine.TouchScreenKeyboard
            public constructor ($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $characterLimit: number)
            public constructor ()
        }
        /** Enumeration of the different types of supported touchscreen keyboards.
        */
        enum TouchScreenKeyboardType
        { Default = 0, ASCIICapable = 1, NumbersAndPunctuation = 2, URL = 3, NumberPad = 4, PhonePad = 5, NamePhonePad = 6, EmailAddress = 7, NintendoNetworkAccount = 8, Social = 9, Search = 10, DecimalPad = 11, OneTimeCode = 12 }
        /** A UnityGUI event.
        */
        class Event extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get rawType(): UnityEngine.EventType;
            /** The mouse position.
            */
            public get mousePosition(): UnityEngine.Vector2;
            public set mousePosition(value: UnityEngine.Vector2);
            /** The relative movement of the mouse compared to last event.
            */
            public get delta(): UnityEngine.Vector2;
            public set delta(value: UnityEngine.Vector2);
            /** The type of pointer that created this event (for example, mouse, touch screen, pen).
            */
            public get pointerType(): UnityEngine.PointerType;
            public set pointerType(value: UnityEngine.PointerType);
            /** Which mouse button was pressed.
            */
            public get button(): number;
            public set button(value: number);
            /** Which modifier keys are held down.
            */
            public get modifiers(): UnityEngine.EventModifiers;
            public set modifiers(value: UnityEngine.EventModifiers);
            /** How hard stylus pressure is applied.
            */
            public get pressure(): number;
            public set pressure(value: number);
            /** How many consecutive mouse clicks have we received.
            */
            public get clickCount(): number;
            public set clickCount(value: number);
            /** The character typed.
            */
            public get character(): number;
            public set character(value: number);
            /** The raw key code for keyboard events.
            */
            public get keyCode(): UnityEngine.KeyCode;
            public set keyCode(value: UnityEngine.KeyCode);
            /** Index of display that the event belongs to.
            */
            public get displayIndex(): number;
            public set displayIndex(value: number);
            /** The type of event.
            */
            public get type(): UnityEngine.EventType;
            public set type(value: UnityEngine.EventType);
            /** The name of an ExecuteCommand or ValidateCommand Event.
            */
            public get commandName(): string;
            public set commandName(value: string);
            /** Is Shift held down? (Read Only)
            */
            public get shift(): boolean;
            public set shift(value: boolean);
            /** Is Control key held down? (Read Only)
            */
            public get control(): boolean;
            public set control(value: boolean);
            /** Is Alt/Option key held down? (Read Only)
            */
            public get alt(): boolean;
            public set alt(value: boolean);
            /** Is Command/Windows key held down? (Read Only)
            */
            public get command(): boolean;
            public set command(value: boolean);
            /** Is Caps Lock on? (Read Only)
            */
            public get capsLock(): boolean;
            public set capsLock(value: boolean);
            /** Is the current keypress on the numeric keyboard? (Read Only)
            */
            public get numeric(): boolean;
            public set numeric(value: boolean);
            /** Is the current keypress a function key? (Read Only)
            */
            public get functionKey(): boolean;
            /** The current event that's being processed right now.
            */
            public static get current(): UnityEngine.Event;
            public static set current(value: UnityEngine.Event);
            /** Is this event a keyboard event? (Read Only)
            */
            public get isKey(): boolean;
            /** Is this event a mouse event? (Read Only)
            */
            public get isMouse(): boolean;
            public get isScrollWheel(): boolean;
            /** Get a filtered event type for a given control ID.
            * @param controlID The ID of the control you are querying from.
            */
            public GetTypeForControl ($controlID: number) : UnityEngine.EventType
            /** Get the next queued [Event] from the event system.
            * @param outEvent Next Event.
            */
            public static PopEvent ($outEvent: UnityEngine.Event) : boolean
            public static GetEventCount () : number
            /** Create a keyboard event.
            */
            public static KeyboardEvent ($key: string) : UnityEngine.Event
            public Use () : void
            public constructor ()
            public constructor ($displayIndex: number)
            public constructor ($other: UnityEngine.Event)
        }
        /** AndroidJavaRunnable is the Unity representation of a java.lang.Runnable object.
        */
        interface AndroidJavaRunnable
        { 
        () : void; 
        Invoke?: () => void;
        }
        var AndroidJavaRunnable: { new (func: () => void): AndroidJavaRunnable; }
        class AndroidJavaException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get StackTrace(): string;
        }
        /** AndroidJavaObject is the Unity representation of a generic instance of java.lang.Object.
        */
        class AndroidJavaObject extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Dispose () : void
            /** Call a Java method on an object.
            * @param methodName Specifies which method to call.
            * @param args An array of parameters passed to the method.
            */
            public Call ($methodName: string, ...args: any[]) : void
            /** Call a static Java method on a class.
            * @param methodName Specifies which method to call.
            * @param args An array of parameters passed to the method.
            */
            public CallStatic ($methodName: string, ...args: any[]) : void
            public GetRawObject () : System.IntPtr
            public GetRawClass () : System.IntPtr
            public CloneReference () : UnityEngine.AndroidJavaObject
            public constructor ($className: string, $args: System.Array$1<string>)
            public constructor ($className: string, $args: System.Array$1<UnityEngine.AndroidJavaObject>)
            public constructor ($className: string, $args: System.Array$1<UnityEngine.AndroidJavaClass>)
            public constructor ($className: string, $args: System.Array$1<UnityEngine.AndroidJavaProxy>)
            public constructor ($className: string, $args: System.Array$1<UnityEngine.AndroidJavaRunnable>)
            public constructor ($className: string, ...args: any[])
            public constructor ()
        }
        /** AndroidJavaClass is the Unity representation of a generic instance of java.lang.Class.
        */
        class AndroidJavaClass extends UnityEngine.AndroidJavaObject implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ($className: string)
            public constructor ($className: string, $args: System.Array$1<string>)
            public constructor ($className: string, $args: System.Array$1<UnityEngine.AndroidJavaObject>)
            public constructor ($className: string, $args: System.Array$1<UnityEngine.AndroidJavaClass>)
            public constructor ($className: string, $args: System.Array$1<UnityEngine.AndroidJavaProxy>)
            public constructor ($className: string, $args: System.Array$1<UnityEngine.AndroidJavaRunnable>)
            public constructor ($className: string, ...args: any[])
            public constructor ()
        }
        /** This class can be used to implement any java interface. Any java vm method invocation matching the interface on the proxy object will automatically be passed to the c# implementation.
        */
        class AndroidJavaProxy extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class jvalue extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public z : boolean
            public b : number
            public c : number
            public s : number
            public i : number
            public j : bigint
            public f : number
            public d : number
            public l : System.IntPtr
        }
        /** Helper interface for JNI interaction; signature creation and method lookups.
        Note: Using raw JNI functions requires advanced knowledge of the Android Java Native Interface (JNI). Please take note.
        */
        class AndroidJNIHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Set debug to true to log calls through the AndroidJNIHelper.
            */
            public static get debug(): boolean;
            public static set debug(value: boolean);
            /** Scans a particular Java class for a constructor method matching a signature.
            * @param javaClass Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).
            * @param signature Constructor method signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).
            */
            public static GetConstructorID ($javaClass: System.IntPtr) : System.IntPtr
            /** Scans a particular Java class for a constructor method matching a signature.
            * @param javaClass Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).
            * @param signature Constructor method signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).
            */
            public static GetConstructorID ($javaClass: System.IntPtr, $signature: string) : System.IntPtr
            /** Scans a particular Java class for a method matching a name and a signature.
            * @param javaClass Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).
            * @param methodName Name of the method as declared in Java.
            * @param signature Method signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).
            * @param isStatic Set to <tt>true<tt> for static methods; <tt>false<tt> for instance (nonstatic) methods.
            */
            public static GetMethodID ($javaClass: System.IntPtr, $methodName: string) : System.IntPtr
            /** Scans a particular Java class for a method matching a name and a signature.
            * @param javaClass Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).
            * @param methodName Name of the method as declared in Java.
            * @param signature Method signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).
            * @param isStatic Set to <tt>true<tt> for static methods; <tt>false<tt> for instance (nonstatic) methods.
            */
            public static GetMethodID ($javaClass: System.IntPtr, $methodName: string, $signature: string) : System.IntPtr
            /** Scans a particular Java class for a method matching a name and a signature.
            * @param javaClass Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).
            * @param methodName Name of the method as declared in Java.
            * @param signature Method signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).
            * @param isStatic Set to <tt>true<tt> for static methods; <tt>false<tt> for instance (nonstatic) methods.
            */
            public static GetMethodID ($javaClass: System.IntPtr, $methodName: string, $signature: string, $isStatic: boolean) : System.IntPtr
            /** Scans a particular Java class for a field matching a name and a signature.
            * @param javaClass Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).
            * @param fieldName Name of the field as declared in Java.
            * @param signature Field signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).
            * @param isStatic Set to <tt>true<tt> for static fields; <tt>false<tt> for instance (nonstatic) fields.
            */
            public static GetFieldID ($javaClass: System.IntPtr, $fieldName: string) : System.IntPtr
            /** Scans a particular Java class for a field matching a name and a signature.
            * @param javaClass Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).
            * @param fieldName Name of the field as declared in Java.
            * @param signature Field signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).
            * @param isStatic Set to <tt>true<tt> for static fields; <tt>false<tt> for instance (nonstatic) fields.
            */
            public static GetFieldID ($javaClass: System.IntPtr, $fieldName: string, $signature: string) : System.IntPtr
            /** Scans a particular Java class for a field matching a name and a signature.
            * @param javaClass Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).
            * @param fieldName Name of the field as declared in Java.
            * @param signature Field signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).
            * @param isStatic Set to <tt>true<tt> for static fields; <tt>false<tt> for instance (nonstatic) fields.
            */
            public static GetFieldID ($javaClass: System.IntPtr, $fieldName: string, $signature: string, $isStatic: boolean) : System.IntPtr
            /** Creates a UnityJavaRunnable object (implements java.lang.Runnable).
            * @param runnable A delegate representing the java.lang.Runnable.
            */
            public static CreateJavaRunnable ($jrunnable: UnityEngine.AndroidJavaRunnable) : System.IntPtr
            /** Creates a java proxy object which connects to the supplied proxy implementation.
            * @param proxy An implementatinon of a java interface in c#.
            */
            public static CreateJavaProxy ($proxy: UnityEngine.AndroidJavaProxy) : System.IntPtr
            /** Creates a Java array from a managed array.
            * @param array Managed array to be converted into a Java array object.
            */
            public static ConvertToJNIArray ($array: System.Array) : System.IntPtr
            /** Creates the parameter array to be used as argument list when invoking Java code through CallMethod() in AndroidJNI.
            * @param args An array of objects that should be converted to Call parameters.
            */
            public static CreateJNIArgArray ($args: System.Array$1<any>) : System.Array$1<UnityEngine.jvalue>
            /** Deletes any local jni references previously allocated by CreateJNIArgArray().
            * @param args The array of arguments used as a parameter to CreateJNIArgArray().
            * @param jniArgs The array returned by CreateJNIArgArray().
            */
            public static DeleteJNIArgArray ($args: System.Array$1<any>, $jniArgs: System.Array$1<UnityEngine.jvalue>) : void
            /** Get a JNI method ID for a constructor based on calling arguments.
            * @param javaClass Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).
            * @param args Array with parameters to be passed to the constructor when invoked.
            */
            public static GetConstructorID ($jclass: System.IntPtr, $args: System.Array$1<any>) : System.IntPtr
            /** Get a JNI method ID based on calling arguments.
            * @param javaClass Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).
            * @param methodName Name of the method as declared in Java.
            * @param args Array with parameters to be passed to the method when invoked.
            * @param isStatic Set to <tt>true<tt> for static methods; <tt>false<tt> for instance (nonstatic) methods.
            */
            public static GetMethodID ($jclass: System.IntPtr, $methodName: string, $args: System.Array$1<any>, $isStatic: boolean) : System.IntPtr
            /** Creates the JNI signature string for particular object type.
            * @param obj Object for which a signature is to be produced.
            */
            public static GetSignature ($obj: any) : string
            /** Creates the JNI signature string for an object parameter list.
            * @param args Array of object for which a signature is to be produced.
            */
            public static GetSignature ($args: System.Array$1<any>) : string
        }
        /** 'Raw' JNI interface to Android Java VM from Unity scripting (C#).
        Note: Using raw JNI functions requires advanced knowledge of the Android Java Native Interface (JNI). Please take note.
        */
        class AndroidJNI extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static AttachCurrentThread () : number
            public static DetachCurrentThread () : number
            public static GetVersion () : number
            /** This function loads a locally-defined class.
            */
            public static FindClass ($name: string) : System.IntPtr
            /** Converts a <tt>java.lang.reflect.Method<tt> or <tt>java.lang.reflect.Constructor<tt> object to a method ID.
            */
            public static FromReflectedMethod ($refMethod: System.IntPtr) : System.IntPtr
            /** Converts a <tt>java.lang.reflect.Field</tt> to a field ID.
            */
            public static FromReflectedField ($refField: System.IntPtr) : System.IntPtr
            /** Converts a method ID derived from clazz to a <tt>java.lang.reflect.Method<tt> or <tt>java.lang.reflect.Constructor<tt> object.
            */
            public static ToReflectedMethod ($clazz: System.IntPtr, $methodID: System.IntPtr, $isStatic: boolean) : System.IntPtr
            /** Converts a field ID derived from cls to a <tt>java.lang.reflect.Field</tt> object.
            */
            public static ToReflectedField ($clazz: System.IntPtr, $fieldID: System.IntPtr, $isStatic: boolean) : System.IntPtr
            /** If <tt>clazz<tt> represents any class other than the class <tt>Object<tt>, then this function returns the object that represents the superclass of the class specified by <tt>clazz</tt>.
            */
            public static GetSuperclass ($clazz: System.IntPtr) : System.IntPtr
            /** Determines whether an object of <tt>clazz1<tt> can be safely cast to <tt>clazz2<tt>.
            */
            public static IsAssignableFrom ($clazz1: System.IntPtr, $clazz2: System.IntPtr) : boolean
            /** Causes a <tt>java.lang.Throwable</tt> object to be thrown.
            */
            public static Throw ($obj: System.IntPtr) : number
            /** Constructs an exception object from the specified class with the <tt>message</tt> specified by message and causes that exception to be thrown.
            */
            public static ThrowNew ($clazz: System.IntPtr, $message: string) : number
            public static ExceptionOccurred () : System.IntPtr
            public static ExceptionDescribe () : void
            public static ExceptionClear () : void
            /** Raises a fatal error and does not expect the VM to recover. This function does not return.
            */
            public static FatalError ($message: string) : void
            /** Creates a new local reference frame, in which at least a given number of local references can be created.
            */
            public static PushLocalFrame ($capacity: number) : number
            /** Pops off the current local reference frame, frees all the local references, and returns a local reference in the previous local reference frame for the given <tt>result</tt> object.
            */
            public static PopLocalFrame ($ptr: System.IntPtr) : System.IntPtr
            /** Creates a new global reference to the object referred to by the <tt>obj</tt> argument.
            */
            public static NewGlobalRef ($obj: System.IntPtr) : System.IntPtr
            /** Deletes the global reference pointed to by <tt>obj</tt>.
            */
            public static DeleteGlobalRef ($obj: System.IntPtr) : void
            /** Creates a new global weak reference to the object referred to by the <tt>obj</tt> argument.
            */
            public static NewWeakGlobalRef ($obj: System.IntPtr) : System.IntPtr
            /** Deletes the global weak reference pointed to by <tt>obj</tt>.
            */
            public static DeleteWeakGlobalRef ($obj: System.IntPtr) : void
            /** Creates a new local reference that refers to the same object as <tt>obj</tt>.
            */
            public static NewLocalRef ($obj: System.IntPtr) : System.IntPtr
            /** Deletes the local reference pointed to by <tt>obj</tt>.
            */
            public static DeleteLocalRef ($obj: System.IntPtr) : void
            /** Tests whether two references refer to the same Java object.
            */
            public static IsSameObject ($obj1: System.IntPtr, $obj2: System.IntPtr) : boolean
            /** Ensures that at least a given number of local references can be created in the current thread.
            */
            public static EnsureLocalCapacity ($capacity: number) : number
            /** Allocates a new Java object without invoking any of the constructors for the object.
            */
            public static AllocObject ($clazz: System.IntPtr) : System.IntPtr
            /** Constructs a new Java object. The method ID indicates which constructor method to invoke. This ID must be obtained by calling GetMethodID() with <init> as the method name and void (V) as the return type.
            */
            public static NewObject ($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : System.IntPtr
            /** Returns the class of an object.
            */
            public static GetObjectClass ($obj: System.IntPtr) : System.IntPtr
            /** Tests whether an object is an instance of a class.
            */
            public static IsInstanceOf ($obj: System.IntPtr, $clazz: System.IntPtr) : boolean
            /** Returns the method ID for an instance (nonstatic) method of a class or interface.
            */
            public static GetMethodID ($clazz: System.IntPtr, $name: string, $sig: string) : System.IntPtr
            /** Returns the field ID for an instance (nonstatic) field of a class.
            */
            public static GetFieldID ($clazz: System.IntPtr, $name: string, $sig: string) : System.IntPtr
            /** Returns the method ID for a static method of a class.
            */
            public static GetStaticMethodID ($clazz: System.IntPtr, $name: string, $sig: string) : System.IntPtr
            /** Returns the field ID for a static field of a class.
            */
            public static GetStaticFieldID ($clazz: System.IntPtr, $name: string, $sig: string) : System.IntPtr
            /** Constructs a new <tt>java.lang.String</tt> object from an array of Unicode characters.
            */
            public static NewString ($chars: string) : System.IntPtr
            /** Constructs a new <tt>java.lang.String</tt> object from an array of Unicode characters.
            */
            public static NewString ($chars: System.Array$1<number>) : System.IntPtr
            /** Constructs a new <tt>java.lang.String</tt> object from an array of characters in modified UTF-8 encoding.
            */
            public static NewStringUTF ($bytes: string) : System.IntPtr
            /** Returns a pointer to the array of Unicode characters of the string. This pointer is valid until ReleaseStringchars() is called.
            */
            public static GetStringChars ($str: System.IntPtr) : string
            /** Returns the length (the count of Unicode characters) of a Java string.
            */
            public static GetStringLength ($str: System.IntPtr) : number
            /** Returns the length in bytes of the modified UTF-8 representation of a string.
            */
            public static GetStringUTFLength ($str: System.IntPtr) : number
            /** Returns a managed string object representing the string in modified UTF-8 encoding.
            */
            public static GetStringUTFChars ($str: System.IntPtr) : string
            /** Calls a Java instance method defined by <tt>methodID<tt>, optionally passing an array of arguments (<tt>args<tt>) to the method.
            */
            public static CallStringMethod ($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : string
            /** Calls a Java instance method defined by <tt>methodID<tt>, optionally passing an array of arguments (<tt>args<tt>) to the method.
            */
            public static CallObjectMethod ($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : System.IntPtr
            /** Calls a Java instance method defined by <tt>methodID<tt>, optionally passing an array of arguments (<tt>args<tt>) to the method.
            */
            public static CallIntMethod ($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : number
            /** Calls a Java instance method defined by <tt>methodID<tt>, optionally passing an array of arguments (<tt>args<tt>) to the method.
            */
            public static CallBooleanMethod ($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : boolean
            /** Calls a Java instance method defined by <tt>methodID<tt>, optionally passing an array of arguments (<tt>args<tt>) to the method.
            */
            public static CallShortMethod ($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : number
            /** Calls a Java instance method defined by <tt>methodID<tt>, optionally passing an array of arguments (<tt>args<tt>) to the method.
            */
            public static CallSByteMethod ($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : number
            /** Calls a Java instance method defined by <tt>methodID<tt>, optionally passing an array of arguments (<tt>args<tt>) to the method.
            */
            public static CallCharMethod ($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : number
            /** Calls a Java instance method defined by <tt>methodID<tt>, optionally passing an array of arguments (<tt>args<tt>) to the method.
            */
            public static CallFloatMethod ($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : number
            /** Calls a Java instance method defined by <tt>methodID<tt>, optionally passing an array of arguments (<tt>args<tt>) to the method.
            */
            public static CallDoubleMethod ($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : number
            /** Calls a Java instance method defined by <tt>methodID<tt>, optionally passing an array of arguments (<tt>args<tt>) to the method.
            */
            public static CallLongMethod ($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : bigint
            /** Calls a Java instance method defined by <tt>methodID<tt>, optionally passing an array of arguments (<tt>args<tt>) to the method.
            */
            public static CallVoidMethod ($obj: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : void
            /** Returns the value of an instance (nonstatic) field of an object.
            */
            public static GetStringField ($obj: System.IntPtr, $fieldID: System.IntPtr) : string
            /** Returns the value of an instance (nonstatic) field of an object.
            */
            public static GetObjectField ($obj: System.IntPtr, $fieldID: System.IntPtr) : System.IntPtr
            /** Returns the value of an instance (nonstatic) field of an object.
            */
            public static GetBooleanField ($obj: System.IntPtr, $fieldID: System.IntPtr) : boolean
            /** Returns the value of an instance (nonstatic) field of an object.
            */
            public static GetSByteField ($obj: System.IntPtr, $fieldID: System.IntPtr) : number
            /** Returns the value of an instance (nonstatic) field of an object.
            */
            public static GetCharField ($obj: System.IntPtr, $fieldID: System.IntPtr) : number
            /** Returns the value of an instance (nonstatic) field of an object.
            */
            public static GetShortField ($obj: System.IntPtr, $fieldID: System.IntPtr) : number
            /** Returns the value of an instance (nonstatic) field of an object.
            */
            public static GetIntField ($obj: System.IntPtr, $fieldID: System.IntPtr) : number
            /** Returns the value of an instance (nonstatic) field of an object.
            */
            public static GetLongField ($obj: System.IntPtr, $fieldID: System.IntPtr) : bigint
            /** Returns the value of an instance (nonstatic) field of an object.
            */
            public static GetFloatField ($obj: System.IntPtr, $fieldID: System.IntPtr) : number
            /** Returns the value of an instance (nonstatic) field of an object.
            */
            public static GetDoubleField ($obj: System.IntPtr, $fieldID: System.IntPtr) : number
            /** Sets the value of an instance field of the specified object.
            */
            public static SetStringField ($obj: System.IntPtr, $fieldID: System.IntPtr, $val: string) : void
            /** Sets the value of an instance field of the specified object.
            */
            public static SetObjectField ($obj: System.IntPtr, $fieldID: System.IntPtr, $val: System.IntPtr) : void
            /** Sets the value of an instance field of the specified object.
            */
            public static SetBooleanField ($obj: System.IntPtr, $fieldID: System.IntPtr, $val: boolean) : void
            /** Sets the value of an instance field of the specified object.
            */
            public static SetSByteField ($obj: System.IntPtr, $fieldID: System.IntPtr, $val: number) : void
            /** Sets the value of an instance field of the specified object.
            */
            public static SetCharField ($obj: System.IntPtr, $fieldID: System.IntPtr, $val: number) : void
            /** Sets the value of an instance field of the specified object.
            */
            public static SetShortField ($obj: System.IntPtr, $fieldID: System.IntPtr, $val: number) : void
            /** Sets the value of an instance field of the specified object.
            */
            public static SetIntField ($obj: System.IntPtr, $fieldID: System.IntPtr, $val: number) : void
            /** Sets the value of an instance field of the specified object.
            */
            public static SetLongField ($obj: System.IntPtr, $fieldID: System.IntPtr, $val: bigint) : void
            /** Sets the value of an instance field of the specified object.
            */
            public static SetFloatField ($obj: System.IntPtr, $fieldID: System.IntPtr, $val: number) : void
            /** Sets the value of an instance field of the specified object.
            */
            public static SetDoubleField ($obj: System.IntPtr, $fieldID: System.IntPtr, $val: number) : void
            /** Invokes the specified <tt>methodID<tt> static method on a Java object, optionally passing in an array of arguments (<tt>args<tt>).
            */
            public static CallStaticStringMethod ($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : string
            /** Invokes the specified <tt>methodID<tt> static method on a Java object, optionally passing in an array of arguments (<tt>args<tt>).
            */
            public static CallStaticObjectMethod ($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : System.IntPtr
            /** Invokes the specified <tt>methodID<tt> static method on a Java object, optionally passing in an array of arguments (<tt>args<tt>).
            */
            public static CallStaticIntMethod ($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : number
            /** Invokes the specified <tt>methodID<tt> static method on a Java object, optionally passing in an array of arguments (<tt>args<tt>).
            */
            public static CallStaticBooleanMethod ($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : boolean
            /** Invokes the specified <tt>methodID<tt> static method on a Java object, optionally passing in an array of arguments (<tt>args<tt>).
            */
            public static CallStaticShortMethod ($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : number
            /** Invokes the specified <tt>methodID<tt> static method on a Java object, optionally passing in an array of arguments (<tt>args<tt>).
            */
            public static CallStaticSByteMethod ($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : number
            /** Invokes the specified <tt>methodID<tt> static method on a Java object, optionally passing in an array of arguments (<tt>args<tt>).
            */
            public static CallStaticCharMethod ($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : number
            /** Invokes the specified <tt>methodID<tt> static method on a Java object, optionally passing in an array of arguments (<tt>args<tt>).
            */
            public static CallStaticFloatMethod ($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : number
            /** Invokes the specified <tt>methodID<tt> static method on a Java object, optionally passing in an array of arguments (<tt>args<tt>).
            */
            public static CallStaticDoubleMethod ($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : number
            /** Invokes the specified <tt>methodID<tt> static method on a Java object, optionally passing in an array of arguments (<tt>args<tt>).
            */
            public static CallStaticLongMethod ($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : bigint
            /** Invokes the specified <tt>methodID<tt> static method on a Java object, optionally passing in an array of arguments (<tt>args<tt>).
            */
            public static CallStaticVoidMethod ($clazz: System.IntPtr, $methodID: System.IntPtr, $args: System.Array$1<UnityEngine.jvalue>) : void
            /** Returns the value of a static field of an object.
            */
            public static GetStaticStringField ($clazz: System.IntPtr, $fieldID: System.IntPtr) : string
            /** Returns the value of a static field of an object.
            */
            public static GetStaticObjectField ($clazz: System.IntPtr, $fieldID: System.IntPtr) : System.IntPtr
            /** Returns the value of a static field of an object.
            */
            public static GetStaticBooleanField ($clazz: System.IntPtr, $fieldID: System.IntPtr) : boolean
            /** Returns the value of a static field of an object.
            */
            public static GetStaticSByteField ($clazz: System.IntPtr, $fieldID: System.IntPtr) : number
            /** Returns the value of a static field of an object.
            */
            public static GetStaticCharField ($clazz: System.IntPtr, $fieldID: System.IntPtr) : number
            /** Returns the value of a static field of an object.
            */
            public static GetStaticShortField ($clazz: System.IntPtr, $fieldID: System.IntPtr) : number
            /** Returns the value of a static field of an object.
            */
            public static GetStaticIntField ($clazz: System.IntPtr, $fieldID: System.IntPtr) : number
            /** Returns the value of a static field of an object.
            */
            public static GetStaticLongField ($clazz: System.IntPtr, $fieldID: System.IntPtr) : bigint
            /** Returns the value of a static field of an object.
            */
            public static GetStaticFloatField ($clazz: System.IntPtr, $fieldID: System.IntPtr) : number
            /** Returns the value of a static field of an object.
            */
            public static GetStaticDoubleField ($clazz: System.IntPtr, $fieldID: System.IntPtr) : number
            /** Sets the value of a static field in the specified object.
            */
            public static SetStaticStringField ($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: string) : void
            /** Sets the value of a static field in the specified object.
            */
            public static SetStaticObjectField ($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: System.IntPtr) : void
            /** Sets the value of a static field in the specified object.
            */
            public static SetStaticBooleanField ($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: boolean) : void
            /** Sets the value of a static field in the specified object.
            */
            public static SetStaticSByteField ($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: number) : void
            /** Sets the value of a static field in the specified object.
            */
            public static SetStaticCharField ($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: number) : void
            /** Sets the value of a static field in the specified object.
            */
            public static SetStaticShortField ($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: number) : void
            /** Sets the value of a static field in the specified object.
            */
            public static SetStaticIntField ($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: number) : void
            /** Sets the value of a static field in the specified object.
            */
            public static SetStaticLongField ($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: bigint) : void
            /** Sets the value of a static field in the specified object.
            */
            public static SetStaticFloatField ($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: number) : void
            /** Sets the value of a static field in the specified object.
            */
            public static SetStaticDoubleField ($clazz: System.IntPtr, $fieldID: System.IntPtr, $val: number) : void
            /** Converts a managed array of System.Boolean to a Java array of <tt>boolean</tt>.
            */
            public static ToBooleanArray ($array: System.Array$1<boolean>) : System.IntPtr
            /** Converts a managed array of System.SByte to a Java array of <tt>byte</tt>.
            */
            public static ToSByteArray ($array: System.Array$1<number>) : System.IntPtr
            /** Converts a managed array of System.Char to a Java array of <tt>char</tt>.
            */
            public static ToCharArray ($array: System.Array$1<number>) : System.IntPtr
            /** Converts a managed array of System.Int16 to a Java array of <tt>short</tt>.
            */
            public static ToShortArray ($array: System.Array$1<number>) : System.IntPtr
            /** Converts a managed array of System.Int32 to a Java array of <tt>int</tt>.
            */
            public static ToIntArray ($array: System.Array$1<number>) : System.IntPtr
            /** Converts a managed array of System.Int64 to a Java array of <tt>long</tt>.
            */
            public static ToLongArray ($array: System.Array$1<bigint>) : System.IntPtr
            /** Converts a managed array of System.Single to a Java array of <tt>float</tt>.
            */
            public static ToFloatArray ($array: System.Array$1<number>) : System.IntPtr
            /** Converts a managed array of System.Double to a Java array of <tt>double</tt>.
            */
            public static ToDoubleArray ($array: System.Array$1<number>) : System.IntPtr
            public static ToObjectArray ($array: System.Array$1<System.IntPtr>, $arrayClass: System.IntPtr) : System.IntPtr
            /** Converts a managed array of System.IntPtr, representing Java objects, to a Java array of <tt>java.lang.Object</tt>.
            */
            public static ToObjectArray ($array: System.Array$1<System.IntPtr>) : System.IntPtr
            /** Converts a Java array of <tt>boolean</tt> to a managed array of System.Boolean.
            */
            public static FromBooleanArray ($array: System.IntPtr) : System.Array$1<boolean>
            /** Converts a Java array of <tt>byte</tt> to a managed array of System.SByte.
            */
            public static FromSByteArray ($array: System.IntPtr) : System.Array$1<number>
            /** Converts a Java array of <tt>char</tt> to a managed array of System.Char.
            */
            public static FromCharArray ($array: System.IntPtr) : System.Array$1<number>
            /** Converts a Java array of <tt>short</tt> to a managed array of System.Int16.
            */
            public static FromShortArray ($array: System.IntPtr) : System.Array$1<number>
            /** Converts a Java array of <tt>int</tt> to a managed array of System.Int32.
            */
            public static FromIntArray ($array: System.IntPtr) : System.Array$1<number>
            /** Converts a Java array of <tt>long</tt> to a managed array of System.Int64.
            */
            public static FromLongArray ($array: System.IntPtr) : System.Array$1<bigint>
            /** Converts a Java array of <tt>float</tt> to a managed array of System.Single.
            */
            public static FromFloatArray ($array: System.IntPtr) : System.Array$1<number>
            /** Converts a Java array of <tt>double</tt> to a managed array of System.Double.
            */
            public static FromDoubleArray ($array: System.IntPtr) : System.Array$1<number>
            /** Converts a Java array of <tt>java.lang.Object</tt> to a managed array of System.IntPtr, representing Java objects.
            */
            public static FromObjectArray ($array: System.IntPtr) : System.Array$1<System.IntPtr>
            /** Returns the number of elements in the array.
            */
            public static GetArrayLength ($array: System.IntPtr) : number
            /** Constructs a new primitive array object.
            */
            public static NewBooleanArray ($size: number) : System.IntPtr
            /** Constructs a new primitive array object.
            */
            public static NewSByteArray ($size: number) : System.IntPtr
            /** Constructs a new primitive array object.
            */
            public static NewCharArray ($size: number) : System.IntPtr
            /** Constructs a new primitive array object.
            */
            public static NewShortArray ($size: number) : System.IntPtr
            /** Constructs a new primitive array object.
            */
            public static NewIntArray ($size: number) : System.IntPtr
            /** Constructs a new primitive array object.
            */
            public static NewLongArray ($size: number) : System.IntPtr
            /** Constructs a new primitive array object.
            */
            public static NewFloatArray ($size: number) : System.IntPtr
            /** Constructs a new primitive array object.
            */
            public static NewDoubleArray ($size: number) : System.IntPtr
            /** Constructs a new array holding objects in class <tt>clazz<tt>. All elements are initially set to <tt>obj<tt>.
            */
            public static NewObjectArray ($size: number, $clazz: System.IntPtr, $obj: System.IntPtr) : System.IntPtr
            /** Returns the value of one element of a primitive array.
            */
            public static GetBooleanArrayElement ($array: System.IntPtr, $index: number) : boolean
            /** Returns the value of one element of a primitive array.
            */
            public static GetSByteArrayElement ($array: System.IntPtr, $index: number) : number
            /** Returns the value of one element of a primitive array.
            */
            public static GetCharArrayElement ($array: System.IntPtr, $index: number) : number
            /** Returns the value of one element of a primitive array.
            */
            public static GetShortArrayElement ($array: System.IntPtr, $index: number) : number
            /** Returns the value of one element of a primitive array.
            */
            public static GetIntArrayElement ($array: System.IntPtr, $index: number) : number
            /** Returns the value of one element of a primitive array.
            */
            public static GetLongArrayElement ($array: System.IntPtr, $index: number) : bigint
            /** Returns the value of one element of a primitive array.
            */
            public static GetFloatArrayElement ($array: System.IntPtr, $index: number) : number
            /** Returns the value of one element of a primitive array.
            */
            public static GetDoubleArrayElement ($array: System.IntPtr, $index: number) : number
            /** Returns an element of an <tt>Object</tt> array.
            */
            public static GetObjectArrayElement ($array: System.IntPtr, $index: number) : System.IntPtr
            /** Sets the boolean value of one element in a primitive array.
            * @param array The array of native booleans.
            * @param index Index of the array element to set.
            * @param val The value to set.
            */
            public static SetBooleanArrayElement ($array: System.IntPtr, $index: number, $val: boolean) : void
            /** Sets the sbyte value of one element in a primitive array.
            */
            public static SetSByteArrayElement ($array: System.IntPtr, $index: number, $val: number) : void
            /** Sets the char value of one element in a primitive array.
            */
            public static SetCharArrayElement ($array: System.IntPtr, $index: number, $val: number) : void
            /** Sets the short value of one element in a primitive array.
            */
            public static SetShortArrayElement ($array: System.IntPtr, $index: number, $val: number) : void
            /** Sets the int value of one element in a primitive array.
            */
            public static SetIntArrayElement ($array: System.IntPtr, $index: number, $val: number) : void
            /** Sets the long value of one element in a primitive array.
            */
            public static SetLongArrayElement ($array: System.IntPtr, $index: number, $val: bigint) : void
            /** Sets the float value of one element in a primitive array.
            */
            public static SetFloatArrayElement ($array: System.IntPtr, $index: number, $val: number) : void
            /** Sets the double value of one element in a primitive array.
            */
            public static SetDoubleArrayElement ($array: System.IntPtr, $index: number, $val: number) : void
            /** Sets an element of an <tt>Object</tt> array.
            */
            public static SetObjectArrayElement ($array: System.IntPtr, $index: number, $obj: System.IntPtr) : void
        }
        /** Information about what animation clips is played and its weight.
        */
        class AnimationInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** The update mode of the Animator.
        */
        enum AnimatorUpdateMode
        { Normal = 0, AnimatePhysics = 1, UnscaledTime = 2 }
        /** IK Goal.
        */
        enum AvatarIKGoal
        { LeftFoot = 0, RightFoot = 1, LeftHand = 2, RightHand = 3 }
        /** IK Hint.
        */
        enum AvatarIKHint
        { LeftKnee = 0, RightKnee = 1, LeftElbow = 2, RightElbow = 3 }
        /** Human Body Bones.
        */
        enum HumanBodyBones
        { Hips = 0, LeftUpperLeg = 1, RightUpperLeg = 2, LeftLowerLeg = 3, RightLowerLeg = 4, LeftFoot = 5, RightFoot = 6, Spine = 7, Chest = 8, UpperChest = 54, Neck = 9, Head = 10, LeftShoulder = 11, RightShoulder = 12, LeftUpperArm = 13, RightUpperArm = 14, LeftLowerArm = 15, RightLowerArm = 16, LeftHand = 17, RightHand = 18, LeftToes = 19, RightToes = 20, LeftEye = 21, RightEye = 22, Jaw = 23, LeftThumbProximal = 24, LeftThumbIntermediate = 25, LeftThumbDistal = 26, LeftIndexProximal = 27, LeftIndexIntermediate = 28, LeftIndexDistal = 29, LeftMiddleProximal = 30, LeftMiddleIntermediate = 31, LeftMiddleDistal = 32, LeftRingProximal = 33, LeftRingIntermediate = 34, LeftRingDistal = 35, LeftLittleProximal = 36, LeftLittleIntermediate = 37, LeftLittleDistal = 38, RightThumbProximal = 39, RightThumbIntermediate = 40, RightThumbDistal = 41, RightIndexProximal = 42, RightIndexIntermediate = 43, RightIndexDistal = 44, RightMiddleProximal = 45, RightMiddleIntermediate = 46, RightMiddleDistal = 47, RightRingProximal = 48, RightRingIntermediate = 49, RightRingDistal = 50, RightLittleProximal = 51, RightLittleIntermediate = 52, RightLittleDistal = 53, LastBone = 55 }
        /** A class you can derive from if you want to create objects that don't need to be attached to game objects.
        */
        class ScriptableObject extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Creates an instance of a scriptable object.
            * @param className The type of the ScriptableObject to create, as the name of the type.
            * @param type The type of the ScriptableObject to create, as a System.Type instance.
            * @returns The created ScriptableObject. 
            */
            public static CreateInstance ($className: string) : UnityEngine.ScriptableObject
            /** Creates an instance of a scriptable object.
            * @param className The type of the ScriptableObject to create, as the name of the type.
            * @param type The type of the ScriptableObject to create, as a System.Type instance.
            * @returns The created ScriptableObject. 
            */
            public static CreateInstance ($type: System.Type) : UnityEngine.ScriptableObject
            public constructor ()
        }
        /** StateMachineBehaviour is a component that can be added to a state machine state. It's the base class every script on a state derives from.
        */
        class StateMachineBehaviour extends UnityEngine.ScriptableObject
        {
            protected [__keep_incompatibility]: never;
            public OnStateEnter ($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number) : void
            public OnStateUpdate ($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number) : void
            public OnStateExit ($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number) : void
            public OnStateMove ($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number) : void
            public OnStateIK ($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number) : void
            /** Called on the first Update frame when making a transition to a state machine. This is not called when making a transition into a state machine sub-state.
            * @param animator The Animator playing this state machine.
            * @param stateMachinePathHash The full path hash for this state machine.
            */
            public OnStateMachineEnter ($animator: UnityEngine.Animator, $stateMachinePathHash: number) : void
            /** Called on the last Update frame when making a transition out of a StateMachine. This is not called when making a transition into a StateMachine sub-state.
            * @param animator The Animator playing this state machine.
            * @param stateMachinePathHash The full path hash for this state machine.
            */
            public OnStateMachineExit ($animator: UnityEngine.Animator, $stateMachinePathHash: number) : void
            public OnStateEnter ($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable) : void
            public OnStateUpdate ($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable) : void
            public OnStateExit ($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable) : void
            public OnStateMove ($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable) : void
            public OnStateIK ($animator: UnityEngine.Animator, $stateInfo: UnityEngine.AnimatorStateInfo, $layerIndex: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable) : void
            public OnStateMachineEnter ($animator: UnityEngine.Animator, $stateMachinePathHash: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable) : void
            public OnStateMachineExit ($animator: UnityEngine.Animator, $stateMachinePathHash: number, $controller: UnityEngine.Animations.AnimatorControllerPlayable) : void
        }
        /** Information about the current or next state.
        */
        class AnimatorStateInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The full path hash for this state.
            */
            public get fullPathHash(): number;
            /** The hash is generated using Animator.StringToHash. The hash does not include the name of the parent layer.
            */
            public get shortNameHash(): number;
            /** Normalized time of the State.
            */
            public get normalizedTime(): number;
            /** Current duration of the state.
            */
            public get length(): number;
            /** The playback speed of the animation. 1 is the normal playback speed.
            */
            public get speed(): number;
            /** The speed multiplier for this state.
            */
            public get speedMultiplier(): number;
            /** The Tag of the State.
            */
            public get tagHash(): number;
            /** Is the state looping.
            */
            public get loop(): boolean;
            /** Does name match the name of the active state in the statemachine?
            */
            public IsName ($name: string) : boolean
            /** Does tag match the tag of the active state in the statemachine.
            */
            public IsTag ($tag: string) : boolean
        }
        /** Information about the current transition.
        */
        class AnimatorTransitionInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The hash name of the Transition.
            */
            public get fullPathHash(): number;
            /** The simplified name of the Transition.
            */
            public get nameHash(): number;
            /** The user-specified name of the Transition.
            */
            public get userNameHash(): number;
            /** The unit of the transition duration.
            */
            public get durationUnit(): UnityEngine.DurationUnit;
            /** Duration of the transition.
            */
            public get duration(): number;
            /** Normalized time of the Transition.
            */
            public get normalizedTime(): number;
            /** Returns true if the transition is from an AnyState node, or from Animator.CrossFade.
            */
            public get anyState(): boolean;
            /** Does name match the name of the active Transition.
            */
            public IsName ($name: string) : boolean
            /** Does userName match the name of the active Transition.
            */
            public IsUserName ($name: string) : boolean
        }
        /** Information about clip being played and blended by the Animator.
        */
        class AnimatorClipInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Returns the animation clip played by the Animator.
            */
            public get clip(): UnityEngine.AnimationClip;
            /** Returns the blending weight used by the Animator to blend this clip.
            */
            public get weight(): number;
        }
        /** Used to communicate between scripting and the controller. Some parameters can be set in scripting and used by the controller, while other parameters are based on Custom Curves in Animation Clips and can be sampled using the scripting API.
        */
        class AnimatorControllerParameter extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns the hash of the parameter based on its name.
            */
            public get nameHash(): number;
            /** The type of the parameter.
            */
            public get type(): UnityEngine.AnimatorControllerParameterType;
            public set type(value: UnityEngine.AnimatorControllerParameterType);
            /** The default float value for the parameter.
            */
            public get defaultFloat(): number;
            public set defaultFloat(value: number);
            /** The default int value for the parameter.
            */
            public get defaultInt(): number;
            public set defaultInt(value: number);
            /** The default bool value for the parameter.
            */
            public get defaultBool(): boolean;
            public set defaultBool(value: boolean);
            public constructor ()
        }
        /** Target.
        */
        enum AvatarTarget
        { Root = 0, Body = 1, LeftFoot = 2, RightFoot = 3, LeftHand = 4, RightHand = 5 }
        /** Use this struct to specify the position and rotation weight mask for Animator.MatchTarget.
        */
        class MatchTargetWeightMask extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Position XYZ weight.
            */
            public get positionXYZWeight(): UnityEngine.Vector3;
            public set positionXYZWeight(value: UnityEngine.Vector3);
            /** Rotation weight.
            */
            public get rotationWeight(): number;
            public set rotationWeight(value: number);
            public constructor ($positionXYZWeight: UnityEngine.Vector3, $rotationWeight: number)
            public constructor ()
        }
        /** Culling mode for the Animator.
        */
        enum AnimatorCullingMode
        { AlwaysAnimate = 0, CullUpdateTransforms = 1, CullCompletely = 2, BasedOnRenderers = 1 }
        /** The mode of the Animator's recorder.
        */
        enum AnimatorRecorderMode
        { Offline = 0, Playback = 1, Record = 2 }
        /** The runtime representation of the AnimatorController. Use this representation to change the Animator Controller during runtime.
        */
        class RuntimeAnimatorController extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Retrieves all AnimationClip used by the controller.
            */
            public get animationClips(): System.Array$1<UnityEngine.AnimationClip>;
        }
        /** Avatar definition.
        */
        class Avatar extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Return true if this avatar is a valid mecanim avatar. It can be a generic avatar or a human avatar.
            */
            public get isValid(): boolean;
            /** Return true if this avatar is a valid human avatar.
            */
            public get isHuman(): boolean;
            /** Returns the HumanDescription used to create this Avatar.
            */
            public get humanDescription(): UnityEngine.HumanDescription;
        }
        interface IAnimationClipSource
        {
            GetAnimationClips ($results: System.Collections.Generic.List$1<UnityEngine.AnimationClip>) : void
        }
        /** Base class for AnimationClips and BlendTrees.
        */
        class Motion extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            public get averageDuration(): number;
            public get averageAngularSpeed(): number;
            public get averageSpeed(): UnityEngine.Vector3;
            public get apparentSpeed(): number;
            public get isLooping(): boolean;
            public get legacy(): boolean;
            public get isHumanMotion(): boolean;
        }
        /** Stores keyframe based animations.
        */
        class AnimationClip extends UnityEngine.Motion
        {
            protected [__keep_incompatibility]: never;
            /** Animation length in seconds. (Read Only)
            */
            public get length(): number;
            /** Frame rate at which keyframes are sampled. (Read Only)
            */
            public get frameRate(): number;
            public set frameRate(value: number);
            /** Sets the default wrap mode used in the animation state.
            */
            public get wrapMode(): UnityEngine.WrapMode;
            public set wrapMode(value: UnityEngine.WrapMode);
            /** AABB of this Animation Clip in local space of Animation component that it is attached too.
            */
            public get localBounds(): UnityEngine.Bounds;
            public set localBounds(value: UnityEngine.Bounds);
            /** Set to true if the AnimationClip will be used with the Legacy Animation component ( instead of the Animator ).
            */
            public get legacy(): boolean;
            public set legacy(value: boolean);
            /** Returns true if the animation contains curve that drives a humanoid rig.
            */
            public get humanMotion(): boolean;
            /** Returns true if the animation clip has no curves and no events.
            */
            public get empty(): boolean;
            /** Returns true if the Animation has animation on the root transform.
            */
            public get hasGenericRootTransform(): boolean;
            /** Returns true if the AnimationClip has editor curves for its root motion.
            */
            public get hasMotionFloatCurves(): boolean;
            /** Returns true if the AnimationClip has root motion curves.
            */
            public get hasMotionCurves(): boolean;
            /** Returns true if the AnimationClip has root Curves.
            */
            public get hasRootCurves(): boolean;
            /** Animation Events for this animation clip.
            */
            public get events(): System.Array$1<UnityEngine.AnimationEvent>;
            public set events(value: System.Array$1<UnityEngine.AnimationEvent>);
            /** Samples an animation at a given time for any animated properties.
            * @param go The animated game object.
            * @param time The time to sample an animation.
            */
            public SampleAnimation ($go: UnityEngine.GameObject, $time: number) : void
            /** Assigns the curve to animate a specific property.
            * @param relativePath Path to the game object this curve applies to. The relativePath
            is formatted similar to a pathname, e.g. "rootspineleftArm".  If relativePath
            is empty it refers to the game object the animation clip is attached to.
            * @param type The class type of the component that is animated.
            * @param propertyName The name or path to the property being animated.
            * @param curve The animation curve.
            */
            public SetCurve ($relativePath: string, $type: System.Type, $propertyName: string, $curve: UnityEngine.AnimationCurve) : void
            public EnsureQuaternionContinuity () : void
            public ClearCurves () : void
            /** Adds an animation event to the clip.
            * @param evt AnimationEvent to add.
            */
            public AddEvent ($evt: UnityEngine.AnimationEvent) : void
            public constructor ()
        }
        /** The SharedBetweenAnimatorsAttribute specifies that this StateMachineBehaviour is instantiated only once and shared by all Animator instances. This attribute reduces the memory footprint for each controller instance.
        */
        class SharedBetweenAnimatorsAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Used by Animation.Play function.
        */
        enum PlayMode
        { StopSameLayer = 0, StopAll = 4 }
        /** Used by Animation.Play function.
        */
        enum QueueMode
        { CompleteOthers = 0, PlayNow = 2 }
        /** Used by Animation.Play function.
        */
        enum AnimationBlendMode
        { Blend = 0, Additive = 1 }
        enum AnimationPlayMode
        { Stop = 0, Queue = 1, Mix = 2 }
        /** This enum controlls culling of Animation component.
        */
        enum AnimationCullingType
        { AlwaysAnimate = 0, BasedOnRenderers = 1, BasedOnClipBounds = 2, BasedOnUserBounds = 3 }
        /** The animation component is used to play back animations.
        */
        class Animation extends UnityEngine.Behaviour implements System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            /** The default animation.
            */
            public get clip(): UnityEngine.AnimationClip;
            public set clip(value: UnityEngine.AnimationClip);
            /** Should the default animation clip (the Animation.clip property) automatically start playing on startup?
            */
            public get playAutomatically(): boolean;
            public set playAutomatically(value: boolean);
            /** How should time beyond the playback range of the clip be treated?
            */
            public get wrapMode(): UnityEngine.WrapMode;
            public set wrapMode(value: UnityEngine.WrapMode);
            /** Is an animation currently being played?
            */
            public get isPlaying(): boolean;
            /** When turned on, animations will be executed in the physics loop. This is only useful in conjunction with kinematic rigidbodies.
            */
            public get animatePhysics(): boolean;
            public set animatePhysics(value: boolean);
            /** Controls culling of this Animation component.
            */
            public get cullingType(): UnityEngine.AnimationCullingType;
            public set cullingType(value: UnityEngine.AnimationCullingType);
            /** AABB of this Animation animation component in local space.
            */
            public get localBounds(): UnityEngine.Bounds;
            public set localBounds(value: UnityEngine.Bounds);
            public Stop () : void
            /** Stops an animation named name.
            */
            public Stop ($name: string) : void
            public Rewind () : void
            /** Rewinds the animation named name.
            */
            public Rewind ($name: string) : void
            public Sample () : void
            /** Is the animation named name playing?
            */
            public IsPlaying ($name: string) : boolean
            public get_Item ($name: string) : UnityEngine.AnimationState
            /** Plays an animation without blending.
            */
            public Play () : boolean
            /** Plays an animation without blending.
            */
            public Play ($mode: UnityEngine.PlayMode) : boolean
            /** Plays an animation without blending.
            */
            public Play ($animation: string) : boolean
            /** Plays an animation without blending.
            */
            public Play ($animation: string, $mode: UnityEngine.PlayMode) : boolean
            /** Fades in the animation with the name animation over a period of time defined by fadeLength.
            */
            public CrossFade ($animation: string) : void
            /** Fades in the animation with the name animation over a period of time defined by fadeLength.
            */
            public CrossFade ($animation: string, $fadeLength: number) : void
            /** Fades in the animation with the name animation over a period of time defined by fadeLength.
            */
            public CrossFade ($animation: string, $fadeLength: number, $mode: UnityEngine.PlayMode) : void
            /** Blends the animation named animation towards targetWeight over the next time seconds.
            */
            public Blend ($animation: string) : void
            /** Blends the animation named animation towards targetWeight over the next time seconds.
            */
            public Blend ($animation: string, $targetWeight: number) : void
            /** Blends the animation named animation towards targetWeight over the next time seconds.
            */
            public Blend ($animation: string, $targetWeight: number, $fadeLength: number) : void
            /** Cross fades an animation after previous animations has finished playing.
            */
            public CrossFadeQueued ($animation: string) : UnityEngine.AnimationState
            /** Cross fades an animation after previous animations has finished playing.
            */
            public CrossFadeQueued ($animation: string, $fadeLength: number) : UnityEngine.AnimationState
            /** Cross fades an animation after previous animations has finished playing.
            */
            public CrossFadeQueued ($animation: string, $fadeLength: number, $queue: UnityEngine.QueueMode) : UnityEngine.AnimationState
            /** Cross fades an animation after previous animations has finished playing.
            */
            public CrossFadeQueued ($animation: string, $fadeLength: number, $queue: UnityEngine.QueueMode, $mode: UnityEngine.PlayMode) : UnityEngine.AnimationState
            /** Plays an animation after previous animations has finished playing.
            */
            public PlayQueued ($animation: string) : UnityEngine.AnimationState
            /** Plays an animation after previous animations has finished playing.
            */
            public PlayQueued ($animation: string, $queue: UnityEngine.QueueMode) : UnityEngine.AnimationState
            /** Plays an animation after previous animations has finished playing.
            */
            public PlayQueued ($animation: string, $queue: UnityEngine.QueueMode, $mode: UnityEngine.PlayMode) : UnityEngine.AnimationState
            /** Adds a clip to the animation with name newName.
            */
            public AddClip ($clip: UnityEngine.AnimationClip, $newName: string) : void
            /** Adds clip to the only play between firstFrame and lastFrame. The new clip will also be added to the animation with name newName.
            * @param addLoopFrame Should an extra frame be inserted at the end that matches the first frame? Turn this on if you are making a looping animation.
            */
            public AddClip ($clip: UnityEngine.AnimationClip, $newName: string, $firstFrame: number, $lastFrame: number) : void
            /** Adds clip to the only play between firstFrame and lastFrame. The new clip will also be added to the animation with name newName.
            * @param addLoopFrame Should an extra frame be inserted at the end that matches the first frame? Turn this on if you are making a looping animation.
            */
            public AddClip ($clip: UnityEngine.AnimationClip, $newName: string, $firstFrame: number, $lastFrame: number, $addLoopFrame: boolean) : void
            /** Remove clip from the animation list.
            */
            public RemoveClip ($clip: UnityEngine.AnimationClip) : void
            /** Remove clip from the animation list.
            */
            public RemoveClip ($clipName: string) : void
            public GetClipCount () : number
            public SyncLayer ($layer: number) : void
            public GetEnumerator () : System.Collections.IEnumerator
            public GetClip ($name: string) : UnityEngine.AnimationClip
            public constructor ()
        }
        /** Determines how time is treated outside of the keyframed range of an AnimationClip or AnimationCurve.
        */
        enum WrapMode
        { Once = 1, Loop = 2, PingPong = 4, Default = 0, ClampForever = 8, Clamp = 1 }
        class TrackedReference extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static op_Equality ($x: UnityEngine.TrackedReference, $y: UnityEngine.TrackedReference) : boolean
            public static op_Inequality ($x: UnityEngine.TrackedReference, $y: UnityEngine.TrackedReference) : boolean
            public static op_Implicit ($exists: UnityEngine.TrackedReference) : boolean
        }
        /** The AnimationState gives full control over animation blending.
        */
        class AnimationState extends UnityEngine.TrackedReference
        {
            protected [__keep_incompatibility]: never;
            /** Enables / disables the animation.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** The weight of animation.
            */
            public get weight(): number;
            public set weight(value: number);
            /** Wrapping mode of the animation.
            */
            public get wrapMode(): UnityEngine.WrapMode;
            public set wrapMode(value: UnityEngine.WrapMode);
            /** The current time of the animation.
            */
            public get time(): number;
            public set time(value: number);
            /** The normalized time of the animation.
            */
            public get normalizedTime(): number;
            public set normalizedTime(value: number);
            /** The playback speed of the animation. 1 is normal playback speed.
            */
            public get speed(): number;
            public set speed(value: number);
            /** The normalized playback speed.
            */
            public get normalizedSpeed(): number;
            public set normalizedSpeed(value: number);
            /** The length of the animation clip in seconds.
            */
            public get length(): number;
            public get layer(): number;
            public set layer(value: number);
            /** The clip that is being played by this animation state.
            */
            public get clip(): UnityEngine.AnimationClip;
            /** The name of the animation.
            */
            public get name(): string;
            public set name(value: string);
            /** Which blend mode should be used?
            */
            public get blendMode(): UnityEngine.AnimationBlendMode;
            public set blendMode(value: UnityEngine.AnimationBlendMode);
            /** Adds a transform which should be animated. This allows you to reduce the number of animations you have to create.
            * @param mix The transform to animate.
            * @param recursive Whether to also animate all children of the specified transform.
            */
            public AddMixingTransform ($mix: UnityEngine.Transform) : void
            /** Adds a transform which should be animated. This allows you to reduce the number of animations you have to create.
            * @param mix The transform to animate.
            * @param recursive Whether to also animate all children of the specified transform.
            */
            public AddMixingTransform ($mix: UnityEngine.Transform, $recursive: boolean) : void
            /** Removes a transform which should be animated.
            */
            public RemoveMixingTransform ($mix: UnityEngine.Transform) : void
            public constructor ()
        }
        /** Represents an axis aligned bounding box.
        */
        class Bounds extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Bounds>
        {
            protected [__keep_incompatibility]: never;
            /** The center of the bounding box.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** The total size of the box. This is always twice as large as the extents.
            */
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            /** The extents of the Bounding Box. This is always half of the size of the Bounds.
            */
            public get extents(): UnityEngine.Vector3;
            public set extents(value: UnityEngine.Vector3);
            /** The minimal point of the box. This is always equal to center-extents.
            */
            public get min(): UnityEngine.Vector3;
            public set min(value: UnityEngine.Vector3);
            /** The maximal point of the box. This is always equal to center+extents.
            */
            public get max(): UnityEngine.Vector3;
            public set max(value: UnityEngine.Vector3);
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Bounds) : boolean
            public static op_Equality ($lhs: UnityEngine.Bounds, $rhs: UnityEngine.Bounds) : boolean
            public static op_Inequality ($lhs: UnityEngine.Bounds, $rhs: UnityEngine.Bounds) : boolean
            /** Sets the bounds to the min and max value of the box.
            */
            public SetMinMax ($min: UnityEngine.Vector3, $max: UnityEngine.Vector3) : void
            /** Grows the Bounds to include the point.
            */
            public Encapsulate ($point: UnityEngine.Vector3) : void
            /** Grow the bounds to encapsulate the bounds.
            */
            public Encapsulate ($bounds: UnityEngine.Bounds) : void
            /** Expand the bounds by increasing its size by amount along each side.
            */
            public Expand ($amount: number) : void
            /** Expand the bounds by increasing its size by amount along each side.
            */
            public Expand ($amount: UnityEngine.Vector3) : void
            /** Does another bounding box intersect with this bounding box?
            */
            public Intersects ($bounds: UnityEngine.Bounds) : boolean
            /** Does ray intersect this bounding box?
            */
            public IntersectRay ($ray: UnityEngine.Ray) : boolean
            /** Does ray intersect this bounding box?
            */
            public IntersectRay ($ray: UnityEngine.Ray, $distance: $Ref<number>) : boolean
            public ToString () : string
            /** Returns a formatted string for the bounds.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for the bounds.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            /** Is point contained in the bounding box?
            */
            public Contains ($point: UnityEngine.Vector3) : boolean
            /** The smallest squared distance between the point and this bounding box.
            */
            public SqrDistance ($point: UnityEngine.Vector3) : number
            /** The closest point on the bounding box.
            * @param point Arbitrary point.
            * @returns The point on the bounding box or inside the bounding box. 
            */
            public ClosestPoint ($point: UnityEngine.Vector3) : UnityEngine.Vector3
            public constructor ($center: UnityEngine.Vector3, $size: UnityEngine.Vector3)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** AnimationEvent lets you call a script function similar to SendMessage as part of playing back an animation.
        */
        class AnimationEvent extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** String parameter that is stored in the event and will be sent to the function.
            */
            public get stringParameter(): string;
            public set stringParameter(value: string);
            /** Float parameter that is stored in the event and will be sent to the function.
            */
            public get floatParameter(): number;
            public set floatParameter(value: number);
            /** Int parameter that is stored in the event and will be sent to the function.
            */
            public get intParameter(): number;
            public set intParameter(value: number);
            /** Object reference parameter that is stored in the event and will be sent to the function.
            */
            public get objectReferenceParameter(): UnityEngine.Object;
            public set objectReferenceParameter(value: UnityEngine.Object);
            /** The name of the function that will be called.
            */
            public get functionName(): string;
            public set functionName(value: string);
            /** The time at which the event will be fired off.
            */
            public get time(): number;
            public set time(value: number);
            /** Function call options.
            */
            public get messageOptions(): UnityEngine.SendMessageOptions;
            public set messageOptions(value: UnityEngine.SendMessageOptions);
            /** Returns true if this Animation event has been fired by an Animation component.
            */
            public get isFiredByLegacy(): boolean;
            /** Returns true if this Animation event has been fired by an Animator component.
            */
            public get isFiredByAnimator(): boolean;
            /** The animation state that fired this event (Read Only).
            */
            public get animationState(): UnityEngine.AnimationState;
            /** The animator state info related to this event (Read Only).
            */
            public get animatorStateInfo(): UnityEngine.AnimatorStateInfo;
            /** The animator clip info related to this event (Read Only).
            */
            public get animatorClipInfo(): UnityEngine.AnimatorClipInfo;
            public constructor ()
        }
        /** Store a collection of Keyframes that can be evaluated over time.
        */
        class AnimationCurve extends System.Object implements System.IEquatable$1<UnityEngine.AnimationCurve>
        {
            protected [__keep_incompatibility]: never;
            /** All keys defined in the animation curve.
            */
            public get keys(): System.Array$1<UnityEngine.Keyframe>;
            public set keys(value: System.Array$1<UnityEngine.Keyframe>);
            /** The number of keys in the curve. (Read Only)
            */
            public get length(): number;
            /** The behaviour of the animation before the first keyframe.
            */
            public get preWrapMode(): UnityEngine.WrapMode;
            public set preWrapMode(value: UnityEngine.WrapMode);
            /** The behaviour of the animation after the last keyframe.
            */
            public get postWrapMode(): UnityEngine.WrapMode;
            public set postWrapMode(value: UnityEngine.WrapMode);
            /** Evaluate the curve at time.
            * @param time The time within the curve you want to evaluate (the horizontal axis in the curve graph).
            * @returns The value of the curve, at the point in time specified. 
            */
            public Evaluate ($time: number) : number
            /** Add a new key to the curve.
            * @param time The time at which to add the key (horizontal axis in the curve graph).
            * @param value The value for the key (vertical axis in the curve graph).
            * @returns The index of the added key, or -1 if the key could not be added. 
            */
            public AddKey ($time: number, $value: number) : number
            /** Add a new key to the curve.
            * @param key The key to add to the curve.
            * @returns The index of the added key, or -1 if the key could not be added. 
            */
            public AddKey ($key: UnityEngine.Keyframe) : number
            /** Removes the keyframe at index and inserts key.
            * @param index The index of the key to move.
            * @param key The key (with its new time) to insert.
            * @returns The index of the keyframe after moving it. 
            */
            public MoveKey ($index: number, $key: UnityEngine.Keyframe) : number
            /** Removes a key.
            * @param index The index of the key to remove.
            */
            public RemoveKey ($index: number) : void
            public get_Item ($index: number) : UnityEngine.Keyframe
            /** Smooth the in and out tangents of the keyframe at index.
            * @param index The index of the keyframe to be smoothed.
            * @param weight The smoothing weight to apply to the keyframe's tangents.
            */
            public SmoothTangents ($index: number, $weight: number) : void
            /** Creates a constant "curve" starting at timeStart, ending at timeEnd, and set to the value value.
            * @param timeStart The start time for the constant curve.
            * @param timeEnd The end time for the constant curve.
            * @param value The value for the constant curve.
            * @returns The constant curve created from the specified values. 
            */
            public static Constant ($timeStart: number, $timeEnd: number, $value: number) : UnityEngine.AnimationCurve
            /** A straight Line starting at timeStart, valueStart and ending at timeEnd, valueEnd.
            * @param timeStart The start time for the linear curve.
            * @param valueStart The start value for the linear curve.
            * @param timeEnd The end time for the linear curve.
            * @param valueEnd The end value for the linear curve.
            * @returns The linear curve created from the specified values. 
            */
            public static Linear ($timeStart: number, $valueStart: number, $timeEnd: number, $valueEnd: number) : UnityEngine.AnimationCurve
            /** Creates an ease-in and out curve starting at timeStart, valueStart and ending at timeEnd, valueEnd.
            * @param timeStart The start time for the ease curve.
            * @param valueStart The start value for the ease curve.
            * @param timeEnd The end time for the ease curve.
            * @param valueEnd The end value for the ease curve.
            * @returns The ease-in and out curve generated from the specified values. 
            */
            public static EaseInOut ($timeStart: number, $valueStart: number, $timeEnd: number, $valueEnd: number) : UnityEngine.AnimationCurve
            public Equals ($o: any) : boolean
            public Equals ($other: UnityEngine.AnimationCurve) : boolean
            public constructor (...keys: UnityEngine.Keyframe[])
            public constructor ()
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        /** The type of the parameter.
        */
        enum AnimatorControllerParameterType
        { Float = 1, Int = 3, Bool = 4, Trigger = 9 }
        /** Describe the unit of a duration.
        */
        enum DurationUnit
        { Fixed = 0, Normalized = 1 }
        /** Interface to control Animator Override Controller.
        */
        class AnimatorOverrideController extends UnityEngine.RuntimeAnimatorController
        {
            protected [__keep_incompatibility]: never;
            /** The Runtime Animator Controller that the Animator Override Controller overrides.
            */
            public get runtimeAnimatorController(): UnityEngine.RuntimeAnimatorController;
            public set runtimeAnimatorController(value: UnityEngine.RuntimeAnimatorController);
            /** Returns the count of overrides.
            */
            public get overridesCount(): number;
            public get_Item ($name: string) : UnityEngine.AnimationClip
            public set_Item ($name: string, $value: UnityEngine.AnimationClip) : void
            public get_Item ($clip: UnityEngine.AnimationClip) : UnityEngine.AnimationClip
            public set_Item ($clip: UnityEngine.AnimationClip, $value: UnityEngine.AnimationClip) : void
            public GetOverrides ($overrides: System.Collections.Generic.List$1<System.Collections.Generic.KeyValuePair$2<UnityEngine.AnimationClip, UnityEngine.AnimationClip>>) : void
            public ApplyOverrides ($overrides: System.Collections.Generic.IList$1<System.Collections.Generic.KeyValuePair$2<UnityEngine.AnimationClip, UnityEngine.AnimationClip>>) : void
            public constructor ()
            public constructor ($controller: UnityEngine.RuntimeAnimatorController)
        }
        /** This class defines a pair of clips used by AnimatorOverrideController.
        */
        class AnimationClipPair extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** Various utilities for animator manipulation.
        */
        class AnimatorUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** This function will remove all transform hierarchy under GameObject, the animator will write directly transform matrices into the skin mesh matrices saving many CPU cycles.
            * @param go GameObject to Optimize.
            * @param exposedTransforms List of transform name to expose.
            */
            public static OptimizeTransformHierarchy ($go: UnityEngine.GameObject, $exposedTransforms: System.Array$1<string>) : void
            /** This function will recreate all transform hierarchy under GameObject.
            * @param go GameObject to Deoptimize.
            */
            public static DeoptimizeTransformHierarchy ($go: UnityEngine.GameObject) : void
            public constructor ()
        }
        /** Enumeration of all the muscles in the body.
        */
        enum BodyDof
        { SpineFrontBack = 0, SpineLeftRight = 1, SpineRollLeftRight = 2, ChestFrontBack = 3, ChestLeftRight = 4, ChestRollLeftRight = 5, UpperChestFrontBack = 6, UpperChestLeftRight = 7, UpperChestRollLeftRight = 8, LastBodyDof = 9 }
        /** Enumeration of all the muscles in the head.
        */
        enum HeadDof
        { NeckFrontBack = 0, NeckLeftRight = 1, NeckRollLeftRight = 2, HeadFrontBack = 3, HeadLeftRight = 4, HeadRollLeftRight = 5, LeftEyeDownUp = 6, LeftEyeInOut = 7, RightEyeDownUp = 8, RightEyeInOut = 9, JawDownUp = 10, JawLeftRight = 11, LastHeadDof = 12 }
        /** Enumeration of all the muscles in a leg.
        */
        enum LegDof
        { UpperLegFrontBack = 0, UpperLegInOut = 1, UpperLegRollInOut = 2, LegCloseOpen = 3, LegRollInOut = 4, FootCloseOpen = 5, FootInOut = 6, ToesUpDown = 7, LastLegDof = 8 }
        /** Enumeration of all the muscles in an arm.
        */
        enum ArmDof
        { ShoulderDownUp = 0, ShoulderFrontBack = 1, ArmDownUp = 2, ArmFrontBack = 3, ArmRollInOut = 4, ForeArmCloseOpen = 5, ForeArmRollInOut = 6, HandDownUp = 7, HandInOut = 8, LastArmDof = 9 }
        /** Enumeration of all the muscles in a finger.
        */
        enum FingerDof
        { ProximalDownUp = 0, ProximalInOut = 1, IntermediateCloseOpen = 2, DistalCloseOpen = 3, LastFingerDof = 4 }
        /** Enumeration of all the parts in a human.
        */
        enum HumanPartDof
        { Body = 0, Head = 1, LeftLeg = 2, RightLeg = 3, LeftArm = 4, RightArm = 5, LeftThumb = 6, LeftIndex = 7, LeftMiddle = 8, LeftRing = 9, LeftLittle = 10, RightThumb = 11, RightIndex = 12, RightMiddle = 13, RightRing = 14, RightLittle = 15, LastHumanPartDof = 16 }
        /** Class that holds humanoid avatar parameters to pass to the AvatarBuilder.BuildHumanAvatar function.
        */
        class HumanDescription extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Mapping between Mecanim bone names and bone names in the rig.
            */
            public human : System.Array$1<UnityEngine.HumanBone>
            /** List of bone Transforms to include in the model.
            */
            public skeleton : System.Array$1<UnityEngine.SkeletonBone>
            /** Defines how the upper arm's roll/twisting is distributed between the shoulder and elbow joints.
            */
            public get upperArmTwist(): number;
            public set upperArmTwist(value: number);
            /** Defines how the lower arm's roll/twisting is distributed between the elbow and wrist joints.
            */
            public get lowerArmTwist(): number;
            public set lowerArmTwist(value: number);
            /** Defines how the upper leg's roll/twisting is distributed between the thigh and knee joints.
            */
            public get upperLegTwist(): number;
            public set upperLegTwist(value: number);
            /** Defines how the lower leg's roll/twisting is distributed between the knee and ankle.
            */
            public get lowerLegTwist(): number;
            public set lowerLegTwist(value: number);
            /** Amount by which the arm's length is allowed to stretch when using IK.
            */
            public get armStretch(): number;
            public set armStretch(value: number);
            /** Amount by which the leg's length is allowed to stretch when using IK.
            */
            public get legStretch(): number;
            public set legStretch(value: number);
            /** Modification to the minimum distance between the feet of a humanoid model.
            */
            public get feetSpacing(): number;
            public set feetSpacing(value: number);
            /** True for any human that has a translation Degree of Freedom (DoF). It is set to false by default.
            */
            public get hasTranslationDoF(): boolean;
            public set hasTranslationDoF(value: boolean);
        }
        /** Details of the Transform name mapped to the skeleton bone of a model and its default position and rotation in the T-pose.
        */
        class SkeletonBone extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The name of the Transform mapped to the bone.
            */
            public name : string
            /** The T-pose position of the bone in local space.
            */
            public position : UnityEngine.Vector3
            /** The T-pose rotation of the bone in local space.
            */
            public rotation : UnityEngine.Quaternion
            /** The T-pose scaling of the bone in local space.
            */
            public scale : UnityEngine.Vector3
        }
        /** This class stores the rotation limits that define the muscle for a single human bone.
        */
        class HumanLimit extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Should this limit use the default values?
            */
            public get useDefaultValues(): boolean;
            public set useDefaultValues(value: boolean);
            /** The maximum negative rotation away from the initial value that this muscle can apply.
            */
            public get min(): UnityEngine.Vector3;
            public set min(value: UnityEngine.Vector3);
            /** The maximum rotation away from the initial value that this muscle can apply.
            */
            public get max(): UnityEngine.Vector3;
            public set max(value: UnityEngine.Vector3);
            /** The default orientation of a bone when no muscle action is applied.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** Length of the bone to which the limit is applied.
            */
            public get axisLength(): number;
            public set axisLength(value: number);
        }
        /** The mapping between a bone in the model and the conceptual bone in the Mecanim human anatomy.
        */
        class HumanBone extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The rotation limits that define the muscle for this bone.
            */
            public limit : UnityEngine.HumanLimit
            /** The name of the bone to which the Mecanim human bone is mapped.
            */
            public get boneName(): string;
            public set boneName(value: string);
            /** The name of the Mecanim human bone to which the bone from the model is mapped.
            */
            public get humanName(): string;
            public set humanName(value: string);
        }
        /** Class to build avatars from user scripts.
        */
        class AvatarBuilder extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Create a humanoid avatar.
            * @param go Root object of your transform hierachy. It must be the top most gameobject when you create the avatar.
            * @param humanDescription Humanoid description of the avatar.
            * @returns Returns the Avatar, you must always always check the avatar is valid before using it with Avatar.isValid. 
            */
            public static BuildHumanAvatar ($go: UnityEngine.GameObject, $humanDescription: UnityEngine.HumanDescription) : UnityEngine.Avatar
            /** Create a new generic avatar.
            * @param go Root object of your transform hierarchy.
            * @param rootMotionTransformName Transform name of the root motion transform. If empty no root motion is defined and you must take care of avatar movement yourself.
            */
            public static BuildGenericAvatar ($go: UnityEngine.GameObject, $rootMotionTransformName: string) : UnityEngine.Avatar
            public constructor ()
        }
        /** Avatar body part.
        */
        enum AvatarMaskBodyPart
        { Root = 0, Body = 1, Head = 2, LeftLeg = 3, RightLeg = 4, LeftArm = 5, RightArm = 6, LeftFingers = 7, RightFingers = 8, LeftFootIK = 9, RightFootIK = 10, LeftHandIK = 11, RightHandIK = 12, LastBodyPart = 13 }
        /** AvatarMask is used to mask out humanoid body parts and transforms.
        */
        class AvatarMask extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Number of transforms.
            */
            public get transformCount(): number;
            public set transformCount(value: number);
            /** Returns true if the humanoid body part at the given index is active.
            * @param index The index of the humanoid body part.
            */
            public GetHumanoidBodyPartActive ($index: UnityEngine.AvatarMaskBodyPart) : boolean
            /** Sets the humanoid body part at the given index to active or not.
            * @param index The index of the humanoid body part.
            * @param value Active or not.
            */
            public SetHumanoidBodyPartActive ($index: UnityEngine.AvatarMaskBodyPart, $value: boolean) : void
            public AddTransformPath ($transform: UnityEngine.Transform) : void
            /** Adds a transform path into the AvatarMask.
            * @param transform The transform to add into the AvatarMask.
            * @param recursive Whether to also add all children of the specified transform.
            */
            public AddTransformPath ($transform: UnityEngine.Transform, $recursive: boolean) : void
            public RemoveTransformPath ($transform: UnityEngine.Transform) : void
            /** Removes a transform path from the AvatarMask.
            * @param transform The Transform that should be removed from the AvatarMask.
            * @param recursive Whether to also remove all children of the specified transform.
            */
            public RemoveTransformPath ($transform: UnityEngine.Transform, $recursive: boolean) : void
            /** Returns the path of the transform at the given index.
            * @param index The index of the transform.
            */
            public GetTransformPath ($index: number) : string
            /** Sets the path of the transform at the given index.
            * @param index The index of the transform.
            * @param path The path of the transform.
            */
            public SetTransformPath ($index: number, $path: string) : void
            /** Returns true if the transform at the given index is active.
            * @param index The index of the transform.
            */
            public GetTransformActive ($index: number) : boolean
            /** Sets the tranform at the given index to active or not.
            * @param index The index of the transform.
            * @param value Active or not.
            */
            public SetTransformActive ($index: number, $value: boolean) : void
            public constructor ()
        }
        /** Retargetable humanoid pose.
        */
        class HumanPose extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The human body position for that pose.
            */
            public bodyPosition : UnityEngine.Vector3
            /** The human body orientation for that pose.
            */
            public bodyRotation : UnityEngine.Quaternion
            /** The array of muscle values for that pose.
            */
            public muscles : System.Array$1<number>
        }
        /** Use this class to create, read, and write the HumanPose for a humanoid avatar skeleton hierarchy or an avatar pose.
        */
        class HumanPoseHandler extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Dispose () : void
            /** Computes a human pose from the avatar skeleton, stores the pose in the human pose handler, and returns the human pose.
            * @param humanPose The output human pose. In the human pose, the bodyPosition and bodyRotation are the position and rotation of the approximate center of mass of the humanoid in world space. bodyPosition is normalized: the position is divided by avatar human scale.
            */
            public GetHumanPose ($humanPose: $Ref<UnityEngine.HumanPose>) : void
            /** Stores the specified human pose inside the human pose handler.
            * @param humanPose The human pose to set. In the human pose, the bodyPosition and bodyRotation are the position and rotation of the approximate center of mass of the humanoid. This is relative to the humanoid root transform and it is normalized: the local position is divided by avatar human scale.
            */
            public SetHumanPose ($humanPose: $Ref<UnityEngine.HumanPose>) : void
            /** Gets the internal human pose stored in the human pose handler.
            * @param humanPose The output human pose. In the human pose, the bodyPosition and bodyRotation are the position and rotation of the approximate center of mass of the humanoid in world space. bodyPosition is normalized: the position is divided by avatar human scale.
            */
            public GetInternalHumanPose ($humanPose: $Ref<UnityEngine.HumanPose>) : void
            /** Stores the specified human pose as the internal human pose inside the human pose handler.
            * @param humanPose The human pose to set. In the human pose, the bodyPosition and bodyRotation are the position and rotation of the approximate center of mass of the humanoid. This is relative to the humanoid root transform and it is normalized: the local position is divided by avatar human scale.
            */
            public SetInternalHumanPose ($humanPose: $Ref<UnityEngine.HumanPose>) : void
            public GetInternalAvatarPose ($avatarPose: Unity.Collections.NativeArray$1<number>) : void
            public SetInternalAvatarPose ($avatarPose: Unity.Collections.NativeArray$1<number>) : void
            public constructor ($avatar: UnityEngine.Avatar, $root: UnityEngine.Transform)
            public constructor ($avatar: UnityEngine.Avatar, $jointPaths: System.Array$1<string>)
            public constructor ()
        }
        /** Details of all the human bone and muscle types defined by Mecanim.
        */
        class HumanTrait extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The number of human muscle types defined by Mecanim.
            */
            public static get MuscleCount(): number;
            /** Array of the names of all human muscle types defined by Mecanim.
            */
            public static get MuscleName(): System.Array$1<string>;
            /** The number of human bone types defined by Mecanim.
            */
            public static get BoneCount(): number;
            /** Array of the names of all human bone types defined by Mecanim.
            */
            public static get BoneName(): System.Array$1<string>;
            /** The number of bone types that are required by Mecanim for any human model.
            */
            public static get RequiredBoneCount(): number;
            /** Obtain the muscle index for a particular bone index and "degree of freedom".
            * @param i Bone index.
            * @param dofIndex Number representing a "degree of freedom": 0 for X-Axis, 1 for Y-Axis, 2 for Z-Axis.
            */
            public static MuscleFromBone ($i: number, $dofIndex: number) : number
            /** Return the bone to which a particular muscle is connected.
            * @param i Muscle index.
            */
            public static BoneFromMuscle ($i: number) : number
            /** Is the bone a member of the minimal set of bones that Mecanim requires for a human model?
            * @param i Index of the bone to test.
            */
            public static RequiredBone ($i: number) : boolean
            /** Get the default minimum value of rotation for a muscle in degrees.
            * @param i Muscle index.
            */
            public static GetMuscleDefaultMin ($i: number) : number
            /** Get the default maximum value of rotation for a muscle in degrees.
            * @param i Muscle index.
            */
            public static GetMuscleDefaultMax ($i: number) : number
            /** Gets the bone hierarchy mass.
            * @param i The humanoid bone index.
            * @returns The bone hierarchy mass. 
            */
            public static GetBoneDefaultHierarchyMass ($i: number) : number
            /** Returns parent humanoid bone index of a bone.
            * @param i Humanoid bone index to get parent from.
            * @returns Humanoid bone index of parent. 
            */
            public static GetParentBone ($i: number) : number
            public constructor ()
        }
        /** The result of an Asset Bundle Load or Recompress Operation.
        */
        enum AssetBundleLoadResult
        { Success = 0, Cancelled = 1, NotMatchingCrc = 2, FailedCache = 3, NotValidAssetBundle = 4, NoSerializedData = 5, NotCompatible = 6, AlreadyLoaded = 7, FailedRead = 8, FailedDecompression = 9, FailedWrite = 10, FailedDeleteRecompressionTarget = 11, RecompressionTargetIsLoaded = 12, RecompressionTargetExistsButNotArchive = 13 }
        /** AssetBundles let you stream additional assets via the UnityWebRequest class and instantiate them at runtime. AssetBundles are created via BuildPipeline.BuildAssetBundle.
        */
        class AssetBundle extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Return true if the AssetBundle is a streamed Scene AssetBundle.
            */
            public get isStreamedSceneAssetBundle(): boolean;
            /** Controls the size of the shared AssetBundle loading cache. Default value is 1MB. 
            */
            public static get memoryBudgetKB(): number;
            public static set memoryBudgetKB(value: number);
            /** Unloads all currently loaded AssetBundles.
            * @param unloadAllObjects Determines whether the current instances of objects loaded from AssetBundles will also be unloaded.
            */
            public static UnloadAllAssetBundles ($unloadAllObjects: boolean) : void
            public static GetAllLoadedAssetBundles () : System.Collections.Generic.IEnumerable$1<UnityEngine.AssetBundle>
            public static LoadFromFileAsync ($path: string) : UnityEngine.AssetBundleCreateRequest
            public static LoadFromFileAsync ($path: string, $crc: number) : UnityEngine.AssetBundleCreateRequest
            /** Asynchronously loads an AssetBundle from a file on disk.
            * @param path Path of the file on disk.
            * @param crc An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.
            * @param offset An optional byte offset. This value specifies where to start reading the AssetBundle from.
            * @returns Asynchronous create request for an AssetBundle. Use AssetBundleCreateRequest.assetBundle property to get an AssetBundle once it is loaded. 
            */
            public static LoadFromFileAsync ($path: string, $crc: number, $offset: bigint) : UnityEngine.AssetBundleCreateRequest
            public static LoadFromFile ($path: string) : UnityEngine.AssetBundle
            public static LoadFromFile ($path: string, $crc: number) : UnityEngine.AssetBundle
            /** Synchronously loads an AssetBundle from a file on disk.
            * @param path Path of the file on disk.
            * @param crc An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.
            * @param offset An optional byte offset. This value specifies where to start reading the AssetBundle from.
            * @returns Loaded AssetBundle object or null if failed. 
            */
            public static LoadFromFile ($path: string, $crc: number, $offset: bigint) : UnityEngine.AssetBundle
            public static LoadFromMemoryAsync ($binary: System.Array$1<number>) : UnityEngine.AssetBundleCreateRequest
            /** Asynchronously create an AssetBundle from a memory region.
            * @param binary Array of bytes with the AssetBundle data.
            * @param crc An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.
            * @returns Asynchronous create request for an AssetBundle. Use AssetBundleCreateRequest.assetBundle property to get an AssetBundle once it is loaded. 
            */
            public static LoadFromMemoryAsync ($binary: System.Array$1<number>, $crc: number) : UnityEngine.AssetBundleCreateRequest
            public static LoadFromMemory ($binary: System.Array$1<number>) : UnityEngine.AssetBundle
            /** Synchronously create an AssetBundle from a memory region.
            * @param binary Array of bytes with the AssetBundle data.
            * @param crc An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.
            * @returns Loaded AssetBundle object or null if failed. 
            */
            public static LoadFromMemory ($binary: System.Array$1<number>, $crc: number) : UnityEngine.AssetBundle
            /** Asynchronously loads an AssetBundle from a managed Stream.
            * @param stream The managed Stream object. Unity calls Read(), Seek() and the Length property on this object to load the AssetBundle data.
            * @param crc An optional CRC-32 checksum of the uncompressed content.
            * @param managedReadBufferSize You can use this to override the size of the read buffer Unity uses while loading data. The default size is 32KB.
            * @returns Asynchronous create request for an AssetBundle. Use AssetBundleCreateRequest.assetBundle property to get an AssetBundle once it is loaded. 
            */
            public static LoadFromStreamAsync ($stream: System.IO.Stream, $crc: number, $managedReadBufferSize: number) : UnityEngine.AssetBundleCreateRequest
            public static LoadFromStreamAsync ($stream: System.IO.Stream, $crc: number) : UnityEngine.AssetBundleCreateRequest
            public static LoadFromStreamAsync ($stream: System.IO.Stream) : UnityEngine.AssetBundleCreateRequest
            /** Synchronously loads an AssetBundle from a managed Stream.
            * @param stream The managed Stream object. Unity calls Read(), Seek() and the Length property on this object to load the AssetBundle data.
            * @param crc An optional CRC-32 checksum of the uncompressed content.
            * @param managedReadBufferSize You can use this to override the size of the read buffer Unity uses while loading data. The default size is 32KB.
            * @returns The loaded AssetBundle object or null when the object fails to load. 
            */
            public static LoadFromStream ($stream: System.IO.Stream, $crc: number, $managedReadBufferSize: number) : UnityEngine.AssetBundle
            public static LoadFromStream ($stream: System.IO.Stream, $crc: number) : UnityEngine.AssetBundle
            public static LoadFromStream ($stream: System.IO.Stream) : UnityEngine.AssetBundle
            /** Set the 16-bytes key for AssetBundle Decryption. Set NULL will remove the key from memory.
            */
            public static SetAssetBundleDecryptKey ($password: string) : void
            /** Check if an AssetBundle contains a specific object.
            */
            public Contains ($name: string) : boolean
            /** Loads asset with name of type T from the bundle.
            */
            public LoadAsset ($name: string) : UnityEngine.Object
            /** Loads asset with name of a given type from the bundle.
            */
            public LoadAsset ($name: string, $type: System.Type) : UnityEngine.Object
            /** Asynchronously loads asset with name of a given T from the bundle.
            */
            public LoadAssetAsync ($name: string) : UnityEngine.AssetBundleRequest
            /** Asynchronously loads asset with name of a given type from the bundle.
            */
            public LoadAssetAsync ($name: string, $type: System.Type) : UnityEngine.AssetBundleRequest
            /** Loads asset and sub assets with name of type T from the bundle.
            */
            public LoadAssetWithSubAssets ($name: string) : System.Array$1<UnityEngine.Object>
            /** Loads asset and sub assets with name of a given type from the bundle.
            */
            public LoadAssetWithSubAssets ($name: string, $type: System.Type) : System.Array$1<UnityEngine.Object>
            /** Loads asset with sub assets with name of type T from the bundle asynchronously.
            */
            public LoadAssetWithSubAssetsAsync ($name: string) : UnityEngine.AssetBundleRequest
            /** Loads asset with sub assets with name of a given type from the bundle asynchronously.
            */
            public LoadAssetWithSubAssetsAsync ($name: string, $type: System.Type) : UnityEngine.AssetBundleRequest
            public LoadAllAssets () : System.Array$1<UnityEngine.Object>
            /** Loads all assets contained in the asset bundle that inherit from type.
            */
            public LoadAllAssets ($type: System.Type) : System.Array$1<UnityEngine.Object>
            public LoadAllAssetsAsync () : UnityEngine.AssetBundleRequest
            /** Loads all assets contained in the asset bundle that inherit from type asynchronously.
            */
            public LoadAllAssetsAsync ($type: System.Type) : UnityEngine.AssetBundleRequest
            /** Unloads an AssetBundle freeing its data.
            * @param unloadAllLoadedObjects Determines whether the current instances of objects loaded from the AssetBundle will also be unloaded.
            */
            public Unload ($unloadAllLoadedObjects: boolean) : void
            /** Unloads assets in the bundle.
            * @returns Asynchronous unload request for an AssetBundle. 
            */
            public UnloadAsync ($unloadAllLoadedObjects: boolean) : UnityEngine.AsyncOperation
            public GetAllAssetNames () : System.Array$1<string>
            public GetAllScenePaths () : System.Array$1<string>
            /** Asynchronously recompress a downloaded/stored AssetBundle from one BuildCompression to another.
            * @param inputPath Path to the AssetBundle to recompress.
            * @param outputPath Path to the recompressed AssetBundle to be generated. Can be the same as inputPath.
            * @param method The compression method, level and blocksize to use during recompression. Only some BuildCompression types are supported (see note).
            * @param expectedCRC CRC of the AssetBundle to test against. Testing this requires additional file reading and computation. Pass in 0 to skip this check. Unity does not compute a CRC when the source and destination BuildCompression are the same, so no CRC verification takes place (see note).
            * @param priority The priority at which the recompression operation should run. This sets thread priority during the operation and does not effect the order in which operations are performed. Recompression operations run on a background worker thread.
            */
            public static RecompressAssetBundleAsync ($inputPath: string, $outputPath: string, $method: UnityEngine.BuildCompression, $expectedCRC?: number, $priority?: UnityEngine.ThreadPriority) : UnityEngine.AssetBundleRecompressOperation
        }
        /** Asynchronous create request for an AssetBundle.
        */
        class AssetBundleCreateRequest extends UnityEngine.AsyncOperation
        {
            protected [__keep_incompatibility]: never;
            /** Asset object being loaded (Read Only).
            */
            public get assetBundle(): UnityEngine.AssetBundle;
            public constructor ()
        }
        /** Asynchronous load request from the Resources bundle.
        */
        class ResourceRequest extends UnityEngine.AsyncOperation
        {
            protected [__keep_incompatibility]: never;
            /** Asset object being loaded (Read Only).
            */
            public get asset(): UnityEngine.Object;
            public constructor ()
        }
        /** Asynchronous load request from an AssetBundle.
        */
        class AssetBundleRequest extends UnityEngine.ResourceRequest
        {
            protected [__keep_incompatibility]: never;
            /** Asset object being loaded (Read Only).
            */
            public get asset(): UnityEngine.Object;
            /** Asset objects with sub assets being loaded. (Read Only)
            */
            public get allAssets(): System.Array$1<UnityEngine.Object>;
            public constructor ()
        }
        /** Asynchronous AssetBundle recompression from one compression method and level to another.
        */
        class AssetBundleRecompressOperation extends UnityEngine.AsyncOperation
        {
            protected [__keep_incompatibility]: never;
            /** A string describing the recompression operation result (Read Only).
            */
            public get humanReadableResult(): string;
            /** Path of the AssetBundle being recompressed (Read Only).
            */
            public get inputPath(): string;
            /** Path of the resulting recompressed AssetBundle (Read Only).
            */
            public get outputPath(): string;
            /** Result of the recompression operation.
            */
            public get result(): UnityEngine.AssetBundleLoadResult;
            /** True if the recompress operation is complete and was successful, otherwise false (Read Only).
            */
            public get success(): boolean;
            public constructor ()
        }
        /** Contains information about compression methods, compression levels and block sizes that are supported by Asset Bundle compression at build time and recompression at runtime.
        */
        class BuildCompression extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Uncompressed Asset Bundle.
            */
            public static Uncompressed : UnityEngine.BuildCompression
            /** LZ4HC "Chunk Based" Compression.
            */
            public static LZ4 : UnityEngine.BuildCompression
            /** LZMA Compression.
            */
            public static LZMA : UnityEngine.BuildCompression
            /** Uncompressed Asset Bundle.
            */
            public static UncompressedRuntime : UnityEngine.BuildCompression
            /** LZ4 Compression for runtime recompression.
            */
            public static LZ4Runtime : UnityEngine.BuildCompression
            public get compression(): UnityEngine.CompressionType;
            public get level(): UnityEngine.CompressionLevel;
            public get blockSize(): number;
            /** Enable asset bundle protection.
            */
            public get enableProtect(): boolean;
        }
        /** Priority of a thread.
        */
        enum ThreadPriority
        { Low = 0, BelowNormal = 1, Normal = 2, High = 4 }
        /** Manifest for all the AssetBundles in the build.
        */
        class AssetBundleManifest extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            public GetAllAssetBundles () : System.Array$1<string>
            public GetAllAssetBundlesWithVariant () : System.Array$1<string>
            /** Get the hash for the given AssetBundle.
            * @param assetBundleName Name of the asset bundle.
            * @returns The 128-bit hash for the asset bundle. 
            */
            public GetAssetBundleHash ($assetBundleName: string) : UnityEngine.Hash128
            /** Get the direct dependent AssetBundles for the given AssetBundle.
            * @param assetBundleName Name of the asset bundle.
            * @returns Array of asset bundle names this asset bundle depends on. 
            */
            public GetDirectDependencies ($assetBundleName: string) : System.Array$1<string>
            /** Get all the dependent AssetBundles for the given AssetBundle.
            * @param assetBundleName Name of the asset bundle.
            */
            public GetAllDependencies ($assetBundleName: string) : System.Array$1<string>
        }
        /** Represents  a 128-bit hash value.
        */
        class Hash128 extends System.ValueType implements System.IComparable, System.IComparable$1<UnityEngine.Hash128>, System.IEquatable$1<UnityEngine.Hash128>
        {
            protected [__keep_incompatibility]: never;
            /** Returns true is the hash value is valid. (Read Only)
            */
            public get isValid(): boolean;
            public CompareTo ($rhs: UnityEngine.Hash128) : number
            /** Convert a hex-encoded string into Hash128 value.
            * @param hashString A hexadecimal-encoded hash string.
            * @returns The 128-bit hash. 
            */
            public static Parse ($hashString: string) : UnityEngine.Hash128
            /** Compute a hash of input data string.
            * @param data Input data string. Note that Unity interprets the string as UTF-8 data, even if internally in C# strings are UTF-16.
            * @returns The 128-bit hash. 
            */
            public static Compute ($data: string) : UnityEngine.Hash128
            /** Compute a hash of input data.
            * @param val Input value.
            * @returns The 128-bit hash. 
            */
            public static Compute ($val: number) : UnityEngine.Hash128
            /** Hash new input string and combine with the current hash value.
            * @param data Input data string. Note that Unity interprets the string as UTF-8 data, even if internally in C# strings are UTF-16.
            */
            public Append ($data: string) : void
            /** Hash new input data and combine with the current hash value.
            * @param val Input value.
            */
            public Append ($val: number) : void
            public Equals ($obj: any) : boolean
            public Equals ($obj: UnityEngine.Hash128) : boolean
            public CompareTo ($obj: any) : number
            public static op_Equality ($hash1: UnityEngine.Hash128, $hash2: UnityEngine.Hash128) : boolean
            public static op_Inequality ($hash1: UnityEngine.Hash128, $hash2: UnityEngine.Hash128) : boolean
            public static op_LessThan ($x: UnityEngine.Hash128, $y: UnityEngine.Hash128) : boolean
            public static op_GreaterThan ($x: UnityEngine.Hash128, $y: UnityEngine.Hash128) : boolean
            public constructor ($u32_0: number, $u32_1: number, $u32_2: number, $u32_3: number)
            public constructor ($u64_0: bigint, $u64_1: bigint)
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** Compression Method for Asset Bundles.
        */
        enum CompressionType
        { None = 0, Lzma = 1, Lz4 = 2, Lz4HC = 3 }
        /** Compression Levels relate to how much time should be spent compressing Assets into an Asset Bundle.
        */
        enum CompressionLevel
        { None = 0, Fastest = 1, Fast = 2, Normal = 3, High = 4, Maximum = 5 }
        /** Controls the global audio settings from script.
        */
        class AudioSettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns the speaker mode capability of the current audio driver. (Read Only)
            */
            public static get driverCapabilities(): UnityEngine.AudioSpeakerMode;
            /** AudioSettings.speakerMode is deprecated. Use AudioSettings.GetConfiguration and AudioSettings.Reset to adjust audio settings instead.
            */
            public static get speakerMode(): UnityEngine.AudioSpeakerMode;
            public static set speakerMode(value: UnityEngine.AudioSpeakerMode);
            /** Returns the current time of the audio system.
            */
            public static get dspTime(): number;
            /** Get the mixer's current output rate.
            */
            public static get outputSampleRate(): number;
            public static set outputSampleRate(value: number);
            /** Get the mixer's buffer size in samples.
            * @param bufferLength Is the length of each buffer in the ringbuffer.
            * @param numBuffers Is number of buffers.
            */
            public static GetDSPBufferSize ($bufferLength: $Ref<number>, $numBuffers: $Ref<number>) : void
            public static GetSpatializerPluginName () : string
            public static GetConfiguration () : UnityEngine.AudioConfiguration
            /** Performs a change of the device configuration. In response to this the AudioSettings.OnAudioConfigurationChanged delegate is invoked with the argument deviceWasChanged=false. It cannot be guaranteed that the exact settings specified can be used, but an attempt is made to use the closest match supported by the system.
            * @param config The new configuration to be used.
            * @returns True if all settings could be successfully applied. 
            */
            public static Reset ($config: UnityEngine.AudioConfiguration) : boolean
            public static add_OnAudioConfigurationChanged ($value: UnityEngine.AudioSettings.AudioConfigurationChangeHandler) : void
            public static remove_OnAudioConfigurationChanged ($value: UnityEngine.AudioSettings.AudioConfigurationChangeHandler) : void
            public constructor ()
        }
        /** These are speaker types defined for use with AudioSettings.speakerMode.
        */
        enum AudioSpeakerMode
        { Raw = 0, Mono = 1, Stereo = 2, Quad = 3, Surround = 4, Mode5point1 = 5, Mode7point1 = 6, Prologic = 7 }
        /** Specifies the current properties or desired properties to be set for the audio system.
        */
        class AudioConfiguration extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The current speaker mode used by the audio output device.
            */
            public speakerMode : UnityEngine.AudioSpeakerMode
            /** The length of the DSP buffer in samples determining the latency of sounds by the audio output device.
            */
            public dspBufferSize : number
            /** The current sample rate of the audio output device used.
            */
            public sampleRate : number
            /** The current maximum number of simultaneously audible sounds in the game.
            */
            public numRealVoices : number
            /** The  maximum number of managed sounds in the game. Beyond this limit sounds will simply stop playing.
            */
            public numVirtualVoices : number
        }
        /** The Audio Low Pass Filter passes low frequencies of an AudioSource or all sounds reaching an AudioListener, while removing frequencies higher than the Cutoff Frequency.
        */
        class AudioLowPassFilter extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Returns or sets the current custom frequency cutoff curve.
            */
            public get customCutoffCurve(): UnityEngine.AnimationCurve;
            public set customCutoffCurve(value: UnityEngine.AnimationCurve);
            /** Lowpass cutoff frequency in hz. 10.0 to 22000.0. Default = 5000.0.
            */
            public get cutoffFrequency(): number;
            public set cutoffFrequency(value: number);
            /** Determines how much the filter's self-resonance is dampened.
            */
            public get lowpassResonanceQ(): number;
            public set lowpassResonanceQ(value: number);
            public constructor ()
        }
        /** The Audio High Pass Filter passes high frequencies of an AudioSource, and cuts off signals with frequencies lower than the Cutoff Frequency.
        */
        class AudioHighPassFilter extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Highpass cutoff frequency in hz. 10.0 to 22000.0. Default = 5000.0.
            */
            public get cutoffFrequency(): number;
            public set cutoffFrequency(value: number);
            /** Determines how much the filter's self-resonance isdampened.
            */
            public get highpassResonanceQ(): number;
            public set highpassResonanceQ(value: number);
            public constructor ()
        }
        /** The Audio Reverb Filter takes an Audio Clip and distorts it to create a custom reverb effect.
        */
        class AudioReverbFilter extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Set/Get reverb preset properties.
            */
            public get reverbPreset(): UnityEngine.AudioReverbPreset;
            public set reverbPreset(value: UnityEngine.AudioReverbPreset);
            /** Mix level of dry signal in output in millibels (mB). Ranges from -10000.0 to 0.0. Default is 0.
            */
            public get dryLevel(): number;
            public set dryLevel(value: number);
            /** Room effect level at low frequencies in millibels (mB). Ranges from -10000.0 to 0.0. Default is 0.0.
            */
            public get room(): number;
            public set room(value: number);
            /** Room effect high-frequency level re. low frequency level in millibels (mB). Ranges from -10000.0 to 0.0. Default is 0.0.
            */
            public get roomHF(): number;
            public set roomHF(value: number);
            /** Reverberation decay time at low-frequencies in seconds. Ranges from 0.1 to 20.0. Default is 1.0.
            */
            public get decayTime(): number;
            public set decayTime(value: number);
            /** Decay HF Ratio : High-frequency to low-frequency decay time ratio. Ranges from 0.1 to 2.0. Default is 0.5.
            */
            public get decayHFRatio(): number;
            public set decayHFRatio(value: number);
            /** Early reflections level relative to room effect in millibels (mB). Ranges from -10000.0 to 1000.0. Default is -10000.0.
            */
            public get reflectionsLevel(): number;
            public set reflectionsLevel(value: number);
            /** Late reverberation level relative to room effect in millibels (mB). Ranges from -10000.0 to 2000.0. Default is 0.0.
            */
            public get reflectionsDelay(): number;
            public set reflectionsDelay(value: number);
            /** Late reverberation level relative to room effect in millibels (mB). Ranges from -10000.0 to 2000.0. Default is 0.0.
            */
            public get reverbLevel(): number;
            public set reverbLevel(value: number);
            /** Late reverberation delay time relative to first reflection in seconds. Ranges from 0.0 to 0.1. Default is 0.04.
            */
            public get reverbDelay(): number;
            public set reverbDelay(value: number);
            /** Reverberation diffusion (echo density) in percent. Ranges from 0.0 to 100.0. Default is 100.0.
            */
            public get diffusion(): number;
            public set diffusion(value: number);
            /** Reverberation density (modal density) in percent. Ranges from 0.0 to 100.0. Default is 100.0.
            */
            public get density(): number;
            public set density(value: number);
            /** Reference high frequency in hertz (Hz). Ranges from 1000.0 to 20000.0. Default is 5000.0.
            */
            public get hfReference(): number;
            public set hfReference(value: number);
            /** Room effect low-frequency level in millibels (mB). Ranges from -10000.0 to 0.0. Default is 0.0.
            */
            public get roomLF(): number;
            public set roomLF(value: number);
            /** Reference low-frequency in hertz (Hz). Ranges from 20.0 to 1000.0. Default is 250.0.
            */
            public get lfReference(): number;
            public set lfReference(value: number);
            public constructor ()
        }
        /** Reverb presets used by the Reverb Zone class and the audio reverb filter.
        */
        enum AudioReverbPreset
        { Off = 0, Generic = 1, PaddedCell = 2, Room = 3, Bathroom = 4, Livingroom = 5, Stoneroom = 6, Auditorium = 7, Concerthall = 8, Cave = 9, Arena = 10, Hangar = 11, CarpetedHallway = 12, Hallway = 13, StoneCorridor = 14, Alley = 15, Forest = 16, City = 17, Mountains = 18, Quarry = 19, Plain = 20, ParkingLot = 21, SewerPipe = 22, Underwater = 23, Drugged = 24, Dizzy = 25, Psychotic = 26, User = 27 }
        /** Value describing the current load state of the audio data associated with an AudioClip.
        */
        enum AudioDataLoadState
        { Unloaded = 0, Loading = 1, Loaded = 2, Failed = 3 }
        /** An enum containing different compression types.
        */
        enum AudioCompressionFormat
        { PCM = 0, Vorbis = 1, ADPCM = 2, MP3 = 3, VAG = 4, HEVAG = 5, XMA = 6, AAC = 7, GCADPCM = 8, ATRAC9 = 9 }
        /** Determines how the audio clip is loaded in.
        */
        enum AudioClipLoadType
        { DecompressOnLoad = 0, CompressedInMemory = 1, Streaming = 2 }
        /** Describes when an AudioSource or AudioListener is updated.
        */
        enum AudioVelocityUpdateMode
        { Auto = 0, Fixed = 1, Dynamic = 2 }
        /** Spectrum analysis windowing types.
        */
        enum FFTWindow
        { Rectangular = 0, Triangle = 1, Hamming = 2, Hanning = 3, Blackman = 4, BlackmanHarris = 5 }
        /** Rolloff modes that a 3D sound can have in an audio source.
        */
        enum AudioRolloffMode
        { Logarithmic = 0, Linear = 1, Custom = 2 }
        /** This defines the curve type of the different custom curves that can be queried and set within the AudioSource.
        */
        enum AudioSourceCurveType
        { CustomRolloff = 0, SpatialBlend = 1, ReverbZoneMix = 2, Spread = 3 }
        /** Gamepad audio output types.
        */
        enum GamepadSpeakerOutputType
        { Speaker = 0, Vibration = 1, SecondaryVibration = 2 }
        /** A container for audio data.
        */
        class AudioClip extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The length of the audio clip in seconds. (Read Only)
            */
            public get length(): number;
            /** The length of the audio clip in samples. (Read Only)
            */
            public get samples(): number;
            /** The number of channels in the audio clip. (Read Only)
            */
            public get channels(): number;
            /** The sample frequency of the clip in Hertz. (Read Only)
            */
            public get frequency(): number;
            /** The load type of the clip (read-only).
            */
            public get loadType(): UnityEngine.AudioClipLoadType;
            /** Preloads audio data of the clip when the clip asset is loaded. When this flag is off, scripts have to call AudioClip.LoadAudioData() to load the data before the clip can be played. Properties like length, channels and format are available before the audio data has been loaded.
            */
            public get preloadAudioData(): boolean;
            /** Returns true if this audio clip is ambisonic (read-only).
            */
            public get ambisonic(): boolean;
            /** Corresponding to the "Load In Background" flag in the inspector, when this flag is set, the loading will happen delayed without blocking the main thread.
            */
            public get loadInBackground(): boolean;
            /** Returns the current load state of the audio data associated with an AudioClip.
            */
            public get loadState(): UnityEngine.AudioDataLoadState;
            public LoadAudioData () : boolean
            public UnloadAudioData () : boolean
            /** Fills an array with sample data from the clip.
            */
            public GetData ($data: System.Array$1<number>, $offsetSamples: number) : boolean
            /** Set sample data in a clip.
            */
            public SetData ($data: System.Array$1<number>, $offsetSamples: number) : boolean
            /** Creates a user AudioClip with a name and with the given length in samples, channels and frequency.
            * @param name Name of clip.
            * @param lengthSamples Number of sample frames.
            * @param channels Number of channels per frame.
            * @param frequency Sample frequency of clip.
            * @param _3D Audio clip is played back in 3D.
            * @param stream True if clip is streamed, that is if the pcmreadercallback generates data on the fly.
            * @param pcmreadercallback This callback is invoked to generate a block of sample data. Non-streamed clips call this only once at creation time while streamed clips call this continuously.
            * @param pcmsetpositioncallback This callback is invoked whenever the clip loops or changes playback position.
            * @returns A reference to the created AudioClip. 
            */
            public static Create ($name: string, $lengthSamples: number, $channels: number, $frequency: number, $stream: boolean) : UnityEngine.AudioClip
            public static Create ($name: string, $lengthSamples: number, $channels: number, $frequency: number, $stream: boolean, $pcmreadercallback: UnityEngine.AudioClip.PCMReaderCallback) : UnityEngine.AudioClip
            public static Create ($name: string, $lengthSamples: number, $channels: number, $frequency: number, $stream: boolean, $pcmreadercallback: UnityEngine.AudioClip.PCMReaderCallback, $pcmsetpositioncallback: UnityEngine.AudioClip.PCMSetPositionCallback) : UnityEngine.AudioClip
        }
        class AudioBehaviour extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Representation of a listener in 3D space.
        */
        class AudioListener extends UnityEngine.AudioBehaviour
        {
            protected [__keep_incompatibility]: never;
            /** Controls the game sound volume (0.0 to 1.0).
            */
            public static get volume(): number;
            public static set volume(value: number);
            /** The paused state of the audio system.
            */
            public static get pause(): boolean;
            public static set pause(value: boolean);
            /** This lets you set whether the Audio Listener should be updated in the fixed or dynamic update.
            */
            public get velocityUpdateMode(): UnityEngine.AudioVelocityUpdateMode;
            public set velocityUpdateMode(value: UnityEngine.AudioVelocityUpdateMode);
            /** Provides a block of the listener (master)'s output data.
            * @param samples The array to populate with audio samples. Its length must be a power of 2.
            * @param channel The channel to sample from.
            */
            public static GetOutputData ($samples: System.Array$1<number>, $channel: number) : void
            /** Provides a block of the listener (master)'s spectrum data.
            * @param samples The array to populate with audio samples. Its length must be a power of 2.
            * @param channel The channel to sample from.
            * @param window The FFTWindow type to use when sampling.
            */
            public static GetSpectrumData ($samples: System.Array$1<number>, $channel: number, $window: UnityEngine.FFTWindow) : void
            public constructor ()
        }
        /** Reverb Zones are used when you want to create location based ambient effects in the Scene.
        */
        class AudioReverbZone extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The distance from the centerpoint that the reverb will have full effect at. Default = 10.0.
            */
            public get minDistance(): number;
            public set minDistance(value: number);
            /** The distance from the centerpoint that the reverb will not have any effect. Default = 15.0.
            */
            public get maxDistance(): number;
            public set maxDistance(value: number);
            /** Set/Get reverb preset properties.
            */
            public get reverbPreset(): UnityEngine.AudioReverbPreset;
            public set reverbPreset(value: UnityEngine.AudioReverbPreset);
            /** Room effect level (at mid frequencies).
            */
            public get room(): number;
            public set room(value: number);
            /** Relative room effect level at high frequencies.
            */
            public get roomHF(): number;
            public set roomHF(value: number);
            /** Relative room effect level at low frequencies.
            */
            public get roomLF(): number;
            public set roomLF(value: number);
            /** Reverberation decay time at mid frequencies.
            */
            public get decayTime(): number;
            public set decayTime(value: number);
            /** High-frequency to mid-frequency decay time ratio.
            */
            public get decayHFRatio(): number;
            public set decayHFRatio(value: number);
            /** Early reflections level relative to room effect.
            */
            public get reflections(): number;
            public set reflections(value: number);
            /** Initial reflection delay time.
            */
            public get reflectionsDelay(): number;
            public set reflectionsDelay(value: number);
            /** Late reverberation level relative to room effect.
            */
            public get reverb(): number;
            public set reverb(value: number);
            /** Late reverberation delay time relative to initial reflection.
            */
            public get reverbDelay(): number;
            public set reverbDelay(value: number);
            /** Reference high frequency (hz).
            */
            public get HFReference(): number;
            public set HFReference(value: number);
            /** Reference low frequency (hz).
            */
            public get LFReference(): number;
            public set LFReference(value: number);
            /** Value that controls the echo density in the late reverberation decay.
            */
            public get diffusion(): number;
            public set diffusion(value: number);
            /** Value that controls the modal density in the late reverberation decay.
            */
            public get density(): number;
            public set density(value: number);
            public constructor ()
        }
        /** The Audio Distortion Filter distorts the sound from an AudioSource or sounds reaching the AudioListener.
        */
        class AudioDistortionFilter extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Distortion value. 0.0 to 1.0. Default = 0.5.
            */
            public get distortionLevel(): number;
            public set distortionLevel(value: number);
            public constructor ()
        }
        /** The Audio Echo Filter repeats a sound after a given Delay, attenuating the repetitions based on the Decay Ratio.
        */
        class AudioEchoFilter extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Echo delay in ms. 10 to 5000. Default = 500.
            */
            public get delay(): number;
            public set delay(value: number);
            /** Echo decay per delay. 0 to 1. 1.0 = No decay, 0.0 = total decay (i.e. simple 1 line delay). Default = 0.5.
            */
            public get decayRatio(): number;
            public set decayRatio(value: number);
            /** Volume of original signal to pass to output. 0.0 to 1.0. Default = 1.0.
            */
            public get dryMix(): number;
            public set dryMix(value: number);
            /** Volume of echo signal to pass to output. 0.0 to 1.0. Default = 1.0.
            */
            public get wetMix(): number;
            public set wetMix(value: number);
            public constructor ()
        }
        /** The Audio Chorus Filter takes an Audio Clip and processes it creating a chorus effect.
        */
        class AudioChorusFilter extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Volume of original signal to pass to output. 0.0 to 1.0. Default = 0.5.
            */
            public get dryMix(): number;
            public set dryMix(value: number);
            /** Volume of 1st chorus tap. 0.0 to 1.0. Default = 0.5.
            */
            public get wetMix1(): number;
            public set wetMix1(value: number);
            /** Volume of 2nd chorus tap. This tap is 90 degrees out of phase of the first tap. 0.0 to 1.0. Default = 0.5.
            */
            public get wetMix2(): number;
            public set wetMix2(value: number);
            /** Volume of 3rd chorus tap. This tap is 90 degrees out of phase of the second tap. 0.0 to 1.0. Default = 0.5.
            */
            public get wetMix3(): number;
            public set wetMix3(value: number);
            /** Chorus delay in ms. 0.1 to 100.0. Default = 40.0 ms.
            */
            public get delay(): number;
            public set delay(value: number);
            /** Chorus modulation rate in hz. 0.0 to 20.0. Default = 0.8 hz.
            */
            public get rate(): number;
            public set rate(value: number);
            /** Chorus modulation depth. 0.0 to 1.0. Default = 0.03.
            */
            public get depth(): number;
            public set depth(value: number);
            public constructor ()
        }
        /** Use this class to record to an AudioClip using a connected microphone.
        */
        class Microphone extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** A list of available microphone devices, identified by name.
            */
            public static get devices(): System.Array$1<string>;
            /** Start Recording with device.
            * @param deviceName The name of the device.
            * @param loop Indicates whether the recording should continue recording if lengthSec is reached, and wrap around and record from the beginning of the AudioClip.
            * @param lengthSec Is the length of the AudioClip produced by the recording.
            * @param frequency The sample rate of the AudioClip produced by the recording.
            * @returns The function returns null if the recording fails to start. 
            */
            public static Start ($deviceName: string, $loop: boolean, $lengthSec: number, $frequency: number) : UnityEngine.AudioClip
            /** Stops recording.
            * @param deviceName The name of the device.
            */
            public static End ($deviceName: string) : void
            /** Query if a device is currently recording.
            * @param deviceName The name of the device.
            */
            public static IsRecording ($deviceName: string) : boolean
            /** Get the position in samples of the recording.
            * @param deviceName The name of the device.
            */
            public static GetPosition ($deviceName: string) : number
            /** Get the frequency capabilities of a device.
            * @param deviceName The name of the device.
            * @param minFreq Returns the minimum sampling frequency of the device.
            * @param maxFreq Returns the maximum sampling frequency of the device.
            */
            public static GetDeviceCaps ($deviceName: string, $minFreq: $Ref<number>, $maxFreq: $Ref<number>) : void
            public constructor ()
        }
        /** Allow recording the main output of the game or specific groups in the AudioMixer.
        */
        class AudioRenderer extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Start () : boolean
            public static Stop () : boolean
            public static GetSampleCountForCaptureFrame () : number
            public static Render ($buffer: Unity.Collections.NativeArray$1<number>) : boolean
            public constructor ()
        }
        enum WebCamFlags
        { FrontFacing = 1, AutoFocusPointSupported = 2 }
        /** Enum representing the different types of web camera device.
        */
        enum WebCamKind
        { WideAngle = 1, Telephoto = 2, ColorAndDepth = 3, UltraWideAngle = 4 }
        /** A structure describing the webcam device.
        */
        class WebCamDevice extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** A human-readable name of the device. Varies across different systems.
            */
            public get name(): string;
            /** True if camera faces the same direction a screen does, false otherwise.
            */
            public get isFrontFacing(): boolean;
            /** Property of type WebCamKind denoting the kind of webcam device.
            */
            public get kind(): UnityEngine.WebCamKind;
            /** A string identifier used to create a depth data based WebCamTexture.
            */
            public get depthCameraName(): string;
            /** Returns true if the camera supports automatic focusing on points of interest and false otherwise.
            */
            public get isAutoFocusPointSupported(): boolean;
            /** Possible WebCamTexture resolutions for this device.
            */
            public get availableResolutions(): System.Array$1<UnityEngine.Resolution>;
        }
        /** Represents a display resolution.
        */
        class Resolution extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Resolution width in pixels.
            */
            public get width(): number;
            public set width(value: number);
            /** Resolution height in pixels.
            */
            public get height(): number;
            public set height(value: number);
            /** Resolution's vertical refresh rate in Hz.
            */
            public get refreshRate(): number;
            public set refreshRate(value: number);
        }
        /** Base class for Texture handling.
        */
        class Texture extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
            */
            public static GenerateAllMips : number
            public static get masterTextureLimit(): number;
            public static set masterTextureLimit(value: number);
            /** How many mipmap levels are in this Texture (Read Only).
            */
            public get mipmapCount(): number;
            public static get anisotropicFiltering(): UnityEngine.AnisotropicFiltering;
            public static set anisotropicFiltering(value: UnityEngine.AnisotropicFiltering);
            /** Returns the GraphicsFormat format or color format of a Texture object.
            */
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            /** Width of the Texture in pixels (Read Only).
            */
            public get width(): number;
            public set width(value: number);
            /** Height of the Texture in pixels (Read Only).
            */
            public get height(): number;
            public set height(value: number);
            /** Dimensionality (type) of the Texture (Read Only).
            */
            public get dimension(): UnityEngine.Rendering.TextureDimension;
            public set dimension(value: UnityEngine.Rendering.TextureDimension);
            /** Whether Unity stores an additional copy of this texture's pixel data in CPU-addressable memory.
            */
            public get isReadable(): boolean;
            /** Texture coordinate wrapping mode.
            */
            public get wrapMode(): UnityEngine.TextureWrapMode;
            public set wrapMode(value: UnityEngine.TextureWrapMode);
            /** Texture U coordinate wrapping mode.
            */
            public get wrapModeU(): UnityEngine.TextureWrapMode;
            public set wrapModeU(value: UnityEngine.TextureWrapMode);
            /** Texture V coordinate wrapping mode.
            */
            public get wrapModeV(): UnityEngine.TextureWrapMode;
            public set wrapModeV(value: UnityEngine.TextureWrapMode);
            /** Texture W coordinate wrapping mode for Texture3D.
            */
            public get wrapModeW(): UnityEngine.TextureWrapMode;
            public set wrapModeW(value: UnityEngine.TextureWrapMode);
            /** Filtering mode of the Texture.
            */
            public get filterMode(): UnityEngine.FilterMode;
            public set filterMode(value: UnityEngine.FilterMode);
            /** Defines the anisotropic filtering level of the Texture.
            */
            public get anisoLevel(): number;
            public set anisoLevel(value: number);
            /** The mipmap bias of the Texture.
            */
            public get mipMapBias(): number;
            public set mipMapBias(value: number);
            public get texelSize(): UnityEngine.Vector2;
            /** This counter is incremented when the Texture is updated.
            */
            public get updateCount(): number;
            /** Returns true if the texture pixel data is in sRGB color space (Read Only).
            */
            public get isDataSRGB(): boolean;
            /** The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0. 
            This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually. 
            To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`. 
            `totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
            */
            public static get totalTextureMemory(): bigint;
            /** The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The desiredTextureMemory value takes into account the mipmap levels that Unity has requested or that you have set manually.
            For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the desiredTextureMemory value to match the total memory needed.
            The desiredTextureMemory value can be greater than the Texture.targetTextureMemory value.
            */
            public static get desiredTextureMemory(): bigint;
            /** The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
            */
            public static get targetTextureMemory(): bigint;
            /** The amount of memory that all Textures in the scene use.
            */
            public static get currentTextureMemory(): bigint;
            /** The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
            */
            public static get nonStreamingTextureMemory(): bigint;
            /** How many times has a Texture been uploaded due to Texture mipmap streaming.
            */
            public static get streamingMipmapUploadCount(): bigint;
            /** Number of renderers registered with the Texture streaming system.
            */
            public static get streamingRendererCount(): bigint;
            /** Number of streaming Textures.
            */
            public static get streamingTextureCount(): bigint;
            /** The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
            */
            public static get nonStreamingTextureCount(): bigint;
            /** Number of streaming Textures with outstanding mipmaps to be loaded.
            */
            public static get streamingTexturePendingLoadCount(): bigint;
            /** Number of streaming Textures with mipmaps currently loading.
            */
            public static get streamingTextureLoadingCount(): bigint;
            /** Force streaming Textures to load all mipmap levels.
            */
            public static get streamingTextureForceLoadAll(): boolean;
            public static set streamingTextureForceLoadAll(value: boolean);
            /** This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
            */
            public static get streamingTextureDiscardUnusedMips(): boolean;
            public static set streamingTextureDiscardUnusedMips(value: boolean);
            /** Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
            */
            public static get allowThreadedTextureCreation(): boolean;
            public static set allowThreadedTextureCreation(value: boolean);
            /** Sets Anisotropic limits.
            */
            public static SetGlobalAnisotropicFilteringLimits ($forcedMin: number, $globalMax: number) : void
            public GetNativeTexturePtr () : System.IntPtr
            public IncrementUpdateCount () : void
            public static SetStreamingTextureMaterialDebugProperties () : void
        }
        /** WebCam Textures are textures onto which the live video input is rendered.
        */
        class WebCamTexture extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** Return a list of available devices.
            */
            public static get devices(): System.Array$1<UnityEngine.WebCamDevice>;
            /** Returns if the camera is currently playing.
            */
            public get isPlaying(): boolean;
            /** Set this to specify the name of the device to use.
            */
            public get deviceName(): string;
            public set deviceName(value: string);
            /** Set the requested frame rate of the camera device (in frames per second).
            */
            public get requestedFPS(): number;
            public set requestedFPS(value: number);
            /** Set the requested width of the camera device.
            */
            public get requestedWidth(): number;
            public set requestedWidth(value: number);
            /** Set the requested height of the camera device.
            */
            public get requestedHeight(): number;
            public set requestedHeight(value: number);
            /** Returns an clockwise angle (in degrees), which can be used to rotate a polygon so camera contents are shown in correct orientation.
            */
            public get videoRotationAngle(): number;
            /** Returns if the texture image is vertically flipped.
            */
            public get videoVerticallyMirrored(): boolean;
            /** Did the video buffer update this frame?
            */
            public get didUpdateThisFrame(): boolean;
            /** This property allows you to set/get the auto focus point of the camera. This works only on Android and iOS devices.
            */
            public get autoFocusPoint(): UnityEngine.Vector2 | null;
            public set autoFocusPoint(value: UnityEngine.Vector2 | null);
            /** This property is true if the texture is based on depth data.
            */
            public get isDepth(): boolean;
            public Play () : void
            public Pause () : void
            public Stop () : void
            /** Gets the pixel color at coordinates (x, y).
            * @param x The x coordinate of the pixel to get. The range is 0 through the (texture width - 1).
            * @param y The y coordinate of the pixel to get. The range is 0 through the (texture height - 1).
            * @returns The pixel color. 
            */
            public GetPixel ($x: number, $y: number) : UnityEngine.Color
            public GetPixels () : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for part of the texture as Color structs.
            * @param x The starting x position of the section to fetch.
            * @param y The starting y position of the section to fetch.
            * @param blockWidth The width of the section to fetch.
            * @param blockHeight The height of the section to fetch.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($x: number, $y: number, $blockWidth: number, $blockHeight: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level as Color32 structs.
            * @param colors An optional array to write the pixel data to.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 () : System.Array$1<UnityEngine.Color32>
            /** Gets the pixel color data for a mipmap level as Color32 structs.
            * @param colors An optional array to write the pixel data to.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($colors: System.Array$1<UnityEngine.Color32>) : System.Array$1<UnityEngine.Color32>
            public constructor ($deviceName: string, $requestedWidth: number, $requestedHeight: number, $requestedFPS: number)
            public constructor ($deviceName: string, $requestedWidth: number, $requestedHeight: number)
            public constructor ($deviceName: string)
            public constructor ($requestedWidth: number, $requestedHeight: number, $requestedFPS: number)
            public constructor ($requestedWidth: number, $requestedHeight: number)
            public constructor ()
        }
        /** A pair of SphereColliders used to define shapes for Cloth objects to collide against.
        */
        class ClothSphereColliderPair extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The first SphereCollider of a ClothSphereColliderPair.
            */
            public get first(): UnityEngine.SphereCollider;
            public set first(value: UnityEngine.SphereCollider);
            /** The second SphereCollider of a ClothSphereColliderPair.
            */
            public get second(): UnityEngine.SphereCollider;
            public set second(value: UnityEngine.SphereCollider);
            public constructor ($a: UnityEngine.SphereCollider)
            public constructor ($a: UnityEngine.SphereCollider, $b: UnityEngine.SphereCollider)
            public constructor ()
        }
        /** A base class of all colliders.
        */
        class Collider extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Enabled Colliders will collide with other Colliders, disabled Colliders won't.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** The rigidbody the collider is attached to.
            */
            public get attachedRigidbody(): UnityEngine.Rigidbody;
            /** The articulation body the collider is attached to.
            */
            public get attachedArticulationBody(): UnityEngine.ArticulationBody;
            /** Specify if this collider is configured as a trigger.
            */
            public get isTrigger(): boolean;
            public set isTrigger(value: boolean);
            /** Contact offset value of this collider.
            */
            public get contactOffset(): number;
            public set contactOffset(value: number);
            /** The world space bounding volume of the collider (Read Only).
            */
            public get bounds(): UnityEngine.Bounds;
            /** Specify whether this Collider's contacts are modifiable or not.
            */
            public get hasModifiableContacts(): boolean;
            public set hasModifiableContacts(value: boolean);
            /** The shared physic material of this collider.
            */
            public get sharedMaterial(): UnityEngine.PhysicMaterial;
            public set sharedMaterial(value: UnityEngine.PhysicMaterial);
            /** The material used by the collider.
            */
            public get material(): UnityEngine.PhysicMaterial;
            public set material(value: UnityEngine.PhysicMaterial);
            /** Returns a point on the collider that is closest to a given location.
            * @param position Location you want to find the closest point to.
            * @returns The point on the collider that is closest to the specified location. 
            */
            public ClosestPoint ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Casts a Ray that ignores all Colliders except this one.
            * @param ray The starting point and direction of the ray.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit.
            * @param maxDistance The max length of the ray.
            * @returns True when the ray intersects the collider, otherwise false. 
            */
            public Raycast ($ray: UnityEngine.Ray, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number) : boolean
            /** The closest point to the bounding box of the attached collider.
            */
            public ClosestPointOnBounds ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            public constructor ()
        }
        /** A sphere-shaped primitive collider.
        */
        class SphereCollider extends UnityEngine.Collider
        {
            protected [__keep_incompatibility]: never;
            /** The center of the sphere in the object's local space.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** The radius of the sphere measured in the object's local space.
            */
            public get radius(): number;
            public set radius(value: number);
            public constructor ()
        }
        /** The ClothSkinningCoefficient struct is used to set up how a Cloth component is allowed to move with respect to the SkinnedMeshRenderer it is attached to.
        */
        class ClothSkinningCoefficient extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Distance a vertex is allowed to travel from the skinned mesh vertex position.
            */
            public maxDistance : number
            /** Definition of a sphere a vertex is not allowed to enter. This allows collision against the animated cloth.
            */
            public collisionSphereDistance : number
        }
        /** The Cloth class provides an interface to cloth simulation physics.
        */
        class Cloth extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** The current vertex positions of the cloth object.
            */
            public get vertices(): System.Array$1<UnityEngine.Vector3>;
            /** The current normals of the cloth object.
            */
            public get normals(): System.Array$1<UnityEngine.Vector3>;
            /** The cloth skinning coefficients used to set up how the cloth interacts with the skinned mesh.
            */
            public get coefficients(): System.Array$1<UnityEngine.ClothSkinningCoefficient>;
            public set coefficients(value: System.Array$1<UnityEngine.ClothSkinningCoefficient>);
            /** An array of CapsuleColliders which this Cloth instance should collide with.
            */
            public get capsuleColliders(): System.Array$1<UnityEngine.CapsuleCollider>;
            public set capsuleColliders(value: System.Array$1<UnityEngine.CapsuleCollider>);
            /** An array of ClothSphereColliderPairs which this Cloth instance should collide with.
            */
            public get sphereColliders(): System.Array$1<UnityEngine.ClothSphereColliderPair>;
            public set sphereColliders(value: System.Array$1<UnityEngine.ClothSphereColliderPair>);
            /** Cloth's sleep threshold.
            */
            public get sleepThreshold(): number;
            public set sleepThreshold(value: number);
            /** Bending stiffness of the cloth.
            */
            public get bendingStiffness(): number;
            public set bendingStiffness(value: number);
            /** Stretching stiffness of the cloth.
            */
            public get stretchingStiffness(): number;
            public set stretchingStiffness(value: number);
            /** Damp cloth motion.
            */
            public get damping(): number;
            public set damping(value: number);
            /** A constant, external acceleration applied to the cloth.
            */
            public get externalAcceleration(): UnityEngine.Vector3;
            public set externalAcceleration(value: UnityEngine.Vector3);
            /** A random, external acceleration applied to the cloth.
            */
            public get randomAcceleration(): UnityEngine.Vector3;
            public set randomAcceleration(value: UnityEngine.Vector3);
            /** Should gravity affect the cloth simulation?
            */
            public get useGravity(): boolean;
            public set useGravity(value: boolean);
            /** Is this cloth enabled?
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** The friction of the cloth when colliding with the character.
            */
            public get friction(): number;
            public set friction(value: number);
            /** How much to increase mass of colliding particles.
            */
            public get collisionMassScale(): number;
            public set collisionMassScale(value: number);
            /** Enable continuous collision to improve collision stability.
            */
            public get enableContinuousCollision(): boolean;
            public set enableContinuousCollision(value: boolean);
            /** Add one virtual particle per triangle to improve collision stability.
            */
            public get useVirtualParticles(): number;
            public set useVirtualParticles(value: number);
            /** How much world-space movement of the character will affect cloth vertices.
            */
            public get worldVelocityScale(): number;
            public set worldVelocityScale(value: number);
            /** How much world-space acceleration of the character will affect cloth vertices.
            */
            public get worldAccelerationScale(): number;
            public set worldAccelerationScale(value: number);
            /** Number of cloth solver iterations per second.
            */
            public get clothSolverFrequency(): number;
            public set clothSolverFrequency(value: number);
            /** Use Tether Anchors.
            */
            public get useTethers(): boolean;
            public set useTethers(value: boolean);
            /** Sets the stiffness frequency parameter.
            */
            public get stiffnessFrequency(): number;
            public set stiffnessFrequency(value: number);
            /** Minimum distance at which two cloth particles repel each other (default: 0.0).
            */
            public get selfCollisionDistance(): number;
            public set selfCollisionDistance(value: number);
            /** Self-collision stiffness defines how strong the separating impulse should be for colliding particles.
            */
            public get selfCollisionStiffness(): number;
            public set selfCollisionStiffness(value: number);
            public ClearTransformMotion () : void
            public GetSelfAndInterCollisionIndices ($indices: System.Collections.Generic.List$1<number>) : void
            public SetSelfAndInterCollisionIndices ($indices: System.Collections.Generic.List$1<number>) : void
            public GetVirtualParticleIndices ($indicesOutList: System.Collections.Generic.List$1<number>) : void
            public SetVirtualParticleIndices ($indicesIn: System.Collections.Generic.List$1<number>) : void
            public GetVirtualParticleWeights ($weightsOutList: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public SetVirtualParticleWeights ($weights: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            /** Fade the cloth simulation in or out.
            * @param enabled Fading enabled or not.
            */
            public SetEnabledFading ($enabled: boolean, $interpolationTime: number) : void
            public SetEnabledFading ($enabled: boolean) : void
            public constructor ()
        }
        /** A capsule-shaped primitive collider.
        */
        class CapsuleCollider extends UnityEngine.Collider
        {
            protected [__keep_incompatibility]: never;
            /** The center of the capsule, measured in the object's local space.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** The radius of the sphere, measured in the object's local space.
            */
            public get radius(): number;
            public set radius(value: number);
            /** The height of the capsule measured in the object's local space.
            */
            public get height(): number;
            public set height(value: number);
            /** The direction of the capsule.
            */
            public get direction(): number;
            public set direction(value: number);
            public constructor ()
        }
        /** Values to determine the type of input value to be expect from one entry of ClusterInput.
        */
        enum ClusterInputType
        { Button = 0, Axis = 1, Tracker = 2, CustomProvidedInput = 3 }
        class ClusterSerialization extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static SaveTimeManagerState ($buffer: Unity.Collections.NativeArray$1<number>) : number
            public static RestoreTimeManagerState ($buffer: Unity.Collections.NativeArray$1<number>) : boolean
            public static SaveInputManagerState ($buffer: Unity.Collections.NativeArray$1<number>) : number
            public static RestoreInputManagerState ($buffer: Unity.Collections.NativeArray$1<number>) : boolean
            public static SaveClusterInputState ($buffer: Unity.Collections.NativeArray$1<number>) : number
            public static RestoreClusterInputState ($buffer: Unity.Collections.NativeArray$1<number>) : boolean
        }
        /** The platform application is running. Returned by Application.platform.
        */
        enum RuntimePlatform
        { OSXEditor = 0, OSXPlayer = 1, WindowsPlayer = 2, OSXWebPlayer = 3, OSXDashboardPlayer = 4, WindowsWebPlayer = 5, WindowsEditor = 7, IPhonePlayer = 8, XBOX360 = 10, PS3 = 9, Android = 11, NaCl = 12, FlashPlayer = 15, LinuxPlayer = 13, LinuxEditor = 16, WebGLPlayer = 17, MetroPlayerX86 = 18, WSAPlayerX86 = 18, MetroPlayerX64 = 19, WSAPlayerX64 = 19, MetroPlayerARM = 20, WSAPlayerARM = 20, WP8Player = 21, BB10Player = 22, BlackBerryPlayer = 22, TizenPlayer = 23, PSP2 = 24, PS4 = 25, PSM = 26, XboxOne = 27, SamsungTVPlayer = 28, WiiU = 30, tvOS = 31, Switch = 32, Lumin = 33, Stadia = 34, CloudRendering = 35, GameCoreScarlett = -1, GameCoreXboxSeries = 36, GameCoreXboxOne = 37, PS5 = 38, EmbeddedLinuxArm64 = 39, EmbeddedLinuxArm32 = 40, EmbeddedLinuxX64 = 41, EmbeddedLinuxX86 = 42, LinuxServer = 43, WindowsServer = 44, OSXServer = 45 }
        /** The language the user's operating system is running in. Returned by Application.systemLanguage.
        */
        enum SystemLanguage
        { Afrikaans = 0, Arabic = 1, Basque = 2, Belarusian = 3, Bulgarian = 4, Catalan = 5, Chinese = 6, Czech = 7, Danish = 8, Dutch = 9, English = 10, Estonian = 11, Faroese = 12, Finnish = 13, French = 14, German = 15, Greek = 16, Hebrew = 17, Hugarian = 18, Icelandic = 19, Indonesian = 20, Italian = 21, Japanese = 22, Korean = 23, Latvian = 24, Lithuanian = 25, Norwegian = 26, Polish = 27, Portuguese = 28, Romanian = 29, Russian = 30, SerboCroatian = 31, Slovak = 32, Slovenian = 33, Spanish = 34, Swedish = 35, Thai = 36, Turkish = 37, Ukrainian = 38, Vietnamese = 39, ChineseSimplified = 40, ChineseTraditional = 41, Unknown = 42, Hungarian = 18 }
        /** SortingLayer allows you to set the render order of multiple sprites easily. There is always a default SortingLayer named "Default" which all sprites are added to initially. Added more SortingLayers to easily control the order of rendering of groups of sprites. Layers can be ordered before or after the default layer.
        */
        class SortingLayer extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** This is the unique id assigned to the layer. It is not an ordered running value and it should not be used to compare with other layers to determine the sorting order.
            */
            public get id(): number;
            /** Returns the name of the layer as defined in the TagManager.
            */
            public get name(): string;
            /** This is the relative value that indicates the sort order of this layer relative to the other layers.
            */
            public get value(): number;
            /** Returns all the layers defined in this project.
            */
            public static get layers(): System.Array$1<UnityEngine.SortingLayer>;
            /** Returns the final sorting layer value. To determine the sorting order between the various sorting layers, use this method to retrieve the final sorting value and use CompareTo to determine the order.
            * @param id The unique value of the sorting layer as returned by any renderer's sortingLayerID property.
            * @returns The final sorting value of the layer relative to other layers. 
            */
            public static GetLayerValueFromID ($id: number) : number
            /** Returns the final sorting layer value. See Also: GetLayerValueFromID.
            * @param name The unique value of the sorting layer as returned by any renderer's sortingLayerID property.
            * @returns The final sorting value of the layer relative to other layers. 
            */
            public static GetLayerValueFromName ($name: string) : number
            /** Returns the id given the name. Will return 0 if an invalid name was given.
            * @param name The name of the layer.
            * @returns The unique id of the layer with name. 
            */
            public static NameToID ($name: string) : number
            /** Returns the unique id of the layer. Will return "<unknown layer>" if an invalid id is given.
            * @param id The unique id of the layer.
            * @returns The name of the layer with id or "<unknown layer>" for invalid id. 
            */
            public static IDToName ($id: number) : string
            /** Returns true if the id provided is a valid layer id.
            * @param id The unique id of a layer.
            * @returns True if the id provided is valid and assigned to a layer. 
            */
            public static IsValid ($id: number) : boolean
        }
        /** Sets which weights to use when calculating curve segments.
        */
        enum WeightedMode
        { None = 0, In = 1, Out = 2, Both = 3 }
        /** A single keyframe that can be injected into an animation curve.
        */
        class Keyframe extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The time of the keyframe.
            */
            public get time(): number;
            public set time(value: number);
            /** The value of the curve at keyframe.
            */
            public get value(): number;
            public set value(value: number);
            /** Sets the incoming tangent for this key. The incoming tangent affects the slope of the curve from the previous key to this key.
            */
            public get inTangent(): number;
            public set inTangent(value: number);
            /** Sets the outgoing tangent for this key. The outgoing tangent affects the slope of the curve from this key to the next key.
            */
            public get outTangent(): number;
            public set outTangent(value: number);
            /** Sets the incoming weight for this key. The incoming weight affects the slope of the curve from the previous key to this key.
            */
            public get inWeight(): number;
            public set inWeight(value: number);
            /** Sets the outgoing weight for this key. The outgoing weight affects the slope of the curve from this key to the next key.
            */
            public get outWeight(): number;
            public set outWeight(value: number);
            /** Weighted mode for the keyframe.
            */
            public get weightedMode(): UnityEngine.WeightedMode;
            public set weightedMode(value: UnityEngine.WeightedMode);
            public constructor ($time: number, $value: number)
            public constructor ($time: number, $value: number, $inTangent: number, $outTangent: number)
            public constructor ($time: number, $value: number, $inTangent: number, $outTangent: number, $inWeight: number, $outWeight: number)
            public constructor ()
        }
        /** Access to application runtime data.
        */
        class Application extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns true when called in any kind of built Player, or when called in the Editor in Play Mode (Read Only).
            */
            public static get isPlaying(): boolean;
            /** Whether the Player currently has focus (Read-only).
            */
            public static get isFocused(): boolean;
            /** Returns a GUID for this build (Read Only).
            */
            public static get buildGUID(): string;
            /** Should the Player be running when the application is in the background?
            */
            public static get runInBackground(): boolean;
            public static set runInBackground(value: boolean);
            /** Returns true when Unity is launched with the -batchmode flag from the command line (Read Only).
            */
            public static get isBatchMode(): boolean;
            /** Contains the path to the game data folder on the target device (Read Only).
            */
            public static get dataPath(): string;
            /** The path to the StreamingAssets  folder (Read Only).
            */
            public static get streamingAssetsPath(): string;
            /** Contains the path to a persistent data directory (Read Only).
            */
            public static get persistentDataPath(): string;
            /** Contains the path to a temporary data / cache directory (Read Only).
            */
            public static get temporaryCachePath(): string;
            /** The URL of the document. For WebGL, this a web URL. For Android, iOS, or Universal Windows Platform (UWP) this is a deep link URL (Read Only).
            */
            public static get absoluteURL(): string;
            /** The version of the Unity runtime used to play the content.
            */
            public static get unityVersion(): string;
            /** Returns application version number  (Read Only).
            */
            public static get version(): string;
            /** Returns the name of the store or package that installed the application (Read Only).
            */
            public static get installerName(): string;
            /** Returns application identifier at runtime. 
            */
            public static get identifier(): string;
            /** Returns application install mode (Read Only).
            */
            public static get installMode(): UnityEngine.ApplicationInstallMode;
            /** Returns application running in sandbox (Read Only).
            */
            public static get sandboxType(): UnityEngine.ApplicationSandboxType;
            /** Returns application product name (Read Only).
            */
            public static get productName(): string;
            /** Returns application company name (Read Only).
            */
            public static get companyName(): string;
            /** A unique cloud project identifier. It is unique for every project (Read Only).
            */
            public static get cloudProjectId(): string;
            /** Specifies the frame rate at which Unity tries to render your game.
            */
            public static get targetFrameRate(): number;
            public static set targetFrameRate(value: number);
            /** Returns the path to the console log file, or an empty string if the current platform does not support log files.
            */
            public static get consoleLogPath(): string;
            /** Priority of background loading thread.
            */
            public static get backgroundLoadingPriority(): UnityEngine.ThreadPriority;
            public static set backgroundLoadingPriority(value: UnityEngine.ThreadPriority);
            /** Returns false if application is altered in any way after it was built.
            */
            public static get genuine(): boolean;
            /** Returns true if application integrity can be confirmed.
            */
            public static get genuineCheckAvailable(): boolean;
            /** Returns the platform the game is running on (Read Only).
            */
            public static get platform(): UnityEngine.RuntimePlatform;
            /** Identifies whether the current Runtime platform is a known mobile platform.
            */
            public static get isMobilePlatform(): boolean;
            /** Is the current Runtime platform a known console platform.
            */
            public static get isConsolePlatform(): boolean;
            /** The language the user's operating system is running in.
            */
            public static get systemLanguage(): UnityEngine.SystemLanguage;
            /** Returns the type of internet reachability currently possible on the device.
            */
            public static get internetReachability(): UnityEngine.NetworkReachability;
            /** Whether the game is running inside the Unity Editor (Read Only).
            */
            public static get isEditor(): boolean;
            public static Quit ($exitCode: number) : void
            public static Quit () : void
            public static Unload () : void
            /** Checks if the streamed level can be loaded.
            */
            public static CanStreamedLevelBeLoaded ($levelIndex: number) : boolean
            /** Checks if the streamed level can be loaded.
            */
            public static CanStreamedLevelBeLoaded ($levelName: string) : boolean
            /** Returns true if the given object is part of the playing world either in any kind of built Player or in Play Mode.
            * @param obj The object to test.
            * @returns True if the object is part of the playing world. 
            */
            public static IsPlaying ($obj: UnityEngine.Object) : boolean
            public static GetBuildTags () : System.Array$1<string>
            /** Set an array of feature tags for this build.
            */
            public static SetBuildTags ($buildTags: System.Array$1<string>) : void
            public static HasProLicense () : boolean
            public static RequestAdvertisingIdentifierAsync ($delegateMethod: UnityEngine.Application.AdvertisingIdentifierCallback) : boolean
            /** Opens the URL specified, subject to the permissions and limitations of your app’s current platform and environment. 
            * @param url The URL to open.
            */
            public static OpenURL ($url: string) : void
            /** Get stack trace logging options. The default value is StackTraceLogType.ScriptOnly.
            */
            public static GetStackTraceLogType ($logType: UnityEngine.LogType) : UnityEngine.StackTraceLogType
            /** Set stack trace logging options. The default value is StackTraceLogType.ScriptOnly.
            */
            public static SetStackTraceLogType ($logType: UnityEngine.LogType, $stackTraceType: UnityEngine.StackTraceLogType) : void
            /** Request authorization to use the webcam or microphone on iOS and WebGL.
            */
            public static RequestUserAuthorization ($mode: UnityEngine.UserAuthorization) : UnityEngine.AsyncOperation
            /** Check if the user has authorized use of the webcam or microphone in the Web Player.
            */
            public static HasUserAuthorization ($mode: UnityEngine.UserAuthorization) : boolean
            public static add_lowMemory ($value: UnityEngine.Application.LowMemoryCallback) : void
            public static remove_lowMemory ($value: UnityEngine.Application.LowMemoryCallback) : void
            public static add_logMessageReceived ($value: UnityEngine.Application.LogCallback) : void
            public static remove_logMessageReceived ($value: UnityEngine.Application.LogCallback) : void
            public static add_logMessageReceivedThreaded ($value: UnityEngine.Application.LogCallback) : void
            public static remove_logMessageReceivedThreaded ($value: UnityEngine.Application.LogCallback) : void
            public static add_onBeforeRender ($value: UnityEngine.Events.UnityAction) : void
            public static remove_onBeforeRender ($value: UnityEngine.Events.UnityAction) : void
            public static add_focusChanged ($value: System.Action$1<boolean>) : void
            public static remove_focusChanged ($value: System.Action$1<boolean>) : void
            public static add_deepLinkActivated ($value: System.Action$1<string>) : void
            public static remove_deepLinkActivated ($value: System.Action$1<string>) : void
            public static add_wantsToQuit ($value: System.Func$1<boolean>) : void
            public static remove_wantsToQuit ($value: System.Func$1<boolean>) : void
            public static add_quitting ($value: System.Action) : void
            public static remove_quitting ($value: System.Action) : void
            public static add_unloading ($value: System.Action) : void
            public static remove_unloading ($value: System.Action) : void
            public constructor ()
        }
        /** Application installation mode (Read Only).
        */
        enum ApplicationInstallMode
        { Unknown = 0, Store = 1, DeveloperBuild = 2, Adhoc = 3, Enterprise = 4, Editor = 5 }
        /** Application sandbox type.
        */
        enum ApplicationSandboxType
        { Unknown = 0, NotSandboxed = 1, Sandboxed = 2, SandboxBroken = 3 }
        /** Stack trace logging options.
        */
        enum StackTraceLogType
        { None = 0, ScriptOnly = 1, Full = 2 }
        /** Constants to pass to Application.RequestUserAuthorization.
        */
        enum UserAuthorization
        { WebCam = 1, Microphone = 2 }
        /** Describes network reachability options.
        */
        enum NetworkReachability
        { NotReachable = 0, ReachableViaCarrierDataNetwork = 1, ReachableViaLocalAreaNetwork = 2 }
        /** Type of the imported(native) data.
        */
        enum AudioType
        { UNKNOWN = 0, ACC = 1, AIFF = 2, IT = 10, MOD = 12, MPEG = 13, OGGVORBIS = 14, S3M = 17, WAV = 20, XM = 21, XMA = 22, VAG = 23, AUDIOQUEUE = 24 }
        /** Data structure for downloading AssetBundles to a customized cache path. See Also:UnityWebRequestAssetBundle.GetAssetBundle for more information.
        */
        class CachedAssetBundle extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** AssetBundle name which is used as the customized cache path.
            */
            public get name(): string;
            public set name(value: string);
            /** Hash128 which is used as the version of the AssetBundle.
            */
            public get hash(): UnityEngine.Hash128;
            public set hash(value: UnityEngine.Hash128);
            public constructor ($name: string, $hash: UnityEngine.Hash128)
            public constructor ()
        }
        /** Data structure for cache. Please refer to See Also:Caching.AddCache for more information.
        */
        class Cache extends System.ValueType implements System.IEquatable$1<UnityEngine.Cache>
        {
            protected [__keep_incompatibility]: never;
            /** Returns true if the cache is valid.
            */
            public get valid(): boolean;
            /** Returns true if the cache is ready.
            */
            public get ready(): boolean;
            /** Returns true if the cache is readonly.
            */
            public get readOnly(): boolean;
            /** Returns the path of the cache.
            */
            public get path(): string;
            /** Returns the index of the cache in the cache list.
            */
            public get index(): number;
            /** Returns the number of currently unused bytes in the cache.
            */
            public get spaceFree(): bigint;
            /** Allows you to specify the total number of bytes that can be allocated for the cache.
            */
            public get maximumAvailableStorageSpace(): bigint;
            public set maximumAvailableStorageSpace(value: bigint);
            /** Returns the used disk space in bytes.
            */
            public get spaceOccupied(): bigint;
            /** The number of seconds that an AssetBundle may remain unused in the cache before it is automatically deleted.
            */
            public get expirationDelay(): number;
            public set expirationDelay(value: number);
            public static op_Equality ($lhs: UnityEngine.Cache, $rhs: UnityEngine.Cache) : boolean
            public static op_Inequality ($lhs: UnityEngine.Cache, $rhs: UnityEngine.Cache) : boolean
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Cache) : boolean
            public ClearCache () : boolean
            /** Removes all cached content in the cache that has been cached by the current application.
            * @param expiration The number of seconds that AssetBundles may remain unused in the cache.
            * @returns Returns True when cache clearing succeeded. 
            */
            public ClearCache ($expiration: number) : boolean
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        /** Rendering path of a Camera.
        */
        enum RenderingPath
        { UsePlayerSettings = -1, VertexLit = 0, Forward = 1, DeferredLighting = 2, DeferredShading = 3 }
        /** Transparent object sorting mode of a Camera.
        */
        enum TransparencySortMode
        { Default = 0, Perspective = 1, Orthographic = 2, CustomAxis = 3 }
        /** Describes different types of camera.
        */
        enum CameraType
        { Game = 1, SceneView = 2, Preview = 4, VR = 8, Reflection = 16 }
        /** Values for Camera.clearFlags, determining what to clear when rendering a Camera.
        */
        enum CameraClearFlags
        { Skybox = 1, Color = 2, SolidColor = 2, Depth = 3, Nothing = 4 }
        /** Depth texture generation mode for Camera.
        */
        enum DepthTextureMode
        { None = 0, Depth = 1, DepthNormals = 2, MotionVectors = 4 }
        /** Shader scripts used for all rendering.
        */
        class Shader extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Sets the limit on the number of shader variant chunks Unity loads and keeps in memory.
            */
            public static get maximumChunksOverride(): number;
            public static set maximumChunksOverride(value: number);
            /** Shader LOD level for this shader.
            */
            public get maximumLOD(): number;
            public set maximumLOD(value: number);
            /** Shader LOD level for all shaders.
            */
            public static get globalMaximumLOD(): number;
            public static set globalMaximumLOD(value: number);
            /** Can this shader run on the end-users graphics card? (Read Only)
            */
            public get isSupported(): boolean;
            /** Render pipeline currently in use.
            */
            public static get globalRenderPipeline(): string;
            public static set globalRenderPipeline(value: string);
            /** An array containing the global shader keywords that are currently enabled.
            */
            public static get enabledGlobalKeywords(): System.Array$1<UnityEngine.Rendering.GlobalKeyword>;
            /** An array containing the global shader keywords that currently exist. This includes enabled and disabled global shader keywords.
            */
            public static get globalKeywords(): System.Array$1<UnityEngine.Rendering.GlobalKeyword>;
            /** The local keyword space of this shader.
            */
            public get keywordSpace(): UnityEngine.Rendering.LocalKeywordSpace;
            /** Render queue of this shader. (Read Only)
            */
            public get renderQueue(): number;
            /** Returns the number of shader passes on the active SubShader.
            */
            public get passCount(): number;
            /** Returns the number of SubShaders in this shader.
            */
            public get subshaderCount(): number;
            /** Finds a shader with the given name. Returns null if the shader is not found.
            */
            public static Find ($name: string) : UnityEngine.Shader
            /** Enables a global shader keyword.
            * @param keyword The name of the Rendering.GlobalKeyword to enable.
            */
            public static EnableKeyword ($keyword: string) : void
            /** Disables a global shader keyword.
            * @param keyword The name of the Rendering.GlobalKeyword to disable.
            */
            public static DisableKeyword ($keyword: string) : void
            /** Checks whether a global shader keyword is enabled.
            * @param keyword The name of the Rendering.GlobalKeyword to check.
            * @returns Returns true if a global shader keyword with the given name exists, and is enabled. Otherwise, returns false. 
            */
            public static IsKeywordEnabled ($keyword: string) : boolean
            /** Enables a global shader keyword.
            * @param keyword The name of the Rendering.GlobalKeyword to enable.
            */
            public static EnableKeyword ($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>) : void
            /** Disables a global shader keyword.
            * @param keyword The name of the Rendering.GlobalKeyword to disable.
            */
            public static DisableKeyword ($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>) : void
            /** Sets the state of a global shader keyword.
            * @param keyword The Rendering.GlobalKeyword to enable or disable.
            * @param value The desired keyword state.
            */
            public static SetKeyword ($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>, $value: boolean) : void
            /** Checks whether a global shader keyword is enabled.
            * @param keyword The Rendering.GlobalKeyword to check.
            * @returns Returns true if the given global shader keyword is enabled. Otherwise, returns false. 
            */
            public static IsKeywordEnabled ($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>) : boolean
            public static WarmupAllShaders () : void
            /** Gets unique identifier for a shader property name.
            * @param name Shader property name.
            * @returns Unique integer for the name. 
            */
            public static PropertyToID ($name: string) : number
            /** Returns the dependency shader.
            * @param name The name of the dependency to query.
            */
            public GetDependency ($name: string) : UnityEngine.Shader
            /** Returns the number of passes in the given SubShader.
            * @param subshaderIndex The index of the SubShader.
            */
            public GetPassCountInSubshader ($subshaderIndex: number) : number
            /** Searches for the tag specified by tagName on the shader's active SubShader and returns the value of the tag.
            * @param passIndex The index of the pass.
            * @param tagName The name of the tag.
            */
            public FindPassTagValue ($passIndex: number, $tagName: UnityEngine.Rendering.ShaderTagId) : UnityEngine.Rendering.ShaderTagId
            /** Searches for the tag specified by tagName on the SubShader specified by subshaderIndex and returns the value of the tag.
            * @param subshaderIndex The index of the SubShader.
            * @param passIndex The index of the pass.
            * @param tagName The name of the tag.
            */
            public FindPassTagValue ($subshaderIndex: number, $passIndex: number, $tagName: UnityEngine.Rendering.ShaderTagId) : UnityEngine.Rendering.ShaderTagId
            /** Searches for the tag specified by tagName on the SubShader specified by subshaderIndex and returns the value of the tag.
            * @param subshaderIndex The index of the SubShader.
            * @param tagName The name of the tag.
            */
            public FindSubshaderTagValue ($subshaderIndex: number, $tagName: UnityEngine.Rendering.ShaderTagId) : UnityEngine.Rendering.ShaderTagId
            /** This method is deprecated. Use SetGlobalFloat or SetGlobalInteger instead.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalInt ($name: string, $value: number) : void
            /** This method is deprecated. Use SetGlobalFloat or SetGlobalInteger instead.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalInt ($nameID: number, $value: number) : void
            /** Sets a global float property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalFloat ($name: string, $value: number) : void
            /** Sets a global float property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalFloat ($nameID: number, $value: number) : void
            /** Sets a global integer property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalInteger ($name: string, $value: number) : void
            /** Sets a global integer property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalInteger ($nameID: number, $value: number) : void
            /** Sets a global vector property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalVector ($name: string, $value: UnityEngine.Vector4) : void
            /** Sets a global vector property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalVector ($nameID: number, $value: UnityEngine.Vector4) : void
            /** Sets a global color property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalColor ($name: string, $value: UnityEngine.Color) : void
            /** Sets a global color property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalColor ($nameID: number, $value: UnityEngine.Color) : void
            /** Sets a global matrix property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalMatrix ($name: string, $value: UnityEngine.Matrix4x4) : void
            /** Sets a global matrix property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalMatrix ($nameID: number, $value: UnityEngine.Matrix4x4) : void
            /** Sets a global texture property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            * @param value The texture to set.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public static SetGlobalTexture ($name: string, $value: UnityEngine.Texture) : void
            /** Sets a global texture property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            * @param value The texture to set.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public static SetGlobalTexture ($nameID: number, $value: UnityEngine.Texture) : void
            /** Sets a global texture property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            * @param value The texture to set.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public static SetGlobalTexture ($name: string, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Sets a global texture property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            * @param value The texture to set.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public static SetGlobalTexture ($nameID: number, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Sets a global buffer property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            * @param value The buffer to set.
            */
            public static SetGlobalBuffer ($name: string, $value: UnityEngine.ComputeBuffer) : void
            /** Sets a global buffer property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            * @param value The buffer to set.
            */
            public static SetGlobalBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer) : void
            /** Sets a global buffer property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            * @param value The buffer to set.
            */
            public static SetGlobalBuffer ($name: string, $value: UnityEngine.GraphicsBuffer) : void
            /** Sets a global buffer property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            * @param value The buffer to set.
            */
            public static SetGlobalBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
            * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
            * @param name The name of the constant buffer to override.
            * @param value The buffer to override the constant buffer values with, or null to remove binding.
            * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            */
            public static SetGlobalConstantBuffer ($name: string, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
            * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
            * @param name The name of the constant buffer to override.
            * @param value The buffer to override the constant buffer values with, or null to remove binding.
            * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            */
            public static SetGlobalConstantBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
            * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
            * @param name The name of the constant buffer to override.
            * @param value The buffer to override the constant buffer values with, or null to remove binding.
            * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            */
            public static SetGlobalConstantBuffer ($name: string, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for all shader types.
            * @param nameID The name ID of the constant buffer retrieved by Shader.PropertyToID.
            * @param name The name of the constant buffer to override.
            * @param value The buffer to override the constant buffer values with, or null to remove binding.
            * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            */
            public static SetGlobalConstantBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            public static SetGlobalFloatArray ($name: string, $values: System.Collections.Generic.List$1<number>) : void
            public static SetGlobalFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            /** Sets a global float array property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalFloatArray ($name: string, $values: System.Array$1<number>) : void
            /** Sets a global float array property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalFloatArray ($nameID: number, $values: System.Array$1<number>) : void
            public static SetGlobalVectorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public static SetGlobalVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** Sets a global vector array property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalVectorArray ($name: string, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Sets a global vector array property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalVectorArray ($nameID: number, $values: System.Array$1<UnityEngine.Vector4>) : void
            public static SetGlobalMatrixArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public static SetGlobalMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            /** Sets a global matrix array property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalMatrixArray ($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Sets a global matrix array property for all shaders.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static SetGlobalMatrixArray ($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** This method is deprecated. Use GetGlobalFloat or GetGlobalInteger instead.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalInt ($name: string) : number
            /** This method is deprecated. Use GetGlobalFloat or GetGlobalInteger instead.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalInt ($nameID: number) : number
            /** Gets a global float property for all shaders previously set using SetGlobalFloat.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalFloat ($name: string) : number
            /** Gets a global float property for all shaders previously set using SetGlobalFloat.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalFloat ($nameID: number) : number
            /** Gets a global integer property for all shaders previously set using SetGlobalInteger.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalInteger ($name: string) : number
            /** Gets a global integer property for all shaders previously set using SetGlobalInteger.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalInteger ($nameID: number) : number
            /** Gets a global vector property for all shaders previously set using SetGlobalVector.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalVector ($name: string) : UnityEngine.Vector4
            /** Gets a global vector property for all shaders previously set using SetGlobalVector.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalVector ($nameID: number) : UnityEngine.Vector4
            /** Gets a global color property for all shaders previously set using SetGlobalColor.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalColor ($name: string) : UnityEngine.Color
            /** Gets a global color property for all shaders previously set using SetGlobalColor.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalColor ($nameID: number) : UnityEngine.Color
            /** Gets a global matrix property for all shaders previously set using SetGlobalMatrix.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalMatrix ($name: string) : UnityEngine.Matrix4x4
            /** Gets a global matrix property for all shaders previously set using SetGlobalMatrix.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalMatrix ($nameID: number) : UnityEngine.Matrix4x4
            /** Gets a global texture property for all shaders previously set using SetGlobalTexture.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalTexture ($name: string) : UnityEngine.Texture
            /** Gets a global texture property for all shaders previously set using SetGlobalTexture.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalTexture ($nameID: number) : UnityEngine.Texture
            /** Gets a global float array for all shaders previously set using SetGlobalFloatArray.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalFloatArray ($name: string) : System.Array$1<number>
            /** Gets a global float array for all shaders previously set using SetGlobalFloatArray.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalFloatArray ($nameID: number) : System.Array$1<number>
            /** Gets a global vector array for all shaders previously set using SetGlobalVectorArray.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalVectorArray ($name: string) : System.Array$1<UnityEngine.Vector4>
            /** Gets a global vector array for all shaders previously set using SetGlobalVectorArray.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalVectorArray ($nameID: number) : System.Array$1<UnityEngine.Vector4>
            /** Gets a global matrix array for all shaders previously set using SetGlobalMatrixArray.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalMatrixArray ($name: string) : System.Array$1<UnityEngine.Matrix4x4>
            /** Gets a global matrix array for all shaders previously set using SetGlobalMatrixArray.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public static GetGlobalMatrixArray ($nameID: number) : System.Array$1<UnityEngine.Matrix4x4>
            public static GetGlobalFloatArray ($name: string, $values: System.Collections.Generic.List$1<number>) : void
            public static GetGlobalFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            public static GetGlobalVectorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public static GetGlobalVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public static GetGlobalMatrixArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public static GetGlobalMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public GetPropertyCount () : number
            /** Finds the index of a shader property by its name.
            * @param propertyName The name of the shader property.
            */
            public FindPropertyIndex ($propertyName: string) : number
            /** Returns the name of the shader property at the specified index.
            * @param propertyIndex The index of the shader property.
            */
            public GetPropertyName ($propertyIndex: number) : string
            /** Returns the nameId of the shader property at the specified index.
            * @param propertyIndex The index of the shader property.
            */
            public GetPropertyNameId ($propertyIndex: number) : number
            /** Returns the ShaderPropertyType of the property at the specified index.
            * @param propertyIndex The index of the shader property.
            */
            public GetPropertyType ($propertyIndex: number) : UnityEngine.Rendering.ShaderPropertyType
            /** Returns the description string of the shader property at the specified index.
            * @param propertyIndex The index of the shader property.
            */
            public GetPropertyDescription ($propertyIndex: number) : string
            /** Returns the ShaderPropertyFlags of the shader property at the specified index.
            * @param propertyIndex The index of the shader property.
            */
            public GetPropertyFlags ($propertyIndex: number) : UnityEngine.Rendering.ShaderPropertyFlags
            /** Returns an array of strings containing attributes of the shader property at the specified index.
            * @param propertyIndex The index of the shader property.
            */
            public GetPropertyAttributes ($propertyIndex: number) : System.Array$1<string>
            /** Returns the default float value of the shader property at the specified index.
            * @param propertyIndex The index of the shader property.
            */
            public GetPropertyDefaultFloatValue ($propertyIndex: number) : number
            /** Returns the default Vector4 value of the shader property at the specified index.
            * @param propertyIndex The index of the shader property.
            */
            public GetPropertyDefaultVectorValue ($propertyIndex: number) : UnityEngine.Vector4
            /** Returns the min and max limits for a <a href="Rendering.ShaderPropertyType.Range.html">Range</a> property at the specified index.
            * @param propertyIndex The index of the shader property.
            */
            public GetPropertyRangeLimits ($propertyIndex: number) : UnityEngine.Vector2
            /** Returns the TextureDimension of a <a href="Rendering.ShaderPropertyType.Texture.html">Texture</a> shader property at the specified index.
            * @param propertyIndex The index of the shader property.
            */
            public GetPropertyTextureDimension ($propertyIndex: number) : UnityEngine.Rendering.TextureDimension
            /** Returns the default Texture name of a <a href="Rendering.ShaderPropertyType.Texture.html">Texture</a> shader property at the specified index.
            * @param propertyIndex The index of the shader property.
            */
            public GetPropertyTextureDefaultName ($propertyIndex: number) : string
            /** Find the name of a texture stack a texture belongs too.
            * @param propertyIndex Index of the property.
            * @param stackName On exit, contanis the name of the stack if one was found.
            * @param layerIndex On exit, contains the stack layer index of the texture property.
            * @returns True, if a stack was found for the given texture property, false if not. 
            */
            public FindTextureStack ($propertyIndex: number, $stackName: $Ref<string>, $layerIndex: $Ref<number>) : boolean
        }
        /** Render textures are textures that can be rendered to.
        */
        class RenderTexture extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** The width of the render texture in pixels.
            */
            public get width(): number;
            public set width(value: number);
            /** The height of the render texture in pixels.
            */
            public get height(): number;
            public set height(value: number);
            /** Dimensionality (type) of the render texture.
            */
            public get dimension(): UnityEngine.Rendering.TextureDimension;
            public set dimension(value: UnityEngine.Rendering.TextureDimension);
            /** The color format of the render texture. You can set the color format to None to achieve depth-only rendering.
            */
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set graphicsFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** Render texture has mipmaps when this flag is set.
            */
            public get useMipMap(): boolean;
            public set useMipMap(value: boolean);
            /** Does this render texture use sRGB read/write conversions? (Read Only).
            */
            public get sRGB(): boolean;
            /** If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any.
            */
            public get vrUsage(): UnityEngine.VRTextureUsage;
            public set vrUsage(value: UnityEngine.VRTextureUsage);
            /** The render texture memoryless mode property.
            */
            public get memorylessMode(): UnityEngine.RenderTextureMemoryless;
            public set memorylessMode(value: UnityEngine.RenderTextureMemoryless);
            public get format(): UnityEngine.RenderTextureFormat;
            public set format(value: UnityEngine.RenderTextureFormat);
            /** The format of the stencil data that you can encapsulate within a RenderTexture.
            Specifying this property creates a stencil element for the RenderTexture and sets its format.
            This allows for stencil data to be bound as a Texture to all shader types for the platforms that support it.
            This property does not specify the format of the stencil buffer, which is constrained by the depth buffer format specified in RenderTexture.depth.
            Currently, most platforms only support R8_UInt (DirectX11, DirectX12), while PS4 also supports R8_UNorm.
            */
            public get stencilFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set stencilFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** The format of the depth/stencil buffer.
            */
            public get depthStencilFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set depthStencilFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** Mipmap levels are generated automatically when this flag is set.
            */
            public get autoGenerateMips(): boolean;
            public set autoGenerateMips(value: boolean);
            /** Volume extent of a 3D render texture or number of slices of array texture.
            */
            public get volumeDepth(): number;
            public set volumeDepth(value: number);
            /** The antialiasing level for the RenderTexture.
            */
            public get antiAliasing(): number;
            public set antiAliasing(value: number);
            /** If true and antiAliasing is greater than 1, the render texture will not be resolved by default.  Use this if the render texture needs to be bound as a multisampled texture in a shader.
            */
            public get bindTextureMS(): boolean;
            public set bindTextureMS(value: boolean);
            /** Enable random access write into this render texture on Shader Model 5.0 level shaders.
            */
            public get enableRandomWrite(): boolean;
            public set enableRandomWrite(value: boolean);
            /** Is the render texture marked to be scaled by the.
            */
            public get useDynamicScale(): boolean;
            public set useDynamicScale(value: boolean);
            public get isPowerOfTwo(): boolean;
            public set isPowerOfTwo(value: boolean);
            /** Currently active render texture.
            */
            public static get active(): UnityEngine.RenderTexture;
            public static set active(value: UnityEngine.RenderTexture);
            /** Color buffer of the render texture (Read Only).
            */
            public get colorBuffer(): UnityEngine.RenderBuffer;
            /** Depth/stencil buffer of the render texture (Read Only).
            */
            public get depthBuffer(): UnityEngine.RenderBuffer;
            /** The precision of the render texture's depth buffer in bits (0, 16, 24 and 32 are supported).
            */
            public get depth(): number;
            public set depth(value: number);
            /** This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties.
            */
            public get descriptor(): UnityEngine.RenderTextureDescriptor;
            public set descriptor(value: UnityEngine.RenderTextureDescriptor);
            public GetNativeDepthBufferPtr () : System.IntPtr
            /** Hint the GPU driver that the contents of the RenderTexture will not be used.
            * @param discardColor Should the colour buffer be discarded?
            * @param discardDepth Should the depth buffer be discarded?
            */
            public DiscardContents ($discardColor: boolean, $discardDepth: boolean) : void
            public DiscardContents () : void
            public ResolveAntiAliasedSurface () : void
            /** Force an antialiased render texture to be resolved.
            * @param target The render texture to resolve into.  If set, the target render texture must have the same dimensions and format as the source.
            */
            public ResolveAntiAliasedSurface ($target: UnityEngine.RenderTexture) : void
            /** Assigns this RenderTexture as a global shader property named propertyName.
            */
            public SetGlobalShaderProperty ($propertyName: string) : void
            public Create () : boolean
            public Release () : void
            public IsCreated () : boolean
            public GenerateMips () : void
            public ConvertToEquirect ($equirect: UnityEngine.RenderTexture, $eye?: UnityEngine.Camera.MonoOrStereoscopicEye) : void
            /** Does a RenderTexture have stencil buffer?
            * @param rt Render texture, or null for main screen.
            */
            public static SupportsStencil ($rt: UnityEngine.RenderTexture) : boolean
            /** Release a temporary texture allocated with GetTemporary.
            */
            public static ReleaseTemporary ($temp: UnityEngine.RenderTexture) : void
            /** Allocate a temporary render texture.
            * @param width Width in pixels.
            * @param height Height in pixels.
            * @param depthBuffer Depth buffer bits (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
            * @param format Render texture format.
            * @param readWrite Color space conversion mode.
            * @param antiAliasing Number of antialiasing samples to store in the texture. Valid values are 1, 2, 4, and 8. Throws an exception if any other value is passed.
            * @param memorylessMode Render texture memoryless mode.
            * @param vrUsage How Unity uses the RenderTexture as a VR eye texture. The default is VRTextureUsage.None.
            * @param useDynamicScale Determines whether Unity scales the render texture using. The default is false.
            * @param desc Use this RenderTextureDesc for the settings when creating the temporary RenderTexture.
            */
            public static GetTemporary ($desc: UnityEngine.RenderTextureDescriptor) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage, $useDynamicScale: boolean) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat) : UnityEngine.RenderTexture
            /** Allocate a temporary render texture.
            * @param width Width in pixels.
            * @param height Height in pixels.
            * @param depthBuffer Depth buffer bits (0, 16 or 24). Note that only 24 bit depth has stencil buffer.
            * @param format Render texture format.
            * @param readWrite Color space conversion mode.
            * @param antiAliasing Number of antialiasing samples to store in the texture. Valid values are 1, 2, 4, and 8. Throws an exception if any other value is passed.
            * @param memorylessMode Render texture memoryless mode.
            * @param vrUsage How Unity uses the RenderTexture as a VR eye texture. The default is VRTextureUsage.None.
            * @param useDynamicScale Determines whether Unity scales the render texture using. The default is false.
            * @param desc Use this RenderTextureDesc for the settings when creating the temporary RenderTexture.
            */
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage, $useDynamicScale: boolean) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number, $depthBuffer: number) : UnityEngine.RenderTexture
            public static GetTemporary ($width: number, $height: number) : UnityEngine.RenderTexture
            public constructor ($desc: UnityEngine.RenderTextureDescriptor)
            public constructor ($textureToCopy: UnityEngine.RenderTexture)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat)
            public constructor ($width: number, $height: number, $depth: number)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $mipCount: number)
            public constructor ()
        }
        /** Color or depth buffer part of a RenderTexture.
        */
        class RenderBuffer extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public GetNativeRenderBufferPtr () : System.IntPtr
        }
        /** Representation of rays.
        */
        class Ray extends System.ValueType implements System.IFormattable
        {
            protected [__keep_incompatibility]: never;
            /** The origin point of the ray.
            */
            public get origin(): UnityEngine.Vector3;
            public set origin(value: UnityEngine.Vector3);
            /** The direction of the ray.
            */
            public get direction(): UnityEngine.Vector3;
            public set direction(value: UnityEngine.Vector3);
            /** Returns a point at distance units along the ray.
            */
            public GetPoint ($distance: number) : UnityEngine.Vector3
            public ToString () : string
            /** Returns a formatted string for this ray.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this ray.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3)
            public constructor ()
        }
        /** Enum values for the Camera's targetEye property.
        */
        enum StereoTargetEyeMask
        { None = 0, Left = 1, Right = 2, Both = 3 }
        /** Class for handling cube maps, Use this to create or modify existing.
        */
        class Cubemap extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** The format of the pixel data in the texture (Read Only).
            */
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            /** Determines whether mipmap streaming is enabled for this Texture.
            */
            public get streamingMipmaps(): boolean;
            /** Sets the relative priority for this Texture when reducing memory size to fit within the memory budget.
            */
            public get streamingMipmapsPriority(): number;
            /** The mipmap level to load.
            */
            public get requestedMipmapLevel(): number;
            public set requestedMipmapLevel(value: number);
            /** The mipmap level that the streaming system would load before memory budgets are applied.
            */
            public get desiredMipmapLevel(): number;
            /** The mipmap level that the mipmap streaming system is in the process of loading.
            */
            public get loadingMipmapLevel(): number;
            /** The mipmap level that is currently loaded by the streaming system.
            */
            public get loadedMipmapLevel(): number;
            /** Updates Unity cubemap to use different native cubemap texture object.
            * @param nativeTexture Native cubemap texture object.
            */
            public UpdateExternalTexture ($nativeTexture: System.IntPtr) : void
            /** Performs smoothing of near edge regions.
            * @param smoothRegionWidthInPixels Pixel distance at edges over which to apply smoothing.
            */
            public SmoothEdges ($smoothRegionWidthInPixels: number) : void
            public SmoothEdges () : void
            /** Gets the pixel color data for a mipmap level of a face as Color structs.
            * @param face The CubemapFace to read from.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($face: UnityEngine.CubemapFace, $miplevel: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level of a face as Color structs.
            * @param face The CubemapFace to read from.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($face: UnityEngine.CubemapFace) : System.Array$1<UnityEngine.Color>
            /** Sets the pixel colors of an entire mipmap level of a face.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param face The CubemapFace to write colors to.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level of a face.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param face The CubemapFace to write colors to.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace) : void
            public ClearRequestedMipmapLevel () : void
            public IsRequestedMipmapLevelLoaded () : boolean
            /** Creates a Unity cubemap out of externally created native cubemap object.
            * @param size The width and height of each face of the cubemap should be the same.
            * @param format Format of underlying cubemap object.
            * @param mipmap Does the cubemap have mipmaps?
            * @param nativeTex Native cubemap texture object.
            */
            public static CreateExternalTexture ($width: number, $format: UnityEngine.TextureFormat, $mipmap: boolean, $nativeTex: System.IntPtr) : UnityEngine.Cubemap
            /** Sets the pixel color at coordinates (x,y).
            * @param x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
            * @param y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
            * @param color The color to set.
            * @param mip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param face The CubemapFace to write to.
            */
            public SetPixel ($face: UnityEngine.CubemapFace, $x: number, $y: number, $color: UnityEngine.Color) : void
            /** Sets the pixel color at coordinates (x,y).
            * @param x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
            * @param y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
            * @param color The color to set.
            * @param mip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param face The CubemapFace to write to.
            */
            public SetPixel ($face: UnityEngine.CubemapFace, $x: number, $y: number, $color: UnityEngine.Color, $mip: number) : void
            /** Gets the pixel color at coordinates (x, y).
            * @param x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
            * @param y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
            * @param mip The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param face The CubemapFace to sample.
            * @returns The pixel color. 
            */
            public GetPixel ($face: UnityEngine.CubemapFace, $x: number, $y: number) : UnityEngine.Color
            /** Gets the pixel color at coordinates (x, y).
            * @param x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
            * @param y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
            * @param mip The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param face The CubemapFace to sample.
            * @returns The pixel color. 
            */
            public GetPixel ($face: UnityEngine.CubemapFace, $x: number, $y: number, $mip: number) : UnityEngine.Color
            /** Copies changes you've made in a CPU texture to the GPU.
            * @param updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
            * @param makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
            */
            public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
            public Apply ($updateMipmaps: boolean) : void
            public Apply () : void
            public constructor ($width: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $format: UnityEngine.TextureFormat, $mipCount: number)
            public constructor ($width: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number)
            public constructor ($width: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean)
            public constructor ()
        }
        /** Describes a single bounding sphere for use by a CullingGroup.
        */
        class BoundingSphere extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The position of the center of the BoundingSphere.
            */
            public position : UnityEngine.Vector3
            /** The radius of the BoundingSphere.
            */
            public radius : number
            public constructor ($pos: UnityEngine.Vector3, $rad: number)
            public constructor ($packedSphere: UnityEngine.Vector4)
            public constructor ()
        }
        /** Provides information about the current and previous states of one sphere in a CullingGroup.
        */
        class CullingGroupEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The index of the sphere that has changed.
            */
            public get index(): number;
            /** Was the sphere considered visible by the most recent culling pass?
            */
            public get isVisible(): boolean;
            /** Was the sphere visible before the most recent culling pass?
            */
            public get wasVisible(): boolean;
            /** Did this sphere change from being invisible to being visible in the most recent culling pass?
            */
            public get hasBecomeVisible(): boolean;
            /** Did this sphere change from being visible to being invisible in the most recent culling pass?
            */
            public get hasBecomeInvisible(): boolean;
            /** The current distance band index of the sphere, after the most recent culling pass.
            */
            public get currentDistance(): number;
            /** The distance band index of the sphere before the most recent culling pass.
            */
            public get previousDistance(): number;
        }
        /** Describes a set of bounding spheres that should have their visibility and distances maintained.
        */
        class CullingGroup extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Sets the callback that will be called when a sphere's visibility and/or distance state has changed.
            */
            public get onStateChanged(): UnityEngine.CullingGroup.StateChanged;
            public set onStateChanged(value: UnityEngine.CullingGroup.StateChanged);
            /** Pauses culling group execution.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** Locks the CullingGroup to a specific camera.
            */
            public get targetCamera(): UnityEngine.Camera;
            public set targetCamera(value: UnityEngine.Camera);
            public Dispose () : void
            /** Sets the array of bounding sphere definitions that the CullingGroup should compute culling for.
            * @param array The BoundingSpheres to cull.
            */
            public SetBoundingSpheres ($array: System.Array$1<UnityEngine.BoundingSphere>) : void
            /** Sets the number of bounding spheres in the bounding spheres array that are actually being used.
            * @param count The number of bounding spheres being used.
            */
            public SetBoundingSphereCount ($count: number) : void
            /** Erase a given bounding sphere by moving the final sphere on top of it.
            * @param index The index of the entry to erase.
            */
            public EraseSwapBack ($index: number) : void
            /** Retrieve the indices of spheres that have particular visibility and/or distance states.
            * @param visible True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.
            * @param distanceIndex The distance band that retrieved spheres must be in.
            * @param result An array that will be filled with the retrieved sphere indices.
            * @param firstIndex The index of the sphere to begin searching at.
            * @returns The number of sphere indices found and written into the result array. 
            */
            public QueryIndices ($visible: boolean, $result: System.Array$1<number>, $firstIndex: number) : number
            /** Retrieve the indices of spheres that have particular visibility and/or distance states.
            * @param visible True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.
            * @param distanceIndex The distance band that retrieved spheres must be in.
            * @param result An array that will be filled with the retrieved sphere indices.
            * @param firstIndex The index of the sphere to begin searching at.
            * @returns The number of sphere indices found and written into the result array. 
            */
            public QueryIndices ($distanceIndex: number, $result: System.Array$1<number>, $firstIndex: number) : number
            /** Retrieve the indices of spheres that have particular visibility and/or distance states.
            * @param visible True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.
            * @param distanceIndex The distance band that retrieved spheres must be in.
            * @param result An array that will be filled with the retrieved sphere indices.
            * @param firstIndex The index of the sphere to begin searching at.
            * @returns The number of sphere indices found and written into the result array. 
            */
            public QueryIndices ($visible: boolean, $distanceIndex: number, $result: System.Array$1<number>, $firstIndex: number) : number
            /** Returns true if the bounding sphere at index is currently visible from any of the contributing cameras.
            * @param index The index of the bounding sphere.
            * @returns True if the sphere is visible; false if it is invisible. 
            */
            public IsVisible ($index: number) : boolean
            /** Get the current distance band index of a given sphere.
            * @param index The index of the sphere.
            * @returns The sphere's current distance band index. 
            */
            public GetDistance ($index: number) : number
            /** Set bounding distances for 'distance bands' the group should compute, as well as options for how spheres falling into each distance band should be treated.
            * @param distances An array of bounding distances. The distances should be sorted in increasing order.
            */
            public SetBoundingDistances ($distances: System.Array$1<number>) : void
            /** Set the reference point from which distance bands are measured.
            * @param point A fixed point to measure the distance from.
            * @param transform A transform to measure the distance from. The transform's position will be automatically tracked.
            */
            public SetDistanceReferencePoint ($point: UnityEngine.Vector3) : void
            /** Set the reference point from which distance bands are measured.
            * @param point A fixed point to measure the distance from.
            * @param transform A transform to measure the distance from. The transform's position will be automatically tracked.
            */
            public SetDistanceReferencePoint ($transform: UnityEngine.Transform) : void
            public constructor ()
        }
        /** FlareLayer component.
        */
        class FlareLayer extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
        }
        /** The reflection probe is used to capture the surroundings into a texture which is passed to the shaders and used for reflections.
        */
        class ReflectionProbe extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The size of the probe's bounding box in which the probe can contribute to reflections. The size is in world space.
            */
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            /** The center of the probe's bounding box in which the probe can contribute to reflections. The center is relative to the position of the probe.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** The near clipping plane distance when rendering the probe.
            */
            public get nearClipPlane(): number;
            public set nearClipPlane(value: number);
            /** The far clipping plane distance when rendering the probe.
            */
            public get farClipPlane(): number;
            public set farClipPlane(value: number);
            /** The intensity modifier that is applied to the texture of reflection probe in the shader.
            */
            public get intensity(): number;
            public set intensity(value: number);
            /** The probe's world space axis-aligned bounding box in which the probe can contribute to reflections (Read Only).
            */
            public get bounds(): UnityEngine.Bounds;
            /** Should this reflection probe use HDR rendering?
            */
            public get hdr(): boolean;
            public set hdr(value: boolean);
            /** Specifies whether Unity should render non-static GameObjects into the Reflection Probe. If you set this to true, Unity renders non-static GameObjects into the Reflection Probe. If you set this to false, Unity does not render non-static GameObjects into the Reflection Probe. Unity only takes this property into account if the Reflection Probe's Type is Custom.
            */
            public get renderDynamicObjects(): boolean;
            public set renderDynamicObjects(value: boolean);
            /** Shadow drawing distance when rendering the probe.
            */
            public get shadowDistance(): number;
            public set shadowDistance(value: number);
            /** Resolution of the underlying reflection texture in pixels.
            */
            public get resolution(): number;
            public set resolution(value: number);
            /** This is used to render parts of the reflecion probe's surrounding selectively.
            */
            public get cullingMask(): number;
            public set cullingMask(value: number);
            /** How the reflection probe clears the background.
            */
            public get clearFlags(): UnityEngine.Rendering.ReflectionProbeClearFlags;
            public set clearFlags(value: UnityEngine.Rendering.ReflectionProbeClearFlags);
            /** The color with which the texture of reflection probe will be cleared.
            */
            public get backgroundColor(): UnityEngine.Color;
            public set backgroundColor(value: UnityEngine.Color);
            /** Distance around probe used for blending (used in deferred probes).
            */
            public get blendDistance(): number;
            public set blendDistance(value: number);
            /** Should this reflection probe use box projection?
            */
            public get boxProjection(): boolean;
            public set boxProjection(value: boolean);
            /** Should reflection probe texture be generated in the Editor (ReflectionProbeMode.Baked) or should probe use custom specified texure (ReflectionProbeMode.Custom)?
            */
            public get mode(): UnityEngine.Rendering.ReflectionProbeMode;
            public set mode(value: UnityEngine.Rendering.ReflectionProbeMode);
            /** Reflection probe importance.
            */
            public get importance(): number;
            public set importance(value: number);
            /** Sets the way the probe will refresh.
            See Also: ReflectionProbeRefreshMode.
            */
            public get refreshMode(): UnityEngine.Rendering.ReflectionProbeRefreshMode;
            public set refreshMode(value: UnityEngine.Rendering.ReflectionProbeRefreshMode);
            /** Sets this probe time-slicing mode
            See Also: ReflectionProbeTimeSlicingMode.
            */
            public get timeSlicingMode(): UnityEngine.Rendering.ReflectionProbeTimeSlicingMode;
            public set timeSlicingMode(value: UnityEngine.Rendering.ReflectionProbeTimeSlicingMode);
            /** Reference to the baked texture of the reflection probe's surrounding.
            */
            public get bakedTexture(): UnityEngine.Texture;
            public set bakedTexture(value: UnityEngine.Texture);
            /** Reference to the baked texture of the reflection probe's surrounding. Use this to assign custom reflection texture.
            */
            public get customBakedTexture(): UnityEngine.Texture;
            public set customBakedTexture(value: UnityEngine.Texture);
            /** Reference to the real-time texture of the reflection probe's surroundings. Use this to assign a RenderTexture to use for real-time reflection.
            */
            public get realtimeTexture(): UnityEngine.RenderTexture;
            public set realtimeTexture(value: UnityEngine.RenderTexture);
            /** Texture which is passed to the shader of the objects in the vicinity of the reflection probe (Read Only).
            */
            public get texture(): UnityEngine.Texture;
            /** HDR decode values of the reflection probe texture.
            */
            public get textureHDRDecodeValues(): UnityEngine.Vector4;
            public static get minBakedCubemapResolution(): number;
            public static get maxBakedCubemapResolution(): number;
            /** HDR decode values of the default reflection probe texture.
            */
            public static get defaultTextureHDRDecodeValues(): UnityEngine.Vector4;
            /** The surface texture of the default reflection probe that captures the environment contribution. Read only.
            */
            public static get defaultTexture(): UnityEngine.Texture;
            public Reset () : void
            public RenderProbe () : number
            /** Refreshes the probe's cubemap.
            * @param targetTexture Target RenderTexture in which rendering should be done. Specifying null will update the probe's default texture.
            * @returns 
            An integer representing a RenderID which can subsequently be used to check if the probe has finished rendering while rendering in time-slice mode.
            See Also: IsFinishedRendering
            See Also: timeSlicingMode
            */
            public RenderProbe ($targetTexture: UnityEngine.RenderTexture) : number
            /** Checks if a probe has finished a time-sliced render.
            * @param renderId An integer representing the RenderID as returned by the RenderProbe method.
            * @returns 
            True if the render has finished, false otherwise.
            See Also: timeSlicingMode
            */
            public IsFinishedRendering ($renderId: number) : boolean
            /** Utility method to blend 2 cubemaps into a target render texture.
            * @param src Cubemap to blend from.
            * @param dst Cubemap to blend to.
            * @param blend Blend weight.
            * @param target RenderTexture which will hold the result of the blend.
            * @returns Returns trues if cubemaps were blended, false otherwise. 
            */
            public static BlendCubemap ($src: UnityEngine.Texture, $dst: UnityEngine.Texture, $blend: number, $target: UnityEngine.RenderTexture) : boolean
            public static UpdateCachedState () : void
            public static add_reflectionProbeChanged ($value: System.Action$2<UnityEngine.ReflectionProbe, UnityEngine.ReflectionProbe.ReflectionProbeEvent>) : void
            public static remove_reflectionProbeChanged ($value: System.Action$2<UnityEngine.ReflectionProbe, UnityEngine.ReflectionProbe.ReflectionProbeEvent>) : void
            public static add_defaultReflectionSet ($value: System.Action$1<UnityEngine.Cubemap>) : void
            public static remove_defaultReflectionSet ($value: System.Action$1<UnityEngine.Cubemap>) : void
            public static add_defaultReflectionTexture ($value: System.Action$1<UnityEngine.Texture>) : void
            public static remove_defaultReflectionTexture ($value: System.Action$1<UnityEngine.Texture>) : void
            public constructor ()
        }
        class CloudStreaming extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static PostMessage ($content: string) : boolean
            public static PeekMessage () : string
            public static PeekRemoteAudioCapture () : System.Array$1<number>
            public static EnableMicRecording () : boolean
            public static DisableMicRecording () : boolean
        }
        /** Holds data for a single application crash event and provides access to all gathered crash reports.
        */
        class CrashReport extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Time, when the crash occured.
            */
            public time : Date
            /** Crash report data as formatted text.
            */
            public text : string
            /** Returns all currently available reports in a new array.
            */
            public static get reports(): System.Array$1<UnityEngine.CrashReport>;
            /** Returns last crash report, or null if no reports are available.
            */
            public static get lastReport(): UnityEngine.CrashReport;
            public static RemoveAll () : void
            public Remove () : void
        }
        /** Object that is used to resolve references to an ExposedReference field.
        */
        class ExposedPropertyResolver extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        interface IExposedPropertyTable
        {
            /** Assigns a value for an ExposedReference.
            * @param id Identifier of the ExposedReference.
            * @param value The value to assigned to the ExposedReference.
            */
            SetReferenceValue ($id: UnityEngine.PropertyName, $value: UnityEngine.Object) : void
            /** Retrieves a value for the given identifier.
            * @param id Identifier of the ExposedReference.
            * @param idValid Is the identifier valid?
            * @returns The value stored in the table. 
            */
            GetReferenceValue ($id: UnityEngine.PropertyName, $idValid: $Ref<boolean>) : UnityEngine.Object
            /** Remove a value for the given reference.
            * @param id Identifier of the ExposedReference.
            */
            ClearReferenceValue ($id: UnityEngine.PropertyName) : void
        }
        /** Represents a string as an int for efficient lookup and comparison. Use this for common PropertyNames.
        Internally stores just an int to represent the string. A PropertyName can be created from a string but can not be converted back to a string. The same string always results in the same int representing that string. Thus this is a very efficient string representation in both memory and speed when all you need is comparison.
        PropertyName is serializable.
        ToString() is only implemented for debugging purposes in the editor it returns "theName:3737" in the player it returns "Unknown:3737".
        */
        class PropertyName extends System.ValueType implements System.IEquatable$1<UnityEngine.PropertyName>
        {
            protected [__keep_incompatibility]: never;
            /** Indicates whether the specified PropertyName is an Empty string.
            */
            public static IsNullOrEmpty ($prop: UnityEngine.PropertyName) : boolean
            public static op_Equality ($lhs: UnityEngine.PropertyName, $rhs: UnityEngine.PropertyName) : boolean
            public static op_Inequality ($lhs: UnityEngine.PropertyName, $rhs: UnityEngine.PropertyName) : boolean
            /** Determines whether this instance and a specified object, which must also be a PropertyName object, have the same value.
            */
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.PropertyName) : boolean
            public static op_Implicit ($name: string) : UnityEngine.PropertyName
            public static op_Implicit ($id: number) : UnityEngine.PropertyName
            public constructor ($name: string)
            public constructor ($other: UnityEngine.PropertyName)
            public constructor ($id: number)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** Represents an axis aligned bounding box with all values as integers.
        */
        class BoundsInt extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.BoundsInt>
        {
            protected [__keep_incompatibility]: never;
            /** X value of the minimal point of the box.
            */
            public get x(): number;
            public set x(value: number);
            /** Y value of the minimal point of the box.
            */
            public get y(): number;
            public set y(value: number);
            /** Z value of the minimal point of the box.
            */
            public get z(): number;
            public set z(value: number);
            /** The center of the bounding box.
            */
            public get center(): UnityEngine.Vector3;
            /** The minimal point of the box.
            */
            public get min(): UnityEngine.Vector3Int;
            public set min(value: UnityEngine.Vector3Int);
            /** The maximal point of the box.
            */
            public get max(): UnityEngine.Vector3Int;
            public set max(value: UnityEngine.Vector3Int);
            /** The minimal x point of the box.
            */
            public get xMin(): number;
            public set xMin(value: number);
            /** The minimal y point of the box.
            */
            public get yMin(): number;
            public set yMin(value: number);
            /** The minimal z point of the box.
            */
            public get zMin(): number;
            public set zMin(value: number);
            /** The maximal x point of the box.
            */
            public get xMax(): number;
            public set xMax(value: number);
            /** The maximal y point of the box.
            */
            public get yMax(): number;
            public set yMax(value: number);
            /** The maximal z point of the box.
            */
            public get zMax(): number;
            public set zMax(value: number);
            /** The position of the bounding box.
            */
            public get position(): UnityEngine.Vector3Int;
            public set position(value: UnityEngine.Vector3Int);
            /** The total size of the box.
            */
            public get size(): UnityEngine.Vector3Int;
            public set size(value: UnityEngine.Vector3Int);
            /** A BoundsInt.PositionCollection that contains all positions within the BoundsInt.
            */
            public get allPositionsWithin(): UnityEngine.BoundsInt.PositionEnumerator;
            /** Sets the bounds to the min and max value of the box.
            */
            public SetMinMax ($minPosition: UnityEngine.Vector3Int, $maxPosition: UnityEngine.Vector3Int) : void
            /** Clamps the position and size of this bounding box to the given bounds.
            * @param bounds Bounds to clamp to.
            */
            public ClampToBounds ($bounds: UnityEngine.BoundsInt) : void
            /** Is point contained in the bounding box?
            * @param position Point to check.
            * @returns Is point contained in the bounding box? 
            */
            public Contains ($position: UnityEngine.Vector3Int) : boolean
            public ToString () : string
            /** Returns a formatted string for the bounds.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for the bounds.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public static op_Equality ($lhs: UnityEngine.BoundsInt, $rhs: UnityEngine.BoundsInt) : boolean
            public static op_Inequality ($lhs: UnityEngine.BoundsInt, $rhs: UnityEngine.BoundsInt) : boolean
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.BoundsInt) : boolean
            public constructor ($xMin: number, $yMin: number, $zMin: number, $sizeX: number, $sizeY: number, $sizeZ: number)
            public constructor ($position: UnityEngine.Vector3Int, $size: UnityEngine.Vector3Int)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** Representation of 3D vectors and points using integers.
        */
        class Vector3Int extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Vector3Int>
        {
            protected [__keep_incompatibility]: never;
            /** X component of the vector.
            */
            public get x(): number;
            public set x(value: number);
            /** Y component of the vector.
            */
            public get y(): number;
            public set y(value: number);
            /** Z component of the vector.
            */
            public get z(): number;
            public set z(value: number);
            /** Returns the length of this vector (Read Only).
            */
            public get magnitude(): number;
            /** Returns the squared length of this vector (Read Only).
            */
            public get sqrMagnitude(): number;
            /** Shorthand for writing Vector3Int(0, 0, 0).
            */
            public static get zero(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(1, 1, 1).
            */
            public static get one(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(0, 1, 0).
            */
            public static get up(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(0, -1, 0).
            */
            public static get down(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(-1, 0, 0).
            */
            public static get left(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(1, 0, 0).
            */
            public static get right(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(0, 0, 1).
            */
            public static get forward(): UnityEngine.Vector3Int;
            /** Shorthand for writing Vector3Int(0, 0, -1).
            */
            public static get back(): UnityEngine.Vector3Int;
            /** Set x, y and z components of an existing Vector3Int.
            */
            public Set ($x: number, $y: number, $z: number) : void
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Returns the distance between a and b.
            */
            public static Distance ($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int) : number
            /** Returns a vector that is made from the smallest components of two vectors.
            */
            public static Min ($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            /** Returns a vector that is made from the largest components of two vectors.
            */
            public static Max ($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            /** Multiplies two vectors component-wise.
            */
            public static Scale ($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            /** Multiplies every component of this vector by the same component of scale.
            */
            public Scale ($scale: UnityEngine.Vector3Int) : void
            /** Clamps the Vector3Int to the bounds given by min and max.
            */
            public Clamp ($min: UnityEngine.Vector3Int, $max: UnityEngine.Vector3Int) : void
            public static op_Implicit ($v: UnityEngine.Vector3Int) : UnityEngine.Vector3
            public static op_Explicit ($v: UnityEngine.Vector3Int) : UnityEngine.Vector2Int
            /** Converts a  Vector3 to a Vector3Int by doing a Floor to each value.
            */
            public static FloorToInt ($v: UnityEngine.Vector3) : UnityEngine.Vector3Int
            /** Converts a  Vector3 to a Vector3Int by doing a Ceiling to each value.
            */
            public static CeilToInt ($v: UnityEngine.Vector3) : UnityEngine.Vector3Int
            /** Converts a  Vector3 to a Vector3Int by doing a Round to each value.
            */
            public static RoundToInt ($v: UnityEngine.Vector3) : UnityEngine.Vector3Int
            public static op_Addition ($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            public static op_Subtraction ($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            public static op_Multiply ($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            public static op_UnaryNegation ($a: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            public static op_Multiply ($a: UnityEngine.Vector3Int, $b: number) : UnityEngine.Vector3Int
            public static op_Multiply ($a: number, $b: UnityEngine.Vector3Int) : UnityEngine.Vector3Int
            public static op_Division ($a: UnityEngine.Vector3Int, $b: number) : UnityEngine.Vector3Int
            public static op_Equality ($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int) : boolean
            public static op_Inequality ($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int) : boolean
            /** Returns true if the objects are equal.
            */
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Vector3Int) : boolean
            public ToString () : string
            /** Returns a formatted string for this vector.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this vector.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($x: number, $y: number)
            public constructor ($x: number, $y: number, $z: number)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** Utility class for common geometric functions.
        */
        class GeometryUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Calculates frustum planes.
            * @param camera The camera with the view frustum that you want to calculate planes from.
            * @returns The planes that form the camera's view frustum. 
            */
            public static CalculateFrustumPlanes ($camera: UnityEngine.Camera) : System.Array$1<UnityEngine.Plane>
            /** Calculates frustum planes.
            * @param worldToProjectionMatrix A matrix that transforms from world space to projection space, from which the planes will be calculated.
            * @returns The planes that enclose the projection space described by the matrix. 
            */
            public static CalculateFrustumPlanes ($worldToProjectionMatrix: UnityEngine.Matrix4x4) : System.Array$1<UnityEngine.Plane>
            /** Calculates frustum planes.
            * @param camera The camera with the view frustum that you want to calculate planes from.
            * @param planes An array of 6 Planes that will be overwritten with the calculated plane values.
            */
            public static CalculateFrustumPlanes ($camera: UnityEngine.Camera, $planes: System.Array$1<UnityEngine.Plane>) : void
            /** Calculates frustum planes.
            * @param worldToProjectionMatrix A matrix that transforms from world space to projection space, from which the planes will be calculated.
            * @param planes An array of 6 Planes that will be overwritten with the calculated plane values.
            */
            public static CalculateFrustumPlanes ($worldToProjectionMatrix: UnityEngine.Matrix4x4, $planes: System.Array$1<UnityEngine.Plane>) : void
            /** Calculates the bounding box from the given array of positions and the transformation matrix.
            * @param positions An array that stores the location of 3d positions.
            * @param transform A matrix that changes the position, rotation and size of the bounds calculation.
            * @returns Calculates the axis-aligned bounding box. 
            */
            public static CalculateBounds ($positions: System.Array$1<UnityEngine.Vector3>, $transform: UnityEngine.Matrix4x4) : UnityEngine.Bounds
            /** GeometryUtility.TryCreatePlaneFromPolygon creates a plane from the given list of vertices that define the polygon, as long as they do not characterize a straight line or zero area.
            * @param vertices An array of vertex positions that define the shape of a polygon.
            * @param plane A valid plane that goes through the vertices.
            * @returns Returns true on success, false if Unity did not create a plane from the vertices. 
            */
            public static TryCreatePlaneFromPolygon ($vertices: System.Array$1<UnityEngine.Vector3>, $plane: $Ref<UnityEngine.Plane>) : boolean
            /** Returns true if bounds are inside the plane array.
            */
            public static TestPlanesAABB ($planes: System.Array$1<UnityEngine.Plane>, $bounds: UnityEngine.Bounds) : boolean
            public constructor ()
        }
        /** Representation of a plane in 3D space.
        */
        class Plane extends System.ValueType implements System.IFormattable
        {
            protected [__keep_incompatibility]: never;
            /** Normal vector of the plane.
            */
            public get normal(): UnityEngine.Vector3;
            public set normal(value: UnityEngine.Vector3);
            /** The distance measured from the Plane to the origin, along the Plane's normal.
            */
            public get distance(): number;
            public set distance(value: number);
            /** Returns a copy of the plane that faces in the opposite direction.
            */
            public get flipped(): UnityEngine.Plane;
            /** Sets a plane using a point that lies within it along with a normal to orient it.
            * @param inNormal The plane's normal vector.
            * @param inPoint A point that lies on the plane.
            */
            public SetNormalAndPosition ($inNormal: UnityEngine.Vector3, $inPoint: UnityEngine.Vector3) : void
            /** Sets a plane using three points that lie within it.  The points go around clockwise as you look down on the top surface of the plane.
            * @param a First point in clockwise order.
            * @param b Second point in clockwise order.
            * @param c Third point in clockwise order.
            */
            public Set3Points ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $c: UnityEngine.Vector3) : void
            public Flip () : void
            /** Moves the plane in space by the translation vector.
            * @param translation The offset in space to move the plane with.
            */
            public Translate ($translation: UnityEngine.Vector3) : void
            /** Returns a copy of the given plane that is moved in space by the given translation.
            * @param plane The plane to move in space.
            * @param translation The offset in space to move the plane with.
            * @returns The translated plane. 
            */
            public static Translate ($plane: UnityEngine.Plane, $translation: UnityEngine.Vector3) : UnityEngine.Plane
            /** For a given point returns the closest point on the plane.
            * @param point The point to project onto the plane.
            * @returns A point on the plane that is closest to point. 
            */
            public ClosestPointOnPlane ($point: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Returns a signed distance from plane to point.
            */
            public GetDistanceToPoint ($point: UnityEngine.Vector3) : number
            /** Is a point on the positive side of the plane?
            */
            public GetSide ($point: UnityEngine.Vector3) : boolean
            /** Are two points on the same side of the plane?
            */
            public SameSide ($inPt0: UnityEngine.Vector3, $inPt1: UnityEngine.Vector3) : boolean
            /** Intersects a ray with the plane.
            */
            public Raycast ($ray: UnityEngine.Ray, $enter: $Ref<number>) : boolean
            public ToString () : string
            public ToString ($format: string) : string
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($inNormal: UnityEngine.Vector3, $inPoint: UnityEngine.Vector3)
            public constructor ($inNormal: UnityEngine.Vector3, $d: number)
            public constructor ($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $c: UnityEngine.Vector3)
            public constructor ()
        }
        /** A ray in 2D space.
        */
        class Ray2D extends System.ValueType implements System.IFormattable
        {
            protected [__keep_incompatibility]: never;
            /** The starting point of the ray in world space.
            */
            public get origin(): UnityEngine.Vector2;
            public set origin(value: UnityEngine.Vector2);
            /** The direction of the ray in world space.
            */
            public get direction(): UnityEngine.Vector2;
            public set direction(value: UnityEngine.Vector2);
            /** Get a point that lies a given distance along a ray.
            * @param distance Distance of the desired point along the path of the ray.
            */
            public GetPoint ($distance: number) : UnityEngine.Vector2
            public ToString () : string
            /** Returns a formatted string for this 2D ray.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this 2D ray.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2)
            public constructor ()
        }
        /** A 2D Rectangle defined by x, y, width, height with integers.
        */
        class RectInt extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.RectInt>
        {
            protected [__keep_incompatibility]: never;
            /** Left coordinate of the rectangle.
            */
            public get x(): number;
            public set x(value: number);
            /** Top coordinate of the rectangle.
            */
            public get y(): number;
            public set y(value: number);
            /** Center coordinate of the rectangle.
            */
            public get center(): UnityEngine.Vector2;
            /** The lower left corner of the rectangle; which is the minimal position of the rectangle along the x- and y-axes, when it is aligned to both axes.
            */
            public get min(): UnityEngine.Vector2Int;
            public set min(value: UnityEngine.Vector2Int);
            /** The upper right corner of the rectangle; which is the maximal position of the rectangle along the x- and y-axes, when it is aligned to both axes.
            */
            public get max(): UnityEngine.Vector2Int;
            public set max(value: UnityEngine.Vector2Int);
            /** Width of the rectangle.
            */
            public get width(): number;
            public set width(value: number);
            /** Height of the rectangle.
            */
            public get height(): number;
            public set height(value: number);
            /** Shows the minimum X value of the RectInt.
            */
            public get xMin(): number;
            public set xMin(value: number);
            /** Show the minimum Y value of the RectInt.
            */
            public get yMin(): number;
            public set yMin(value: number);
            /** Shows the maximum X value of the RectInt.
            */
            public get xMax(): number;
            public set xMax(value: number);
            /** Shows the maximum Y value of the RectInt.
            */
            public get yMax(): number;
            public set yMax(value: number);
            /** Returns the position (x, y) of the RectInt.
            */
            public get position(): UnityEngine.Vector2Int;
            public set position(value: UnityEngine.Vector2Int);
            /** Returns the width and height of the RectInt.
            */
            public get size(): UnityEngine.Vector2Int;
            public set size(value: UnityEngine.Vector2Int);
            /** A RectInt.PositionCollection that contains all positions within the RectInt.
            */
            public get allPositionsWithin(): UnityEngine.RectInt.PositionEnumerator;
            /** Sets the bounds to the min and max value of the rect.
            */
            public SetMinMax ($minPosition: UnityEngine.Vector2Int, $maxPosition: UnityEngine.Vector2Int) : void
            /** Clamps the position and size of the RectInt to the given bounds.
            * @param bounds Bounds to clamp the RectInt.
            */
            public ClampToBounds ($bounds: UnityEngine.RectInt) : void
            /** Returns true if the given position is within the RectInt.
            * @param position Position to check.
            * @returns Whether the position is within the RectInt. 
            */
            public Contains ($position: UnityEngine.Vector2Int) : boolean
            /** RectInts overlap if each RectInt Contains a shared point.
            * @param other Other rectangle to test overlapping with.
            * @returns True if the other rectangle overlaps this one. 
            */
            public Overlaps ($other: UnityEngine.RectInt) : boolean
            public ToString () : string
            /** Returns the x, y, width and height of the RectInt.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns the x, y, width and height of the RectInt.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            /** Returns true if the given RectInt is equal to this RectInt.
            */
            public Equals ($other: UnityEngine.RectInt) : boolean
            public constructor ($xMin: number, $yMin: number, $width: number, $height: number)
            public constructor ($position: UnityEngine.Vector2Int, $size: UnityEngine.Vector2Int)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** Representation of 2D vectors and points using integers.
        */
        class Vector2Int extends System.ValueType implements System.IFormattable, System.IEquatable$1<UnityEngine.Vector2Int>
        {
            protected [__keep_incompatibility]: never;
            /** X component of the vector.
            */
            public get x(): number;
            public set x(value: number);
            /** Y component of the vector.
            */
            public get y(): number;
            public set y(value: number);
            /** Returns the length of this vector (Read Only).
            */
            public get magnitude(): number;
            /** Returns the squared length of this vector (Read Only).
            */
            public get sqrMagnitude(): number;
            /** Shorthand for writing Vector2Int(0, 0).
            */
            public static get zero(): UnityEngine.Vector2Int;
            /** Shorthand for writing Vector2Int(1, 1).
            */
            public static get one(): UnityEngine.Vector2Int;
            /** Shorthand for writing Vector2Int(0, 1).
            */
            public static get up(): UnityEngine.Vector2Int;
            /** Shorthand for writing Vector2Int(0, -1).
            */
            public static get down(): UnityEngine.Vector2Int;
            /** Shorthand for writing Vector2Int(-1, 0).
            */
            public static get left(): UnityEngine.Vector2Int;
            /** Shorthand for writing Vector2Int(1, 0).
            */
            public static get right(): UnityEngine.Vector2Int;
            /** Set x and y components of an existing Vector2Int.
            */
            public Set ($x: number, $y: number) : void
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            /** Returns the distance between a and b.
            */
            public static Distance ($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int) : number
            /** Returns a vector that is made from the smallest components of two vectors.
            */
            public static Min ($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            /** Returns a vector that is made from the largest components of two vectors.
            */
            public static Max ($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            /** Multiplies two vectors component-wise.
            */
            public static Scale ($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            /** Multiplies every component of this vector by the same component of scale.
            */
            public Scale ($scale: UnityEngine.Vector2Int) : void
            /** Clamps the Vector2Int to the bounds given by min and max.
            */
            public Clamp ($min: UnityEngine.Vector2Int, $max: UnityEngine.Vector2Int) : void
            public static op_Implicit ($v: UnityEngine.Vector2Int) : UnityEngine.Vector2
            public static op_Explicit ($v: UnityEngine.Vector2Int) : UnityEngine.Vector3Int
            /** Converts a Vector2 to a Vector2Int by doing a Floor to each value.
            */
            public static FloorToInt ($v: UnityEngine.Vector2) : UnityEngine.Vector2Int
            /** Converts a  Vector2 to a Vector2Int by doing a Ceiling to each value.
            */
            public static CeilToInt ($v: UnityEngine.Vector2) : UnityEngine.Vector2Int
            /** Converts a  Vector2 to a Vector2Int by doing a Round to each value.
            */
            public static RoundToInt ($v: UnityEngine.Vector2) : UnityEngine.Vector2Int
            public static op_UnaryNegation ($v: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            public static op_Addition ($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            public static op_Subtraction ($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            public static op_Multiply ($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            public static op_Multiply ($a: number, $b: UnityEngine.Vector2Int) : UnityEngine.Vector2Int
            public static op_Multiply ($a: UnityEngine.Vector2Int, $b: number) : UnityEngine.Vector2Int
            public static op_Division ($a: UnityEngine.Vector2Int, $b: number) : UnityEngine.Vector2Int
            public static op_Equality ($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int) : boolean
            public static op_Inequality ($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int) : boolean
            /** Returns true if the objects are equal.
            */
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.Vector2Int) : boolean
            public ToString () : string
            /** Returns a formatted string for this vector.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this vector.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            public constructor ($x: number, $y: number)
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** Offsets for rectangles, borders, etc.
        */
        class RectOffset extends System.Object implements System.IFormattable
        {
            protected [__keep_incompatibility]: never;
            /** Left edge size.
            */
            public get left(): number;
            public set left(value: number);
            /** Right edge size.
            */
            public get right(): number;
            public set right(value: number);
            /** Top edge size.
            */
            public get top(): number;
            public set top(value: number);
            /** Bottom edge size.
            */
            public get bottom(): number;
            public set bottom(value: number);
            /** Shortcut for left + right. (Read Only)
            */
            public get horizontal(): number;
            /** Shortcut for top + bottom. (Read Only)
            */
            public get vertical(): number;
            public ToString () : string
            /** Returns a formatted string for this RectOffset.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string) : string
            /** Returns a formatted string for this RectOffset.
            * @param format A numeric format string.
            * @param formatProvider An object that specifies culture-specific formatting.
            */
            public ToString ($format: string, $formatProvider: System.IFormatProvider) : string
            /** Add the border offsets to a rect.
            */
            public Add ($rect: UnityEngine.Rect) : UnityEngine.Rect
            /** Remove the border offsets from a rect.
            */
            public Remove ($rect: UnityEngine.Rect) : UnityEngine.Rect
            public constructor ()
            public constructor ($left: number, $right: number, $top: number, $bottom: number)
        }
        /** Allows to control the dynamic Global Illumination.
        */
        class DynamicGI extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Allows for scaling the contribution coming from real-time & baked lightmaps.
            Note: this value can be set in the Lighting Window UI and it is serialized, that is not the case for other properties in this class.
            */
            public static get indirectScale(): number;
            public static set indirectScale(value: number);
            /** Determines the percentage change in lighting intensity that triggers Unity to recalculate the real-time lightmap.
            */
            public static get updateThreshold(): number;
            public static set updateThreshold(value: number);
            /** The number of milliseconds that can be spent on material updates.
            */
            public static get materialUpdateTimeSlice(): number;
            public static set materialUpdateTimeSlice(value: number);
            /** When enabled, new dynamic Global Illumination output is shown in each frame.
            */
            public static get synchronousMode(): boolean;
            public static set synchronousMode(value: boolean);
            /** Is precomputed Enlighten Realtime Global Illumination output converged?
            */
            public static get isConverged(): boolean;
            /** Allows to set an emissive color for a given renderer quickly, without the need to render the emissive input for the entire system.
            * @param renderer The Renderer that should get a new color.
            * @param color The emissive Color.
            */
            public static SetEmissive ($renderer: UnityEngine.Renderer, $color: UnityEngine.Color) : void
            /** Allows overriding the distant environment lighting for Enlighten Realtime Global Illumination, without changing the Skybox Material.
            * @param input Array of float values to be used for Enlighten Realtime Global Illumination environment lighting.
            */
            public static SetEnvironmentData ($input: System.Array$1<number>) : void
            public static UpdateEnvironment () : void
            public constructor ()
        }
        /** General functionality for all renderers.
        */
        class Renderer extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** The bounding box of the renderer in world space.
            */
            public get bounds(): UnityEngine.Bounds;
            public set bounds(value: UnityEngine.Bounds);
            /** The bounding box of the renderer in local space.
            */
            public get localBounds(): UnityEngine.Bounds;
            public set localBounds(value: UnityEngine.Bounds);
            /** Makes the rendered 3D object visible if enabled.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** Is this renderer visible in any camera? (Read Only)
            */
            public get isVisible(): boolean;
            /** Does this object cast shadows?
            */
            public get shadowCastingMode(): UnityEngine.Rendering.ShadowCastingMode;
            public set shadowCastingMode(value: UnityEngine.Rendering.ShadowCastingMode);
            /** Does this object receive shadows?
            */
            public get receiveShadows(): boolean;
            public set receiveShadows(value: boolean);
            /** Allows turning off rendering for a specific component.
            */
            public get forceRenderingOff(): boolean;
            public set forceRenderingOff(value: boolean);
            /** Is this renderer a static shadow caster?
            */
            public get staticShadowCaster(): boolean;
            public set staticShadowCaster(value: boolean);
            /** Specifies the mode for motion vector rendering.
            */
            public get motionVectorGenerationMode(): UnityEngine.MotionVectorGenerationMode;
            public set motionVectorGenerationMode(value: UnityEngine.MotionVectorGenerationMode);
            /** The light probe interpolation type.
            */
            public get lightProbeUsage(): UnityEngine.Rendering.LightProbeUsage;
            public set lightProbeUsage(value: UnityEngine.Rendering.LightProbeUsage);
            /** Should reflection probes be used for this Renderer?
            */
            public get reflectionProbeUsage(): UnityEngine.Rendering.ReflectionProbeUsage;
            public set reflectionProbeUsage(value: UnityEngine.Rendering.ReflectionProbeUsage);
            /** Determines which rendering layer this renderer lives on.
            */
            public get renderingLayerMask(): number;
            public set renderingLayerMask(value: number);
            /** This value sorts renderers by priority. Lower values are rendered first and higher values are rendered last.
            */
            public get rendererPriority(): number;
            public set rendererPriority(value: number);
            /** Describes how this renderer is updated for ray tracing.
            */
            public get rayTracingMode(): UnityEngine.Experimental.Rendering.RayTracingMode;
            public set rayTracingMode(value: UnityEngine.Experimental.Rendering.RayTracingMode);
            /** Name of the Renderer's sorting layer.
            */
            public get sortingLayerName(): string;
            public set sortingLayerName(value: string);
            /** Unique ID of the Renderer's sorting layer.
            */
            public get sortingLayerID(): number;
            public set sortingLayerID(value: number);
            /** Renderer's order within a sorting layer.
            */
            public get sortingOrder(): number;
            public set sortingOrder(value: number);
            /** Controls if dynamic occlusion culling should be performed for this renderer.
            */
            public get allowOcclusionWhenDynamic(): boolean;
            public set allowOcclusionWhenDynamic(value: boolean);
            /** Indicates whether the renderer is part of a with other renderers.
            */
            public get isPartOfStaticBatch(): boolean;
            /** Matrix that transforms a point from world space into local space (Read Only).
            */
            public get worldToLocalMatrix(): UnityEngine.Matrix4x4;
            /** Matrix that transforms a point from local space into world space (Read Only).
            */
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            /** If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.
            */
            public get lightProbeProxyVolumeOverride(): UnityEngine.GameObject;
            public set lightProbeProxyVolumeOverride(value: UnityEngine.GameObject);
            /** If set, Renderer will use this Transform's position to find the light or reflection probe.
            */
            public get probeAnchor(): UnityEngine.Transform;
            public set probeAnchor(value: UnityEngine.Transform);
            /** The index of the baked lightmap applied to this renderer.
            */
            public get lightmapIndex(): number;
            public set lightmapIndex(value: number);
            /** The index of the real-time lightmap applied to this renderer.
            */
            public get realtimeLightmapIndex(): number;
            public set realtimeLightmapIndex(value: number);
            /** The UV scale & offset used for a lightmap.
            */
            public get lightmapScaleOffset(): UnityEngine.Vector4;
            public set lightmapScaleOffset(value: UnityEngine.Vector4);
            /** The UV scale & offset used for a real-time lightmap.
            */
            public get realtimeLightmapScaleOffset(): UnityEngine.Vector4;
            public set realtimeLightmapScaleOffset(value: UnityEngine.Vector4);
            /** Returns all the instantiated materials of this object.
            */
            public get materials(): System.Array$1<UnityEngine.Material>;
            public set materials(value: System.Array$1<UnityEngine.Material>);
            /** Returns the first instantiated Material assigned to the renderer.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            /** The shared material of this object.
            */
            public get sharedMaterial(): UnityEngine.Material;
            public set sharedMaterial(value: UnityEngine.Material);
            /** All the shared materials of this object.
            */
            public get sharedMaterials(): System.Array$1<UnityEngine.Material>;
            public set sharedMaterials(value: System.Array$1<UnityEngine.Material>);
            public ResetBounds () : void
            public ResetLocalBounds () : void
            public HasPropertyBlock () : boolean
            /** Lets you set or clear per-renderer or per-material parameter overrides.
            * @param properties Property block with values you want to override.
            * @param materialIndex The index of the Material you want to override the parameters of. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
            */
            public SetPropertyBlock ($properties: UnityEngine.MaterialPropertyBlock) : void
            /** Lets you set or clear per-renderer or per-material parameter overrides.
            * @param properties Property block with values you want to override.
            * @param materialIndex The index of the Material you want to override the parameters of. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
            */
            public SetPropertyBlock ($properties: UnityEngine.MaterialPropertyBlock, $materialIndex: number) : void
            /** Get per-Renderer or per-Material property block.
            * @param properties Material parameters to retrieve.
            * @param materialIndex The index of the Material you want to get overridden parameters from. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
            */
            public GetPropertyBlock ($properties: UnityEngine.MaterialPropertyBlock) : void
            /** Get per-Renderer or per-Material property block.
            * @param properties Material parameters to retrieve.
            * @param materialIndex The index of the Material you want to get overridden parameters from. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
            */
            public GetPropertyBlock ($properties: UnityEngine.MaterialPropertyBlock, $materialIndex: number) : void
            public GetMaterials ($m: System.Collections.Generic.List$1<UnityEngine.Material>) : void
            public GetSharedMaterials ($m: System.Collections.Generic.List$1<UnityEngine.Material>) : void
            public GetClosestReflectionProbes ($result: System.Collections.Generic.List$1<UnityEngine.Rendering.ReflectionProbeBlendInfo>) : void
            public constructor ()
        }
        /** General functionality for all renderers.
        */
        interface Renderer {
            /** Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
            */
            UpdateGIMaterials () : void;
        }
        /** Gizmos are used to give visual debugging or setup aids in the Scene view.
        */
        class Gizmos extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Sets the Color of the gizmos that are drawn next.
            */
            public static get color(): UnityEngine.Color;
            public static set color(value: UnityEngine.Color);
            /** Sets the Matrix4x4 that the Unity Editor uses to draw Gizmos.
            */
            public static get matrix(): UnityEngine.Matrix4x4;
            public static set matrix(value: UnityEngine.Matrix4x4);
            /** Set a texture that contains the exposure correction for LightProbe gizmos. The value is sampled from the red channel in the middle of the texture.
            */
            public static get exposure(): UnityEngine.Texture;
            public static set exposure(value: UnityEngine.Texture);
            /** Set a scale for Light Probe gizmos. This scale will be used to render the spherical harmonic preview spheres.
            */
            public static get probeSize(): number;
            /** Draws a line starting at from towards to.
            */
            public static DrawLine ($from: UnityEngine.Vector3, $to: UnityEngine.Vector3) : void
            /** Draws a wireframe sphere with center and radius.
            */
            public static DrawWireSphere ($center: UnityEngine.Vector3, $radius: number) : void
            /** Draws a solid sphere with center and radius.
            */
            public static DrawSphere ($center: UnityEngine.Vector3, $radius: number) : void
            /** Draw a wireframe box with center and size.
            */
            public static DrawWireCube ($center: UnityEngine.Vector3, $size: UnityEngine.Vector3) : void
            /** Draw a solid box at center with size.
            */
            public static DrawCube ($center: UnityEngine.Vector3, $size: UnityEngine.Vector3) : void
            /** Draws a mesh.
            * @param mesh Mesh to draw as a gizmo.
            * @param position Position (default is zero).
            * @param rotation Rotation (default is no rotation).
            * @param scale Scale (default is no scale).
            * @param submeshIndex Submesh to draw (default is -1, which draws whole mesh).
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3) : void
            /** Draws a wireframe mesh.
            * @param mesh Mesh to draw as a gizmo.
            * @param position Position (default is zero).
            * @param rotation Rotation (default is no rotation).
            * @param scale Scale (default is no scale).
            * @param submeshIndex Submesh to draw (default is -1, which draws whole mesh).
            */
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3) : void
            /** Draw an icon at a position in the Scene view.
            */
            public static DrawIcon ($center: UnityEngine.Vector3, $name: string, $allowScaling: boolean) : void
            public static DrawIcon ($center: UnityEngine.Vector3, $name: string, $allowScaling: boolean, $tint: UnityEngine.Color) : void
            /** Draw a texture in the Scene.
            * @param screenRect The size and position of the texture on the "screen" defined by the XY plane.
            * @param texture The texture to be displayed.
            * @param mat An optional material to apply the texture.
            * @param leftBorder Inset from the rectangle's left edge.
            * @param rightBorder Inset from the rectangle's right edge.
            * @param topBorder Inset from the rectangle's top edge.
            * @param bottomBorder Inset from the rectangle's bottom edge.
            */
            public static DrawGUITexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material) : void
            /** Draw a camera frustum using the currently set Gizmos.matrix for its location and rotation.
            * @param center The apex of the truncated pyramid.
            * @param fov Vertical field of view (ie, the angle at the apex in degrees).
            * @param maxRange Distance of the frustum's far plane.
            * @param minRange Distance of the frustum's near plane.
            * @param aspect Width/height ratio.
            */
            public static DrawFrustum ($center: UnityEngine.Vector3, $fov: number, $maxRange: number, $minRange: number, $aspect: number) : void
            /** Draws a ray starting at from to from + direction.
            */
            public static DrawRay ($r: UnityEngine.Ray) : void
            /** Draws a ray starting at from to from + direction.
            */
            public static DrawRay ($from: UnityEngine.Vector3, $direction: UnityEngine.Vector3) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh) : void
            /** Draws a mesh.
            * @param mesh Mesh to draw as a gizmo.
            * @param position Position (default is zero).
            * @param rotation Rotation (default is no rotation).
            * @param scale Scale (default is no scale).
            * @param submeshIndex Submesh to draw (default is -1, which draws whole mesh).
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number) : void
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3) : void
            public static DrawWireMesh ($mesh: UnityEngine.Mesh) : void
            /** Draws a wireframe mesh.
            * @param mesh Mesh to draw as a gizmo.
            * @param position Position (default is zero).
            * @param rotation Rotation (default is no rotation).
            * @param scale Scale (default is no scale).
            * @param submeshIndex Submesh to draw (default is -1, which draws whole mesh).
            */
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3) : void
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3) : void
            public static DrawWireMesh ($mesh: UnityEngine.Mesh, $submeshIndex: number) : void
            /** Draw an icon at a position in the Scene view.
            */
            public static DrawIcon ($center: UnityEngine.Vector3, $name: string) : void
            /** Draw a texture in the Scene.
            * @param screenRect The size and position of the texture on the "screen" defined by the XY plane.
            * @param texture The texture to be displayed.
            * @param mat An optional material to apply the texture.
            * @param leftBorder Inset from the rectangle's left edge.
            * @param rightBorder Inset from the rectangle's right edge.
            * @param topBorder Inset from the rectangle's top edge.
            * @param bottomBorder Inset from the rectangle's bottom edge.
            */
            public static DrawGUITexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture) : void
            /** Draw a texture in the Scene.
            * @param screenRect The size and position of the texture on the "screen" defined by the XY plane.
            * @param texture The texture to be displayed.
            * @param mat An optional material to apply the texture.
            * @param leftBorder Inset from the rectangle's left edge.
            * @param rightBorder Inset from the rectangle's right edge.
            * @param topBorder Inset from the rectangle's top edge.
            * @param bottomBorder Inset from the rectangle's bottom edge.
            */
            public static DrawGUITexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $mat: UnityEngine.Material) : void
            /** Draw a texture in the Scene.
            * @param screenRect The size and position of the texture on the "screen" defined by the XY plane.
            * @param texture The texture to be displayed.
            * @param mat An optional material to apply the texture.
            * @param leftBorder Inset from the rectangle's left edge.
            * @param rightBorder Inset from the rectangle's right edge.
            * @param topBorder Inset from the rectangle's top edge.
            * @param bottomBorder Inset from the rectangle's bottom edge.
            */
            public static DrawGUITexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number) : void
            public constructor ()
        }
        /** A class that allows you to create or modify meshes.
        */
        class Mesh extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Format of the mesh index buffer data.
            */
            public get indexFormat(): UnityEngine.Rendering.IndexFormat;
            public set indexFormat(value: UnityEngine.Rendering.IndexFormat);
            /** Gets the number of vertex buffers present in the Mesh. (Read Only)
            */
            public get vertexBufferCount(): number;
            /** The intended target usage of the Mesh GPU vertex buffer.
            */
            public get vertexBufferTarget(): UnityEngine.GraphicsBuffer.Target;
            public set vertexBufferTarget(value: UnityEngine.GraphicsBuffer.Target);
            /** The intended target usage of the Mesh GPU index buffer.
            */
            public get indexBufferTarget(): UnityEngine.GraphicsBuffer.Target;
            public set indexBufferTarget(value: UnityEngine.GraphicsBuffer.Target);
            /** Returns BlendShape count on this mesh.
            */
            public get blendShapeCount(): number;
            /** The bind poses. The bind pose at each index refers to the bone with the same index.
            */
            public get bindposes(): System.Array$1<UnityEngine.Matrix4x4>;
            public set bindposes(value: System.Array$1<UnityEngine.Matrix4x4>);
            /** Returns true if the Mesh is read/write enabled, or false if it is not.
            */
            public get isReadable(): boolean;
            /** Returns the number of vertices in the Mesh (Read Only).
            */
            public get vertexCount(): number;
            /** The number of sub-meshes inside the Mesh object.
            */
            public get subMeshCount(): number;
            public set subMeshCount(value: number);
            /** The bounding volume of the Mesh.
            */
            public get bounds(): UnityEngine.Bounds;
            public set bounds(value: UnityEngine.Bounds);
            /** Returns a copy of the vertex positions or assigns a new vertex positions array.
            */
            public get vertices(): System.Array$1<UnityEngine.Vector3>;
            public set vertices(value: System.Array$1<UnityEngine.Vector3>);
            /** The normals of the Mesh.
            */
            public get normals(): System.Array$1<UnityEngine.Vector3>;
            public set normals(value: System.Array$1<UnityEngine.Vector3>);
            /** The tangents of the Mesh.
            */
            public get tangents(): System.Array$1<UnityEngine.Vector4>;
            public set tangents(value: System.Array$1<UnityEngine.Vector4>);
            /** The texture coordinates (UVs) in the first channel.
            */
            public get uv(): System.Array$1<UnityEngine.Vector2>;
            public set uv(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the second channel.
            */
            public get uv2(): System.Array$1<UnityEngine.Vector2>;
            public set uv2(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the third channel.
            */
            public get uv3(): System.Array$1<UnityEngine.Vector2>;
            public set uv3(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the fourth channel.
            */
            public get uv4(): System.Array$1<UnityEngine.Vector2>;
            public set uv4(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the fifth channel.
            */
            public get uv5(): System.Array$1<UnityEngine.Vector2>;
            public set uv5(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the sixth channel.
            */
            public get uv6(): System.Array$1<UnityEngine.Vector2>;
            public set uv6(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the seventh channel.
            */
            public get uv7(): System.Array$1<UnityEngine.Vector2>;
            public set uv7(value: System.Array$1<UnityEngine.Vector2>);
            /** The texture coordinates (UVs) in the eighth channel.
            */
            public get uv8(): System.Array$1<UnityEngine.Vector2>;
            public set uv8(value: System.Array$1<UnityEngine.Vector2>);
            /** Vertex colors of the Mesh.
            */
            public get colors(): System.Array$1<UnityEngine.Color>;
            public set colors(value: System.Array$1<UnityEngine.Color>);
            /** Vertex colors of the Mesh.
            */
            public get colors32(): System.Array$1<UnityEngine.Color32>;
            public set colors32(value: System.Array$1<UnityEngine.Color32>);
            /** Returns the number of vertex attributes that the mesh has. (Read Only)
            */
            public get vertexAttributeCount(): number;
            /** An array containing all triangles in the Mesh.
            */
            public get triangles(): System.Array$1<number>;
            public set triangles(value: System.Array$1<number>);
            /** The BoneWeight for each vertex in the Mesh, which represents 4 bones per vertex.
            */
            public get boneWeights(): System.Array$1<UnityEngine.BoneWeight>;
            public set boneWeights(value: System.Array$1<UnityEngine.BoneWeight>);
            /** Sets the index buffer size and format.
            * @param indexCount Size of index buffer.
            * @param format Format of the indices.
            */
            public SetIndexBufferParams ($indexCount: number, $format: UnityEngine.Rendering.IndexFormat) : void
            /** Returns information about a vertex attribute based on its index.
            * @param index The vertex attribute index (0 to vertexAttributeCount-1).
            * @returns Information about the vertex attribute. 
            */
            public GetVertexAttribute ($index: number) : UnityEngine.Rendering.VertexAttributeDescriptor
            /** Checks if a specific vertex data attribute exists on this Mesh.
            * @param attr Vertex data attribute to check for.
            * @returns Returns true if the data attribute is present in the mesh. 
            */
            public HasVertexAttribute ($attr: UnityEngine.Rendering.VertexAttribute) : boolean
            /** Get dimension of a specific vertex data attribute on this Mesh.
            * @param attr Vertex data attribute to check for.
            * @returns Dimensionality of the data attribute, or zero if it is not present. 
            */
            public GetVertexAttributeDimension ($attr: UnityEngine.Rendering.VertexAttribute) : number
            /** Get format of a specific vertex data attribute on this Mesh.
            * @param attr Vertex data attribute to check for.
            * @returns Format of the data attribute. 
            */
            public GetVertexAttributeFormat ($attr: UnityEngine.Rendering.VertexAttribute) : UnityEngine.Rendering.VertexAttributeFormat
            /** Gets the vertex buffer stream index of a specific vertex data attribute on this Mesh.
            * @param attr The vertex data attribute to check for.
            * @returns Stream index of the data attribute, or -1 if it is not present. 
            */
            public GetVertexAttributeStream ($attr: UnityEngine.Rendering.VertexAttribute) : number
            /** Get offset within a vertex buffer stream of a specific vertex data attribute on this Mesh.
            * @param attr The vertex data attribute to check for.
            * @returns The byte offset within a atream of the data attribute, or -1 if it is not present. 
            */
            public GetVertexAttributeOffset ($attr: UnityEngine.Rendering.VertexAttribute) : number
            /** Get vertex buffer stream stride in bytes.
            * @param stream Vertex data stream index to check for.
            * @returns Vertex data size in bytes in this stream, or zero if the stream is not present. 
            */
            public GetVertexBufferStride ($stream: number) : number
            /** Retrieves a native (underlying graphics API) pointer to the vertex buffer.
            * @param index Which vertex buffer to get (some Meshes might have more than one). See vertexBufferCount.
            * @returns Pointer to the underlying graphics API vertex buffer. 
            */
            public GetNativeVertexBufferPtr ($index: number) : System.IntPtr
            public GetNativeIndexBufferPtr () : System.IntPtr
            public ClearBlendShapes () : void
            /** Returns name of BlendShape by given index.
            */
            public GetBlendShapeName ($shapeIndex: number) : string
            /** Returns index of BlendShape by given name.
            */
            public GetBlendShapeIndex ($blendShapeName: string) : number
            /** Returns the frame count for a blend shape.
            * @param shapeIndex The shape index to get frame count from.
            */
            public GetBlendShapeFrameCount ($shapeIndex: number) : number
            /** Returns the weight of a blend shape frame.
            * @param shapeIndex The shape index of the frame.
            * @param frameIndex The frame index to get the weight from.
            */
            public GetBlendShapeFrameWeight ($shapeIndex: number, $frameIndex: number) : number
            /** Retreives deltaVertices, deltaNormals and deltaTangents of a blend shape frame.
            * @param shapeIndex The shape index of the frame.
            * @param frameIndex The frame index to get the weight from.
            * @param deltaVertices Delta vertices output array for the frame being retreived.
            * @param deltaNormals Delta normals output array for the frame being retreived.
            * @param deltaTangents Delta tangents output array for the frame being retreived.
            */
            public GetBlendShapeFrameVertices ($shapeIndex: number, $frameIndex: number, $deltaVertices: System.Array$1<UnityEngine.Vector3>, $deltaNormals: System.Array$1<UnityEngine.Vector3>, $deltaTangents: System.Array$1<UnityEngine.Vector3>) : void
            /** Adds a new blend shape frame.
            * @param shapeName Name of the blend shape to add a frame to.
            * @param frameWeight Weight for the frame being added.
            * @param deltaVertices Delta vertices for the frame being added.
            * @param deltaNormals Delta normals for the frame being added.
            * @param deltaTangents Delta tangents for the frame being added.
            */
            public AddBlendShapeFrame ($shapeName: string, $frameWeight: number, $deltaVertices: System.Array$1<UnityEngine.Vector3>, $deltaNormals: System.Array$1<UnityEngine.Vector3>, $deltaTangents: System.Array$1<UnityEngine.Vector3>) : void
            public SetBoneWeights ($bonesPerVertex: Unity.Collections.NativeArray$1<number>, $weights: Unity.Collections.NativeArray$1<UnityEngine.BoneWeight1>) : void
            public GetAllBoneWeights () : Unity.Collections.NativeArray$1<UnityEngine.BoneWeight1>
            public GetBonesPerVertex () : Unity.Collections.NativeArray$1<number>
            /** Sets the information about a sub-mesh of the Mesh.
            * @param index Sub-mesh index. See subMeshCount. Out of range indices throw an exception.
            * @param desc Sub-mesh data.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetSubMesh ($index: number, $desc: UnityEngine.Rendering.SubMeshDescriptor, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Get information about a sub-mesh of the Mesh.
            * @param index Sub-mesh index. See subMeshCount. Out of range indices throw an exception.
            * @returns Sub-mesh data. 
            */
            public GetSubMesh ($index: number) : UnityEngine.Rendering.SubMeshDescriptor
            public MarkModified () : void
            /** The UV distribution metric can be used to calculate the desired mipmap level based on the position of the camera.
            * @param uvSetIndex UV set index to return the UV distibution metric for. 0 for first.
            * @returns Average of triangle area / uv area. 
            */
            public GetUVDistributionMetric ($uvSetIndex: number) : number
            public GetVertices ($vertices: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public SetVertices ($inVertices: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public SetVertices ($inVertices: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number) : void
            public SetVertices ($inVertices: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Assigns a new vertex positions array.
            * @param inVertices Per-vertex positions.
            */
            public SetVertices ($inVertices: System.Array$1<UnityEngine.Vector3>) : void
            /** Sets the vertex positions of the Mesh, using a part of the input array.
            * @param inVertices Per-vertex positions.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetVertices ($inVertices: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number) : void
            /** Sets the vertex positions of the Mesh, using a part of the input array.
            * @param inVertices Per-vertex positions.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetVertices ($inVertices: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public GetNormals ($normals: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public SetNormals ($inNormals: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public SetNormals ($inNormals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number) : void
            public SetNormals ($inNormals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Set the normals of the Mesh.
            * @param inNormals Per-vertex normals.
            */
            public SetNormals ($inNormals: System.Array$1<UnityEngine.Vector3>) : void
            /** Sets the vertex normals of the Mesh, using a part of the input array.
            * @param inNormals Per-vertex normals.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetNormals ($inNormals: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number) : void
            /** Sets the vertex normals of the Mesh, using a part of the input array.
            * @param inNormals Per-vertex normals.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetNormals ($inNormals: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public GetTangents ($tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public SetTangents ($inTangents: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public SetTangents ($inTangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number) : void
            public SetTangents ($inTangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Set the tangents of the Mesh.
            * @param inTangents Per-vertex tangents.
            */
            public SetTangents ($inTangents: System.Array$1<UnityEngine.Vector4>) : void
            /** Sets the tangents of the Mesh, using a part of the input array.
            * @param inTangents Per-vertex tangents.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetTangents ($inTangents: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number) : void
            /** Sets the tangents of the Mesh, using a part of the input array.
            * @param inTangents Per-vertex tangents.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetTangents ($inTangents: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public GetColors ($colors: System.Collections.Generic.List$1<UnityEngine.Color>) : void
            public SetColors ($inColors: System.Collections.Generic.List$1<UnityEngine.Color>) : void
            public SetColors ($inColors: System.Collections.Generic.List$1<UnityEngine.Color>, $start: number, $length: number) : void
            public SetColors ($inColors: System.Collections.Generic.List$1<UnityEngine.Color>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Set the per-vertex colors of the Mesh.
            * @param inColors Per-vertex colors.
            */
            public SetColors ($inColors: System.Array$1<UnityEngine.Color>) : void
            /** Sets the per-vertex colors of the Mesh, using a part of the input array.
            * @param inColors Per-vertex colors.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetColors ($inColors: System.Array$1<UnityEngine.Color>, $start: number, $length: number) : void
            /** Sets the per-vertex colors of the Mesh, using a part of the input array.
            * @param inColors Per-vertex colors.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetColors ($inColors: System.Array$1<UnityEngine.Color>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public GetColors ($colors: System.Collections.Generic.List$1<UnityEngine.Color32>) : void
            public SetColors ($inColors: System.Collections.Generic.List$1<UnityEngine.Color32>) : void
            public SetColors ($inColors: System.Collections.Generic.List$1<UnityEngine.Color32>, $start: number, $length: number) : void
            public SetColors ($inColors: System.Collections.Generic.List$1<UnityEngine.Color32>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Set the per-vertex colors of the Mesh.
            * @param inColors Per-vertex colors.
            */
            public SetColors ($inColors: System.Array$1<UnityEngine.Color32>) : void
            /** Sets the per-vertex colors of the Mesh, using a part of the input array.
            * @param inColors Per-vertex colors.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetColors ($inColors: System.Array$1<UnityEngine.Color32>, $start: number, $length: number) : void
            /** Sets the per-vertex colors of the Mesh, using a part of the input array.
            * @param inColors Per-vertex colors.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetColors ($inColors: System.Array$1<UnityEngine.Color32>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>, $start: number, $length: number) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number) : void
            public SetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Sets the texture coordinates (UVs) stored in a given channel.
            * @param channel The channel, in [0..7] range.
            * @param uvs The UV data to set.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector2>) : void
            /** Sets the texture coordinates (UVs) stored in a given channel.
            * @param channel The channel, in [0..7] range.
            * @param uvs The UV data to set.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector3>) : void
            /** Sets the texture coordinates (UVs) stored in a given channel.
            * @param channel The channel, in [0..7] range.
            * @param uvs The UV data to set.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector4>) : void
            /** Sets the UVs of the Mesh, using a part of the input array.
            * @param channel The UV channel, in [0..7] range.
            * @param uvs UVs to set for the given index.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector2>, $start: number, $length: number) : void
            /** Sets the UVs of the Mesh, using a part of the input array.
            * @param channel The UV channel, in [0..7] range.
            * @param uvs UVs to set for the given index.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector2>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Sets the UVs of the Mesh, using a part of the input array.
            * @param channel The UV channel, in [0..7] range.
            * @param uvs UVs to set for the given index.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number) : void
            /** Sets the UVs of the Mesh, using a part of the input array.
            * @param channel The UV channel, in [0..7] range.
            * @param uvs UVs to set for the given index.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Sets the UVs of the Mesh, using a part of the input array.
            * @param channel The UV channel, in [0..7] range.
            * @param uvs UVs to set for the given index.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number) : void
            /** Sets the UVs of the Mesh, using a part of the input array.
            * @param channel The UV channel, in [0..7] range.
            * @param uvs UVs to set for the given index.
            * @param start Index of the first element to take from the input array.
            * @param length Number of elements to take from the input array.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetUVs ($channel: number, $uvs: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            public GetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            public GetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public GetUVs ($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public GetVertexAttributes () : System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>
            /** Get information about vertex attributes of a Mesh, without memory allocations.
            * @param attributes Collection of vertex attributes to receive the results.
            * @returns The number of vertex attributes returned in the attributes container. 
            */
            public GetVertexAttributes ($attributes: System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>) : number
            public GetVertexAttributes ($attributes: System.Collections.Generic.List$1<UnityEngine.Rendering.VertexAttributeDescriptor>) : number
            /** Sets the vertex buffer size and layout.
            * @param vertexCount The number of vertices in the Mesh.
            * @param attributes Layout of the vertex data -- which attributes are present, their data types and so on.
            */
            public SetVertexBufferParams ($vertexCount: number, ...attributes: UnityEngine.Rendering.VertexAttributeDescriptor[]) : void
            public SetVertexBufferParams ($vertexCount: number, $attributes: Unity.Collections.NativeArray$1<UnityEngine.Rendering.VertexAttributeDescriptor>) : void
            /** Gets a snapshot of Mesh data for read-only access.
            * @param mesh The input mesh.
            * @param meshes The input meshes.
            * @returns Returns a MeshDataArray containing read-only MeshData structs. See Mesh.MeshDataArray and Mesh.MeshData. 
            */
            public static AcquireReadOnlyMeshData ($mesh: UnityEngine.Mesh) : UnityEngine.Mesh.MeshDataArray
            /** Gets a snapshot of Mesh data for read-only access.
            * @param mesh The input mesh.
            * @param meshes The input meshes.
            * @returns Returns a MeshDataArray containing read-only MeshData structs. See Mesh.MeshDataArray and Mesh.MeshData. 
            */
            public static AcquireReadOnlyMeshData ($meshes: System.Array$1<UnityEngine.Mesh>) : UnityEngine.Mesh.MeshDataArray
            public static AcquireReadOnlyMeshData ($meshes: System.Collections.Generic.List$1<UnityEngine.Mesh>) : UnityEngine.Mesh.MeshDataArray
            /** Allocates data structures for Mesh creation using C# Jobs.
            * @param meshCount The amount of meshes that will be created.
            * @returns Returns a MeshDataArray containing writeable MeshData structs. See Mesh.MeshDataArray and Mesh.MeshData. 
            */
            public static AllocateWritableMeshData ($meshCount: number) : UnityEngine.Mesh.MeshDataArray
            public static ApplyAndDisposeWritableMeshData ($data: UnityEngine.Mesh.MeshDataArray, $mesh: UnityEngine.Mesh, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            public static ApplyAndDisposeWritableMeshData ($data: UnityEngine.Mesh.MeshDataArray, $meshes: System.Array$1<UnityEngine.Mesh>, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            public static ApplyAndDisposeWritableMeshData ($data: UnityEngine.Mesh.MeshDataArray, $meshes: System.Collections.Generic.List$1<UnityEngine.Mesh>, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Retrieves a GraphicsBuffer that provides direct acces to the GPU vertex buffer.
            * @param index Vertex data stream index to get the buffer for.
            * @returns The mesh vertex buffer as a GraphicsBuffer. 
            */
            public GetVertexBuffer ($index: number) : UnityEngine.GraphicsBuffer
            public GetIndexBuffer () : UnityEngine.GraphicsBuffer
            /** Fetches the triangle list for the specified sub-mesh on this object.
            * @param triangles A list of vertex indices to populate. Any existing items in the list are replaced.
            * @param submesh The sub-mesh index. See subMeshCount.
            * @param applyBaseVertex True (default value) will apply base vertex offset to returned indices.
            */
            public GetTriangles ($submesh: number) : System.Array$1<number>
            /** Fetches the triangle list for the specified sub-mesh on this object.
            * @param triangles A list of vertex indices to populate. Any existing items in the list are replaced.
            * @param submesh The sub-mesh index. See subMeshCount.
            * @param applyBaseVertex True (default value) will apply base vertex offset to returned indices.
            */
            public GetTriangles ($submesh: number, $applyBaseVertex: boolean) : System.Array$1<number>
            public GetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number) : void
            public GetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex: boolean) : void
            public GetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex?: boolean) : void
            /** Fetches the index list for the specified sub-mesh.
            * @param submesh The sub-mesh index. See subMeshCount.
            * @param applyBaseVertex True (default value) will apply base vertex offset to returned indices.
            * @returns Array with face indices. 
            */
            public GetIndices ($submesh: number) : System.Array$1<number>
            /** Fetches the index list for the specified sub-mesh.
            * @param submesh The sub-mesh index. See subMeshCount.
            * @param applyBaseVertex True (default value) will apply base vertex offset to returned indices.
            * @returns Array with face indices. 
            */
            public GetIndices ($submesh: number, $applyBaseVertex: boolean) : System.Array$1<number>
            public GetIndices ($indices: System.Collections.Generic.List$1<number>, $submesh: number) : void
            public GetIndices ($indices: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex: boolean) : void
            public GetIndices ($indices: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex?: boolean) : void
            /** Gets the starting index location within the Mesh's index buffer, for the given sub-mesh.
            */
            public GetIndexStart ($submesh: number) : number
            /** Gets the index count of the given sub-mesh.
            */
            public GetIndexCount ($submesh: number) : number
            /** Gets the base vertex index of the given sub-mesh.
            * @param submesh The sub-mesh index. See subMeshCount.
            * @returns The offset applied to all vertex indices of this sub-mesh. 
            */
            public GetBaseVertex ($submesh: number) : number
            /** Sets the triangle list for the sub-mesh.
            * @param triangles The list of indices that define the triangles.
            * @param submesh The sub-mesh to modify.
            * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
            * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
            */
            public SetTriangles ($triangles: System.Array$1<number>, $submesh: number) : void
            /** Sets the triangle list for the sub-mesh.
            * @param triangles The list of indices that define the triangles.
            * @param submesh The sub-mesh to modify.
            * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
            * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
            */
            public SetTriangles ($triangles: System.Array$1<number>, $submesh: number, $calculateBounds: boolean) : void
            /** Sets the triangle list for the sub-mesh.
            * @param triangles The list of indices that define the triangles.
            * @param submesh The sub-mesh to modify.
            * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
            * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
            */
            public SetTriangles ($triangles: System.Array$1<number>, $submesh: number, $calculateBounds: boolean, $baseVertex: number) : void
            /** Sets the triangle list of the Mesh, using a part of the input array.
            * @param triangles The list of indices that define the triangles.
            * @param trianglesStart Index of the first element to take from the input array.
            * @param trianglesLength Number of elements to take from the input array.
            * @param submesh The sub-mesh to modify.
            * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
            * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
            */
            public SetTriangles ($triangles: System.Array$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            /** Sets the triangle list for the sub-mesh.
            * @param triangles The list of indices that define the triangles.
            * @param submesh The sub-mesh to modify.
            * @param calculateBounds Calculate the bounding box of the Mesh after setting the triangles. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.
            * @param baseVertex Optional vertex offset that is added to all triangle vertex indices.
            */
            public SetTriangles ($triangles: System.Array$1<number>, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            public SetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number) : void
            public SetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $calculateBounds: boolean) : void
            public SetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $calculateBounds: boolean, $baseVertex: number) : void
            public SetTriangles ($triangles: System.Collections.Generic.List$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            public SetTriangles ($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            /** Sets the index buffer for the sub-mesh.
            * @param indices The array of indices that define the mesh faces.
            * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
            * @param submesh The sub-mesh to modify.
            * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
            * @param baseVertex Optional vertex offset that is added to all vertex indices.
            */
            public SetIndices ($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number) : void
            /** Sets the index buffer for the sub-mesh.
            * @param indices The array of indices that define the mesh faces.
            * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
            * @param submesh The sub-mesh to modify.
            * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
            * @param baseVertex Optional vertex offset that is added to all vertex indices.
            */
            public SetIndices ($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds: boolean) : void
            /** Sets the index buffer for the sub-mesh.
            * @param indices The array of indices that define the mesh faces.
            * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
            * @param submesh The sub-mesh to modify.
            * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
            * @param baseVertex Optional vertex offset that is added to all vertex indices.
            */
            public SetIndices ($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds: boolean, $baseVertex: number) : void
            /** Sets the index buffer of a sub-mesh, using a part of the input array.
            * @param indices The array of indices that define the mesh faces.
            * @param indicesStart Index of the first element to take from the input array.
            * @param indicesLength Number of elements to take from the input array.
            * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
            * @param submesh The sub-mesh to modify.
            * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
            * @param baseVertex Optional vertex offset that is added to all vertex indices.
            */
            public SetIndices ($indices: System.Array$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            /** Sets the index buffer for the sub-mesh.
            * @param indices The array of indices that define the mesh faces.
            * @param topology The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See MeshTopology.
            * @param submesh The sub-mesh to modify.
            * @param calculateBounds Calculate the bounding box of the Mesh after setting the indices. This is done by default.
            Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.
            * @param baseVertex Optional vertex offset that is added to all vertex indices.
            */
            public SetIndices ($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            public SetIndices ($indices: System.Collections.Generic.List$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            public SetIndices ($indices: System.Collections.Generic.List$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number) : void
            /** Sets information defining all sub-meshes in this Mesh, replacing any existing sub-meshes.
            * @param desc An array or list of sub-mesh data descriptors.
            * @param start Index of the first element to take from the array or list in desc.
            * @param count Number of elements to take from the array or list in desc.
            * @param flags (Optional) Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetSubMeshes ($desc: System.Array$1<UnityEngine.Rendering.SubMeshDescriptor>, $start: number, $count: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Sets information defining all sub-meshes in this Mesh, replacing any existing sub-meshes.
            * @param desc An array or list of sub-mesh data descriptors.
            * @param start Index of the first element to take from the array or list in desc.
            * @param count Number of elements to take from the array or list in desc.
            * @param flags (Optional) Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public SetSubMeshes ($desc: System.Array$1<UnityEngine.Rendering.SubMeshDescriptor>, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            public SetSubMeshes ($desc: System.Collections.Generic.List$1<UnityEngine.Rendering.SubMeshDescriptor>, $start: number, $count: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            public SetSubMeshes ($desc: System.Collections.Generic.List$1<UnityEngine.Rendering.SubMeshDescriptor>, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
            public GetBindposes ($bindposes: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public GetBoneWeights ($boneWeights: System.Collections.Generic.List$1<UnityEngine.BoneWeight>) : void
            /** Clears all vertex data and all triangle indices.
            * @param keepVertexLayout True if the existing Mesh data layout should be preserved.
            */
            public Clear ($keepVertexLayout: boolean) : void
            /** Clears all vertex data and all triangle indices.
            * @param keepVertexLayout True if the existing Mesh data layout should be preserved.
            */
            public Clear () : void
            /** Recalculate the bounding volume of the Mesh from the vertices.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public RecalculateBounds () : void
            /** Recalculates the normals of the Mesh from the triangles and vertices.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public RecalculateNormals () : void
            /** Recalculates the tangents of the Mesh from the normals and texture coordinates.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public RecalculateTangents () : void
            /** Recalculate the bounding volume of the Mesh from the vertices.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public RecalculateBounds ($flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Recalculates the normals of the Mesh from the triangles and vertices.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public RecalculateNormals ($flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Recalculates the tangents of the Mesh from the normals and texture coordinates.
            * @param flags Flags controlling the function behavior, see MeshUpdateFlags.
            */
            public RecalculateTangents ($flags: UnityEngine.Rendering.MeshUpdateFlags) : void
            /** Recalculates the UV distribution metric of the Mesh from the vertices and uv coordinates.
            * @param uvSetIndex The UV set index to set the UV distibution metric for. Use 0 for first index.
            * @param uvAreaThreshold The minimum UV area to consider. The default value is 1e-9f.
            */
            public RecalculateUVDistributionMetric ($uvSetIndex: number, $uvAreaThreshold?: number) : void
            /** Recalculates the UV distribution metrics of the Mesh from the vertices and uv coordinates.
            * @param uvAreaThreshold The minimum UV area to consider. The default value is 1e-9f.
            */
            public RecalculateUVDistributionMetrics ($uvAreaThreshold?: number) : void
            public MarkDynamic () : void
            /** Upload previously done Mesh modifications to the graphics API.
            * @param markNoLongerReadable Frees up system memory copy of mesh data when set to true.
            */
            public UploadMeshData ($markNoLongerReadable: boolean) : void
            public Optimize () : void
            public OptimizeIndexBuffers () : void
            public OptimizeReorderVertexBuffer () : void
            /** Gets the topology of a sub-mesh.
            */
            public GetTopology ($submesh: number) : UnityEngine.MeshTopology
            /** Combines several Meshes into this Mesh.
            * @param combine Descriptions of the Meshes to combine.
            * @param mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
            * @param useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
            * @param hasLightmapData Defines whether to transform the input Mesh lightmap UV data using the lightmap scale offset data in CombineInstance structs.
            */
            public CombineMeshes ($combine: System.Array$1<UnityEngine.CombineInstance>, $mergeSubMeshes: boolean, $useMatrices: boolean, $hasLightmapData: boolean) : void
            /** Combines several Meshes into this Mesh.
            * @param combine Descriptions of the Meshes to combine.
            * @param mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
            * @param useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
            * @param hasLightmapData Defines whether to transform the input Mesh lightmap UV data using the lightmap scale offset data in CombineInstance structs.
            */
            public CombineMeshes ($combine: System.Array$1<UnityEngine.CombineInstance>, $mergeSubMeshes: boolean, $useMatrices: boolean) : void
            /** Combines several Meshes into this Mesh.
            * @param combine Descriptions of the Meshes to combine.
            * @param mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
            * @param useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
            * @param hasLightmapData Defines whether to transform the input Mesh lightmap UV data using the lightmap scale offset data in CombineInstance structs.
            */
            public CombineMeshes ($combine: System.Array$1<UnityEngine.CombineInstance>, $mergeSubMeshes: boolean) : void
            /** Combines several Meshes into this Mesh.
            * @param combine Descriptions of the Meshes to combine.
            * @param mergeSubMeshes Defines whether Meshes should be combined into a single sub-mesh.
            * @param useMatrices Defines whether the transforms supplied in the CombineInstance array should be used or ignored.
            * @param hasLightmapData Defines whether to transform the input Mesh lightmap UV data using the lightmap scale offset data in CombineInstance structs.
            */
            public CombineMeshes ($combine: System.Array$1<UnityEngine.CombineInstance>) : void
            public constructor ()
        }
        /** Use this BeforeRenderOrderAttribute when you need to specify a custom callback order for Application.onBeforeRender.
        */
        class BeforeRenderOrderAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The order, lowest to highest, that the Application.onBeforeRender event recievers will be called in.
            */
            public get order(): number;
            public constructor ($order: number)
            public constructor ()
        }
        /** BillboardAsset describes how a billboard is rendered.
        */
        class BillboardAsset extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Width of the billboard.
            */
            public get width(): number;
            public set width(value: number);
            /** Height of the billboard.
            */
            public get height(): number;
            public set height(value: number);
            /** Height of the billboard that is below ground.
            */
            public get bottom(): number;
            public set bottom(value: number);
            /** Number of pre-rendered images that can be switched when the billboard is viewed from different angles.
            */
            public get imageCount(): number;
            /** Number of vertices in the billboard mesh.
            */
            public get vertexCount(): number;
            /** Number of indices in the billboard mesh.
            */
            public get indexCount(): number;
            /** The material used for rendering.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public GetImageTexCoords ($imageTexCoords: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public GetImageTexCoords () : System.Array$1<UnityEngine.Vector4>
            public SetImageTexCoords ($imageTexCoords: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** Set the array of billboard image texture coordinate data.
            * @param imageTexCoords The array of data to set.
            */
            public SetImageTexCoords ($imageTexCoords: System.Array$1<UnityEngine.Vector4>) : void
            public GetVertices ($vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            public GetVertices () : System.Array$1<UnityEngine.Vector2>
            public SetVertices ($vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            /** Set the vertices of the billboard mesh.
            * @param vertices The array of data to set.
            */
            public SetVertices ($vertices: System.Array$1<UnityEngine.Vector2>) : void
            public GetIndices ($indices: System.Collections.Generic.List$1<number>) : void
            public GetIndices () : System.Array$1<number>
            public SetIndices ($indices: System.Collections.Generic.List$1<number>) : void
            /** Set the indices of the billboard mesh.
            * @param indices The array of data to set.
            */
            public SetIndices ($indices: System.Array$1<number>) : void
            public constructor ()
        }
        /** Renders a billboard from a BillboardAsset.
        */
        class BillboardRenderer extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
            /** The BillboardAsset to render.
            */
            public get billboard(): UnityEngine.BillboardAsset;
            public set billboard(value: UnityEngine.BillboardAsset);
            public constructor ()
        }
        /** Custom Render Texture Manager.
        */
        class CustomRenderTextureManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static add_textureLoaded ($value: System.Action$1<UnityEngine.CustomRenderTexture>) : void
            public static remove_textureLoaded ($value: System.Action$1<UnityEngine.CustomRenderTexture>) : void
            public static add_textureUnloaded ($value: System.Action$1<UnityEngine.CustomRenderTexture>) : void
            public static remove_textureUnloaded ($value: System.Action$1<UnityEngine.CustomRenderTexture>) : void
            public static GetAllCustomRenderTextures ($currentCustomRenderTextures: System.Collections.Generic.List$1<UnityEngine.CustomRenderTexture>) : void
            public static add_updateTriggered ($value: System.Action$2<UnityEngine.CustomRenderTexture, number>) : void
            public static remove_updateTriggered ($value: System.Action$2<UnityEngine.CustomRenderTexture, number>) : void
            public static add_initializeTriggered ($value: System.Action$1<UnityEngine.CustomRenderTexture>) : void
            public static remove_initializeTriggered ($value: System.Action$1<UnityEngine.CustomRenderTexture>) : void
        }
        /** Custom Render Textures are an extension to Render Textures that allow you to render directly to the Texture using a Shader.
        */
        class CustomRenderTexture extends UnityEngine.RenderTexture
        {
            protected [__keep_incompatibility]: never;
            /** The Material that Unity uses to initialize the content of a Custom Render Texture.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            /** The Material that Unity uses to initialize a Custom Render Texture. Initialization texture and color are ignored if you have set this parameter.
            */
            public get initializationMaterial(): UnityEngine.Material;
            public set initializationMaterial(value: UnityEngine.Material);
            /** The Texture that Unity uses to initialize a Custom Render Texture, multiplied by the initialization color. Unity ignores this parameter if an initializationMaterial is set.
            */
            public get initializationTexture(): UnityEngine.Texture;
            public set initializationTexture(value: UnityEngine.Texture);
            /** Determine if Unity initializes the Custom Render Texture with a Texture and a Color or a Material.
            */
            public get initializationSource(): UnityEngine.CustomRenderTextureInitializationSource;
            public set initializationSource(value: UnityEngine.CustomRenderTextureInitializationSource);
            /** The color that Unity uses to initialize a Custom Render Texture. Unity ignores this parameter if an initializationMaterial is set.
            */
            public get initializationColor(): UnityEngine.Color;
            public set initializationColor(value: UnityEngine.Color);
            /** Determine how Unity updates the Custom Render Texture.
            */
            public get updateMode(): UnityEngine.CustomRenderTextureUpdateMode;
            public set updateMode(value: UnityEngine.CustomRenderTextureUpdateMode);
            /** Determine how Unity initializes a texture.
            */
            public get initializationMode(): UnityEngine.CustomRenderTextureUpdateMode;
            public set initializationMode(value: UnityEngine.CustomRenderTextureUpdateMode);
            /** The space in which Unity expresses update zones. You can set this to Normalized or Pixel space.
            */
            public get updateZoneSpace(): UnityEngine.CustomRenderTextureUpdateZoneSpace;
            public set updateZoneSpace(value: UnityEngine.CustomRenderTextureUpdateZoneSpace);
            /** The Shader Pass Unity uses to update the Custom Render Texture.
            */
            public get shaderPass(): number;
            public set shaderPass(value: number);
            /** The bit field that you can use to enable or disable update on each of the cubemap faces. The bit order from least to most significant bit is as follows: +X, -X, +Y, -Y, +Z, -Z.
            */
            public get cubemapFaceMask(): number;
            public set cubemapFaceMask(value: number);
            /** When this parameter is set to true, Unity double-buffers the Custom Render Texture so that you can access it during its own update.
            */
            public get doubleBuffered(): boolean;
            public set doubleBuffered(value: boolean);
            /** When this parameter is set to true, Unity wraps Update zones around the border of the Custom Render Texture. Otherwise, Unity clamps Update zones at the border of the Custom Render Texture.
            */
            public get wrapUpdateZones(): boolean;
            public set wrapUpdateZones(value: boolean);
            /** The period in seconds that Unity updates real-time Custom Render Textures. A value of 0.0 means Unity updates real-time Custom Render Textures every frame.
            */
            public get updatePeriod(): number;
            public set updatePeriod(value: number);
            /** Triggers an update of the Custom Render Texture.
            * @param count Number of upate pass to perform. The default value of this count parameter is 1.
            */
            public Update ($count: number) : void
            public Update () : void
            public Initialize () : void
            public ClearUpdateZones () : void
            public GetUpdateZones ($updateZones: System.Collections.Generic.List$1<UnityEngine.CustomRenderTextureUpdateZone>) : void
            public GetDoubleBufferRenderTexture () : UnityEngine.RenderTexture
            public EnsureDoubleBufferConsistency () : void
            /** Setup the list of Update Zones for the Custom Render Texture.
            */
            public SetUpdateZones ($updateZones: System.Array$1<UnityEngine.CustomRenderTextureUpdateZone>) : void
            public constructor ($width: number, $height: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite)
            public constructor ($width: number, $height: number, $format: UnityEngine.RenderTextureFormat)
            public constructor ($width: number, $height: number)
            public constructor ($width: number, $height: number, $defaultFormat: UnityEngine.Experimental.Rendering.DefaultFormat)
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($desc: UnityEngine.RenderTextureDescriptor)
            public constructor ($textureToCopy: UnityEngine.RenderTexture)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat)
            public constructor ($width: number, $height: number, $depth: number)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $mipCount: number)
            public constructor ()
        }
        /** Provides access to a display / screen for rendering operations.
        */
        class Display extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The list of connected displays.
            */
            public static displays : System.Array$1<UnityEngine.Display>
            /** Horizontal resolution that the display is rendering at.
            */
            public get renderingWidth(): number;
            /** Vertical resolution that the display is rendering at.
            */
            public get renderingHeight(): number;
            /** Horizontal native display resolution.
            */
            public get systemWidth(): number;
            /** Vertical native display resolution.
            */
            public get systemHeight(): number;
            /** Color RenderBuffer.
            */
            public get colorBuffer(): UnityEngine.RenderBuffer;
            /** Depth RenderBuffer.
            */
            public get depthBuffer(): UnityEngine.RenderBuffer;
            /** Gets the state of the display and returns true if the display is active and false if otherwise.
            */
            public get active(): boolean;
            /** True when the back buffer requires an intermediate texture to render.
            */
            public get requiresBlitToBackbuffer(): boolean;
            /** True when doing a blit to the back buffer requires manual color space conversion.
            */
            public get requiresSrgbBlitToBackbuffer(): boolean;
            /** Main Display.
            */
            public static get main(): UnityEngine.Display;
            /** Get the Editors active GameView display target.
            */
            public static get activeEditorGameViewTarget(): number;
            public Activate () : void
            public Activate ($width: number, $height: number, $refreshRate: number) : void
            /** Windows platforms only. Sets rendering size and position on screen.
            * @param width Windows platforms only. The width of the window.
            * @param height Windows platforms only. The height of the window.
            * @param x Windows platforms only. The x position of the window.
            * @param y Windows platforms only. The y position of the window.
            */
            public SetParams ($width: number, $height: number, $x: number, $y: number) : void
            /** Sets rendering resolution for the display.
            * @param w The rendering width in pixels.
            * @param h The rendering height in pixels.
            */
            public SetRenderingResolution ($w: number, $h: number) : void
            /** Query relative mouse coordinates.
            * @param inputMouseCoordinates Mouse Input Position as Coordinates.
            */
            public static RelativeMouseAt ($inputMouseCoordinates: UnityEngine.Vector3) : UnityEngine.Vector3
            public static add_onDisplaysUpdated ($value: UnityEngine.Display.DisplaysUpdatedDelegate) : void
            public static remove_onDisplaysUpdated ($value: UnityEngine.Display.DisplaysUpdatedDelegate) : void
        }
        /** Sets the full-screen mode. See the description of each mode for information on platform compatibility.
        */
        enum FullScreenMode
        { ExclusiveFullScreen = 0, FullScreenWindow = 1, MaximizedWindow = 2, Windowed = 3 }
        /** Represents the display refresh rate. This is how many frames the display can show per second.
        */
        class RefreshRate extends System.ValueType implements System.IEquatable$1<UnityEngine.RefreshRate>
        {
            protected [__keep_incompatibility]: never;
            /** Numerator of the refresh rate fraction.
            */
            public numerator : number
            /** Denominator of the refresh rate fraction.
            */
            public denominator : number
            /** The numerical value of the refresh rate in hertz.
            */
            public get value(): number;
            public Equals ($other: UnityEngine.RefreshRate) : boolean
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        /** Represents a connected display.
        */
        class DisplayInfo extends System.ValueType implements System.IEquatable$1<UnityEngine.DisplayInfo>
        {
            protected [__keep_incompatibility]: never;
            /** The display width in pixels.
            */
            public width : number
            /** The display height in pixels.
            */
            public height : number
            /** The current refresh rate of the display.
            */
            public refreshRate : UnityEngine.RefreshRate
            /** Specifies the work area rectangle of the display relative to the top left corner. For example, it excludes the area covered by the macOS Dock or the Windows Taskbar.
            */
            public workArea : UnityEngine.RectInt
            /** Human-friendly display name.
            */
            public name : string
            public Equals ($other: UnityEngine.DisplayInfo) : boolean
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        /** Constants for special values of Screen.sleepTimeout.
        */
        class SleepTimeout extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Prevent screen dimming.
            */
            public static NeverSleep : number
            /** Set the sleep timeout to whatever the user has specified in the system settings.
            */
            public static SystemSetting : number
            public constructor ()
        }
        /** Provides access to display information.
        */
        class Screen extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The current width of the screen window in pixels (Read Only).
            */
            public static get width(): number;
            /** The current height of the screen window in pixels (Read Only).
            */
            public static get height(): number;
            /** The current DPI of the screen / device (Read Only).
            */
            public static get dpi(): number;
            /** The current screen resolution (Read Only).
            */
            public static get currentResolution(): UnityEngine.Resolution;
            /** Returns all full-screen resolutions that the monitor supports (Read Only).
            */
            public static get resolutions(): System.Array$1<UnityEngine.Resolution>;
            /** Enables full-screen mode for the application.
            */
            public static get fullScreen(): boolean;
            public static set fullScreen(value: boolean);
            /** Set this property to one of the values in FullScreenMode to change the display mode of your application.
            */
            public static get fullScreenMode(): UnityEngine.FullScreenMode;
            public static set fullScreenMode(value: UnityEngine.FullScreenMode);
            /** Returns the safe area of the screen in pixels (Read Only).
            */
            public static get safeArea(): UnityEngine.Rect;
            /** Returns a list of screen areas that are not functional for displaying content (Read Only).
            */
            public static get cutouts(): System.Array$1<UnityEngine.Rect>;
            /** Enables auto-rotation to portrait.
            */
            public static get autorotateToPortrait(): boolean;
            public static set autorotateToPortrait(value: boolean);
            /** Enables auto-rotation to portrait, upside down.
            */
            public static get autorotateToPortraitUpsideDown(): boolean;
            public static set autorotateToPortraitUpsideDown(value: boolean);
            /** Enables auto-rotation to landscape left.
            */
            public static get autorotateToLandscapeLeft(): boolean;
            public static set autorotateToLandscapeLeft(value: boolean);
            /** Enables auto-rotation to landscape right.
            */
            public static get autorotateToLandscapeRight(): boolean;
            public static set autorotateToLandscapeRight(value: boolean);
            /** Specifies logical orientation of the screen.
            */
            public static get orientation(): UnityEngine.ScreenOrientation;
            public static set orientation(value: UnityEngine.ScreenOrientation);
            /** A power saving setting, allowing the screen to dim some time after the last active user interaction.
            */
            public static get sleepTimeout(): number;
            public static set sleepTimeout(value: number);
            /** The current brightness of the screen.
            */
            public static get brightness(): number;
            public static set brightness(value: number);
            /** The position of the top left corner of the main window relative to the top left corner of the display.
            */
            public static get mainWindowPosition(): UnityEngine.Vector2Int;
            /** The display information associated with the display that the main application window is on.
            */
            public static get mainWindowDisplayInfo(): UnityEngine.DisplayInfo;
            /** Switches the screen resolution.
            */
            public static SetResolution ($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode, $preferredRefreshRate: number) : void
            /** Switches the screen resolution.
            */
            public static SetResolution ($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode) : void
            /** Switches the screen resolution.
            */
            public static SetResolution ($width: number, $height: number, $fullscreen: boolean, $preferredRefreshRate: number) : void
            /** Switches the screen resolution.
            */
            public static SetResolution ($width: number, $height: number, $fullscreen: boolean) : void
            public static GetDisplayLayout ($displayLayout: System.Collections.Generic.List$1<UnityEngine.DisplayInfo>) : void
            /** Moves the main window to the specified position relative to the top left corner of the specified display. Position value is represented in pixels. Moving the window is an asynchronous operation, which can take multiple frames.
            * @param display The target display where the window should move to.
            * @param position The position the window moves to. Relative to the top left corner of the specified display in pixels.
            * @returns Returns AsyncOperation that represents moving the window. 
            */
            public static MoveMainWindowTo ($display: $Ref<UnityEngine.DisplayInfo>, $position: UnityEngine.Vector2Int) : UnityEngine.AsyncOperation
            public constructor ()
        }
        /** Describes screen orientation.
        */
        enum ScreenOrientation
        { Unknown = 0, Landscape = 3, Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, AutoRotation = 5 }
        /** Intended usage of the buffer.
        */
        enum ComputeBufferMode
        { Immutable = 0, Dynamic = 1, Circular = 2, StreamOut = 3, SubUpdates = 4 }
        /** Raw interface to Unity's drawing functions.
        */
        class Graphics extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns the currently active color gamut.
            */
            public static get activeColorGamut(): UnityEngine.ColorGamut;
            /** The GraphicsTier for the current device.
            */
            public static get activeTier(): UnityEngine.Rendering.GraphicsTier;
            public static set activeTier(value: UnityEngine.Rendering.GraphicsTier);
            /** True when rendering over native UI is enabled in Player Settings (readonly).
            */
            public static get preserveFramebufferAlpha(): boolean;
            /** The minimum OpenGL ES version. The value is specified in PlayerSettings.
            */
            public static get minOpenGLESVersion(): UnityEngine.Rendering.OpenGLESVersion;
            /** Currently active color buffer (Read Only).
            */
            public static get activeColorBuffer(): UnityEngine.RenderBuffer;
            /** Currently active depth/stencil buffer (Read Only).
            */
            public static get activeDepthBuffer(): UnityEngine.RenderBuffer;
            public static ClearRandomWriteTargets () : void
            /** Execute a command buffer.
            * @param buffer The buffer to execute.
            */
            public static ExecuteCommandBuffer ($buffer: UnityEngine.Rendering.CommandBuffer) : void
            /** Executes a command buffer on an async compute queue with the queue selected based on the ComputeQueueType parameter passed.
            * @param buffer The CommandBuffer to be executed.
            * @param queueType Describes the desired async compute queue the supplied CommandBuffer should be executed on.
            */
            public static ExecuteCommandBufferAsync ($buffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType) : void
            /** Sets current render target.
            * @param rt RenderTexture to set as active render target.
            * @param mipLevel Mipmap level to render into (use 0 if not mipmapped).
            * @param face Cubemap face to render into (use Unknown if not a cubemap).
            * @param depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
            * @param colorBuffer Color buffer to render into.
            * @param depthBuffer Depth buffer to render into.
            * @param colorBuffers Color buffers to render into (for multiple render target effects).
            * @param setup Full render target setup information.
            */
            public static SetRenderTarget ($rt: UnityEngine.RenderTexture, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number) : void
            /** Sets current render target.
            * @param rt RenderTexture to set as active render target.
            * @param mipLevel Mipmap level to render into (use 0 if not mipmapped).
            * @param face Cubemap face to render into (use Unknown if not a cubemap).
            * @param depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
            * @param colorBuffer Color buffer to render into.
            * @param depthBuffer Depth buffer to render into.
            * @param colorBuffers Color buffers to render into (for multiple render target effects).
            * @param setup Full render target setup information.
            */
            public static SetRenderTarget ($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number) : void
            /** Sets current render target.
            * @param rt RenderTexture to set as active render target.
            * @param mipLevel Mipmap level to render into (use 0 if not mipmapped).
            * @param face Cubemap face to render into (use Unknown if not a cubemap).
            * @param depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
            * @param colorBuffer Color buffer to render into.
            * @param depthBuffer Depth buffer to render into.
            * @param colorBuffers Color buffers to render into (for multiple render target effects).
            * @param setup Full render target setup information.
            */
            public static SetRenderTarget ($colorBuffers: System.Array$1<UnityEngine.RenderBuffer>, $depthBuffer: UnityEngine.RenderBuffer) : void
            /** Sets current render target.
            * @param rt RenderTexture to set as active render target.
            * @param mipLevel Mipmap level to render into (use 0 if not mipmapped).
            * @param face Cubemap face to render into (use Unknown if not a cubemap).
            * @param depthSlice Depth slice to render into (use 0 if not a 3D or 2DArray render target).
            * @param colorBuffer Color buffer to render into.
            * @param depthBuffer Depth buffer to render into.
            * @param colorBuffers Color buffers to render into (for multiple render target effects).
            * @param setup Full render target setup information.
            */
            public static SetRenderTarget ($setup: UnityEngine.RenderTargetSetup) : void
            /** Set random write target for level pixel shaders.
            * @param index Index of the random write target in the shader.
            * @param uav Buffer or texture to set as the write target.
            * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
            */
            public static SetRandomWriteTarget ($index: number, $uav: UnityEngine.RenderTexture) : void
            /** Set random write target for level pixel shaders.
            * @param index Index of the random write target in the shader.
            * @param uav Buffer or texture to set as the write target.
            * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
            */
            public static SetRandomWriteTarget ($index: number, $uav: UnityEngine.ComputeBuffer, $preserveCounterValue: boolean) : void
            /** Set random write target for level pixel shaders.
            * @param index Index of the random write target in the shader.
            * @param uav Buffer or texture to set as the write target.
            * @param preserveCounterValue Whether to leave the append/consume counter value unchanged.
            */
            public static SetRandomWriteTarget ($index: number, $uav: UnityEngine.GraphicsBuffer, $preserveCounterValue: boolean) : void
            /** Copies pixel data from one texture to another.
            * @param src The source texture.
            * @param dst The destination texture.
            * @param srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
            * @param srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @param dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
            * @param srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
            * @param srcWidth The width of src to copy.
            * @param srcHeight The height of src to copy.
            * @param dstX The x coordinate of dst to copy to.
            * @param dstY The y coordinate to dst to copy to.
            */
            public static CopyTexture ($src: UnityEngine.Texture, $dst: UnityEngine.Texture) : void
            public static CopyTexture ($src: UnityEngine.Texture, $srcElement: number, $dst: UnityEngine.Texture, $dstElement: number) : void
            /** Copies pixel data from one texture to another.
            * @param src The source texture.
            * @param dst The destination texture.
            * @param srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
            * @param srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @param dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
            * @param srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
            * @param srcWidth The width of src to copy.
            * @param srcHeight The height of src to copy.
            * @param dstX The x coordinate of dst to copy to.
            * @param dstY The y coordinate to dst to copy to.
            */
            public static CopyTexture ($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $dst: UnityEngine.Texture, $dstElement: number, $dstMip: number) : void
            /** Copies pixel data from one texture to another.
            * @param src The source texture.
            * @param dst The destination texture.
            * @param srcElement The element in the source texture to copy from. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if src is a 2D texture.
            * @param srcMip The mipmap level to copy from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @param dstMip The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param srcX The starting x coordinate of src to copy from. 0 is the left of the texture.
            * @param srcY The starting y coordinate of src to copy from. 0 is the bottom of the texture.
            * @param srcWidth The width of src to copy.
            * @param srcHeight The height of src to copy.
            * @param dstX The x coordinate of dst to copy to.
            * @param dstY The y coordinate to dst to copy to.
            */
            public static CopyTexture ($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dst: UnityEngine.Texture, $dstElement: number, $dstMip: number, $dstX: number, $dstY: number) : void
            /** Copies the pixel data from one texture, converts the data into a different format, and copies it into another texture.
            * @param src The source texture. The texture must be a Texture2D or Cubemap.
            * @param dst The destination texture. The texture must be a Texture2D, Texture2DArray, Cubemap, or CubemapArray. The texture must also be uncompressed and correspond to a supported RenderTextureFormat.
            * @param srcElement The element in the source texture to copy from. Use CubemapFace if src is a Cubemap. Set the value to 0 if src is a 2D texture.
            * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @returns true if the method succeeded. 
            */
            public static ConvertTexture ($src: UnityEngine.Texture, $dst: UnityEngine.Texture) : boolean
            /** Copies the pixel data from one texture, converts the data into a different format, and copies it into another texture.
            * @param src The source texture. The texture must be a Texture2D or Cubemap.
            * @param dst The destination texture. The texture must be a Texture2D, Texture2DArray, Cubemap, or CubemapArray. The texture must also be uncompressed and correspond to a supported RenderTextureFormat.
            * @param srcElement The element in the source texture to copy from. Use CubemapFace if src is a Cubemap. Set the value to 0 if src is a 2D texture.
            * @param dstElement The element in the source texture to copy to. For example, the CubemapFace in a Cubemap or the slice in a texture array. Set the value to 0 if `dst` is a 2D texture.
            * @returns true if the method succeeded. 
            */
            public static ConvertTexture ($src: UnityEngine.Texture, $srcElement: number, $dst: UnityEngine.Texture, $dstElement: number) : boolean
            /** Shortcut for calling Graphics.CreateGraphicsFence with Rendering.GraphicsFenceType.AsyncQueueSynchronisation as the first parameter.
            * @param stage Which SynchronisationStage to insert the fence after.
            * @returns Returns a new GraphicsFence. 
            */
            public static CreateAsyncGraphicsFence ($stage: UnityEngine.Rendering.SynchronisationStage) : UnityEngine.Rendering.GraphicsFence
            public static CreateAsyncGraphicsFence () : UnityEngine.Rendering.GraphicsFence
            /** Creates a GraphicsFence.
            * @param fenceType The Rendering.GraphicsFenceType to create. Currently the only supported value is Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
            * @param stage Which SynchronisationStage to insert the fence after.
            * @returns Returns a new GraphicsFence. 
            */
            public static CreateGraphicsFence ($fenceType: UnityEngine.Rendering.GraphicsFenceType, $stage: UnityEngine.Rendering.SynchronisationStageFlags) : UnityEngine.Rendering.GraphicsFence
            /** Instructs the GPU to pause processing of the queue until it passes through the GraphicsFence fence.
            * @param fence The GraphicsFence the GPU waits for. The fenceType of the graphics fence must be Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
            * @param stage Which SynchronisationStage to wait for.
            */
            public static WaitOnAsyncGraphicsFence ($fence: UnityEngine.Rendering.GraphicsFence) : void
            /** Instructs the GPU to pause processing of the queue until it passes through the GraphicsFence fence.
            * @param fence The GraphicsFence the GPU waits for. The fenceType of the graphics fence must be Rendering.GraphicsFenceType.AsyncQueueSynchronisation.
            * @param stage Which SynchronisationStage to wait for.
            */
            public static WaitOnAsyncGraphicsFence ($fence: UnityEngine.Rendering.GraphicsFence, $stage: UnityEngine.Rendering.SynchronisationStage) : void
            /** Copies the contents of one GraphicsBuffer into another.
            * @param source The source buffer.
            * @param dest The destination buffer.
            */
            public static CopyBuffer ($source: UnityEngine.GraphicsBuffer, $dest: UnityEngine.GraphicsBuffer) : void
            /** Draw a texture in screen coordinates.
            * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param texture Texture to draw.
            * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param leftBorder Number of pixels from the left that are not affected by scale.
            * @param rightBorder Number of pixels from the right that are not affected by scale.
            * @param topBorder Number of pixels from the top that are not affected by scale.
            * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: UnityEngine.Color, $mat: UnityEngine.Material, $pass: number) : void
            /** Draw a texture in screen coordinates.
            * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param texture Texture to draw.
            * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param leftBorder Number of pixels from the left that are not affected by scale.
            * @param rightBorder Number of pixels from the right that are not affected by scale.
            * @param topBorder Number of pixels from the top that are not affected by scale.
            * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material, $pass: number) : void
            /** Draw a texture in screen coordinates.
            * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param texture Texture to draw.
            * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param leftBorder Number of pixels from the left that are not affected by scale.
            * @param rightBorder Number of pixels from the right that are not affected by scale.
            * @param topBorder Number of pixels from the top that are not affected by scale.
            * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material, $pass: number) : void
            /** Draw a texture in screen coordinates.
            * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param texture Texture to draw.
            * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param leftBorder Number of pixels from the left that are not affected by scale.
            * @param rightBorder Number of pixels from the right that are not affected by scale.
            * @param topBorder Number of pixels from the top that are not affected by scale.
            * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $mat: UnityEngine.Material, $pass: number) : void
            public static RenderMesh ($rparams: $Ref<UnityEngine.RenderParams>, $mesh: UnityEngine.Mesh, $submeshIndex: number, $objectToWorld: UnityEngine.Matrix4x4, $prevObjectToWorld?: UnityEngine.Matrix4x4 | null) : void
            /** Renders multiple instances of a mesh using GPU instancing and rendering command arguments from commandBuffer.
            * @param rparams The parameters Unity uses to render the mesh.
            * @param mesh The Mesh to render.
            * @param commandBuffer A command buffer that provides rendering command arguments (see GraphicsBuffer.IndirectDrawIndexedArgs).
            * @param commandCount The number of rendering commands to execute in the commandBuffer.
            * @param startCommand The first command to execute in the commandBuffer.
            */
            public static RenderMeshIndirect ($rparams: $Ref<UnityEngine.RenderParams>, $mesh: UnityEngine.Mesh, $commandBuffer: UnityEngine.GraphicsBuffer, $commandCount?: number, $startCommand?: number) : void
            /** Renders multiple instances of a Mesh using GPU instancing and a custom shader.
            * @param rparams The parameters Unity uses to render the Mesh primitives.
            * @param mesh The Mesh to render.
            * @param submeshIndex The index of a submesh Unity renders when the Mesh contains multiple Materials (submeshes). For a Mesh with a single Material, use value 0.
            * @param instanceCount The number of instances to render.
            */
            public static RenderMeshPrimitives ($rparams: $Ref<UnityEngine.RenderParams>, $mesh: UnityEngine.Mesh, $submeshIndex: number, $instanceCount?: number) : void
            /** Renders non-indexed primitives with GPU instancing and a custom shader.
            * @param rparams The parameters Unity uses to render the primitives.
            * @param topology Primitive topology (for example, triangles or lines).
            * @param vertexCount The number of vertices per instance.
            * @param instanceCount The number of instances to render.
            */
            public static RenderPrimitives ($rparams: $Ref<UnityEngine.RenderParams>, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount?: number) : void
            /** Renders indexed primitives with GPU instancing and a custom shader.
            * @param rparams The parameters Unity uses to render the primitives.
            * @param topology Primitive topology (for example, triangles or lines).
            * @param indexBuffer The index buffer for the rendered primitives.
            * @param indexCount The number of indices per instance.
            * @param startIndex The first index in the indexBuffer.
            * @param instanceCount The number of instances to render.
            */
            public static RenderPrimitivesIndexed ($rparams: $Ref<UnityEngine.RenderParams>, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $indexCount: number, $startIndex?: number, $instanceCount?: number) : void
            /** Renders primitives with GPU instancing and a custom shader using rendering command arguments from commandBuffer.
            * @param rparams The parameters Unity uses to render the primitives.
            * @param topology Primitive topology (for example, triangles or lines).
            * @param commandBuffer A command buffer that provides rendering command arguments (see GraphicsBuffer.IndirectDrawArgs).
            * @param commandCount The number of rendering commands to execute in the commandBuffer.
            * @param startCommand The first command to execute in the commandBuffer.
            */
            public static RenderPrimitivesIndirect ($rparams: $Ref<UnityEngine.RenderParams>, $topology: UnityEngine.MeshTopology, $commandBuffer: UnityEngine.GraphicsBuffer, $commandCount?: number, $startCommand?: number) : void
            /** Renders indexed primitives with GPU instancing and a custom shader with rendering command arguments from commandBuffer.
            * @param rparams The parameters Unity uses to render the primitives.
            * @param topology Primitive topology (for example, triangles or lines).
            * @param indexBuffer Index buffer for the rendered primitives.
            * @param commandBuffer A command buffer that provides rendering command arguments (see GraphicsBuffer.IndirectDrawIndexedArgs).
            * @param commandCount The number of rendering commands to execute in the commandBuffer.
            * @param startCommand The first command to execute in the commandBuffer.
            */
            public static RenderPrimitivesIndexedIndirect ($rparams: $Ref<UnityEngine.RenderParams>, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $commandBuffer: UnityEngine.GraphicsBuffer, $commandCount?: number, $startCommand?: number) : void
            /** Draw a mesh immediately.
            * @param mesh The Mesh to draw.
            * @param position Position of the mesh.
            * @param rotation Rotation of the mesh.
            * @param matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param materialIndex Subset of the mesh to draw.
            */
            public static DrawMeshNow ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $materialIndex: number) : void
            /** Draw a mesh immediately.
            * @param mesh The Mesh to draw.
            * @param position Position of the mesh.
            * @param rotation Rotation of the mesh.
            * @param matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param materialIndex Subset of the mesh to draw.
            */
            public static DrawMeshNow ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $materialIndex: number) : void
            /** Draw a mesh immediately.
            * @param mesh The Mesh to draw.
            * @param position Position of the mesh.
            * @param rotation Rotation of the mesh.
            * @param matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param materialIndex Subset of the mesh to draw.
            */
            public static DrawMeshNow ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            /** Draw a mesh immediately.
            * @param mesh The Mesh to draw.
            * @param position Position of the mesh.
            * @param rotation Rotation of the mesh.
            * @param matrix The transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param materialIndex Subset of the mesh to draw.
            */
            public static DrawMeshNow ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4) : void
            /** Draw a mesh.
            * @param mesh The Mesh to draw.
            * @param position Position of the mesh.
            * @param rotation Rotation of the mesh.
            * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param material Material to use.
            * @param layer  the mesh is drawn on.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param useLightProbes Should the mesh use light probes?
            * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
            * @param lightProbeUsage LightProbeUsage for the mesh.
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean, $useLightProbes: boolean) : void
            /** Draw a mesh.
            * @param mesh The Mesh to draw.
            * @param position Position of the mesh.
            * @param rotation Rotation of the mesh.
            * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param material Material to use.
            * @param layer  the mesh is drawn on.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param useLightProbes Should the mesh use light probes?
            * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
            * @param lightProbeUsage LightProbeUsage for the mesh.
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $useLightProbes: boolean) : void
            /** Draw a mesh.
            * @param mesh The Mesh to draw.
            * @param position Position of the mesh.
            * @param rotation Rotation of the mesh.
            * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param material Material to use.
            * @param layer  the mesh is drawn on.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param useLightProbes Should the mesh use light probes?
            * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
            * @param lightProbeUsage LightProbeUsage for the mesh.
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean, $useLightProbes: boolean) : void
            /** Draw a mesh.
            * @param mesh The Mesh to draw.
            * @param position Position of the mesh.
            * @param rotation Rotation of the mesh.
            * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param material Material to use.
            * @param layer  the mesh is drawn on.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param useLightProbes Should the mesh use light probes?
            * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
            * @param lightProbeUsage LightProbeUsage for the mesh.
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume) : void
            /** Draws the same mesh multiple times using GPU instancing.
            * @param mesh The Mesh to draw.
            * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param material Material to use.
            * @param matrices The array of object transformation matrices.
            * @param count The number of instances to be drawn.
            * @param properties Additional material properties to apply. See MaterialPropertyBlock.
            * @param castShadows Determines whether the Meshes should cast shadows.
            * @param receiveShadows Determines whether the Meshes should receive shadows.
            * @param layer  to use.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
            * @param lightProbeUsage LightProbeUsage for the instances.
            */
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume) : void
            /** Draws the same mesh multiple times using GPU instancing.
            This is similar to Graphics.DrawMeshInstancedIndirect, except that when the instance count is known from script, it can be supplied directly using this method, rather than via a ComputeBuffer.
            * @param mesh The Mesh to draw.
            * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param material Material to use.
            * @param bounds The bounding volume surrounding the instances you intend to draw.
            * @param count The number of instances to be drawn.
            * @param properties Additional material properties to apply. See MaterialPropertyBlock.
            * @param castShadows Determines whether the Meshes should cast shadows.
            * @param receiveShadows Determines whether the Meshes should receive shadows.
            * @param layer  to use.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
            * @param lightProbeUsage LightProbeUsage for the instances.
            */
            public static DrawMeshInstancedProcedural ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $count: number, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: UnityEngine.Camera, $lightProbeUsage?: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume?: UnityEngine.LightProbeProxyVolume) : void
            /** Draws the same mesh multiple times using GPU instancing.
            * @param mesh The Mesh to draw.
            * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param material Material to use.
            * @param bounds The bounding volume surrounding the instances you intend to draw.
            * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
            * @param argsOffset The byte offset into the buffer, where the draw arguments start.
            * @param properties Additional material properties to apply. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param layer  to use.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
            * @param lightProbeUsage LightProbeUsage for the instances.
            */
            public static DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume) : void
            /** Draws the same mesh multiple times using GPU instancing.
            * @param mesh The Mesh to draw.
            * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param material Material to use.
            * @param bounds The bounding volume surrounding the instances you intend to draw.
            * @param bufferWithArgs The GPU buffer containing the arguments for how many instances of this mesh to draw.
            * @param argsOffset The byte offset into the buffer, where the draw arguments start.
            * @param properties Additional material properties to apply. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param layer  to use.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given Camera only.
            * @param lightProbeUsage LightProbeUsage for the instances.
            */
            public static DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume) : void
            /** Draws procedural geometry on the GPU.
            * @param topology Topology of the procedural geometry.
            * @param vertexCount Vertex count to render.
            * @param instanceCount Instance count to render.
            */
            public static DrawProceduralNow ($topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param topology Topology of the procedural geometry.
            * @param indexCount Index count to render.
            * @param instanceCount Instance count to render.
            * @param indexBuffer Index buffer used to submit vertices to the GPU.
            */
            public static DrawProceduralNow ($topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $indexCount: number, $instanceCount?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param topology Topology of the procedural geometry.
            * @param bufferWithArgs Buffer with draw arguments.
            * @param argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public static DrawProceduralIndirectNow ($topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param topology Topology of the procedural geometry.
            * @param indexBuffer Index buffer used to submit vertices to the GPU.
            * @param bufferWithArgs Buffer with draw arguments.
            * @param argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public static DrawProceduralIndirectNow ($topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param topology Topology of the procedural geometry.
            * @param bufferWithArgs Buffer with draw arguments.
            * @param argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public static DrawProceduralIndirectNow ($topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param topology Topology of the procedural geometry.
            * @param indexBuffer Index buffer used to submit vertices to the GPU.
            * @param bufferWithArgs Buffer with draw arguments.
            * @param argsOffset Byte offset where in the buffer the draw arguments are.
            */
            public static DrawProceduralIndirectNow ($topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param material Material to use.
            * @param bounds The bounding volume surrounding the instances you intend to draw.
            * @param topology Topology of the procedural geometry.
            * @param vertexCount Vertex count to render.
            * @param instanceCount Instance count to render.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param layer  to use.
            */
            public static DrawProcedural ($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number) : void
            /** Draws procedural geometry on the GPU, with an index buffer.
            * @param material Material to use.
            * @param bounds The bounding volume surrounding the instances you intend to draw.
            * @param topology Topology of the procedural geometry.
            * @param indexBuffer Index buffer used to submit vertices to the GPU.
            * @param instanceCount Instance count to render.
            * @param indexCount Index count to render.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param layer  to use.
            */
            public static DrawProcedural ($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $indexCount: number, $instanceCount?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param material Material to use.
            * @param bounds The bounding volume surrounding the instances you intend to draw.
            * @param topology Topology of the procedural geometry.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param bufferWithArgs Buffer with draw arguments.
            * @param argsOffset Byte offset where in the buffer the draw arguments are.
            * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param layer  to use.
            */
            public static DrawProceduralIndirect ($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param material Material to use.
            * @param bounds The bounding volume surrounding the instances you intend to draw.
            * @param topology Topology of the procedural geometry.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param bufferWithArgs Buffer with draw arguments.
            * @param argsOffset Byte offset where in the buffer the draw arguments are.
            * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param layer  to use.
            */
            public static DrawProceduralIndirect ($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param material Material to use.
            * @param bounds The bounding volume surrounding the instances you intend to draw.
            * @param topology Topology of the procedural geometry.
            * @param indexBuffer Index buffer used to submit vertices to the GPU.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param bufferWithArgs Buffer with draw arguments.
            * @param argsOffset Byte offset where in the buffer the draw arguments are.
            * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param layer  to use.
            */
            public static DrawProceduralIndirect ($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number) : void
            /** Draws procedural geometry on the GPU.
            * @param material Material to use.
            * @param bounds The bounding volume surrounding the instances you intend to draw.
            * @param topology Topology of the procedural geometry.
            * @param indexBuffer Index buffer used to submit vertices to the GPU.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param bufferWithArgs Buffer with draw arguments.
            * @param argsOffset Byte offset where in the buffer the draw arguments are.
            * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param layer  to use.
            */
            public static DrawProceduralIndirect ($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number) : void
            /** Uses a shader to copy the pixel data from a texture into a render texture.
            * @param source The source texture.
            * @param dest The destination RenderTexture.
            * @param mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param scale The scale to apply.
            * @param offset The offset to apply.
            * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture) : void
            /** Uses a shader to copy the pixel data from a texture into a render texture.
            * @param source The source texture.
            * @param dest The destination RenderTexture.
            * @param mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param scale The scale to apply.
            * @param offset The offset to apply.
            * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $sourceDepthSlice: number, $destDepthSlice: number) : void
            /** Uses a shader to copy the pixel data from a texture into a render texture.
            * @param source The source texture.
            * @param dest The destination RenderTexture.
            * @param mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param scale The scale to apply.
            * @param offset The offset to apply.
            * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2) : void
            /** Uses a shader to copy the pixel data from a texture into a render texture.
            * @param source The source texture.
            * @param dest The destination RenderTexture.
            * @param mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param scale The scale to apply.
            * @param offset The offset to apply.
            * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2, $sourceDepthSlice: number, $destDepthSlice: number) : void
            /** Uses a shader to copy the pixel data from a texture into a render texture.
            * @param source The source texture.
            * @param dest The destination RenderTexture.
            * @param mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param scale The scale to apply.
            * @param offset The offset to apply.
            * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, $pass: number) : void
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number) : void
            public static Blit ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material) : void
            /** Uses a shader to copy the pixel data from a texture into a render texture.
            * @param source The source texture.
            * @param dest The destination RenderTexture.
            * @param mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param scale The scale to apply.
            * @param offset The offset to apply.
            * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $mat: UnityEngine.Material, $pass: number) : void
            /** Uses a shader to copy the pixel data from a texture into a render texture.
            * @param source The source texture.
            * @param dest The destination RenderTexture.
            * @param mat The material to use. If you don't provide mat, Unity uses a default material.
            * @param pass If the value is -1, Unity draws all the passes in mat. Otherwise, Unity draws only the pass you set pass to. The default value is -1.
            * @param scale The scale to apply.
            * @param offset The offset to apply.
            * @param sourceDepthSlice The element in the source texture to copy from, for example the texture in a texture array. You can't use sourceDepthSlice to specify a face in a Cubemap.
            * @param destDepthSlice The element in the destination texture to copy from, for example the texture in a texture array. You can't use destDepthSlice to specify a face in a Cubemap.
            */
            public static Blit ($source: UnityEngine.Texture, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number) : void
            public static Blit ($source: UnityEngine.Texture, $mat: UnityEngine.Material) : void
            /** Copies source texture into destination, for multi-tap shader.
            * @param source Source texture.
            * @param dest Destination RenderTexture, or null to blit directly to screen.
            * @param mat Material to use for copying. Material's shader should do some post-processing effect.
            * @param offsets Variable number of filtering offsets. Offsets are given in pixels.
            * @param destDepthSlice The texture array destination slice to blit to.
            */
            public static BlitMultiTap ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, ...offsets: UnityEngine.Vector2[]) : void
            /** Copies source texture into destination, for multi-tap shader.
            * @param source Source texture.
            * @param dest Destination RenderTexture, or null to blit directly to screen.
            * @param mat Material to use for copying. Material's shader should do some post-processing effect.
            * @param offsets Variable number of filtering offsets. Offsets are given in pixels.
            * @param destDepthSlice The texture array destination slice to blit to.
            */
            public static BlitMultiTap ($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, $destDepthSlice: number, ...offsets: UnityEngine.Vector2[]) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean) : void
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform) : void
            /** Draw a mesh.
            * @param mesh The Mesh to draw.
            * @param position Position of the mesh.
            * @param rotation Rotation of the mesh.
            * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param material Material to use.
            * @param layer  the mesh is drawn on.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param useLightProbes Should the mesh use light probes?
            * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
            * @param lightProbeUsage LightProbeUsage for the mesh.
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $useLightProbes: boolean) : void
            /** Draw a mesh.
            * @param mesh The Mesh to draw.
            * @param position Position of the mesh.
            * @param rotation Rotation of the mesh.
            * @param matrix Transformation matrix of the mesh (combines position, rotation and other transformations).
            * @param material Material to use.
            * @param layer  the mesh is drawn on.
            * @param camera If null (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given Camera only.
            * @param submeshIndex Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.
            * @param properties Additional material properties to apply onto material just before this mesh will be drawn. See MaterialPropertyBlock.
            * @param castShadows Determines whether the mesh can cast shadows.
            * @param receiveShadows Determines whether the mesh can receive shadows.
            * @param useLightProbes Should the mesh use light probes?
            * @param probeAnchor If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.
            * @param lightProbeUsage LightProbeUsage for the mesh.
            */
            public static DrawMesh ($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera) : void
            public static DrawMeshInstanced ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage) : void
            public static DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: UnityEngine.Camera, $lightProbeUsage?: UnityEngine.Rendering.LightProbeUsage) : void
            public static DrawMeshInstancedIndirect ($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: UnityEngine.Camera, $lightProbeUsage?: UnityEngine.Rendering.LightProbeUsage) : void
            /** Draw a texture in screen coordinates.
            * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param texture Texture to draw.
            * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param leftBorder Number of pixels from the left that are not affected by scale.
            * @param rightBorder Number of pixels from the right that are not affected by scale.
            * @param topBorder Number of pixels from the top that are not affected by scale.
            * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: UnityEngine.Color, $mat: UnityEngine.Material) : void
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: UnityEngine.Color) : void
            /** Draw a texture in screen coordinates.
            * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param texture Texture to draw.
            * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param leftBorder Number of pixels from the left that are not affected by scale.
            * @param rightBorder Number of pixels from the right that are not affected by scale.
            * @param topBorder Number of pixels from the top that are not affected by scale.
            * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material) : void
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number) : void
            /** Draw a texture in screen coordinates.
            * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param texture Texture to draw.
            * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param leftBorder Number of pixels from the left that are not affected by scale.
            * @param rightBorder Number of pixels from the right that are not affected by scale.
            * @param topBorder Number of pixels from the top that are not affected by scale.
            * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material) : void
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number) : void
            /** Draw a texture in screen coordinates.
            * @param screenRect Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.
            * @param texture Texture to draw.
            * @param sourceRect Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.
            * @param leftBorder Number of pixels from the left that are not affected by scale.
            * @param rightBorder Number of pixels from the right that are not affected by scale.
            * @param topBorder Number of pixels from the top that are not affected by scale.
            * @param bottomBorder Number of pixels from the bottom that are not affected by scale.
            * @param color Color that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.
            * @param mat Custom Material that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.
            * @param pass If -1 (default), draws all passes in the material. Otherwise, draws given pass only.
            */
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $mat: UnityEngine.Material) : void
            public static DrawTexture ($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture) : void
            public static SetRenderTarget ($rt: UnityEngine.RenderTexture) : void
            public static SetRenderTarget ($rt: UnityEngine.RenderTexture, $mipLevel: number) : void
            public static SetRenderTarget ($rt: UnityEngine.RenderTexture, $mipLevel: number, $face: UnityEngine.CubemapFace) : void
            public static SetRenderTarget ($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer) : void
            public static SetRenderTarget ($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer, $mipLevel: number) : void
            public static SetRenderTarget ($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace) : void
            public static SetRandomWriteTarget ($index: number, $uav: UnityEngine.ComputeBuffer) : void
            public static SetRandomWriteTarget ($index: number, $uav: UnityEngine.GraphicsBuffer) : void
            public constructor ()
        }
        /** Represents a color gamut.
        */
        enum ColorGamut
        { sRGB = 0, Rec709 = 1, Rec2020 = 2, DisplayP3 = 3, HDR10 = 4, DolbyHDR = 5 }
        /** Cubemap face.
        */
        enum CubemapFace
        { Unknown = -1, PositiveX = 0, NegativeX = 1, PositiveY = 2, NegativeY = 3, PositiveZ = 4, NegativeZ = 5 }
        /** Fully describes setup of RenderTarget.
        */
        class RenderTargetSetup extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Color Buffers to set.
            */
            public color : System.Array$1<UnityEngine.RenderBuffer>
            /** Depth Buffer to set.
            */
            public depth : UnityEngine.RenderBuffer
            /** Mip Level to render to.
            */
            public mipLevel : number
            /** Cubemap face to render to.
            */
            public cubemapFace : UnityEngine.CubemapFace
            /** Slice of a Texture3D or Texture2DArray to set as a render target.
            */
            public depthSlice : number
            /** Load Actions for Color Buffers. It will override any actions set on RenderBuffers themselves.
            */
            public colorLoad : System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>
            /** Store Actions for Color Buffers. It will override any actions set on RenderBuffers themselves.
            */
            public colorStore : System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>
            /** Load Action for Depth Buffer. It will override any actions set on RenderBuffer itself.
            */
            public depthLoad : UnityEngine.Rendering.RenderBufferLoadAction
            /** Store Actions for Depth Buffer. It will override any actions set on RenderBuffer itself.
            */
            public depthStore : UnityEngine.Rendering.RenderBufferStoreAction
            public constructor ($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer, $mip: number, $face: UnityEngine.CubemapFace, $colorLoad: System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>, $colorStore: System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>, $depthLoad: UnityEngine.Rendering.RenderBufferLoadAction, $depthStore: UnityEngine.Rendering.RenderBufferStoreAction)
            public constructor ($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer)
            public constructor ($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer, $mipLevel: number)
            public constructor ($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace)
            public constructor ($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number)
            public constructor ($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer)
            public constructor ($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer, $mipLevel: number)
            public constructor ($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer, $mip: number, $face: UnityEngine.CubemapFace)
            public constructor ()
        }
        /** GPU data buffer, mostly for use with compute shaders.
        */
        class ComputeBuffer extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Number of elements in the buffer (Read Only).
            */
            public get count(): number;
            /** Size of one element in the buffer in bytes (Read Only).
            */
            public get stride(): number;
            public set name(value: string);
            public Dispose () : void
            public Release () : void
            public IsValid () : boolean
            /** Set the buffer with values from an array.
            * @param data Array of values to fill the buffer.
            */
            public SetData ($data: System.Array) : void
            /** Partial copy of data values from an array into the buffer.
            * @param data Array of values to fill the buffer.
            * @param managedBufferStartIndex The first element index in data to copy to the compute buffer.
            * @param computeBufferStartIndex The first element index in compute buffer to receive the data.
            * @param count The number of elements to copy.
            */
            public SetData ($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number) : void
            /** Read data values from the buffer into an array. The array can only use <a href="https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types">blittable<a> types.
            * @param data An array to receive the data.
            */
            public GetData ($data: System.Array) : void
            /** Partial read of data values from the buffer into an array.
            * @param data An array to receive the data.
            * @param managedBufferStartIndex The first element index in data where retrieved elements are copied.
            * @param computeBufferStartIndex The first element index of the compute buffer from which elements are read.
            * @param count The number of elements to retrieve.
            */
            public GetData ($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number) : void
            /** Sets counter value of append/consume buffer.
            * @param counterValue Value of the append/consume counter.
            */
            public SetCounterValue ($counterValue: number) : void
            /** Copy counter value of append/consume buffer into another buffer.
            * @param src Append/consume buffer to copy the counter from.
            * @param dst A buffer to copy the counter to.
            * @param dstOffsetBytes Target byte offset in dst.
            */
            public static CopyCount ($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number) : void
            public GetNativeBufferPtr () : System.IntPtr
            public constructor ($count: number, $stride: number)
            public constructor ($count: number, $stride: number, $type: UnityEngine.ComputeBufferType)
            public constructor ($count: number, $stride: number, $type: UnityEngine.ComputeBufferType, $usage: UnityEngine.ComputeBufferMode)
            public constructor ()
        }
        /** GPU graphics data buffer, for working with geometry or compute shader data.
        */
        class GraphicsBuffer extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** Number of elements in the buffer (Read Only).
            */
            public get count(): number;
            /** Size of one element in the buffer. For index buffers, this must be either 2 or 4 bytes (Read Only).
            */
            public get stride(): number;
            /** Usage target, which specifies the intended usage of this GraphicsBuffer (Read Only).
            */
            public get target(): UnityEngine.GraphicsBuffer.Target;
            public set name(value: string);
            public Dispose () : void
            public Release () : void
            public IsValid () : boolean
            /** Set the buffer with values from an array.
            * @param data Array of values to fill the buffer.
            */
            public SetData ($data: System.Array) : void
            /** Partial copy of data values from an array into the buffer.
            * @param data Array of values to fill the buffer.
            * @param managedBufferStartIndex The first element index in data to copy to the graphics buffer.
            * @param count The number of elements to copy.
            * @param graphicsBufferStartIndex The first element index in the graphics buffer to receive the data.
            */
            public SetData ($data: System.Array, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number) : void
            /** Read data values from the buffer into an array. The array can only use <a href="https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types">blittable<a> types.
            * @param data An array to receive the data.
            * @param managedBufferStartIndex The first element index in data where retrieved elements are copied.
            * @param computeBufferStartIndex The first element index of the buffer from which elements are read.
            * @param count The number of elements to retrieve.
            */
            public GetData ($data: System.Array) : void
            /** Read data values from the buffer into an array. The array can only use <a href="https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types">blittable<a> types.
            * @param data An array to receive the data.
            * @param managedBufferStartIndex The first element index in data where retrieved elements are copied.
            * @param computeBufferStartIndex The first element index of the buffer from which elements are read.
            * @param count The number of elements to retrieve.
            */
            public GetData ($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number) : void
            public GetNativeBufferPtr () : System.IntPtr
            /** Sets counter value of append/consume buffer.
            * @param counterValue Value of the append/consume counter.
            */
            public SetCounterValue ($counterValue: number) : void
            /** Copy the counter value of a GraphicsBuffer into another buffer.
            * @param src The source GraphicsBuffer.
            * @param dst The destination GraphicsBuffer.
            * @param dstOffsetBytes The destination buffer offset in bytes.
            */
            public static CopyCount ($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number) : void
            /** Copy the counter value of a GraphicsBuffer into another buffer.
            * @param src The source GraphicsBuffer.
            * @param dst The destination GraphicsBuffer.
            * @param dstOffsetBytes The destination buffer offset in bytes.
            */
            public static CopyCount ($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number) : void
            /** Copy the counter value of a GraphicsBuffer into another buffer.
            * @param src The source GraphicsBuffer.
            * @param dst The destination GraphicsBuffer.
            * @param dstOffsetBytes The destination buffer offset in bytes.
            */
            public static CopyCount ($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number) : void
            /** Copy the counter value of a GraphicsBuffer into another buffer.
            * @param src The source GraphicsBuffer.
            * @param dst The destination GraphicsBuffer.
            * @param dstOffsetBytes The destination buffer offset in bytes.
            */
            public static CopyCount ($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number) : void
            public constructor ($target: UnityEngine.GraphicsBuffer.Target, $count: number, $stride: number)
            public constructor ()
        }
        /** Rendering parameters used by various rendering functions.
        */
        class RenderParams extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Layer used for rendering. to use.
            */
            public get layer(): number;
            public set layer(value: number);
            /** Renderer layer mask used for rendering.
            */
            public get renderingLayerMask(): number;
            public set renderingLayerMask(value: number);
            /** Renderer priority.
            */
            public get rendererPriority(): number;
            public set rendererPriority(value: number);
            /** Defines world space bounds for the geometry. Used to cull and sort the rendered geometry.
            */
            public get worldBounds(): UnityEngine.Bounds;
            public set worldBounds(value: UnityEngine.Bounds);
            /** The camera used for rendering. If set to null (default) renders for all cameras.
            */
            public get camera(): UnityEngine.Camera;
            public set camera(value: UnityEngine.Camera);
            /** Motion vector mode used for rendering.
            */
            public get motionVectorMode(): UnityEngine.MotionVectorGenerationMode;
            public set motionVectorMode(value: UnityEngine.MotionVectorGenerationMode);
            /** The type of reflection probe used for rendering.
            */
            public get reflectionProbeUsage(): UnityEngine.Rendering.ReflectionProbeUsage;
            public set reflectionProbeUsage(value: UnityEngine.Rendering.ReflectionProbeUsage);
            /** Material used for rendering.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            /** Material properties used for rendering.
            */
            public get matProps(): UnityEngine.MaterialPropertyBlock;
            public set matProps(value: UnityEngine.MaterialPropertyBlock);
            /** Describes if geometry should cast shadows.
            */
            public get shadowCastingMode(): UnityEngine.Rendering.ShadowCastingMode;
            public set shadowCastingMode(value: UnityEngine.Rendering.ShadowCastingMode);
            /** Descripes if the rendered geometry should receive shadows.
            */
            public get receiveShadows(): boolean;
            public set receiveShadows(value: boolean);
            /** The type of light probe usage.
            */
            public get lightProbeUsage(): UnityEngine.Rendering.LightProbeUsage;
            public set lightProbeUsage(value: UnityEngine.Rendering.LightProbeUsage);
            /** Light Probe Proxy Volume (LPPV) used for rendering.
            */
            public get lightProbeProxyVolume(): UnityEngine.LightProbeProxyVolume;
            public set lightProbeProxyVolume(value: UnityEngine.LightProbeProxyVolume);
            public constructor ($mat: UnityEngine.Material)
            public constructor ()
        }
        /** Topology of Mesh faces.
        */
        enum MeshTopology
        { Triangles = 0, Quads = 2, Lines = 3, LineStrip = 4, Points = 5 }
        /** A block of material values to apply.
        */
        class MaterialPropertyBlock extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Is the material property block empty? (Read Only)
            */
            public get isEmpty(): boolean;
            public Clear () : void
            /** This method is deprecated. Use SetFloat or SetInteger instead.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The int value to set.
            */
            public SetInt ($name: string, $value: number) : void
            /** This method is deprecated. Use SetFloat or SetInteger instead.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The int value to set.
            */
            public SetInt ($nameID: number, $value: number) : void
            /** Set a float property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The float value to set.
            */
            public SetFloat ($name: string, $value: number) : void
            /** Set a float property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The float value to set.
            */
            public SetFloat ($nameID: number, $value: number) : void
            /** Adds a property to the block. If an integer property with the given name already exists, the old value is replaced.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The integer value to set.
            */
            public SetInteger ($name: string, $value: number) : void
            /** Adds a property to the block. If an integer property with the given name already exists, the old value is replaced.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The integer value to set.
            */
            public SetInteger ($nameID: number, $value: number) : void
            /** Set a vector property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The Vector4 value to set.
            */
            public SetVector ($name: string, $value: UnityEngine.Vector4) : void
            /** Set a vector property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The Vector4 value to set.
            */
            public SetVector ($nameID: number, $value: UnityEngine.Vector4) : void
            /** Set a color property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The Color value to set.
            */
            public SetColor ($name: string, $value: UnityEngine.Color) : void
            /** Set a color property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The Color value to set.
            */
            public SetColor ($nameID: number, $value: UnityEngine.Color) : void
            /** Set a matrix property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The matrix value to set.
            */
            public SetMatrix ($name: string, $value: UnityEngine.Matrix4x4) : void
            /** Set a matrix property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The matrix value to set.
            */
            public SetMatrix ($nameID: number, $value: UnityEngine.Matrix4x4) : void
            /** Set a buffer property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The ComputeBuffer or GraphicsBuffer to set.
            */
            public SetBuffer ($name: string, $value: UnityEngine.ComputeBuffer) : void
            /** Set a buffer property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The ComputeBuffer or GraphicsBuffer to set.
            */
            public SetBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer) : void
            /** Set a buffer property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The ComputeBuffer or GraphicsBuffer to set.
            */
            public SetBuffer ($name: string, $value: UnityEngine.GraphicsBuffer) : void
            /** Set a buffer property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The ComputeBuffer or GraphicsBuffer to set.
            */
            public SetBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer) : void
            /** Set a texture property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The Texture to set.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($name: string, $value: UnityEngine.Texture) : void
            /** Set a texture property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The Texture to set.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($nameID: number, $value: UnityEngine.Texture) : void
            /** Set a texture property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The Texture to set.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($name: string, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Set a texture property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param value The Texture to set.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($nameID: number, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
            * @param name The name of the constant buffer to override.
            * @param value The buffer to override the constant buffer values with.
            * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            * @param nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($name: string, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
            * @param name The name of the constant buffer to override.
            * @param value The buffer to override the constant buffer values with.
            * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            * @param nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($nameID: number, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
            * @param name The name of the constant buffer to override.
            * @param value The buffer to override the constant buffer values with.
            * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            * @param nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($name: string, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock.
            * @param name The name of the constant buffer to override.
            * @param value The buffer to override the constant buffer values with.
            * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            * @param nameID The shader property ID of the constant buffer to override.
            */
            public SetConstantBuffer ($nameID: number, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            public SetFloatArray ($name: string, $values: System.Collections.Generic.List$1<number>) : void
            public SetFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            /** Set a float array property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param values The array to set.
            */
            public SetFloatArray ($name: string, $values: System.Array$1<number>) : void
            /** Set a float array property.
            * @param name The name of the property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param values The array to set.
            */
            public SetFloatArray ($nameID: number, $values: System.Array$1<number>) : void
            public SetVectorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public SetVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** Set a vector array property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param values The array to set.
            * @param name The name of the property.
            */
            public SetVectorArray ($name: string, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Set a vector array property.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param values The array to set.
            * @param name The name of the property.
            */
            public SetVectorArray ($nameID: number, $values: System.Array$1<UnityEngine.Vector4>) : void
            public SetMatrixArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public SetMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            /** Set a matrix array property.
            * @param name The name of the property.
            * @param values The name ID of the property retrieved by Shader.PropertyToID.
            * @param nameID The array to set.
            */
            public SetMatrixArray ($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Set a matrix array property.
            * @param name The name of the property.
            * @param values The name ID of the property retrieved by Shader.PropertyToID.
            * @param nameID The array to set.
            */
            public SetMatrixArray ($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Checks if MaterialPropertyBlock has the property with the given name or name ID. To set the property, use one of the Set methods for MaterialPropertyBlock.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasProperty ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the property with the given name or name ID. To set the property, use one of the Set methods for MaterialPropertyBlock.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasProperty ($nameID: number) : boolean
            /** This method is deprecated. Use HasFloat or HasInteger instead.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasInt ($name: string) : boolean
            /** This method is deprecated. Use HasFloat or HasInteger instead.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasInt ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the Float property with the given name or name ID. To set the property, use SetFloat.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasFloat ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the Float property with the given name or name ID. To set the property, use SetFloat.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasFloat ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the Integer property with the given name or name ID. To set the property, use SetInteger.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasInteger ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the Integer property with the given name or name ID. To set the property, use SetInteger.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasInteger ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the Texture property with the given name or name ID. To set the property, use SetTexture.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasTexture ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the Texture property with the given name or name ID. To set the property, use SetTexture.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasTexture ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the Matrix property with the given name or name ID. This also works with the Matrix Array property. To set the property, use SetMatrix.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasMatrix ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the Matrix property with the given name or name ID. This also works with the Matrix Array property. To set the property, use SetMatrix.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasMatrix ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the Vector property with the given name or name ID. This also works with the Vector Array property. To set the property, use SetVector.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasVector ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the Vector property with the given name or name ID. This also works with the Vector Array property. To set the property, use SetVector.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasVector ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the Color property with the given name or name ID. To set the property, use SetColor.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasColor ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the Color property with the given name or name ID. To set the property, use SetColor.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasColor ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the ComputeBuffer property with the given name or name ID. To set the property, use SetBuffer.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasBuffer ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the ComputeBuffer property with the given name or name ID. To set the property, use SetBuffer.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @param name The name of the property.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasBuffer ($nameID: number) : boolean
            /** Checks if MaterialPropertyBlock has the ConstantBuffer property with the given name or name ID. To set the property, use SetConstantBuffer.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasConstantBuffer ($name: string) : boolean
            /** Checks if MaterialPropertyBlock has the ConstantBuffer property with the given name or name ID. To set the property, use SetConstantBuffer.
            * @param name The name of the property.
            * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
            * @returns Returns true if MaterialPropertyBlock has this property. 
            */
            public HasConstantBuffer ($nameID: number) : boolean
            /** Get a float from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetFloat ($name: string) : number
            /** Get a float from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetFloat ($nameID: number) : number
            /** This method is deprecated. Use GetFloat or GetInteger instead.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetInt ($name: string) : number
            /** This method is deprecated. Use GetFloat or GetInteger instead.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetInt ($nameID: number) : number
            /** Get an integer from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetInteger ($name: string) : number
            /** Get an integer from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetInteger ($nameID: number) : number
            /** Get a vector from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetVector ($name: string) : UnityEngine.Vector4
            /** Get a vector from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetVector ($nameID: number) : UnityEngine.Vector4
            /** Get a color from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetColor ($name: string) : UnityEngine.Color
            /** Get a color from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetColor ($nameID: number) : UnityEngine.Color
            /** Get a matrix from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetMatrix ($name: string) : UnityEngine.Matrix4x4
            /** Get a matrix from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetMatrix ($nameID: number) : UnityEngine.Matrix4x4
            /** Get a texture from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetTexture ($name: string) : UnityEngine.Texture
            /** Get a texture from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetTexture ($nameID: number) : UnityEngine.Texture
            /** Get a float array from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetFloatArray ($name: string) : System.Array$1<number>
            /** Get a float array from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetFloatArray ($nameID: number) : System.Array$1<number>
            /** Get a vector array from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetVectorArray ($name: string) : System.Array$1<UnityEngine.Vector4>
            /** Get a vector array from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetVectorArray ($nameID: number) : System.Array$1<UnityEngine.Vector4>
            /** Get a matrix array from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetMatrixArray ($name: string) : System.Array$1<UnityEngine.Matrix4x4>
            /** Get a matrix array from the property block.
            * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
            * @param name The name of the property.
            */
            public GetMatrixArray ($nameID: number) : System.Array$1<UnityEngine.Matrix4x4>
            public GetFloatArray ($name: string, $values: System.Collections.Generic.List$1<number>) : void
            public GetFloatArray ($nameID: number, $values: System.Collections.Generic.List$1<number>) : void
            public GetVectorArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public GetVectorArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public GetMatrixArray ($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public GetMatrixArray ($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>) : void
            public CopySHCoefficientArraysFrom ($lightProbes: System.Collections.Generic.List$1<UnityEngine.Rendering.SphericalHarmonicsL2>) : void
            /** This function converts and copies the entire source array into 7 Vector4 property arrays named unity_SHAr, unity_SHAg, unity_SHAb, unity_SHBr, unity_SHBg, unity_SHBb and unity_SHC for use with instanced rendering.
            * @param lightProbes The array of SH values to copy from.
            */
            public CopySHCoefficientArraysFrom ($lightProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>) : void
            public CopySHCoefficientArraysFrom ($lightProbes: System.Collections.Generic.List$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $sourceStart: number, $destStart: number, $count: number) : void
            /** This function converts and copies the source array into 7 Vector4 property arrays named unity_SHAr, unity_SHAg, unity_SHAb, unity_SHBr, unity_SHBg, unity_SHBb and unity_SHC with the specified source and destination range for use with instanced rendering.
            * @param lightProbes The array of SH values to copy from.
            * @param sourceStart The index of the first element in the source array to copy from.
            * @param destStart The index of the first element in the destination MaterialPropertyBlock array to copy to.
            * @param count The number of elements to copy.
            */
            public CopySHCoefficientArraysFrom ($lightProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $sourceStart: number, $destStart: number, $count: number) : void
            public CopyProbeOcclusionArrayFrom ($occlusionProbes: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            /** This function copies the entire source array into a Vector4 property array named unity_ProbesOcclusion for use with instanced rendering.
            * @param occlusionProbes The array of probe occlusion values to copy from.
            */
            public CopyProbeOcclusionArrayFrom ($occlusionProbes: System.Array$1<UnityEngine.Vector4>) : void
            public CopyProbeOcclusionArrayFrom ($occlusionProbes: System.Collections.Generic.List$1<UnityEngine.Vector4>, $sourceStart: number, $destStart: number, $count: number) : void
            /** This function copies the source array into a Vector4 property array named unity_ProbesOcclusion with the specified source and destination range for use with instanced rendering.
            * @param occlusionProbes The array of probe occlusion values to copy from.
            * @param sourceStart The index of the first element in the source array to copy from.
            * @param destStart The index of the first element in the destination MaterialPropertyBlock array to copy to.
            * @param count The number of elements to copy.
            */
            public CopyProbeOcclusionArrayFrom ($occlusionProbes: System.Array$1<UnityEngine.Vector4>, $sourceStart: number, $destStart: number, $count: number) : void
            public constructor ()
        }
        /** The Light Probe Proxy Volume component offers the possibility to use higher resolution lighting for large non-static GameObjects.
        */
        class LightProbeProxyVolume extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Checks if Light Probe Proxy Volumes are supported.
            */
            public static get isFeatureSupported(): boolean;
            /** The world-space bounding box in which the 3D grid of interpolated Light Probes is generated.
            */
            public get boundsGlobal(): UnityEngine.Bounds;
            /** The size of the bounding box in which the 3D grid of interpolated Light Probes is generated.
            */
            public get sizeCustom(): UnityEngine.Vector3;
            public set sizeCustom(value: UnityEngine.Vector3);
            /** The local-space origin of the bounding box in which the 3D grid of interpolated Light Probes is generated.
            */
            public get originCustom(): UnityEngine.Vector3;
            public set originCustom(value: UnityEngine.Vector3);
            /** Interpolated Light Probe density.
            */
            public get probeDensity(): number;
            public set probeDensity(value: number);
            /** The 3D grid resolution on the x-axis.
            */
            public get gridResolutionX(): number;
            public set gridResolutionX(value: number);
            /** The 3D grid resolution on the y-axis.
            */
            public get gridResolutionY(): number;
            public set gridResolutionY(value: number);
            /** The 3D grid resolution on the z-axis.
            */
            public get gridResolutionZ(): number;
            public set gridResolutionZ(value: number);
            /** The bounding box mode for generating the 3D grid of interpolated Light Probes.
            */
            public get boundingBoxMode(): UnityEngine.LightProbeProxyVolume.BoundingBoxMode;
            public set boundingBoxMode(value: UnityEngine.LightProbeProxyVolume.BoundingBoxMode);
            /** The resolution mode for generating the grid of interpolated Light Probes.
            */
            public get resolutionMode(): UnityEngine.LightProbeProxyVolume.ResolutionMode;
            public set resolutionMode(value: UnityEngine.LightProbeProxyVolume.ResolutionMode);
            /** The mode in which the interpolated Light Probe positions are generated.
            */
            public get probePositionMode(): UnityEngine.LightProbeProxyVolume.ProbePositionMode;
            public set probePositionMode(value: UnityEngine.LightProbeProxyVolume.ProbePositionMode);
            /** Sets the way the Light Probe Proxy Volume refreshes.
            */
            public get refreshMode(): UnityEngine.LightProbeProxyVolume.RefreshMode;
            public set refreshMode(value: UnityEngine.LightProbeProxyVolume.RefreshMode);
            /** Determines how many Spherical Harmonics bands will be evaluated to compute the ambient color.
            */
            public get qualityMode(): UnityEngine.LightProbeProxyVolume.QualityMode;
            public set qualityMode(value: UnityEngine.LightProbeProxyVolume.QualityMode);
            /** The texture data format used by the Light Probe Proxy Volume 3D texture.
            */
            public get dataFormat(): UnityEngine.LightProbeProxyVolume.DataFormat;
            public set dataFormat(value: UnityEngine.LightProbeProxyVolume.DataFormat);
            public Update () : void
            public constructor ()
        }
        /** Low-level graphics library.
        */
        class GL extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Mode for Begin: draw triangles.
            */
            public static TRIANGLES : number
            /** Mode for Begin: draw triangle strip.
            */
            public static TRIANGLE_STRIP : number
            /** Mode for Begin: draw quads.
            */
            public static QUADS : number
            /** Mode for Begin: draw lines.
            */
            public static LINES : number
            /** Mode for Begin: draw line strip.
            */
            public static LINE_STRIP : number
            /** Should rendering be done in wireframe?
            */
            public static get wireframe(): boolean;
            public static set wireframe(value: boolean);
            /** Controls whether Linear-to-sRGB color conversion is performed while rendering.
            */
            public static get sRGBWrite(): boolean;
            public static set sRGBWrite(value: boolean);
            /** Select whether to invert the backface culling (true) or not (false).
            */
            public static get invertCulling(): boolean;
            public static set invertCulling(value: boolean);
            /** Gets or sets the modelview matrix.
            */
            public static get modelview(): UnityEngine.Matrix4x4;
            public static set modelview(value: UnityEngine.Matrix4x4);
            /** Submit a vertex.
            */
            public static Vertex3 ($x: number, $y: number, $z: number) : void
            /** Submit a vertex.
            */
            public static Vertex ($v: UnityEngine.Vector3) : void
            /** Sets current texture coordinate (x,y,z) for all texture units.
            */
            public static TexCoord3 ($x: number, $y: number, $z: number) : void
            /** Sets current texture coordinate (v.x,v.y,v.z) for all texture units.
            */
            public static TexCoord ($v: UnityEngine.Vector3) : void
            /** Sets current texture coordinate (x,y) for all texture units.
            */
            public static TexCoord2 ($x: number, $y: number) : void
            /** Sets current texture coordinate (x,y,z) to the actual texture unit.
            */
            public static MultiTexCoord3 ($unit: number, $x: number, $y: number, $z: number) : void
            /** Sets current texture coordinate (v.x,v.y,v.z) to the actual texture unit.
            */
            public static MultiTexCoord ($unit: number, $v: UnityEngine.Vector3) : void
            /** Sets current texture coordinate (x,y) for the actual texture unit.
            */
            public static MultiTexCoord2 ($unit: number, $x: number, $y: number) : void
            /** Sets current vertex color.
            */
            public static Color ($c: UnityEngine.Color) : void
            public static Flush () : void
            public static RenderTargetBarrier () : void
            /** Sets the current model matrix to the one specified.
            */
            public static MultMatrix ($m: UnityEngine.Matrix4x4) : void
            public static PushMatrix () : void
            public static PopMatrix () : void
            public static LoadIdentity () : void
            public static LoadOrtho () : void
            public static LoadPixelMatrix () : void
            /** Load an arbitrary matrix to the current projection matrix.
            */
            public static LoadProjectionMatrix ($mat: UnityEngine.Matrix4x4) : void
            public static InvalidateState () : void
            /** Compute GPU projection matrix from camera's projection matrix.
            * @param proj Source projection matrix.
            * @param renderIntoTexture Will this projection be used for rendering into a RenderTexture?
            * @returns Adjusted projection matrix for the current graphics API. 
            */
            public static GetGPUProjectionMatrix ($proj: UnityEngine.Matrix4x4, $renderIntoTexture: boolean) : UnityEngine.Matrix4x4
            /** Setup a matrix for pixel-correct rendering.
            */
            public static LoadPixelMatrix ($left: number, $right: number, $bottom: number, $top: number) : void
            /** Send a user-defined event to a native code plugin.
            * @param eventID User defined id to send to the callback.
            * @param callback Native code callback to queue for Unity's renderer to invoke.
            */
            public static IssuePluginEvent ($callback: System.IntPtr, $eventID: number) : void
            /** Begin drawing 3D primitives.
            * @param mode Primitives to draw: can be TRIANGLES, TRIANGLE_STRIP, QUADS or LINES.
            */
            public static Begin ($mode: number) : void
            public static End () : void
            /** Clear the current render buffer.
            * @param clearDepth Should the depth buffer be cleared?
            * @param clearColor Should the color buffer be cleared?
            * @param backgroundColor The color to clear with, used only if clearColor is true.
            * @param depth The depth to clear the z-buffer with, used only if clearDepth is true. The valid
            range is from 0 (near plane) to 1 (far plane). The value is graphics API agnostic: the abstraction layer will convert
            the value to match the convention of the current graphics API.
            */
            public static Clear ($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color, $depth: number) : void
            public static Clear ($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color) : void
            /** Set the rendering viewport.
            */
            public static Viewport ($pixelRect: UnityEngine.Rect) : void
            /** Clear the current render buffer with camera's skybox.
            * @param clearDepth Should the depth buffer be cleared?
            * @param camera Camera to get projection parameters and skybox from.
            */
            public static ClearWithSkybox ($clearDepth: boolean, $camera: UnityEngine.Camera) : void
            public constructor ()
        }
        /** Scales render textures to support dynamic resolution if the target platform/graphics API supports it.
        */
        class ScalableBufferManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Width scale factor to control dynamic resolution.
            */
            public static get widthScaleFactor(): number;
            /** Height scale factor to control dynamic resolution.
            */
            public static get heightScaleFactor(): number;
            /** Function to resize all buffers marked as DynamicallyScalable.
            * @param widthScale New scale factor for the width the ScalableBufferManager will use to resize all render textures the user marked as DynamicallyScalable, has to be some value greater than 0.0 and less than or equal to 1.0.
            * @param heightScale New scale factor for the height the ScalableBufferManager will use to resize all render textures the user marked as DynamicallyScalable, has to be some value greater than 0.0 and less than or equal to 1.0.
            */
            public static ResizeBuffers ($widthScale: number, $heightScale: number) : void
        }
        /** Struct containing basic FrameTimings and accompanying relevant data.
        */
        class FrameTiming extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** This is the CPU clock time at the point Present was called for the current frame.
            */
            public cpuTimePresentCalled : bigint
            /** The CPU time for a given frame, in ms.
            */
            public cpuFrameTime : number
            /** This is the CPU clock time at the point GPU finished rendering the frame and interrupted the CPU.
            */
            public cpuTimeFrameComplete : bigint
            /** The GPU time for a given frame, in ms.
            */
            public gpuFrameTime : number
            /** This was the height scale factor of the Dynamic Resolution system(if used) for the given frame and the linked frame timings.
            */
            public heightScale : number
            /** This was the width scale factor of the Dynamic Resolution system(if used) for the given frame and the linked frame timings.
            */
            public widthScale : number
            /** This was the vsync mode for the given frame and the linked frame timings.
            */
            public syncInterval : number
        }
        /** The FrameTimingManager allows the user to capture and access FrameTiming data for multiple frames.
        */
        class FrameTimingManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CaptureFrameTimings () : void
            /** Allows the user to access the currently captured FrameTimings.
            * @param numFrames User supplies a desired number of frames they would like FrameTimings for. This should be equal to or less than the maximum FrameTimings the platform can capture.
            * @param timings An array of FrameTiming structs that is passed in by the user and will be filled with data as requested. It is the users job to make sure the array that is passed is large enough to hold the requested number of FrameTimings.
            * @returns Returns the number of FrameTimings it actually was able to get. This will always be equal to or less than the requested numFrames depending on availability of captured FrameTimings. 
            */
            public static GetLatestTimings ($numFrames: number, $timings: System.Array$1<UnityEngine.FrameTiming>) : number
            public static GetVSyncsPerSecond () : number
            public static GetGpuTimerFrequency () : bigint
            public static GetCpuTimerFrequency () : bigint
        }
        /** Data of a lightmap.
        */
        class LightmapData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Lightmap storing color of incoming light.
            */
            public get lightmapColor(): UnityEngine.Texture2D;
            public set lightmapColor(value: UnityEngine.Texture2D);
            /** Lightmap storing dominant direction of incoming light.
            */
            public get lightmapDir(): UnityEngine.Texture2D;
            public set lightmapDir(value: UnityEngine.Texture2D);
            /** Texture storing occlusion mask per light (ShadowMask, up to four lights).
            */
            public get shadowMask(): UnityEngine.Texture2D;
            public set shadowMask(value: UnityEngine.Texture2D);
            public constructor ()
        }
        /** Class that represents textures in C# code.
        */
        class Texture2D extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** The format of the pixel data in the texture (Read Only).
            */
            public get format(): UnityEngine.TextureFormat;
            /** This property causes a texture to ignore the QualitySettings.masterTextureLimit.
            */
            public get ignoreMipmapLimit(): boolean;
            public set ignoreMipmapLimit(value: boolean);
            /** Gets a small Texture with all white pixels.
            */
            public static get whiteTexture(): UnityEngine.Texture2D;
            /** Gets a small Texture with all black pixels.
            */
            public static get blackTexture(): UnityEngine.Texture2D;
            /** Gets a small Texture with all red pixels.
            */
            public static get redTexture(): UnityEngine.Texture2D;
            /** Gets a small Texture with all gray pixels.
            */
            public static get grayTexture(): UnityEngine.Texture2D;
            /** Gets a small Texture with all gray pixels.
            */
            public static get linearGrayTexture(): UnityEngine.Texture2D;
            /** Gets a small Texture with pixels that represent surface normal vectors at a neutral position.
            */
            public static get normalTexture(): UnityEngine.Texture2D;
            public get isReadable(): boolean;
            /** Returns true if the VTOnly checkbox was checked when the texture was imported; otherwise returns false. For additional information, see TextureImporter.vtOnly.
            */
            public get vtOnly(): boolean;
            /** Determines whether mipmap streaming is enabled for this Texture.
            */
            public get streamingMipmaps(): boolean;
            /** Sets the relative priority for this Texture when reducing memory size to fit within the memory budget.
            */
            public get streamingMipmapsPriority(): number;
            /** The mipmap level to load.
            */
            public get requestedMipmapLevel(): number;
            public set requestedMipmapLevel(value: number);
            /** Restricts the mipmap streaming system to a minimum mip level for this Texture.
            */
            public get minimumMipmapLevel(): number;
            public set minimumMipmapLevel(value: number);
            /** The mipmap level calculated by the streaming system, which takes into account the streaming Cameras and the location of the objects containing this Texture. This is unaffected by requestedMipmapLevel or minimumMipmapLevel.
            */
            public get calculatedMipmapLevel(): number;
            /** The mipmap level that the streaming system would load before memory budgets are applied.
            */
            public get desiredMipmapLevel(): number;
            /** The mipmap level that the mipmap streaming system is in the process of loading.
            */
            public get loadingMipmapLevel(): number;
            /** The mipmap level that is currently loaded by the streaming system.
            */
            public get loadedMipmapLevel(): number;
            /** Compress texture at runtime to DXT/BCn or ETC formats.
            */
            public Compress ($highQuality: boolean) : void
            public ClearRequestedMipmapLevel () : void
            public IsRequestedMipmapLevelLoaded () : boolean
            public ClearMinimumMipmapLevel () : void
            /** Updates Unity texture to use different native texture object.
            * @param nativeTex Native 2D texture object.
            */
            public UpdateExternalTexture ($nativeTex: System.IntPtr) : void
            public GetRawTextureData () : System.Array$1<number>
            /** Gets the pixel color data for part of a mipmap level as Color structs.
            * @param x The starting x position of the section to fetch.
            * @param y The starting y position of the section to fetch.
            * @param blockWidth The width of the section to fetch.
            * @param blockHeight The height of the section to fetch.
            * @param miplevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($x: number, $y: number, $blockWidth: number, $blockHeight: number, $miplevel: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for part of a mipmap level as Color structs.
            * @param x The starting x position of the section to fetch.
            * @param y The starting y position of the section to fetch.
            * @param blockWidth The width of the section to fetch.
            * @param blockHeight The height of the section to fetch.
            * @param miplevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($x: number, $y: number, $blockWidth: number, $blockHeight: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level as Color32 structs.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($miplevel: number) : System.Array$1<UnityEngine.Color32>
            /** Gets the pixel color data for a mipmap level as Color32 structs.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 () : System.Array$1<UnityEngine.Color32>
            /** Packs multiple Textures into a texture atlas.
            * @param textures Array of textures to pack into the atlas.
            * @param padding Padding in pixels between the packed textures.
            * @param maximumAtlasSize Maximum size of the resulting texture.
            * @param makeNoLongerReadable Should the texture be marked as no longer readable?
            * @returns An array of rectangles containing the UV coordinates in the atlas for each input texture, or null if packing fails. 
            */
            public PackTextures ($textures: System.Array$1<UnityEngine.Texture2D>, $padding: number, $maximumAtlasSize: number, $makeNoLongerReadable: boolean) : System.Array$1<UnityEngine.Rect>
            public PackTextures ($textures: System.Array$1<UnityEngine.Texture2D>, $padding: number, $maximumAtlasSize: number) : System.Array$1<UnityEngine.Rect>
            public PackTextures ($textures: System.Array$1<UnityEngine.Texture2D>, $padding: number) : System.Array$1<UnityEngine.Rect>
            /** Creates a Unity Texture out of an externally created native texture object.
            * @param nativeTex Native 2D texture object.
            * @param width Width of texture in pixels.
            * @param height Height of texture in pixels.
            * @param format Format of underlying texture object.
            * @param mipmap Does the texture have mipmaps?
            * @param linear Is texture using linear color space?
            */
            public static CreateExternalTexture ($width: number, $height: number, $format: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean, $nativeTex: System.IntPtr) : UnityEngine.Texture2D
            /** Sets the pixel color at coordinates (x,y).
            * @param x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
            * @param y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
            * @param color The color to set.
            * @param mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixel ($x: number, $y: number, $color: UnityEngine.Color) : void
            /** Sets the pixel color at coordinates (x,y).
            * @param x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
            * @param y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
            * @param color The color to set.
            * @param mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixel ($x: number, $y: number, $color: UnityEngine.Color, $mipLevel: number) : void
            /** Sets the pixel colors of part of a mipmap level.
            * @param x The x coordinate to place the block of pixels at. The range is 0 through (texture width - 1).
            * @param y The y coordinate to place the block of pixels at. The range is 0 through (texture height - 1).
            * @param blockWidth The width of the block of pixels to set.
            * @param blockHeight The height of the block of pixels to set.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array. Must be blockWidth x blockHeight in length.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels ($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color>, $miplevel: number) : void
            public SetPixels ($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color>) : void
            /** Sets the pixel colors of an entire mipmap level.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $miplevel: number) : void
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>) : void
            /** Gets the pixel color at coordinates (x, y).
            * @param x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
            * @param y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
            * @param mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixel ($x: number, $y: number) : UnityEngine.Color
            /** Gets the pixel color at coordinates (x, y).
            * @param x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
            * @param y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
            * @param mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixel ($x: number, $y: number, $mipLevel: number) : UnityEngine.Color
            /** Gets the filtered pixel color at the normalized coordinates (u, v).
            * @param u The u coordinate of the pixel to get.
            * @param v The v coordinate of the pixel to get.
            * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixelBilinear ($u: number, $v: number) : UnityEngine.Color
            /** Gets the filtered pixel color at the normalized coordinates (u, v).
            * @param u The u coordinate of the pixel to get.
            * @param v The v coordinate of the pixel to get.
            * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixelBilinear ($u: number, $v: number, $mipLevel: number) : UnityEngine.Color
            /** Sets the raw data of an entire texture in CPU memory.
            * @param data The array of data to use.
            * @param size The size of the data in bytes.
            */
            public LoadRawTextureData ($data: System.IntPtr, $size: number) : void
            /** Sets the raw data of an entire texture in CPU memory.
            * @param data The array of data to use.
            * @param size The size of the data in bytes.
            */
            public LoadRawTextureData ($data: System.Array$1<number>) : void
            /** Copies changes you've made in a CPU texture to the GPU.
            * @param updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
            * @param makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
            */
            public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
            public Apply ($updateMipmaps: boolean) : void
            public Apply () : void
            /** Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture.
            * @param width New width of the Texture.
            * @param height New height of the Texture.
            * @param format New format of the Texture.
            * @param hasMipMap Indicates if the Texture should reserve memory for a full mip map chain.
            * @returns Returns true if the reinitialization was a success. 
            */
            public Reinitialize ($width: number, $height: number) : boolean
            /** Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture.
            * @param width New width of the Texture.
            * @param height New height of the Texture.
            * @param format New format of the Texture.
            * @param hasMipMap Indicates if the Texture should reserve memory for a full mip map chain.
            * @returns Returns true if the reinitialization was a success. 
            */
            public Reinitialize ($width: number, $height: number, $format: UnityEngine.TextureFormat, $hasMipMap: boolean) : boolean
            /** Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture.
            * @param width New width of the Texture.
            * @param height New height of the Texture.
            * @param format New format of the Texture.
            * @param hasMipMap Indicates if the Texture should reserve memory for a full mip map chain.
            * @returns Returns true if the reinitialization was a success. 
            */
            public Reinitialize ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $hasMipMap: boolean) : boolean
            /** Reads pixels from the current render target and writes them to a texture.
            * @param source The region of the render target to read from.
            * @param destX The x position in the texture to write the pixels to.
            * @param destY The y position in the texture to write the pixels to.
            * @param recalculateMipMaps When the value is true, Unity automatically recalculates the mipmap for the texture after it writes the pixel data. Otherwise, Unity doesn't do this automatically.
            */
            public ReadPixels ($source: UnityEngine.Rect, $destX: number, $destY: number, $recalculateMipMaps: boolean) : void
            public ReadPixels ($source: UnityEngine.Rect, $destX: number, $destY: number) : void
            public static GenerateAtlas ($sizes: System.Array$1<UnityEngine.Vector2>, $padding: number, $atlasSize: number, $results: System.Collections.Generic.List$1<UnityEngine.Rect>) : boolean
            /** Sets the pixel colors of an entire mipmap level.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>) : void
            /** Sets the pixel colors of part of a mipmap level.
            * @param x The x coordinate to place the block of pixels at. The range is 0 through (texture width - 1).
            * @param y The y coordinate to place the block of pixels at. The range is 0 through (texture height - 1).
            * @param blockWidth The width of the block of pixels to set.
            * @param blockHeight The height of the block of pixels to set.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array. Must be blockWidth x blockHeight in length.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color32>, $miplevel: number) : void
            /** Sets the pixel colors of part of a mipmap level.
            * @param x The x coordinate to place the block of pixels at. The range is 0 through (texture width - 1).
            * @param y The y coordinate to place the block of pixels at. The range is 0 through (texture height - 1).
            * @param blockWidth The width of the block of pixels to set.
            * @param blockHeight The height of the block of pixels to set.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array. Must be blockWidth x blockHeight in length.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color32>) : void
            /** Gets the pixel color data for a mipmap level as Color structs.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($miplevel: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level as Color structs.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels () : System.Array$1<UnityEngine.Color>
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean)
            public constructor ($width: number, $height: number)
            public constructor ()
        }
        /** Class that represents textures in C# code.
        */
        interface Texture2D {
            /** Encodes the specified texture in TGA format.
            * @param tex The texture to encode.
            */
            EncodeToTGA () : System.Array$1<number>;
            /** Encodes this texture into PNG format.
            * @param tex The texture to convert.
            */
            EncodeToPNG () : System.Array$1<number>;
            /** Encodes this texture into JPG format.
            * @param tex Text texture to convert.
            * @param quality JPG quality to encode with. The range is 1 through 100. 1 is the lowest quality. The default is 75.
            */
            EncodeToJPG ($quality: number) : System.Array$1<number>;
            /** Encodes this texture into JPG format.
            * @param tex Text texture to convert.
            * @param quality JPG quality to encode with. The range is 1 through 100. 1 is the lowest quality. The default is 75.
            */
            EncodeToJPG () : System.Array$1<number>;
            EncodeToEXR ($flags: UnityEngine.Texture2D.EXRFlags) : System.Array$1<number>;
            EncodeToEXR () : System.Array$1<number>;
            /** Loads PNG or JPG image byte array into a texture.
            * @param tex The texture to load the image into.
            * @param data The byte array containing the image data to load.
            * @param markNonReadable Set to false by default, pass true to optionally mark the texture as non-readable.
            * @returns Returns true if the data can be loaded, false otherwise. 
            */
            LoadImage ($data: System.Array$1<number>, $markNonReadable: boolean) : boolean;
            LoadImage ($data: System.Array$1<number>) : boolean;
        }
        /** Stores lightmaps of the Scene.
        */
        class LightmapSettings extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Lightmap array.
            */
            public static get lightmaps(): System.Array$1<UnityEngine.LightmapData>;
            public static set lightmaps(value: System.Array$1<UnityEngine.LightmapData>);
            /** NonDirectional or CombinedDirectional Specular lightmaps rendering mode.
            */
            public static get lightmapsMode(): UnityEngine.LightmapsMode;
            public static set lightmapsMode(value: UnityEngine.LightmapsMode);
            /** Baked Light Probe data.
            */
            public static get lightProbes(): UnityEngine.LightProbes;
            public static set lightProbes(value: UnityEngine.LightProbes);
        }
        /** Lightmap (and lighting) configuration mode, controls how lightmaps interact with lighting and what kind of information they store.
        */
        enum LightmapsMode
        { NonDirectional = 0, CombinedDirectional = 1, SeparateDirectional = 2, Single = 0, Dual = 1, Directional = 2 }
        /** Stores light probe data for all currently loaded Scenes.
        */
        class LightProbes extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Positions of the baked light probes (Read Only).
            */
            public get positions(): System.Array$1<UnityEngine.Vector3>;
            /** Coefficients of baked light probes.
            */
            public get bakedProbes(): System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>;
            public set bakedProbes(value: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>);
            /** The number of light probes (Read Only).
            */
            public get count(): number;
            /** The number of cells space is divided into (Read Only).
            */
            public get cellCount(): number;
            public static add_tetrahedralizationCompleted ($value: System.Action) : void
            public static remove_tetrahedralizationCompleted ($value: System.Action) : void
            public static add_needsRetetrahedralization ($value: System.Action) : void
            public static remove_needsRetetrahedralization ($value: System.Action) : void
            public static Tetrahedralize () : void
            public static TetrahedralizeAsync () : void
            /** Returns an interpolated probe for the given position for both real-time and baked light probes combined.
            */
            public static GetInterpolatedProbe ($position: UnityEngine.Vector3, $renderer: UnityEngine.Renderer, $probe: $Ref<UnityEngine.Rendering.SphericalHarmonicsL2>) : void
            /** Calculate light probes and occlusion probes at the given world space positions.
            * @param positions The array of world space positions used to evaluate the probes.
            * @param lightProbes The array where the resulting light probes are written to.
            * @param occlusionProbes The array where the resulting occlusion probes are written to.
            */
            public static CalculateInterpolatedLightAndOcclusionProbes ($positions: System.Array$1<UnityEngine.Vector3>, $lightProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $occlusionProbes: System.Array$1<UnityEngine.Vector4>) : void
            public static CalculateInterpolatedLightAndOcclusionProbes ($positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $lightProbes: System.Collections.Generic.List$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $occlusionProbes: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
        }
        /** Single, dual, or directional lightmaps rendering mode, used only in GIWorkflowMode.Legacy
        */
        enum LightmapsModeLegacy
        { Single = 0, Dual = 1, Directional = 2 }
        /** Color space for player settings.
        */
        enum ColorSpace
        { Uninitialized = -1, Gamma = 0, Linear = 1 }
        /** The type for the number of bits to be used when an HDR display is active in each color channel of swap chain buffers. The bit count also defines the method Unity uses to render content to the display.
        */
        enum D3DHDRDisplayBitDepth
        { D3DHDRDisplayBitDepth10 = 0, D3DHDRDisplayBitDepth16 = 1 }
        /** Provides access to HDR display settings and information.
        */
        class HDROutputSettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The list of currently connected displays with possible HDR availability.
            */
            public static displays : System.Array$1<UnityEngine.HDROutputSettings>
            /** The HDROutputSettings for the main display.
            */
            public static get main(): UnityEngine.HDROutputSettings;
            /** Describes whether HDR output is currently active on the display. It is true if this is the case, and @@false@ otherwise.
            */
            public get active(): boolean;
            /** Describes whether HDR is currently available on your primary display and that you have HDR enabled in your Unity Project. It is true if this is the case, and false otherwise.
            */
            public get available(): boolean;
            /** Describes whether Unity performs HDR tonemapping automatically.
            */
            public get automaticHDRTonemapping(): boolean;
            public set automaticHDRTonemapping(value: boolean);
            /** The ColorGamut used to output to the active HDR display.
            */
            public get displayColorGamut(): UnityEngine.ColorGamut;
            /** The RenderTextureFormat of the display buffer for the active HDR display.
            */
            public get format(): UnityEngine.RenderTextureFormat;
            /** The Experimental.Rendering.GraphicsFormat of the display buffer for the active HDR display.
            */
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            /** The base luminance of a white paper surface in nits or candela per square meter (cd/m2).
            */
            public get paperWhiteNits(): number;
            public set paperWhiteNits(value: number);
            /** Maximum input luminance at which gradation is preserved even when the entire screen is bright.
            */
            public get maxFullFrameToneMapLuminance(): number;
            /** Maximum input luminance at which gradation is preserved when 10% of the screen is bright.
            */
            public get maxToneMapLuminance(): number;
            /** Minimum input luminance at which gradation is identifiable.
            */
            public get minToneMapLuminance(): number;
            /** Describes whether the user has requested to change the HDR Output Mode. It is true if this is the case, and false otherwise.
            */
            public get HDRModeChangeRequested(): boolean;
            /** Use this function to request a change in the HDR Output Mode and in the value of HDROutputSettings.active.
            * @param enabled Indicates whether HDR should be enabled.
            */
            public RequestHDRModeChange ($enabled: boolean) : void
        }
        /** Format of a RenderTexture.
        */
        enum RenderTextureFormat
        { ARGB32 = 0, Depth = 1, ARGBHalf = 2, Shadowmap = 3, RGB565 = 4, ARGB4444 = 5, ARGB1555 = 6, Default = 7, ARGB2101010 = 8, DefaultHDR = 9, ARGB64 = 10, ARGBFloat = 11, RGFloat = 12, RGHalf = 13, RFloat = 14, RHalf = 15, R8 = 16, ARGBInt = 17, RGInt = 18, RInt = 19, BGRA32 = 20, RGB111110Float = 22, RG32 = 23, RGBAUShort = 24, RG16 = 25, BGRA10101010_XR = 26, BGR101010_XR = 27, R16 = 28 }
        /** The type of motion vectors that should be generated.
        */
        enum MotionVectorGenerationMode
        { Camera = 0, Object = 1, ForceNoMotion = 2 }
        /** Script interface for.
        */
        class QualitySettings extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The maximum number of pixel lights that should affect any object.
            */
            public static get pixelLightCount(): number;
            public static set pixelLightCount(value: number);
            /** Real-time Shadows type to be used.
            */
            public static get shadows(): UnityEngine.ShadowQuality;
            public static set shadows(value: UnityEngine.ShadowQuality);
            /** Directional light shadow projection.
            */
            public static get shadowProjection(): UnityEngine.ShadowProjection;
            public static set shadowProjection(value: UnityEngine.ShadowProjection);
            /** Number of cascades to use for directional light shadows.
            */
            public static get shadowCascades(): number;
            public static set shadowCascades(value: number);
            /** Shadow drawing distance.
            */
            public static get shadowDistance(): number;
            public static set shadowDistance(value: number);
            /** The default resolution of the shadow maps.
            */
            public static get shadowResolution(): UnityEngine.ShadowResolution;
            public static set shadowResolution(value: UnityEngine.ShadowResolution);
            /** The rendering mode of Shadowmask.
            */
            public static get shadowmaskMode(): UnityEngine.ShadowmaskMode;
            public static set shadowmaskMode(value: UnityEngine.ShadowmaskMode);
            /** Offset shadow frustum near plane.
            */
            public static get shadowNearPlaneOffset(): number;
            public static set shadowNearPlaneOffset(value: number);
            /** The normalized cascade distribution for a 2 cascade setup. The value defines the position of the cascade with respect to Zero.
            */
            public static get shadowCascade2Split(): number;
            public static set shadowCascade2Split(value: number);
            /** The normalized cascade start position for a 4 cascade setup. Each member of the vector defines the normalized position of the coresponding cascade with respect to Zero.
            */
            public static get shadowCascade4Split(): UnityEngine.Vector3;
            public static set shadowCascade4Split(value: UnityEngine.Vector3);
            /** Global multiplier for the LOD's switching distance.
            */
            public static get lodBias(): number;
            public static set lodBias(value: number);
            /** Global anisotropic filtering mode.
            */
            public static get anisotropicFiltering(): UnityEngine.AnisotropicFiltering;
            public static set anisotropicFiltering(value: UnityEngine.AnisotropicFiltering);
            /** A texture size limit applied to most textures. Indicates how many mipmaps should be dropped. The default value is zero.
            */
            public static get masterTextureLimit(): number;
            public static set masterTextureLimit(value: number);
            /** A maximum LOD level. All LOD groups.
            */
            public static get maximumLODLevel(): number;
            public static set maximumLODLevel(value: number);
            /** Budget for how many ray casts can be performed per frame for approximate collision testing.
            */
            public static get particleRaycastBudget(): number;
            public static set particleRaycastBudget(value: number);
            /** Should soft blending be used for particles?
            */
            public static get softParticles(): boolean;
            public static set softParticles(value: boolean);
            /** Use a two-pass shader for the vegetation in the terrain engine.
            */
            public static get softVegetation(): boolean;
            public static set softVegetation(value: boolean);
            /** The number of vertical syncs that should pass between each frame.
            */
            public static get vSyncCount(): number;
            public static set vSyncCount(value: number);
            /** How much CPU usage to assign to the final lighting calculations at runtime.
            */
            public static get realtimeGICPUUsage(): number;
            public static set realtimeGICPUUsage(value: number);
            /** Choose the level of Multi-Sample Anti-aliasing (MSAA) that the GPU performs.
            */
            public static get antiAliasing(): number;
            public static set antiAliasing(value: number);
            /** Async texture upload provides timesliced async texture upload on the render thread with tight control over memory and timeslicing. There are no allocations except for the ones which driver has to do. To read data and upload texture data a ringbuffer whose size can be controlled is re-used.
            Use asyncUploadTimeSlice to set the time-slice in milliseconds for asynchronous texture uploads per
            frame. Minimum value is 1 and maximum is 33.
            */
            public static get asyncUploadTimeSlice(): number;
            public static set asyncUploadTimeSlice(value: number);
            /** Asynchronous texture and mesh data upload provides timesliced async texture and mesh data upload on the render thread with tight control over memory and timeslicing. There are no allocations except for the ones which driver has to do. To read data and upload texture and mesh data, Unity re-uses a ringbuffer whose size can be controlled.
            Use asyncUploadBufferSize to set the buffer size for asynchronous texture and mesh data uploads. The minimum value is 2 megabytes and the maximum value is 2047 megabytes. The buffer resizes automatically to fit the largest texture currently loading. To avoid a buffer resize (which can use extra system resources) set this value to the size of the largest texture in the Scene. If you have issues with excessive memory usage, you may need to reduce the value of this buffer or disable asyncUploadPersistentBuffer. Memory fragmentation can occur if you choose the latter option.
            */
            public static get asyncUploadBufferSize(): number;
            public static set asyncUploadBufferSize(value: number);
            /** This flag controls if the async upload pipeline's ring buffer remains allocated when there are no active loading operations.
            Set this to true, to make the ring buffer allocation persist after all upload operations have completed.
            If you have issues with excessive memory usage, you can set this to false. This means you reduce the runtime memory footprint, but memory fragmentation can occur.
            The default value is true.
            */
            public static get asyncUploadPersistentBuffer(): boolean;
            public static set asyncUploadPersistentBuffer(value: boolean);
            /** Enables real-time reflection probes.
            */
            public static get realtimeReflectionProbes(): boolean;
            public static set realtimeReflectionProbes(value: boolean);
            /** If enabled, billboards will face towards camera position rather than camera orientation.
            */
            public static get billboardsFaceCameraPosition(): boolean;
            public static set billboardsFaceCameraPosition(value: boolean);
            /** In resolution scaling mode, this factor is used to multiply with the target Fixed DPI specified to get the actual Fixed DPI to use for this quality setting.
            */
            public static get resolutionScalingFixedDPIFactor(): number;
            public static set resolutionScalingFixedDPIFactor(value: number);
            /** The RenderPipelineAsset that defines the override render pipeline for the current quality level.
            */
            public static get renderPipeline(): UnityEngine.Rendering.RenderPipelineAsset;
            public static set renderPipeline(value: UnityEngine.Rendering.RenderPipelineAsset);
            /** The maximum number of bones per vertex that are taken into account during skinning, for all meshes in the project.
            */
            public static get skinWeights(): UnityEngine.SkinWeights;
            public static set skinWeights(value: UnityEngine.SkinWeights);
            /** Enable automatic streaming of texture mipmap levels based on their distance from all active cameras.
            */
            public static get streamingMipmapsActive(): boolean;
            public static set streamingMipmapsActive(value: boolean);
            /** The total amount of memory (in megabytes) to be used by streaming and non-streaming textures.
            */
            public static get streamingMipmapsMemoryBudget(): number;
            public static set streamingMipmapsMemoryBudget(value: number);
            /** The maximum number of mipmap levels to discard for each texture.
            */
            public static get streamingMipmapsMaxLevelReduction(): number;
            public static set streamingMipmapsMaxLevelReduction(value: number);
            /** Process all enabled Cameras for texture streaming (rather than just those with StreamingController components).
            */
            public static get streamingMipmapsAddAllCameras(): boolean;
            public static set streamingMipmapsAddAllCameras(value: boolean);
            /** The maximum number of active texture file IO requests from the texture streaming system.
            */
            public static get streamingMipmapsMaxFileIORequests(): number;
            public static set streamingMipmapsMaxFileIORequests(value: number);
            /** Maximum number of frames queued up by graphics driver.
            */
            public static get maxQueuedFrames(): number;
            public static set maxQueuedFrames(value: number);
            /** The indexed list of available Quality Settings.
            */
            public static get names(): System.Array$1<string>;
            /** Desired color space (Read Only).
            */
            public static get desiredColorSpace(): UnityEngine.ColorSpace;
            /** Active color space (Read Only).
            */
            public static get activeColorSpace(): UnityEngine.ColorSpace;
            /** Increase the current quality level.
            * @param applyExpensiveChanges Should expensive changes be applied (Anti-aliasing etc).
            */
            public static IncreaseLevel ($applyExpensiveChanges: boolean) : void
            /** Decrease the current quality level.
            * @param applyExpensiveChanges Should expensive changes be applied (Anti-aliasing etc).
            */
            public static DecreaseLevel ($applyExpensiveChanges: boolean) : void
            public static SetQualityLevel ($index: number) : void
            public static IncreaseLevel () : void
            public static DecreaseLevel () : void
            /** Sets the QualitySettings.lodBias|lodBias and QualitySettings.maximumLODLevel|maximumLODLevel at the same time.
            * @param lodBias Global multiplier for the LOD's switching distance.
            * @param maximumLODLevel A maximum LOD level. All LOD groups.
            * @param setDirty If true, marks all views as dirty.
            */
            public static SetLODSettings ($lodBias: number, $maximumLODLevel: number, $setDirty?: boolean) : void
            /** Provides a reference to the RenderPipelineAsset that defines the override render pipeline for a given quality level. 
            * @param index Index of the quality level.
            * @returns Returns null if the quality level does not exist, or if no asset is assigned to that quality level. Otherwise, returns the RenderPipelineAsset that defines the override render pipeline for the quality level. 
            */
            public static GetRenderPipelineAssetAt ($index: number) : UnityEngine.Rendering.RenderPipelineAsset
            public static GetQualityLevel () : number
            public static GetQualitySettings () : UnityEngine.Object
            /** Sets a new graphics quality level.
            * @param index Quality index to set.
            * @param applyExpensiveChanges Should expensive changes be applied (Anti-aliasing etc).
            */
            public static SetQualityLevel ($index: number, $applyExpensiveChanges: boolean) : void
            public static GetAllRenderPipelineAssetsForPlatform ($buildTargetGroupName: string, $renderPipelineAssets: $Ref<System.Collections.Generic.List$1<UnityEngine.Rendering.RenderPipelineAsset>>) : void
        }
        enum QualityLevel
        { Fastest = 0, Fast = 1, Simple = 2, Good = 3, Beautiful = 4, Fantastic = 5 }
        /** Determines which type of shadows should be used.
        */
        enum ShadowQuality
        { Disable = 0, HardOnly = 1, All = 2 }
        /** Shadow projection type for.
        */
        enum ShadowProjection
        { CloseFit = 0, StableFit = 1 }
        /** Default shadow resolution. Each decrease in quality level halves the resolution of shadows.
        */
        enum ShadowResolution
        { Low = 0, Medium = 1, High = 2, VeryHigh = 3 }
        /** The rendering mode of Shadowmask.
        */
        enum ShadowmaskMode
        { Shadowmask = 0, DistanceShadowmask = 1 }
        /** Anisotropic filtering mode.
        */
        enum AnisotropicFiltering
        { Disable = 0, Enable = 1, ForceEnable = 2 }
        enum BlendWeights
        { OneBone = 1, TwoBones = 2, FourBones = 4 }
        /** Skin weights.
        */
        enum SkinWeights
        { OneBone = 1, TwoBones = 2, FourBones = 4, Unlimited = 255 }
        /** Extension methods to the Renderer class, used only for the UpdateGIMaterials method used by the Global Illumination System.
        */
        class RendererExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
            */
            public static UpdateGIMaterials ($renderer: UnityEngine.Renderer) : void
        }
        /** When using HDR rendering it can sometime be desirable to switch to LDR rendering during ImageEffect rendering.
        */
        class ImageEffectTransformsToLDR extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Any Image Effect with this attribute can be rendered into the Scene view camera.
        */
        class ImageEffectAllowedInSceneView extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Any Image Effect with this attribute will be rendered after opaque geometry but before transparent geometry.
        */
        class ImageEffectOpaque extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Any Image Effect with this attribute will be rendered after Dynamic Resolution stage.
        */
        class ImageEffectAfterScale extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Use this attribute when image effects are implemented using Command Buffers.
        */
        class ImageEffectUsesCommandBuffer extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Describes a bone weight that affects a vertex in a mesh.
        */
        class BoneWeight1 extends System.ValueType implements System.IEquatable$1<UnityEngine.BoneWeight1>
        {
            protected [__keep_incompatibility]: never;
            /** Skinning weight for bone.
            */
            public get weight(): number;
            public set weight(value: number);
            /** Index of bone.
            */
            public get boneIndex(): number;
            public set boneIndex(value: number);
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.BoneWeight1) : boolean
            public static op_Equality ($lhs: UnityEngine.BoneWeight1, $rhs: UnityEngine.BoneWeight1) : boolean
            public static op_Inequality ($lhs: UnityEngine.BoneWeight1, $rhs: UnityEngine.BoneWeight1) : boolean
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        /** Describes 4 skinning bone weights that affect a vertex in a mesh.
        */
        class BoneWeight extends System.ValueType implements System.IEquatable$1<UnityEngine.BoneWeight>
        {
            protected [__keep_incompatibility]: never;
            /** Skinning weight for first bone.
            */
            public get weight0(): number;
            public set weight0(value: number);
            /** Skinning weight for second bone.
            */
            public get weight1(): number;
            public set weight1(value: number);
            /** Skinning weight for third bone.
            */
            public get weight2(): number;
            public set weight2(value: number);
            /** Skinning weight for fourth bone.
            */
            public get weight3(): number;
            public set weight3(value: number);
            /** Index of first bone.
            */
            public get boneIndex0(): number;
            public set boneIndex0(value: number);
            /** Index of second bone.
            */
            public get boneIndex1(): number;
            public set boneIndex1(value: number);
            /** Index of third bone.
            */
            public get boneIndex2(): number;
            public set boneIndex2(value: number);
            /** Index of fourth bone.
            */
            public get boneIndex3(): number;
            public set boneIndex3(value: number);
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.BoneWeight) : boolean
            public static op_Equality ($lhs: UnityEngine.BoneWeight, $rhs: UnityEngine.BoneWeight) : boolean
            public static op_Inequality ($lhs: UnityEngine.BoneWeight, $rhs: UnityEngine.BoneWeight) : boolean
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        /** Struct used to describe meshes to be combined using Mesh.CombineMeshes.
        */
        class CombineInstance extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Mesh to combine.
            */
            public get mesh(): UnityEngine.Mesh;
            public set mesh(value: UnityEngine.Mesh);
            /** Sub-Mesh index of the Mesh.
            */
            public get subMeshIndex(): number;
            public set subMeshIndex(value: number);
            /** Matrix to transform the Mesh with before combining. Refer to Mesh.CombineMeshes for an example.
            */
            public get transform(): UnityEngine.Matrix4x4;
            public set transform(value: UnityEngine.Matrix4x4);
            /** The baked lightmap UV scale and offset applied to the Mesh.
            */
            public get lightmapScaleOffset(): UnityEngine.Vector4;
            public set lightmapScaleOffset(value: UnityEngine.Vector4);
            /** The real-time lightmap UV scale and offset applied to the Mesh.
            */
            public get realtimeLightmapScaleOffset(): UnityEngine.Vector4;
            public set realtimeLightmapScaleOffset(value: UnityEngine.Vector4);
        }
        /** A script interface for a.
        */
        class Projector extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The near clipping plane distance.
            */
            public get nearClipPlane(): number;
            public set nearClipPlane(value: number);
            /** The far clipping plane distance.
            */
            public get farClipPlane(): number;
            public set farClipPlane(value: number);
            /** The field of view of the projection in degrees.
            */
            public get fieldOfView(): number;
            public set fieldOfView(value: number);
            /** The aspect ratio of the projection.
            */
            public get aspectRatio(): number;
            public set aspectRatio(value: number);
            /** Is the projection orthographic (true) or perspective (false)?
            */
            public get orthographic(): boolean;
            public set orthographic(value: boolean);
            /** Projection's half-size when in orthographic mode.
            */
            public get orthographicSize(): number;
            public set orthographicSize(value: number);
            /** Which object layers are ignored by the projector.
            */
            public get ignoreLayers(): number;
            public set ignoreLayers(value: number);
            /** The material that will be projected onto every object.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public constructor ()
        }
        enum TexGenMode
        { None = 0, SphereMap = 1, Object = 2, EyeLinear = 3, CubeReflect = 4, CubeNormal = 5 }
        /** The trail renderer is used to make trails behind objects in the Scene as they move about.
        */
        class TrailRenderer extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
            /** How long does the trail take to fade out.
            */
            public get time(): number;
            public set time(value: number);
            /** The width of the trail at the spawning point.
            */
            public get startWidth(): number;
            public set startWidth(value: number);
            /** The width of the trail at the end of the trail.
            */
            public get endWidth(): number;
            public set endWidth(value: number);
            /** Set an overall multiplier that is applied to the TrailRenderer.widthCurve to get the final width of the trail.
            */
            public get widthMultiplier(): number;
            public set widthMultiplier(value: number);
            /** Does the GameObject of this Trail Renderer auto destruct?
            */
            public get autodestruct(): boolean;
            public set autodestruct(value: boolean);
            /** Creates trails when the GameObject moves.
            */
            public get emitting(): boolean;
            public set emitting(value: boolean);
            /** Set this to a value greater than 0, to get rounded corners between each segment of the trail.
            */
            public get numCornerVertices(): number;
            public set numCornerVertices(value: number);
            /** Set this to a value greater than 0, to get rounded corners on each end of the trail.
            */
            public get numCapVertices(): number;
            public set numCapVertices(value: number);
            /** Set the minimum distance the trail can travel before a new vertex is added to it.
            */
            public get minVertexDistance(): number;
            public set minVertexDistance(value: number);
            /** Set the color at the start of the trail.
            */
            public get startColor(): UnityEngine.Color;
            public set startColor(value: UnityEngine.Color);
            /** Set the color at the end of the trail.
            */
            public get endColor(): UnityEngine.Color;
            public set endColor(value: UnityEngine.Color);
            /** Get the number of line segments in the trail.
            */
            public get positionCount(): number;
            /** Apply a shadow bias to prevent self-shadowing artifacts. The specified value is the proportion of the trail width at each segment.
            */
            public get shadowBias(): number;
            public set shadowBias(value: number);
            /** Configures a trail to generate Normals and Tangents. With this data, Scene lighting can affect the trail via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.
            */
            public get generateLightingData(): boolean;
            public set generateLightingData(value: boolean);
            /** Choose whether the U coordinate of the trail texture is tiled or stretched.
            */
            public get textureMode(): UnityEngine.LineTextureMode;
            public set textureMode(value: UnityEngine.LineTextureMode);
            /** Select whether the trail will face the camera, or the orientation of the Transform Component.
            */
            public get alignment(): UnityEngine.LineAlignment;
            public set alignment(value: UnityEngine.LineAlignment);
            /** Set the curve describing the width of the trail at various points along its length.
            */
            public get widthCurve(): UnityEngine.AnimationCurve;
            public set widthCurve(value: UnityEngine.AnimationCurve);
            /** Set the color gradient describing the color of the trail at various points along its length.
            */
            public get colorGradient(): UnityEngine.Gradient;
            public set colorGradient(value: UnityEngine.Gradient);
            /** Set the position of a vertex in the trail.
            * @param index Which position to set.
            * @param position The new position.
            */
            public SetPosition ($index: number, $position: UnityEngine.Vector3) : void
            /** Get the position of a vertex in the trail.
            * @param index The index of the position to retrieve.
            * @returns The position at the specified index in the array. 
            */
            public GetPosition ($index: number) : UnityEngine.Vector3
            public Clear () : void
            /** Creates a snapshot of TrailRenderer and stores it in mesh.
            * @param mesh A static mesh that will receive the snapshot of the trail.
            * @param camera The camera used for determining which way camera-space trails will face.
            * @param useTransform Include the rotation and scale of the Transform in the baked mesh.
            */
            public BakeMesh ($mesh: UnityEngine.Mesh, $useTransform?: boolean) : void
            /** Creates a snapshot of TrailRenderer and stores it in mesh.
            * @param mesh A static mesh that will receive the snapshot of the trail.
            * @param camera The camera used for determining which way camera-space trails will face.
            * @param useTransform Include the rotation and scale of the Transform in the baked mesh.
            */
            public BakeMesh ($mesh: UnityEngine.Mesh, $camera: UnityEngine.Camera, $useTransform?: boolean) : void
            /** Get the positions of all vertices in the trail.
            * @param positions The array of positions to retrieve.
            * @returns How many positions were actually stored in the output array. 
            */
            public GetPositions ($positions: System.Array$1<UnityEngine.Vector3>) : number
            /** Get the visible positions of all vertices in the trail.
            * @param positions The array of positions to retrieve.
            * @returns How many positions were actually stored in the output array. 
            */
            public GetVisiblePositions ($positions: System.Array$1<UnityEngine.Vector3>) : number
            /** Sets the positions of all vertices in the trail.
            * @param positions The array of positions to set.
            */
            public SetPositions ($positions: System.Array$1<UnityEngine.Vector3>) : void
            /** Adds a position to the trail.
            * @param position The position to add to the trail.
            */
            public AddPosition ($position: UnityEngine.Vector3) : void
            /** Add an array of positions to the trail.
            * @param positions The positions to add to the trail.
            */
            public AddPositions ($positions: System.Array$1<UnityEngine.Vector3>) : void
            public SetPositions ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : void
            public SetPositions ($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>) : void
            public GetPositions ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : number
            public GetPositions ($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>) : number
            public GetVisiblePositions ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : number
            public GetVisiblePositions ($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>) : number
            public AddPositions ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : void
            public AddPositions ($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>) : void
            public constructor ()
        }
        /** Choose how textures are applied to Lines and Trails.
        */
        enum LineTextureMode
        { Stretch = 0, Tile = 1, DistributePerSegment = 2, RepeatPerSegment = 3 }
        /** Control the direction lines face, when using the LineRenderer or TrailRenderer.
        */
        enum LineAlignment
        { View = 0, Local = 1, TransformZ = 1 }
        /** Gradient used for animating colors.
        */
        class Gradient extends System.Object implements System.IEquatable$1<UnityEngine.Gradient>
        {
            protected [__keep_incompatibility]: never;
            /** All color keys defined in the gradient.
            */
            public get colorKeys(): System.Array$1<UnityEngine.GradientColorKey>;
            public set colorKeys(value: System.Array$1<UnityEngine.GradientColorKey>);
            /** All alpha keys defined in the gradient.
            */
            public get alphaKeys(): System.Array$1<UnityEngine.GradientAlphaKey>;
            public set alphaKeys(value: System.Array$1<UnityEngine.GradientAlphaKey>);
            /** Control how the gradient is evaluated.
            */
            public get mode(): UnityEngine.GradientMode;
            public set mode(value: UnityEngine.GradientMode);
            /** Calculate color at a given time.
            * @param time Time of the key (0 - 1).
            */
            public Evaluate ($time: number) : UnityEngine.Color
            /** Setup Gradient with an array of color keys and alpha keys.
            * @param colorKeys Color keys of the gradient (maximum 8 color keys).
            * @param alphaKeys Alpha keys of the gradient (maximum 8 alpha keys).
            */
            public SetKeys ($colorKeys: System.Array$1<UnityEngine.GradientColorKey>, $alphaKeys: System.Array$1<UnityEngine.GradientAlphaKey>) : void
            public Equals ($o: any) : boolean
            public Equals ($other: UnityEngine.Gradient) : boolean
            public constructor ()
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        /** The line renderer is used to draw free-floating lines in 3D space.
        */
        class LineRenderer extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
            /** Set the width at the start of the line.
            */
            public get startWidth(): number;
            public set startWidth(value: number);
            /** Set the width at the end of the line.
            */
            public get endWidth(): number;
            public set endWidth(value: number);
            /** Set an overall multiplier that is applied to the LineRenderer.widthCurve to get the final width of the line.
            */
            public get widthMultiplier(): number;
            public set widthMultiplier(value: number);
            /** Set this to a value greater than 0, to get rounded corners between each segment of the line.
            */
            public get numCornerVertices(): number;
            public set numCornerVertices(value: number);
            /** Set this to a value greater than 0, to get rounded corners on each end of the line. The default is 0.
            */
            public get numCapVertices(): number;
            public set numCapVertices(value: number);
            /** If enabled, the lines are defined in world space.
            */
            public get useWorldSpace(): boolean;
            public set useWorldSpace(value: boolean);
            /** Connect the start and end positions of the line together to form a continuous loop.
            */
            public get loop(): boolean;
            public set loop(value: boolean);
            /** Set the color at the start of the line.
            */
            public get startColor(): UnityEngine.Color;
            public set startColor(value: UnityEngine.Color);
            /** Set the color at the end of the line.
            */
            public get endColor(): UnityEngine.Color;
            public set endColor(value: UnityEngine.Color);
            /** Set/get the number of vertices.
            */
            public get positionCount(): number;
            public set positionCount(value: number);
            /** Apply a shadow bias to prevent self-shadowing artifacts. The specified value is the proportion of the line width at each segment.
            */
            public get shadowBias(): number;
            public set shadowBias(value: number);
            /** Configures a line to generate Normals and Tangents. With this data, Scene lighting can affect the line via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.
            */
            public get generateLightingData(): boolean;
            public set generateLightingData(value: boolean);
            /** Choose whether the U coordinate of the line texture is tiled or stretched.
            */
            public get textureMode(): UnityEngine.LineTextureMode;
            public set textureMode(value: UnityEngine.LineTextureMode);
            /** Select whether the line will face the camera, or the orientation of the Transform Component.
            */
            public get alignment(): UnityEngine.LineAlignment;
            public set alignment(value: UnityEngine.LineAlignment);
            /** Set the curve describing the width of the line at various points along its length.
            */
            public get widthCurve(): UnityEngine.AnimationCurve;
            public set widthCurve(value: UnityEngine.AnimationCurve);
            /** Set the color gradient describing the color of the line at various points along its length.
            */
            public get colorGradient(): UnityEngine.Gradient;
            public set colorGradient(value: UnityEngine.Gradient);
            /** Set the position of a vertex in the line.
            * @param index Which position to set.
            * @param position The new position.
            */
            public SetPosition ($index: number, $position: UnityEngine.Vector3) : void
            /** Get the position of a vertex in the line.
            * @param index The index of the position to retrieve.
            * @returns The position at the specified index in the array. 
            */
            public GetPosition ($index: number) : UnityEngine.Vector3
            /** Generates a simplified version of the original line by removing points that fall within the specified tolerance.
            * @param tolerance This value is used to evaluate which points should be removed from the line. A higher value results in a simpler line (less points). A positive value close to zero results in a line with little to no reduction. A value of zero or less has no effect.
            */
            public Simplify ($tolerance: number) : void
            /** Creates a snapshot of LineRenderer and stores it in mesh.
            * @param mesh A static mesh that will receive the snapshot of the line.
            * @param camera The camera used for determining which way camera-space lines will face.
            * @param useTransform Include the rotation and scale of the Transform in the baked mesh.
            */
            public BakeMesh ($mesh: UnityEngine.Mesh, $useTransform?: boolean) : void
            /** Creates a snapshot of LineRenderer and stores it in mesh.
            * @param mesh A static mesh that will receive the snapshot of the line.
            * @param camera The camera used for determining which way camera-space lines will face.
            * @param useTransform Include the rotation and scale of the Transform in the baked mesh.
            */
            public BakeMesh ($mesh: UnityEngine.Mesh, $camera: UnityEngine.Camera, $useTransform?: boolean) : void
            /** Get the positions of all vertices in the line.
            * @param positions The array of positions to retrieve. The array passed should be of at least positionCount in size.
            * @returns How many positions were actually stored in the output array. 
            */
            public GetPositions ($positions: System.Array$1<UnityEngine.Vector3>) : number
            /** Set the positions of all vertices in the line.
            * @param positions The array of positions to set.
            */
            public SetPositions ($positions: System.Array$1<UnityEngine.Vector3>) : void
            public SetPositions ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : void
            public SetPositions ($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>) : void
            public GetPositions ($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : number
            public GetPositions ($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>) : number
            public constructor ()
        }
        /** The Render Settings contain values for a range of visual elements in your Scene, like fog and ambient light.
        */
        class RenderSettings extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Is fog enabled?
            */
            public static get fog(): boolean;
            public static set fog(value: boolean);
            /** The starting distance of linear fog.
            */
            public static get fogStartDistance(): number;
            public static set fogStartDistance(value: number);
            /** The ending distance of linear fog.
            */
            public static get fogEndDistance(): number;
            public static set fogEndDistance(value: number);
            /** Fog mode to use.
            */
            public static get fogMode(): UnityEngine.FogMode;
            public static set fogMode(value: UnityEngine.FogMode);
            /** The color of the fog.
            */
            public static get fogColor(): UnityEngine.Color;
            public static set fogColor(value: UnityEngine.Color);
            /** The density of the exponential fog.
            */
            public static get fogDensity(): number;
            public static set fogDensity(value: number);
            /** Ambient lighting mode.
            */
            public static get ambientMode(): UnityEngine.Rendering.AmbientMode;
            public static set ambientMode(value: UnityEngine.Rendering.AmbientMode);
            /** Ambient lighting coming from above.
            */
            public static get ambientSkyColor(): UnityEngine.Color;
            public static set ambientSkyColor(value: UnityEngine.Color);
            /** Ambient lighting coming from the sides.
            */
            public static get ambientEquatorColor(): UnityEngine.Color;
            public static set ambientEquatorColor(value: UnityEngine.Color);
            /** Ambient lighting coming from below.
            */
            public static get ambientGroundColor(): UnityEngine.Color;
            public static set ambientGroundColor(value: UnityEngine.Color);
            /** How much the light from the Ambient Source affects the Scene.
            */
            public static get ambientIntensity(): number;
            public static set ambientIntensity(value: number);
            /** Flat ambient lighting color.
            */
            public static get ambientLight(): UnityEngine.Color;
            public static set ambientLight(value: UnityEngine.Color);
            /** The color used for the sun shadows in the Subtractive lightmode.
            */
            public static get subtractiveShadowColor(): UnityEngine.Color;
            public static set subtractiveShadowColor(value: UnityEngine.Color);
            /** The global skybox to use.
            */
            public static get skybox(): UnityEngine.Material;
            public static set skybox(value: UnityEngine.Material);
            /** The light used by the procedural skybox.
            */
            public static get sun(): UnityEngine.Light;
            public static set sun(value: UnityEngine.Light);
            /** An automatically generated ambient probe that captures environment lighting.
            */
            public static get ambientProbe(): UnityEngine.Rendering.SphericalHarmonicsL2;
            public static set ambientProbe(value: UnityEngine.Rendering.SphericalHarmonicsL2);
            /** Custom specular reflection cubemap.
            */
            public static get customReflection(): UnityEngine.Texture;
            public static set customReflection(value: UnityEngine.Texture);
            /** How much the skybox / custom cubemap reflection affects the Scene.
            */
            public static get reflectionIntensity(): number;
            public static set reflectionIntensity(value: number);
            /** The number of times a reflection includes other reflections.
            */
            public static get reflectionBounces(): number;
            public static set reflectionBounces(value: number);
            /** Default reflection mode.
            */
            public static get defaultReflectionMode(): UnityEngine.Rendering.DefaultReflectionMode;
            public static set defaultReflectionMode(value: UnityEngine.Rendering.DefaultReflectionMode);
            /** Cubemap resolution for default reflection.
            */
            public static get defaultReflectionResolution(): number;
            public static set defaultReflectionResolution(value: number);
            /** Size of the Light halos.
            */
            public static get haloStrength(): number;
            public static set haloStrength(value: number);
            /** The intensity of all flares in the Scene.
            */
            public static get flareStrength(): number;
            public static set flareStrength(value: number);
            /** The fade speed of all flares in the Scene.
            */
            public static get flareFadeSpeed(): number;
            public static set flareFadeSpeed(value: number);
        }
        /** Fog mode to use.
        */
        enum FogMode
        { Linear = 1, Exponential = 2, ExponentialSquared = 3 }
        /** Script interface for.
        */
        class Light extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The type of the light.
            */
            public get type(): UnityEngine.LightType;
            public set type(value: UnityEngine.LightType);
            /** This property describes the shape of the spot light. Only Scriptable Render Pipelines use this property; the built-in renderer does not support it.
            */
            public get shape(): UnityEngine.LightShape;
            public set shape(value: UnityEngine.LightShape);
            /** The angle of the light's spotlight cone in degrees.
            */
            public get spotAngle(): number;
            public set spotAngle(value: number);
            /** The angle of the light's spotlight inner cone in degrees.
            */
            public get innerSpotAngle(): number;
            public set innerSpotAngle(value: number);
            /** The color of the light.
            */
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            /** 
            The color temperature of the light.
            Correlated Color Temperature (abbreviated as CCT) is multiplied with the color filter when calculating the final color of a light source. The color temperature of the electromagnetic radiation emitted from an ideal black body is defined as its surface temperature in Kelvin. White is 6500K according to the D65 standard. A candle light is 1800K and a soft warm light bulb is 2700K.
            If you want to use colorTemperature, GraphicsSettings.lightsUseLinearIntensity and Light.useColorTemperature has to be enabled.
            See Also: GraphicsSettings.lightsUseLinearIntensity, GraphicsSettings.useColorTemperature.
            */
            public get colorTemperature(): number;
            public set colorTemperature(value: number);
            /** Set to true to use the color temperature.
            */
            public get useColorTemperature(): boolean;
            public set useColorTemperature(value: boolean);
            /** The Intensity of a light is multiplied with the Light color.
            */
            public get intensity(): number;
            public set intensity(value: number);
            /** The multiplier that defines the strength of the bounce lighting.
            */
            public get bounceIntensity(): number;
            public set bounceIntensity(value: number);
            /** Set to true to override light bounding sphere for culling.
            */
            public get useBoundingSphereOverride(): boolean;
            public set useBoundingSphereOverride(value: boolean);
            /** Bounding sphere used to override the regular light bounding sphere during culling.
            */
            public get boundingSphereOverride(): UnityEngine.Vector4;
            public set boundingSphereOverride(value: UnityEngine.Vector4);
            /** Whether to cull shadows for this Light when the Light is outside of the view frustum.
            */
            public get useViewFrustumForShadowCasterCull(): boolean;
            public set useViewFrustumForShadowCasterCull(value: boolean);
            /** The custom resolution of the shadow map.
            */
            public get shadowCustomResolution(): number;
            public set shadowCustomResolution(value: number);
            /** Shadow mapping constant bias.
            */
            public get shadowBias(): number;
            public set shadowBias(value: number);
            /** Shadow mapping normal-based bias.
            */
            public get shadowNormalBias(): number;
            public set shadowNormalBias(value: number);
            /** Near plane value to use for shadow frustums.
            */
            public get shadowNearPlane(): number;
            public set shadowNearPlane(value: number);
            /** Set to true to enable custom matrix for culling during shadows.
            */
            public get useShadowMatrixOverride(): boolean;
            public set useShadowMatrixOverride(value: boolean);
            /** Matrix that overrides the regular light projection matrix during shadow culling. Unity uses this matrix if you set Light.useShadowMatrixOverride to true.
            */
            public get shadowMatrixOverride(): UnityEngine.Matrix4x4;
            public set shadowMatrixOverride(value: UnityEngine.Matrix4x4);
            /** The range of the light.
            */
            public get range(): number;
            public set range(value: number);
            /** The to use for this light.
            */
            public get flare(): UnityEngine.Flare;
            public set flare(value: UnityEngine.Flare);
            /** This property describes the output of the last Global Illumination bake.
            */
            public get bakingOutput(): UnityEngine.LightBakingOutput;
            public set bakingOutput(value: UnityEngine.LightBakingOutput);
            /** This is used to light certain objects in the Scene selectively.
            */
            public get cullingMask(): number;
            public set cullingMask(value: number);
            /** Determines which rendering LayerMask this Light affects.
            */
            public get renderingLayerMask(): number;
            public set renderingLayerMask(value: number);
            /** Allows you to override the global Shadowmask Mode per light. Only use this with render pipelines that can handle per light Shadowmask modes. Incompatible with the legacy renderers.
            */
            public get lightShadowCasterMode(): UnityEngine.LightShadowCasterMode;
            public set lightShadowCasterMode(value: UnityEngine.LightShadowCasterMode);
            /** How this light casts shadows
            */
            public get shadows(): UnityEngine.LightShadows;
            public set shadows(value: UnityEngine.LightShadows);
            /** Strength of light's shadows.
            */
            public get shadowStrength(): number;
            public set shadowStrength(value: number);
            /** The resolution of the shadow map.
            */
            public get shadowResolution(): UnityEngine.Rendering.LightShadowResolution;
            public set shadowResolution(value: UnityEngine.Rendering.LightShadowResolution);
            /** Per-light, per-layer shadow culling distances. Directional lights only. 
            */
            public get layerShadowCullDistances(): System.Array$1<number>;
            public set layerShadowCullDistances(value: System.Array$1<number>);
            /** The size of a directional light's cookie.
            */
            public get cookieSize(): number;
            public set cookieSize(value: number);
            /** The cookie texture projected by the light.
            */
            public get cookie(): UnityEngine.Texture;
            public set cookie(value: UnityEngine.Texture);
            /** How to render the light.
            */
            public get renderMode(): UnityEngine.LightRenderMode;
            public set renderMode(value: UnityEngine.LightRenderMode);
            /** Number of command buffers set up on this light (Read Only).
            */
            public get commandBufferCount(): number;
            public Reset () : void
            /** Add a command buffer to be executed at a specified place.
            * @param evt When to execute the command buffer during rendering.
            * @param buffer The buffer to execute.
            * @param shadowPassMask A mask specifying which shadow passes to execute the buffer for.
            */
            public AddCommandBuffer ($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer) : void
            /** Add a command buffer to be executed at a specified place.
            * @param evt When to execute the command buffer during rendering.
            * @param buffer The buffer to execute.
            * @param shadowPassMask A mask specifying which shadow passes to execute the buffer for.
            */
            public AddCommandBuffer ($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $shadowPassMask: UnityEngine.Rendering.ShadowMapPass) : void
            /** Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
            * @param evt The point during the graphics processing at which this command buffer should commence on the GPU.
            * @param buffer The buffer to execute.
            * @param queueType The desired async compute queue type to execute the buffer on.
            * @param shadowPassMask A mask specifying which shadow passes to execute the buffer for.
            */
            public AddCommandBufferAsync ($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType) : void
            /** Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
            * @param evt The point during the graphics processing at which this command buffer should commence on the GPU.
            * @param buffer The buffer to execute.
            * @param queueType The desired async compute queue type to execute the buffer on.
            * @param shadowPassMask A mask specifying which shadow passes to execute the buffer for.
            */
            public AddCommandBufferAsync ($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $shadowPassMask: UnityEngine.Rendering.ShadowMapPass, $queueType: UnityEngine.Rendering.ComputeQueueType) : void
            /** Remove command buffer from execution at a specified place.
            * @param evt When to execute the command buffer during rendering.
            * @param buffer The buffer to execute.
            */
            public RemoveCommandBuffer ($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer) : void
            /** Remove command buffers from execution at a specified place.
            * @param evt When to execute the command buffer during rendering.
            */
            public RemoveCommandBuffers ($evt: UnityEngine.Rendering.LightEvent) : void
            public RemoveAllCommandBuffers () : void
            /** Get command buffers to be executed at a specified place.
            * @param evt When to execute the command buffer during rendering.
            * @returns Array of command buffers. 
            */
            public GetCommandBuffers ($evt: UnityEngine.Rendering.LightEvent) : System.Array$1<UnityEngine.Rendering.CommandBuffer>
            public static GetLights ($type: UnityEngine.LightType, $layer: number) : System.Array$1<UnityEngine.Light>
            public constructor ()
        }
        /** How the material interacts with lightmaps and lightprobes.
        */
        enum MaterialGlobalIlluminationFlags
        { None = 0, RealtimeEmissive = 1, BakedEmissive = 2, EmissiveIsBlack = 4, AnyEmissive = 3 }
        /** The portal for dynamically changing occlusion at runtime.
        */
        class OcclusionPortal extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Gets / sets the portal's open state.
            */
            public get open(): boolean;
            public set open(value: boolean);
            public constructor ()
        }
        /** OcclusionArea is an area in which occlusion culling is performed.
        */
        class OcclusionArea extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Center of the occlusion area relative to the transform.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** Size that the occlusion area will have.
            */
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            public constructor ()
        }
        /** A flare asset. Read more about flares in the.
        */
        class Flare extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Script interface for a.
        */
        class LensFlare extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The strength of the flare.
            */
            public get brightness(): number;
            public set brightness(value: number);
            /** The fade speed of the flare.
            */
            public get fadeSpeed(): number;
            public set fadeSpeed(value: number);
            /** The color of the flare.
            */
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            /** The to use.
            */
            public get flare(): UnityEngine.Flare;
            public set flare(value: UnityEngine.Flare);
            public constructor ()
        }
        /** Struct describing the result of a Global Illumination bake for a given light.
        */
        class LightBakingOutput extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** In case of a LightmapBakeType.Mixed light, contains the index of the light as seen from the occlusion probes point of view if any, otherwise -1.
            */
            public probeOcclusionLightIndex : number
            /** In case of a LightmapBakeType.Mixed light, contains the index of the occlusion mask channel to use if any, otherwise -1.
            */
            public occlusionMaskChannel : number
            /** This property describes what part of a light's contribution was baked.
            */
            public lightmapBakeType : UnityEngine.LightmapBakeType
            /** In case of a LightmapBakeType.Mixed light, describes what Mixed mode was used to bake the light, irrelevant otherwise.
            */
            public mixedLightingMode : UnityEngine.MixedLightingMode
            /** Is the light contribution already stored in lightmaps and/or lightprobes?
            */
            public isBaked : boolean
        }
        /** Enum describing what part of a light contribution can be baked.
        */
        enum LightmapBakeType
        { Realtime = 4, Baked = 2, Mixed = 1 }
        /** Enum describing what lighting mode to be used with Mixed lights.
        */
        enum MixedLightingMode
        { IndirectOnly = 0, Shadowmask = 2, Subtractive = 1 }
        /** Allows mixed lights to control shadow caster culling when Shadowmasks are present.
        */
        enum LightShadowCasterMode
        { Default = 0, NonLightmappedOnly = 1, Everything = 2 }
        /** The type of a Light.
        */
        enum LightType
        { Spot = 0, Directional = 1, Point = 2, Area = 3, Rectangle = 3, Disc = 4 }
        /** Describes the shape of a spot light.
        */
        enum LightShape
        { Cone = 0, Pyramid = 1, Box = 2 }
        /** Shadow casting options for a Light.
        */
        enum LightShadows
        { None = 0, Hard = 1, Soft = 2 }
        /** How the Light is rendered.
        */
        enum LightRenderMode
        { Auto = 0, ForcePixel = 1, ForceVertex = 2 }
        enum LightmappingMode
        { Realtime = 4, Baked = 2, Mixed = 1 }
        /** A script interface for the.
        */
        class Skybox extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The material used by the skybox.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public constructor ()
        }
        /** A class to access the Mesh of the.
        */
        class MeshFilter extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Returns the shared mesh of the mesh filter.
            */
            public get sharedMesh(): UnityEngine.Mesh;
            public set sharedMesh(value: UnityEngine.Mesh);
            /** Returns either a new Mesh|mesh or a duplicate of the existing mesh, and assigns it to the mesh filter.
            */
            public get mesh(): UnityEngine.Mesh;
            public set mesh(value: UnityEngine.Mesh);
            public constructor ()
        }
        /** ComputeBuffer type.
        */
        enum ComputeBufferType
        { Default = 0, Raw = 1, Append = 2, Counter = 4, Constant = 8, Structured = 16, DrawIndirect = 256, IndirectArguments = 256, GPUMemory = 512 }
        /** This property only takes effect if you enable a global illumination setting such as for the GameObject associated with the target Mesh Renderer. Otherwise this property defaults to the Light Probes setting.
        */
        enum ReceiveGI
        { Lightmaps = 1, LightProbes = 2 }
        /** A set of options for the level of compression the Editor uses for lightmaps.
        */
        enum LightmapCompression
        { None = 0, LowQuality = 1, NormalQuality = 2, HighQuality = 3 }
        /** The filters that Unity can use when it renders GameObjects in the shadow pass.
        */
        enum ShadowObjectsFilter
        { AllObjects = 0, DynamicOnly = 1, StaticOnly = 2 }
        /** The maximum number of bones affecting a single vertex.
        */
        enum SkinQuality
        { Auto = 0, Bone1 = 1, Bone2 = 2, Bone4 = 4 }
        /** Filtering mode for textures. Corresponds to the settings in a.
        */
        enum FilterMode
        { Point = 0, Bilinear = 1, Trilinear = 2 }
        /** Wrap mode for textures.
        */
        enum TextureWrapMode
        { Repeat = 0, Clamp = 1, Mirror = 2, MirrorOnce = 3 }
        /** NPOT Texture2D|textures support.
        */
        enum NPOTSupport
        { None = 0, Restricted = 1, Full = 2 }
        /** Format used when creating textures from scripts.
        */
        enum TextureFormat
        { Alpha8 = 1, ARGB4444 = 2, RGB24 = 3, RGBA32 = 4, ARGB32 = 5, RGB565 = 7, R16 = 9, DXT1 = 10, DXT5 = 12, RGBA4444 = 13, BGRA32 = 14, RHalf = 15, RGHalf = 16, RGBAHalf = 17, RFloat = 18, RGFloat = 19, RGBAFloat = 20, YUY2 = 21, RGB9e5Float = 22, BC4 = 26, BC5 = 27, BC6H = 24, BC7 = 25, DXT1Crunched = 28, DXT5Crunched = 29, PVRTC_RGB2 = 30, PVRTC_RGBA2 = 31, PVRTC_RGB4 = 32, PVRTC_RGBA4 = 33, ETC_RGB4 = 34, ATC_RGB4 = -127, ATC_RGBA8 = -127, EAC_R = 41, EAC_R_SIGNED = 42, EAC_RG = 43, EAC_RG_SIGNED = 44, ETC2_RGB = 45, ETC2_RGBA1 = 46, ETC2_RGBA8 = 47, ASTC_4x4 = 48, ASTC_5x5 = 49, ASTC_6x6 = 50, ASTC_8x8 = 51, ASTC_10x10 = 52, ASTC_12x12 = 53, ETC_RGB4_3DS = 60, ETC_RGBA8_3DS = 61, RG16 = 62, R8 = 63, ETC_RGB4Crunched = 64, ETC2_RGBA8Crunched = 65, ASTC_HDR_4x4 = 66, ASTC_HDR_5x5 = 67, ASTC_HDR_6x6 = 68, ASTC_HDR_8x8 = 69, ASTC_HDR_10x10 = 70, ASTC_HDR_12x12 = 71, RG32 = 72, RGB48 = 73, RGBA64 = 74, ASTC_RGB_4x4 = 48, ASTC_RGB_5x5 = 49, ASTC_RGB_6x6 = 50, ASTC_RGB_8x8 = 51, ASTC_RGB_10x10 = 52, ASTC_RGB_12x12 = 53, ASTC_RGBA_4x4 = 54, ASTC_RGBA_5x5 = 55, ASTC_RGBA_6x6 = 56, ASTC_RGBA_8x8 = 57, ASTC_RGBA_10x10 = 58, ASTC_RGBA_12x12 = 59, PVRTC_2BPP_RGB = -127, PVRTC_2BPP_RGBA = -127, PVRTC_4BPP_RGB = -127, PVRTC_4BPP_RGBA = -127 }
        /** This enum describes how the RenderTexture is used as a VR eye texture. Instead of using the values of this enum manually, use the value returned by XR.XRSettings.eyeTextureDesc|eyeTextureDesc or other VR functions returning a RenderTextureDescriptor.
        */
        enum VRTextureUsage
        { None = 0, OneEye = 1, TwoEyes = 2, DeviceSpecific = 3 }
        /** Set of flags that control the state of a newly-created RenderTexture.
        */
        enum RenderTextureCreationFlags
        { MipMap = 1, AutoGenerateMips = 2, SRGB = 4, EyeTexture = 8, EnableRandomWrite = 16, CreatedFromScript = 32, AllowVerticalFlip = 128, NoResolvedColorSurface = 256, DynamicallyScalable = 1024, BindMS = 2048, APISharable = 16384 }
        /** Color space conversion mode of a RenderTexture.
        */
        enum RenderTextureReadWrite
        { Default = 0, Linear = 1, sRGB = 2 }
        /** Flags enumeration of the render texture memoryless modes.
        */
        enum RenderTextureMemoryless
        { None = 0, Color = 1, Depth = 2, MSAA = 4 }
        /** A set of flags that describe the level of HDR display support available on the system.
        */
        enum HDRDisplaySupportFlags
        { None = 0, Supported = 1, RuntimeSwitchable = 2, AutomaticTonemapping = 4 }
        /** Specify the source of a Custom Render Texture initialization.
        */
        enum CustomRenderTextureInitializationSource
        { TextureAndColor = 0, Material = 1 }
        /** Frequency of update or initialization of a Custom Render Texture.
        */
        enum CustomRenderTextureUpdateMode
        { OnLoad = 0, Realtime = 1, OnDemand = 2 }
        /** Space in which coordinates are provided for Update Zones.
        */
        enum CustomRenderTextureUpdateZoneSpace
        { Normalized = 0, Pixel = 1 }
        /** The Skinned Mesh filter.
        */
        class SkinnedMeshRenderer extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
            /** The maximum number of bones per vertex that are taken into account during skinning.
            */
            public get quality(): UnityEngine.SkinQuality;
            public set quality(value: UnityEngine.SkinQuality);
            /** If enabled, the Skinned Mesh will be updated when offscreen. If disabled, this also disables updating animations.
            */
            public get updateWhenOffscreen(): boolean;
            public set updateWhenOffscreen(value: boolean);
            /** Forces the Skinned Mesh to recalculate its matricies when rendered
            */
            public get forceMatrixRecalculationPerRender(): boolean;
            public set forceMatrixRecalculationPerRender(value: boolean);
            public get rootBone(): UnityEngine.Transform;
            public set rootBone(value: UnityEngine.Transform);
            /** The bones used to skin the mesh.
            */
            public get bones(): System.Array$1<UnityEngine.Transform>;
            public set bones(value: System.Array$1<UnityEngine.Transform>);
            /** The mesh used for skinning.
            */
            public get sharedMesh(): UnityEngine.Mesh;
            public set sharedMesh(value: UnityEngine.Mesh);
            /** Specifies whether skinned motion vectors should be used for this renderer.
            */
            public get skinnedMotionVectors(): boolean;
            public set skinnedMotionVectors(value: boolean);
            /** The intended target usage of the skinned mesh GPU vertex buffer.
            */
            public get vertexBufferTarget(): UnityEngine.GraphicsBuffer.Target;
            public set vertexBufferTarget(value: UnityEngine.GraphicsBuffer.Target);
            /** Returns the weight of a BlendShape for this Renderer.
            * @param index The index of the BlendShape whose weight you want to retrieve. Index must be smaller than the Mesh.blendShapeCount of the Mesh attached to this Renderer.
            * @returns The weight of the BlendShape. 
            */
            public GetBlendShapeWeight ($index: number) : number
            /** Sets the weight of a BlendShape for this Renderer.
            * @param index The index of the BlendShape to modify. Index must be smaller than the Mesh.blendShapeCount of the Mesh attached to this Renderer.
            * @param value The weight for this BlendShape.
            */
            public SetBlendShapeWeight ($index: number, $value: number) : void
            /** Creates a snapshot of SkinnedMeshRenderer and stores it in mesh.
            * @param mesh A static mesh that will receive the snapshot of the skinned mesh.
            * @param useScale Whether to use the SkinnedMeshRenderer's Transform scale when baking the Mesh. If this is true, Unity bakes the Mesh using the position, rotation, and scale values from the SkinnedMeshRenderer's Transform. If this is false, Unity bakes the Mesh using the position and rotation values from the SkinnedMeshRenderer's Transform, but without using the scale value from the SkinnedMeshRenderer's Transform. The default value is false.
            */
            public BakeMesh ($mesh: UnityEngine.Mesh) : void
            /** Creates a snapshot of SkinnedMeshRenderer and stores it in mesh.
            * @param mesh A static mesh that will receive the snapshot of the skinned mesh.
            * @param useScale Whether to use the SkinnedMeshRenderer's Transform scale when baking the Mesh. If this is true, Unity bakes the Mesh using the position, rotation, and scale values from the SkinnedMeshRenderer's Transform. If this is false, Unity bakes the Mesh using the position and rotation values from the SkinnedMeshRenderer's Transform, but without using the scale value from the SkinnedMeshRenderer's Transform. The default value is false.
            */
            public BakeMesh ($mesh: UnityEngine.Mesh, $useScale: boolean) : void
            public GetVertexBuffer () : UnityEngine.GraphicsBuffer
            public GetPreviousVertexBuffer () : UnityEngine.GraphicsBuffer
            public constructor ()
        }
        /** Light Probe Group.
        */
        class LightProbeGroup extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** A collection of common line functions.
        */
        class LineUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Simplify ($points: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tolerance: number, $pointsToKeep: System.Collections.Generic.List$1<number>) : void
            public static Simplify ($points: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tolerance: number, $simplifiedPoints: System.Collections.Generic.List$1<UnityEngine.Vector3>) : void
            public static Simplify ($points: System.Collections.Generic.List$1<UnityEngine.Vector2>, $tolerance: number, $pointsToKeep: System.Collections.Generic.List$1<number>) : void
            public static Simplify ($points: System.Collections.Generic.List$1<UnityEngine.Vector2>, $tolerance: number, $simplifiedPoints: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            public constructor ()
        }
        /** The LOD (level of detail) fade modes. Modes other than LODFadeMode.None will result in Unity calculating a blend factor for blending/interpolating between two neighbouring LODs and pass it to your shader.
        */
        enum LODFadeMode
        { None = 0, CrossFade = 1, SpeedTree = 2 }
        /** Structure for building a LOD for passing to the SetLODs function.
        */
        class LOD extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The screen relative height to use for the transition [0-1].
            */
            public screenRelativeTransitionHeight : number
            /** Width of the cross-fade transition zone (proportion to the current LOD's whole length) [0-1]. Only used if it's not animated.
            */
            public fadeTransitionWidth : number
            /** List of renderers for this LOD level.
            */
            public renderers : System.Array$1<UnityEngine.Renderer>
            public constructor ($screenRelativeTransitionHeight: number, $renderers: System.Array$1<UnityEngine.Renderer>)
            public constructor ()
        }
        /** LODGroup lets you group multiple Renderers into LOD levels.
        */
        class LODGroup extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** The local reference point against which the LOD distance is calculated.
            */
            public get localReferencePoint(): UnityEngine.Vector3;
            public set localReferencePoint(value: UnityEngine.Vector3);
            /** The size of the LOD object in local space.
            */
            public get size(): number;
            public set size(value: number);
            /** The number of LOD levels.
            */
            public get lodCount(): number;
            /** The LOD fade mode used.
            */
            public get fadeMode(): UnityEngine.LODFadeMode;
            public set fadeMode(value: UnityEngine.LODFadeMode);
            /** Specify if the cross-fading should be animated by time. The animation duration is specified globally as crossFadeAnimationDuration.
            */
            public get animateCrossFading(): boolean;
            public set animateCrossFading(value: boolean);
            /** Allows you to enable or disable the LODGroup.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** The cross-fading animation duration in seconds. ArgumentException will be thrown if it is set to zero or a negative value.
            */
            public static get crossFadeAnimationDuration(): number;
            public static set crossFadeAnimationDuration(value: number);
            public RecalculateBounds () : void
            public GetLODs () : System.Array$1<UnityEngine.LOD>
            /** Set the LODs for the LOD group. This will remove any existing LODs configured on the LODGroup.
            * @param lods The LODs to use for this group.
            */
            public SetLODs ($lods: System.Array$1<UnityEngine.LOD>) : void
            /** * @param index The LOD level to use. Passing index < 0 will return to standard LOD processing.
            */
            public ForceLOD ($index: number) : void
            public constructor ()
        }
        /** Class for handling 3D Textures, Use this to create.
        */
        class Texture3D extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** The depth of the texture (Read Only).
            */
            public get depth(): number;
            /** The format of the pixel data in the texture (Read Only).
            */
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            /** Updates Unity texture to use different native texture object.
            * @param nativeTex Native 3D texture object.
            */
            public UpdateExternalTexture ($nativeTex: System.IntPtr) : void
            /** Gets the pixel color data for a mipmap level as Color structs.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($miplevel: number) : System.Array$1<UnityEngine.Color>
            public GetPixels () : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level as Color32 structs.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($miplevel: number) : System.Array$1<UnityEngine.Color32>
            public GetPixels32 () : System.Array$1<UnityEngine.Color32>
            /** Sets the pixel colors of an entire mipmap level.
            * @param colors The array of pixel colours to use. This is a 3D texture flattened to a 1D array.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level.
            * @param colors The array of pixel colours to use. This is a 3D texture flattened to a 1D array.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>) : void
            /** Sets the pixel colors of an entire mipmap level.
            * @param colors The array of pixel colours to use. This is a 3D texture flattened to a 1D array.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level.
            * @param colors The array of pixel colours to use. This is a 3D texture flattened to a 1D array.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>) : void
            /** Creates Unity Texture out of externally created native texture object.
            * @param nativeTex Native 3D texture object.
            * @param width Width of texture in pixels.
            * @param height Height of texture in pixels.
            * @param depth Depth of texture in pixels
            * @param format Format of underlying texture object.
            * @param mipmap Does the texture have mipmaps?
            */
            public static CreateExternalTexture ($width: number, $height: number, $depth: number, $format: UnityEngine.TextureFormat, $mipChain: boolean, $nativeTex: System.IntPtr) : UnityEngine.Texture3D
            /** Copies changes you've made in a CPU texture to the GPU.
            * @param updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
            * @param makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
            */
            public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
            public Apply ($updateMipmaps: boolean) : void
            public Apply () : void
            /** Sets the pixel color at coordinates (x, y, z).
            * @param x The x coordinate of the pixel to set. The range is 0 through the (texture width - 1).
            * @param y The y coordinate of the pixel to set. The range is 0 through the (texture height - 1).
            * @param z The z coordinate of the pixel to set. The range is 0 through the (texture depth - 1).
            * @param color The color to set.
            * @param mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixel ($x: number, $y: number, $z: number, $color: UnityEngine.Color) : void
            /** Sets the pixel color at coordinates (x, y, z).
            * @param x The x coordinate of the pixel to set. The range is 0 through the (texture width - 1).
            * @param y The y coordinate of the pixel to set. The range is 0 through the (texture height - 1).
            * @param z The z coordinate of the pixel to set. The range is 0 through the (texture depth - 1).
            * @param color The color to set.
            * @param mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixel ($x: number, $y: number, $z: number, $color: UnityEngine.Color, $mipLevel: number) : void
            /** Gets the pixel color at coordinates (x, y, z).
            * @param x The x coordinate of the pixel to get. The range is 0 through the (texture width - 1).
            * @param y The y coordinate of the pixel to get. The range is 0 through the (texture height - 1).
            * @param z The z coordinate of the pixel to get. The range is 0 through the (texture depth - 1).
            * @param mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixel ($x: number, $y: number, $z: number) : UnityEngine.Color
            /** Gets the pixel color at coordinates (x, y, z).
            * @param x The x coordinate of the pixel to get. The range is 0 through the (texture width - 1).
            * @param y The y coordinate of the pixel to get. The range is 0 through the (texture height - 1).
            * @param z The z coordinate of the pixel to get. The range is 0 through the (texture depth - 1).
            * @param mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixel ($x: number, $y: number, $z: number, $mipLevel: number) : UnityEngine.Color
            /** Gets the filtered pixel color at the normalized coordinates (u, v, w).
            * @param u The u coordinate of the pixel to get.
            * @param v The v coordinate of the pixel to get.
            * @param w The w coordinate of the pixel to get.
            * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixelBilinear ($u: number, $v: number, $w: number) : UnityEngine.Color
            /** Gets the filtered pixel color at the normalized coordinates (u, v, w).
            * @param u The u coordinate of the pixel to get.
            * @param v The v coordinate of the pixel to get.
            * @param w The w coordinate of the pixel to get.
            * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns The pixel color. 
            */
            public GetPixelBilinear ($u: number, $v: number, $w: number, $mipLevel: number) : UnityEngine.Color
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $nativeTex: System.IntPtr)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $nativeTex: System.IntPtr)
            public constructor ()
        }
        /** Class for handling 2D texture arrays.
        */
        class Texture2DArray extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** Read Only. This property is used as a parameter in some overloads of the CommandBuffer.Blit, Graphics.Blit, CommandBuffer.SetRenderTarget, and Graphics.SetRenderTarget methods to indicate that all texture array slices are bound. The value of this property is -1.
            */
            public static get allSlices(): number;
            /** Number of elements in a texture array (Read Only).
            */
            public get depth(): number;
            /** Texture format (Read Only).
            */
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            /** Gets the pixel color data for a mipmap level of a slice as Color structs.
            * @param arrayElement The array slice to read pixel data from.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($arrayElement: number, $miplevel: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level of a slice as Color structs.
            * @param arrayElement The array slice to read pixel data from.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($arrayElement: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level of a slice as Color32 structs.
            * @param arrayElement The array slice to read pixel data from.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($arrayElement: number, $miplevel: number) : System.Array$1<UnityEngine.Color32>
            /** Gets the pixel color data for a mipmap level of a slice as Color32 structs.
            * @param arrayElement The array slice to read pixel data from.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($arrayElement: number) : System.Array$1<UnityEngine.Color32>
            /** Sets the pixel colors of an entire mipmap level of a slice.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param arrayElement The array slice to write to.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $arrayElement: number, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level of a slice.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param arrayElement The array slice to write to.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $arrayElement: number) : void
            /** Sets the pixel colors of an entire mipmap level of a slice.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param arrayElement The array slice to write colors to.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>, $arrayElement: number, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level of a slice.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param arrayElement The array slice to write colors to.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>, $arrayElement: number) : void
            /** Copies changes you've made in a CPU texture to the GPU.
            * @param updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
            * @param makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
            */
            public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
            public Apply ($updateMipmaps: boolean) : void
            public Apply () : void
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean)
            public constructor ($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean)
            public constructor ()
        }
        /** Class for handling Cubemap arrays.
        */
        class CubemapArray extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** Number of cubemaps in the array (Read Only).
            */
            public get cubemapCount(): number;
            /** Texture format (Read Only).
            */
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            /** Gets the pixel color data for a mipmap level of a face of a slice as Color structs.
            * @param face The CubemapFace to read from.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param arrayElement The array slice to read pixel data from.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level of a face of a slice as Color structs.
            * @param face The CubemapFace to read from.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param arrayElement The array slice to read pixel data from.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels ($face: UnityEngine.CubemapFace, $arrayElement: number) : System.Array$1<UnityEngine.Color>
            /** Gets the pixel color data for a mipmap level of a face of a slice as Color32 structs.
            * @param face The CubemapFace to read pixel data from.
            * @param arrayElement The array slice to read pixel data from.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number) : System.Array$1<UnityEngine.Color32>
            /** Gets the pixel color data for a mipmap level of a face of a slice as Color32 structs.
            * @param face The CubemapFace to read pixel data from.
            * @param arrayElement The array slice to read pixel data from.
            * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @returns An array that contains the pixel colors. 
            */
            public GetPixels32 ($face: UnityEngine.CubemapFace, $arrayElement: number) : System.Array$1<UnityEngine.Color32>
            /** Sets the pixel colors of an entire mipmap level of a face of a slice.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param face The CubemapFace to write colors to.
            * @param arrayElement The array slice to write colors to.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level of a face of a slice.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            * @param face The CubemapFace to write colors to.
            * @param arrayElement The array slice to write colors to.
            */
            public SetPixels ($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace, $arrayElement: number) : void
            /** Sets the pixel colors of an entire mipmap level of a face of a slice.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param face The CubemapFace to write colors to.
            * @param arrayElement The array slice to write colors to.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>, $face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number) : void
            /** Sets the pixel colors of an entire mipmap level of a face of a slice.
            * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
            * @param face The CubemapFace to write colors to.
            * @param arrayElement The array slice to write colors to.
            * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
            */
            public SetPixels32 ($colors: System.Array$1<UnityEngine.Color32>, $face: UnityEngine.CubemapFace, $arrayElement: number) : void
            /** Copies changes you've made in a CPU texture to the GPU.
            * @param updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
            * @param makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
            */
            public Apply ($updateMipmaps: boolean, $makeNoLongerReadable: boolean) : void
            public Apply ($updateMipmaps: boolean) : void
            public Apply () : void
            public constructor ($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags)
            public constructor ($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number)
            public constructor ($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean)
            public constructor ($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean)
            public constructor ($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean)
            public constructor ()
        }
        /** Class for handling Sparse Textures.
        */
        class SparseTexture extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
            /** Get sparse texture tile width (Read Only).
            */
            public get tileWidth(): number;
            /** Get sparse texture tile height (Read Only).
            */
            public get tileHeight(): number;
            /** Is the sparse texture actually created? (Read Only)
            */
            public get isCreated(): boolean;
            /** Update sparse texture tile with color values.
            * @param tileX Tile X coordinate.
            * @param tileY Tile Y coordinate.
            * @param miplevel Mipmap level of the texture.
            * @param data Tile color data.
            */
            public UpdateTile ($tileX: number, $tileY: number, $miplevel: number, $data: System.Array$1<UnityEngine.Color32>) : void
            /** Update sparse texture tile with raw pixel values.
            * @param tileX Tile X coordinate.
            * @param tileY Tile Y coordinate.
            * @param miplevel Mipmap level of the texture.
            * @param data Tile raw pixel data.
            */
            public UpdateTileRaw ($tileX: number, $tileY: number, $miplevel: number, $data: System.Array$1<number>) : void
            /** Unload sparse texture tile.
            * @param tileX Tile X coordinate.
            * @param tileY Tile Y coordinate.
            * @param miplevel Mipmap level of the texture.
            */
            public UnloadTile ($tileX: number, $tileY: number, $miplevel: number) : void
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number)
            public constructor ($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean)
            public constructor ()
        }
        /** This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties. Avoid using the default constructor as it does not initialize some flags with the recommended values.
        */
        class RenderTextureDescriptor extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The width of the render texture in pixels.
            */
            public get width(): number;
            public set width(value: number);
            /** The height of the render texture in pixels.
            */
            public get height(): number;
            public set height(value: number);
            /** The multisample antialiasing level for the RenderTexture.
            See Also: RenderTexture.antiAliasing.
            */
            public get msaaSamples(): number;
            public set msaaSamples(value: number);
            /** Volume extent of a 3D render texture.
            */
            public get volumeDepth(): number;
            public set volumeDepth(value: number);
            /** User-defined mipmap count.
            */
            public get mipCount(): number;
            public set mipCount(value: number);
            /** The color format for the RenderTexture. You can set this format to None to achieve depth-only rendering.
            */
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set graphicsFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** The format of the stencil data that you can encapsulate within a RenderTexture.
            Specifying this property creates a stencil element for the RenderTexture and sets its format.
            This allows for stencil data to be bound as a Texture to all shader types for the platforms that support it.
            This property does not specify the format of the stencil buffer, which is constrained by the depth buffer format specified in RenderTexture.depth.
            Currently, most platforms only support R8_UInt (DirectX11, DirectX12), while PS4 also supports R8_UNorm.
            */
            public get stencilFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set stencilFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** The desired format of the depth/stencil buffer.
            */
            public get depthStencilFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public set depthStencilFormat(value: UnityEngine.Experimental.Rendering.GraphicsFormat);
            /** The format of the RenderTarget is expressed as a RenderTextureFormat. Internally, this format is stored as a GraphicsFormat compatible with the current system (see SystemInfo.GetCompatibleFormat). Therefore, if you set a format and immediately get it again, it may return a different result from the one just set.
            */
            public get colorFormat(): UnityEngine.RenderTextureFormat;
            public set colorFormat(value: UnityEngine.RenderTextureFormat);
            /** This flag causes the render texture uses sRGB read/write conversions.
            */
            public get sRGB(): boolean;
            public set sRGB(value: boolean);
            /** The precision of the render texture's depth buffer in bits (0, 16, 24 and 32 are supported).
            */
            public get depthBufferBits(): number;
            public set depthBufferBits(value: number);
            /** Dimensionality (type) of the render texture.
            See Also: RenderTexture.dimension.
            */
            public get dimension(): UnityEngine.Rendering.TextureDimension;
            public set dimension(value: UnityEngine.Rendering.TextureDimension);
            /** Determines how the RenderTexture is sampled if it is used as a shadow map.
            See Also: ShadowSamplingMode for more details.
            */
            public get shadowSamplingMode(): UnityEngine.Rendering.ShadowSamplingMode;
            public set shadowSamplingMode(value: UnityEngine.Rendering.ShadowSamplingMode);
            /** If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any. Instead of setting this manually, use the value returned by XR.XRSettings.eyeTextureDesc|eyeTextureDesc or other VR functions returning a RenderTextureDescriptor.
            */
            public get vrUsage(): UnityEngine.VRTextureUsage;
            public set vrUsage(value: UnityEngine.VRTextureUsage);
            /** A set of RenderTextureCreationFlags that control how the texture is created.
            */
            public get flags(): UnityEngine.RenderTextureCreationFlags;
            /** The render texture memoryless mode property.
            */
            public get memoryless(): UnityEngine.RenderTextureMemoryless;
            public set memoryless(value: UnityEngine.RenderTextureMemoryless);
            /** Render texture has mipmaps when this flag is set.
            See Also: RenderTexture.useMipMap.
            */
            public get useMipMap(): boolean;
            public set useMipMap(value: boolean);
            /** Mipmap levels are generated automatically when this flag is set.
            */
            public get autoGenerateMips(): boolean;
            public set autoGenerateMips(value: boolean);
            /** Enable random access write into this render texture on Shader Model 5.0 level shaders.
            See Also: RenderTexture.enableRandomWrite.
            */
            public get enableRandomWrite(): boolean;
            public set enableRandomWrite(value: boolean);
            /** If true and msaaSamples is greater than 1, the render texture will not be resolved by default.  Use this if the render texture needs to be bound as a multisampled texture in a shader.
            */
            public get bindMS(): boolean;
            public set bindMS(value: boolean);
            /** Set to true to enable dynamic resolution scaling on this render texture.
            See Also: RenderTexture.useDynamicScale.
            */
            public get useDynamicScale(): boolean;
            public set useDynamicScale(value: boolean);
            public constructor ($width: number, $height: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat, $depthBufferBits: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthBufferBits: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat, $depthBufferBits: number, $mipCount: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat, $depthBufferBits: number, $mipCount: number, $readWrite: UnityEngine.RenderTextureReadWrite)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthBufferBits: number, $mipCount: number)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat)
            public constructor ($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number)
            public constructor ()
        }
        /** Structure describing an Update Zone.
        */
        class CustomRenderTextureUpdateZone extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Position of the center of the Update Zone within the Custom Render Texture.
            */
            public updateZoneCenter : UnityEngine.Vector3
            /** Size of the Update Zone.
            */
            public updateZoneSize : UnityEngine.Vector3
            /** Rotation of the Update Zone.
            */
            public rotation : number
            /** Shader Pass used to update the Custom Render Texture for this Update Zone.
            */
            public passIndex : number
            /** If true, and if the texture is double buffered, a request is made to swap the buffers before the next update. Otherwise, the buffers will not be swapped.
            */
            public needSwap : boolean
        }
        /** Describes options for displaying movie playback controls.
        */
        enum FullScreenMovieControlMode
        { Full = 0, Minimal = 1, CancelOnInput = 2, Hidden = 3 }
        /** Describes scaling modes for displaying movies.
        */
        enum FullScreenMovieScalingMode
        { None = 0, AspectFit = 1, AspectFill = 2, Fill = 3 }
        /** ActivityIndicator Style (Android Specific).
        */
        enum AndroidActivityIndicatorStyle
        { DontShow = -1, Large = 0, InversedLarge = 1, Small = 2, InversedSmall = 3 }
        /** Utilities to compute hashes.
        */
        class HashUtilities extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Append inHash in outHash.
            * @param inHash Hash to append.
            * @param outHash Hash that will be updated.
            */
            public static AppendHash ($inHash: $Ref<UnityEngine.Hash128>, $outHash: $Ref<UnityEngine.Hash128>) : void
            /** Compute a Hash128 of a Matrix4x4.
            * @param value The Matrix4x4 to hash.
            * @param hash The computed hash.
            */
            public static QuantisedMatrixHash ($value: $Ref<UnityEngine.Matrix4x4>, $hash: $Ref<UnityEngine.Hash128>) : void
            /** Compute a Hash128 of a Vector3.
            * @param hash The Vector3 to hash.
            * @param value The computed hash.
            */
            public static QuantisedVectorHash ($value: $Ref<UnityEngine.Vector3>, $hash: $Ref<UnityEngine.Hash128>) : void
            /** Compute a 128 bit hash based on a value. the type of the value must be a value type.
            * @param value A reference to the value to hash.
            * @param hash A reference to the Hash128 to updated with the computed hash.
            */
            public static ComputeHash128 ($value: System.Array$1<number>, $hash: $Ref<UnityEngine.Hash128>) : void
        }
        /** Utilities to compute hashes with unsafe code.
        */
        class HashUnsafeUtilities extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** Determines whether the mouse cursor is rendered using software rendering or, on supported platforms, hardware rendering.
        */
        enum CursorMode
        { Auto = 0, ForceSoftware = 1 }
        /** How the cursor should behave.
        */
        enum CursorLockMode
        { None = 0, Locked = 1, Confined = 2 }
        /** Cursor API for setting the cursor (mouse pointer).
        */
        class Cursor extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Determines whether the hardware pointer is visible or not.
            */
            public static get visible(): boolean;
            public static set visible(value: boolean);
            /** Determines whether the hardware pointer is locked to the center of the view, constrained to the window, or not constrained at all.
            */
            public static get lockState(): UnityEngine.CursorLockMode;
            public static set lockState(value: UnityEngine.CursorLockMode);
            /** Sets a custom cursor to use as your cursor.
            * @param texture The texture to use for the cursor. To use a texture, import it with `Read/Write` enabled. Alternatively, you can use the default cursor import setting. If you created your cursor texture from code, it must be in RGBA32 format, have alphaIsTransparency enabled, and have no mip chain. To use the default cursor, set the texture to `Null`.
            * @param hotspot The offset from the top left of the texture to use as the target point. This must be in the bounds of the cursor.
            * @param cursorMode Whether to render this cursor as a hardware cursor on supported platforms, or force software cursor.
            */
            public static SetCursor ($texture: UnityEngine.Texture2D, $hotspot: UnityEngine.Vector2, $cursorMode: UnityEngine.CursorMode) : void
            public constructor ()
        }
        /** Key codes returned by Event.keyCode. These map directly to a physical key on the keyboard.
        */
        enum KeyCode
        { None = 0, Backspace = 8, Delete = 127, Tab = 9, Clear = 12, Return = 13, Pause = 19, Escape = 27, Space = 32, Keypad0 = 256, Keypad1 = 257, Keypad2 = 258, Keypad3 = 259, Keypad4 = 260, Keypad5 = 261, Keypad6 = 262, Keypad7 = 263, Keypad8 = 264, Keypad9 = 265, KeypadPeriod = 266, KeypadDivide = 267, KeypadMultiply = 268, KeypadMinus = 269, KeypadPlus = 270, KeypadEnter = 271, KeypadEquals = 272, UpArrow = 273, DownArrow = 274, RightArrow = 275, LeftArrow = 276, Insert = 277, Home = 278, End = 279, PageUp = 280, PageDown = 281, F1 = 282, F2 = 283, F3 = 284, F4 = 285, F5 = 286, F6 = 287, F7 = 288, F8 = 289, F9 = 290, F10 = 291, F11 = 292, F12 = 293, F13 = 294, F14 = 295, F15 = 296, Alpha0 = 48, Alpha1 = 49, Alpha2 = 50, Alpha3 = 51, Alpha4 = 52, Alpha5 = 53, Alpha6 = 54, Alpha7 = 55, Alpha8 = 56, Alpha9 = 57, Exclaim = 33, DoubleQuote = 34, Hash = 35, Dollar = 36, Percent = 37, Ampersand = 38, Quote = 39, LeftParen = 40, RightParen = 41, Asterisk = 42, Plus = 43, Comma = 44, Minus = 45, Period = 46, Slash = 47, Colon = 58, Semicolon = 59, Less = 60, Equals = 61, Greater = 62, Question = 63, At = 64, LeftBracket = 91, Backslash = 92, RightBracket = 93, Caret = 94, Underscore = 95, BackQuote = 96, A = 97, B = 98, C = 99, D = 100, E = 101, F = 102, G = 103, H = 104, I = 105, J = 106, K = 107, L = 108, M = 109, N = 110, O = 111, P = 112, Q = 113, R = 114, S = 115, T = 116, U = 117, V = 118, W = 119, X = 120, Y = 121, Z = 122, LeftCurlyBracket = 123, Pipe = 124, RightCurlyBracket = 125, Tilde = 126, Numlock = 300, CapsLock = 301, ScrollLock = 302, RightShift = 303, LeftShift = 304, RightControl = 305, LeftControl = 306, RightAlt = 307, LeftAlt = 308, LeftMeta = 310, LeftCommand = 310, LeftApple = 310, LeftWindows = 311, RightMeta = 309, RightCommand = 309, RightApple = 309, RightWindows = 312, AltGr = 313, Help = 315, Print = 316, SysReq = 317, Break = 318, Menu = 319, Mouse0 = 323, Mouse1 = 324, Mouse2 = 325, Mouse3 = 326, Mouse4 = 327, Mouse5 = 328, Mouse6 = 329, JoystickButton0 = 330, JoystickButton1 = 331, JoystickButton2 = 332, JoystickButton3 = 333, JoystickButton4 = 334, JoystickButton5 = 335, JoystickButton6 = 336, JoystickButton7 = 337, JoystickButton8 = 338, JoystickButton9 = 339, JoystickButton10 = 340, JoystickButton11 = 341, JoystickButton12 = 342, JoystickButton13 = 343, JoystickButton14 = 344, JoystickButton15 = 345, JoystickButton16 = 346, JoystickButton17 = 347, JoystickButton18 = 348, JoystickButton19 = 349, Joystick1Button0 = 350, Joystick1Button1 = 351, Joystick1Button2 = 352, Joystick1Button3 = 353, Joystick1Button4 = 354, Joystick1Button5 = 355, Joystick1Button6 = 356, Joystick1Button7 = 357, Joystick1Button8 = 358, Joystick1Button9 = 359, Joystick1Button10 = 360, Joystick1Button11 = 361, Joystick1Button12 = 362, Joystick1Button13 = 363, Joystick1Button14 = 364, Joystick1Button15 = 365, Joystick1Button16 = 366, Joystick1Button17 = 367, Joystick1Button18 = 368, Joystick1Button19 = 369, Joystick2Button0 = 370, Joystick2Button1 = 371, Joystick2Button2 = 372, Joystick2Button3 = 373, Joystick2Button4 = 374, Joystick2Button5 = 375, Joystick2Button6 = 376, Joystick2Button7 = 377, Joystick2Button8 = 378, Joystick2Button9 = 379, Joystick2Button10 = 380, Joystick2Button11 = 381, Joystick2Button12 = 382, Joystick2Button13 = 383, Joystick2Button14 = 384, Joystick2Button15 = 385, Joystick2Button16 = 386, Joystick2Button17 = 387, Joystick2Button18 = 388, Joystick2Button19 = 389, Joystick3Button0 = 390, Joystick3Button1 = 391, Joystick3Button2 = 392, Joystick3Button3 = 393, Joystick3Button4 = 394, Joystick3Button5 = 395, Joystick3Button6 = 396, Joystick3Button7 = 397, Joystick3Button8 = 398, Joystick3Button9 = 399, Joystick3Button10 = 400, Joystick3Button11 = 401, Joystick3Button12 = 402, Joystick3Button13 = 403, Joystick3Button14 = 404, Joystick3Button15 = 405, Joystick3Button16 = 406, Joystick3Button17 = 407, Joystick3Button18 = 408, Joystick3Button19 = 409, Joystick4Button0 = 410, Joystick4Button1 = 411, Joystick4Button2 = 412, Joystick4Button3 = 413, Joystick4Button4 = 414, Joystick4Button5 = 415, Joystick4Button6 = 416, Joystick4Button7 = 417, Joystick4Button8 = 418, Joystick4Button9 = 419, Joystick4Button10 = 420, Joystick4Button11 = 421, Joystick4Button12 = 422, Joystick4Button13 = 423, Joystick4Button14 = 424, Joystick4Button15 = 425, Joystick4Button16 = 426, Joystick4Button17 = 427, Joystick4Button18 = 428, Joystick4Button19 = 429, Joystick5Button0 = 430, Joystick5Button1 = 431, Joystick5Button2 = 432, Joystick5Button3 = 433, Joystick5Button4 = 434, Joystick5Button5 = 435, Joystick5Button6 = 436, Joystick5Button7 = 437, Joystick5Button8 = 438, Joystick5Button9 = 439, Joystick5Button10 = 440, Joystick5Button11 = 441, Joystick5Button12 = 442, Joystick5Button13 = 443, Joystick5Button14 = 444, Joystick5Button15 = 445, Joystick5Button16 = 446, Joystick5Button17 = 447, Joystick5Button18 = 448, Joystick5Button19 = 449, Joystick6Button0 = 450, Joystick6Button1 = 451, Joystick6Button2 = 452, Joystick6Button3 = 453, Joystick6Button4 = 454, Joystick6Button5 = 455, Joystick6Button6 = 456, Joystick6Button7 = 457, Joystick6Button8 = 458, Joystick6Button9 = 459, Joystick6Button10 = 460, Joystick6Button11 = 461, Joystick6Button12 = 462, Joystick6Button13 = 463, Joystick6Button14 = 464, Joystick6Button15 = 465, Joystick6Button16 = 466, Joystick6Button17 = 467, Joystick6Button18 = 468, Joystick6Button19 = 469, Joystick7Button0 = 470, Joystick7Button1 = 471, Joystick7Button2 = 472, Joystick7Button3 = 473, Joystick7Button4 = 474, Joystick7Button5 = 475, Joystick7Button6 = 476, Joystick7Button7 = 477, Joystick7Button8 = 478, Joystick7Button9 = 479, Joystick7Button10 = 480, Joystick7Button11 = 481, Joystick7Button12 = 482, Joystick7Button13 = 483, Joystick7Button14 = 484, Joystick7Button15 = 485, Joystick7Button16 = 486, Joystick7Button17 = 487, Joystick7Button18 = 488, Joystick7Button19 = 489, Joystick8Button0 = 490, Joystick8Button1 = 491, Joystick8Button2 = 492, Joystick8Button3 = 493, Joystick8Button4 = 494, Joystick8Button5 = 495, Joystick8Button6 = 496, Joystick8Button7 = 497, Joystick8Button8 = 498, Joystick8Button9 = 499, Joystick8Button10 = 500, Joystick8Button11 = 501, Joystick8Button12 = 502, Joystick8Button13 = 503, Joystick8Button14 = 504, Joystick8Button15 = 505, Joystick8Button16 = 506, Joystick8Button17 = 507, Joystick8Button18 = 508, Joystick8Button19 = 509 }
        enum iPhoneScreenOrientation
        { Unknown = 0, Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, AutoRotation = 5, Landscape = 6 }
        enum iPhoneNetworkReachability
        { NotReachable = 0, ReachableViaCarrierDataNetwork = 1, ReachableViaWiFiNetwork = 2 }
        enum iPhoneGeneration
        { Unknown = 0, iPhone = 1, iPhone3G = 2, iPhone3GS = 3, iPodTouch1Gen = 4, iPodTouch2Gen = 5, iPodTouch3Gen = 6, iPad1Gen = 7, iPhone4 = 8, iPodTouch4Gen = 9, iPad2Gen = 10, iPhone4S = 11, iPad3Gen = 12, iPhone5 = 13, iPodTouch5Gen = 14, iPadMini1Gen = 15, iPad4Gen = 16, iPhone5C = 17, iPhone5S = 18, iPhoneUnknown = 19, iPadUnknown = 20, iPodTouchUnknown = 21 }
        enum iPhoneTouchPhase
        { Began = 0, Moved = 1, Stationary = 2, Ended = 3, Canceled = 4 }
        enum iPhoneMovieControlMode
        { Full = 0, Minimal = 1, CancelOnTouch = 2, Hidden = 3, VolumeOnly = 4 }
        enum iPhoneMovieScalingMode
        { None = 0, AspectFit = 1, AspectFill = 2, Fill = 3 }
        enum iPhoneKeyboardType
        { Default = 0, ASCIICapable = 1, NumbersAndPunctuation = 2, URL = 3, NumberPad = 4, PhonePad = 5, NamePhonePad = 6, EmailAddress = 7 }
        enum iPhoneOrientation
        { Unknown = 0, Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, FaceUp = 5, FaceDown = 6 }
        enum iOSActivityIndicatorStyle
        { DontShow = 0, WhiteLarge = 1, White = 2, Gray = 3 }
        enum CalendarIdentifier
        { GregorianCalendar = 0, BuddhistCalendar = 1, ChineseCalendar = 2, HebrewCalendar = 3, IslamicCalendar = 4, IslamicCivilCalendar = 5, JapaneseCalendar = 6, RepublicOfChinaCalendar = 7, PersianCalendar = 8, IndianCalendar = 9, ISO8601Calendar = 10 }
        enum CalendarUnit
        { Era = 0, Year = 1, Month = 2, Day = 3, Hour = 4, Minute = 5, Second = 6, Week = 7, Weekday = 8, WeekdayOrdinal = 9, Quarter = 10 }
        enum RemoteNotificationType
        { None = 0, Badge = 1, Sound = 2, Alert = 3 }
        /** Initializes a new instance of the Logger.
        */
        class Logger extends System.Object implements UnityEngine.ILogger, UnityEngine.ILogHandler
        {
            protected [__keep_incompatibility]: never;
            /** Set  Logger.ILogHandler.
            */
            public get logHandler(): UnityEngine.ILogHandler;
            public set logHandler(value: UnityEngine.ILogHandler);
            /** To runtime toggle debug logging [ON/OFF].
            */
            public get logEnabled(): boolean;
            public set logEnabled(value: boolean);
            /** To selective enable debug log message.
            */
            public get filterLogType(): UnityEngine.LogType;
            public set filterLogType(value: UnityEngine.LogType);
            /** Check logging is enabled based on the LogType.
            * @param logType The type of the log message.
            * @returns Retrun true in case logs of LogType will be logged otherwise returns false. 
            */
            public IsLogTypeAllowed ($logType: UnityEngine.LogType) : boolean
            /** Logs message to the Unity Console using default logger.
            * @param logType The type of the log message.
            * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public Log ($logType: UnityEngine.LogType, $message: any) : void
            /** Logs message to the Unity Console using default logger.
            * @param logType The type of the log message.
            * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public Log ($logType: UnityEngine.LogType, $message: any, $context: UnityEngine.Object) : void
            /** Logs message to the Unity Console using default logger.
            * @param logType The type of the log message.
            * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public Log ($logType: UnityEngine.LogType, $tag: string, $message: any) : void
            /** Logs message to the Unity Console using default logger.
            * @param logType The type of the log message.
            * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public Log ($logType: UnityEngine.LogType, $tag: string, $message: any, $context: UnityEngine.Object) : void
            /** Logs message to the Unity Console using default logger.
            * @param logType The type of the log message.
            * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public Log ($message: any) : void
            /** Logs message to the Unity Console using default logger.
            * @param logType The type of the log message.
            * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public Log ($tag: string, $message: any) : void
            /** Logs message to the Unity Console using default logger.
            * @param logType The type of the log message.
            * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public Log ($tag: string, $message: any, $context: UnityEngine.Object) : void
            /** A variant of Logger.Log that logs an warning message.
            * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public LogWarning ($tag: string, $message: any) : void
            /** A variant of Logger.Log that logs an warning message.
            * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public LogWarning ($tag: string, $message: any, $context: UnityEngine.Object) : void
            /** A variant of Logger.Log that logs an error message.
            * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public LogError ($tag: string, $message: any) : void
            /** A variant of Logger.Log that logs an error message.
            * @param tag Used to identify the source of a log message. It usually identifies the class where the log call occurs.
            * @param message String or object to be converted to string representation for display.
            * @param context Object to which the message applies.
            */
            public LogError ($tag: string, $message: any, $context: UnityEngine.Object) : void
            /** A variant of Logger.Log that logs an exception message.
            * @param exception Runtime Exception.
            * @param context Object to which the message applies.
            */
            public LogException ($exception: System.Exception) : void
            /** A variant of Logger.Log that logs an exception message.
            * @param exception Runtime Exception.
            * @param context Object to which the message applies.
            */
            public LogException ($exception: System.Exception, $context: UnityEngine.Object) : void
            /** Logs a formatted message.
            * @param logType The type of the log message.
            * @param context Object to which the message applies.
            * @param format A composite format string.
            * @param args Format arguments.
            */
            public LogFormat ($logType: UnityEngine.LogType, $format: string, ...args: any[]) : void
            /** Logs a formatted message.
            * @param logType The type of the log message.
            * @param context Object to which the message applies.
            * @param format A composite format string.
            * @param args Format arguments.
            */
            public LogFormat ($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]) : void
            public constructor ($logHandler: UnityEngine.ILogHandler)
            public constructor ()
        }
        /** A collection of common color functions.
        */
        class ColorUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Attempts to convert a html color string.
            * @param htmlString Case insensitive html string to be converted into a color.
            * @param color The converted color.
            * @returns True if the string was successfully converted else false. 
            */
            public static TryParseHtmlString ($htmlString: string, $color: $Ref<UnityEngine.Color>) : boolean
            /** Returns the color as a hexadecimal string in the format "RRGGBB".
            * @param color The color to be converted.
            * @returns Hexadecimal string representing the color. 
            */
            public static ToHtmlStringRGB ($color: UnityEngine.Color) : string
            /** Returns the color as a hexadecimal string in the format "RRGGBBAA".
            * @param color The color to be converted.
            * @returns Hexadecimal string representing the color. 
            */
            public static ToHtmlStringRGBA ($color: UnityEngine.Color) : string
            public constructor ()
        }
        /** Color key used by Gradient.
        */
        class GradientColorKey extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Color of key.
            */
            public color : UnityEngine.Color
            /** Time of the key (0 - 1).
            */
            public time : number
            public constructor ($col: UnityEngine.Color, $time: number)
            public constructor ()
        }
        /** Alpha key used by Gradient.
        */
        class GradientAlphaKey extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Alpha channel of key.
            */
            public alpha : number
            /** Time of the key (0 - 1).
            */
            public time : number
            public constructor ($alpha: number, $time: number)
            public constructor ()
        }
        /** Select how gradients will be evaluated.
        */
        enum GradientMode
        { Blend = 0, Fixed = 1 }
        /** This struct contains the view space coordinates of the near projection plane.
        */
        class FrustumPlanes extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Position in view space of the left side of the near projection plane.
            */
            public left : number
            /** Position in view space of the right side of the near projection plane.
            */
            public right : number
            /** Position in view space of the bottom side of the near projection plane.
            */
            public bottom : number
            /** Position in view space of the top side of the near projection plane.
            */
            public top : number
            /** Z distance from the origin of view space to the near projection plane.
            */
            public zNear : number
            /** Z distance from the origin of view space to the far projection plane.
            */
            public zFar : number
        }
        /** A collection of common math functions.
        */
        class Mathf extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The well-known 3.14159265358979... value (Read Only).
            */
            public static PI : number
            /** A representation of positive infinity (Read Only).
            */
            public static Infinity : number
            /** A representation of negative infinity (Read Only).
            */
            public static NegativeInfinity : number
            /** Degrees-to-radians conversion constant (Read Only).
            */
            public static Deg2Rad : number
            /** Radians-to-degrees conversion constant (Read Only).
            */
            public static Rad2Deg : number
            /** A tiny floating point value (Read Only).
            */
            public static Epsilon : number
            /** Returns the closest power of two value.
            */
            public static ClosestPowerOfTwo ($value: number) : number
            /** Returns true if the value is power of two.
            */
            public static IsPowerOfTwo ($value: number) : boolean
            /** Returns the next power of two that is equal to, or greater than, the argument.
            */
            public static NextPowerOfTwo ($value: number) : number
            /** Converts the given value from gamma (sRGB) to linear color space.
            */
            public static GammaToLinearSpace ($value: number) : number
            /** Converts the given value from linear to gamma (sRGB) color space.
            */
            public static LinearToGammaSpace ($value: number) : number
            /** Convert a color temperature in Kelvin to RGB color.
            * @param kelvin Temperature in Kelvin. Range 1000 to 40000 Kelvin.
            * @returns Correlated Color Temperature as floating point RGB color. 
            */
            public static CorrelatedColorTemperatureToRGB ($kelvin: number) : UnityEngine.Color
            /** Encode a floating point value into a 16-bit representation.
            * @param val The floating point value to convert.
            * @returns The converted half-precision float, stored in a 16-bit unsigned integer. 
            */
            public static FloatToHalf ($val: number) : number
            /** Convert a half precision float to a 32-bit floating point value.
            * @param val The half precision value to convert.
            * @returns The decoded 32-bit float. 
            */
            public static HalfToFloat ($val: number) : number
            /** Generate 2D Perlin noise.
            * @param x X-coordinate of sample point.
            * @param y Y-coordinate of sample point.
            * @returns Value between 0.0 and 1.0. (Return value might be slightly below 0.0 or beyond 1.0.) 
            */
            public static PerlinNoise ($x: number, $y: number) : number
            /** Returns the sine of angle f.
            * @param f The input angle, in radians.
            * @returns The return value between -1 and +1. 
            */
            public static Sin ($f: number) : number
            /** Returns the cosine of angle f.
            * @param f The input angle, in radians.
            * @returns The return value between -1 and 1. 
            */
            public static Cos ($f: number) : number
            /** Returns the tangent of angle f in radians.
            */
            public static Tan ($f: number) : number
            /** Returns the arc-sine of f - the angle in radians whose sine is f.
            */
            public static Asin ($f: number) : number
            /** Returns the arc-cosine of f - the angle in radians whose cosine is f.
            */
            public static Acos ($f: number) : number
            /** Returns the arc-tangent of f - the angle in radians whose tangent is f.
            */
            public static Atan ($f: number) : number
            /** Returns the angle in radians whose Tan is y/x.
            */
            public static Atan2 ($y: number, $x: number) : number
            /** Returns square root of f.
            */
            public static Sqrt ($f: number) : number
            /** Returns the absolute value of f.
            */
            public static Abs ($f: number) : number
            /** Returns the absolute value of value.
            */
            public static Abs ($value: number) : number
            /** Returns the smallest of two or more values.
            */
            public static Min ($a: number, $b: number) : number
            /** Returns the smallest of two or more values.
            */
            public static Min (...values: number[]) : number
            /** Returns largest of two or more values.
            */
            public static Max ($a: number, $b: number) : number
            /** Returns largest of two or more values.
            */
            public static Max (...values: number[]) : number
            /** Returns f raised to power p.
            */
            public static Pow ($f: number, $p: number) : number
            /** Returns e raised to the specified power.
            */
            public static Exp ($power: number) : number
            /** Returns the logarithm of a specified number in a specified base.
            */
            public static Log ($f: number, $p: number) : number
            /** Returns the natural (base e) logarithm of a specified number.
            */
            public static Log ($f: number) : number
            /** Returns the base 10 logarithm of a specified number.
            */
            public static Log10 ($f: number) : number
            /** Returns the smallest integer greater to or equal to f.
            */
            public static Ceil ($f: number) : number
            /** Returns the largest integer smaller than or equal to f.
            */
            public static Floor ($f: number) : number
            /** Returns f rounded to the nearest integer.
            */
            public static Round ($f: number) : number
            /** Returns the smallest integer greater to or equal to f.
            */
            public static CeilToInt ($f: number) : number
            /** Returns the largest integer smaller to or equal to f.
            */
            public static FloorToInt ($f: number) : number
            /** Returns f rounded to the nearest integer.
            */
            public static RoundToInt ($f: number) : number
            /** Returns the sign of f.
            */
            public static Sign ($f: number) : number
            /** Clamps the given value between the given minimum float and maximum float values.  Returns the given value if it is within the minimum and maximum range.
            * @param value The floating point value to restrict inside the range defined by the minimum and maximum values.
            * @param min The minimum floating point value to compare against.
            * @param max The maximum floating point value to compare against.
            * @returns The float result between the minimum and maximum values. 
            */
            public static Clamp ($value: number, $min: number, $max: number) : number
            /** Clamps value between 0 and 1 and returns value.
            */
            public static Clamp01 ($value: number) : number
            /** Linearly interpolates between a and b by t.
            * @param a The start value.
            * @param b The end value.
            * @param t The interpolation value between the two floats.
            * @returns The interpolated float result between the two float values. 
            */
            public static Lerp ($a: number, $b: number, $t: number) : number
            /** Linearly interpolates between a and b by t with no limit to t.
            * @param a The start value.
            * @param b The end value.
            * @param t The interpolation between the two floats.
            * @returns The float value as a result from the linear interpolation. 
            */
            public static LerpUnclamped ($a: number, $b: number, $t: number) : number
            /** Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.
            */
            public static LerpAngle ($a: number, $b: number, $t: number) : number
            /** Moves a value current towards target.
            * @param current The current value.
            * @param target The value to move towards.
            * @param maxDelta The maximum change that should be applied to the value.
            */
            public static MoveTowards ($current: number, $target: number, $maxDelta: number) : number
            /** Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.
            */
            public static MoveTowardsAngle ($current: number, $target: number, $maxDelta: number) : number
            /** Interpolates between min and max with smoothing at the limits.
            */
            public static SmoothStep ($from: number, $to: number, $t: number) : number
            public static Gamma ($value: number, $absmax: number, $gamma: number) : number
            /** Compares two floating point values and returns true if they are similar.
            */
            public static Approximately ($a: number, $b: number) : boolean
            /** Gradually changes a value towards a desired goal over time.
            * @param current The current position.
            * @param target The position we are trying to reach.
            * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param maxSpeed Optionally allows you to clamp the maximum speed.
            * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number) : number
            /** Gradually changes a value towards a desired goal over time.
            * @param current The current position.
            * @param target The position we are trying to reach.
            * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param maxSpeed Optionally allows you to clamp the maximum speed.
            * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number) : number
            /** Gradually changes a value towards a desired goal over time.
            * @param current The current position.
            * @param target The position we are trying to reach.
            * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param maxSpeed Optionally allows you to clamp the maximum speed.
            * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDamp ($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number, $deltaTime: number) : number
            /** Gradually changes an angle given in degrees towards a desired goal angle over time.
            * @param current The current position.
            * @param target The position we are trying to reach.
            * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param maxSpeed Optionally allows you to clamp the maximum speed.
            * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDampAngle ($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number) : number
            /** Gradually changes an angle given in degrees towards a desired goal angle over time.
            * @param current The current position.
            * @param target The position we are trying to reach.
            * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param maxSpeed Optionally allows you to clamp the maximum speed.
            * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDampAngle ($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number) : number
            /** Gradually changes an angle given in degrees towards a desired goal angle over time.
            * @param current The current position.
            * @param target The position we are trying to reach.
            * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
            * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
            * @param maxSpeed Optionally allows you to clamp the maximum speed.
            * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
            */
            public static SmoothDampAngle ($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number, $deltaTime: number) : number
            /** Loops the value t, so that it is never larger than length and never smaller than 0.
            */
            public static Repeat ($t: number, $length: number) : number
            /** PingPong returns a value that will increment and decrement between the value 0 and length.
            */
            public static PingPong ($t: number, $length: number) : number
            /** Determines where a value lies between two points.
            * @param a The start of the range.
            * @param b The end of the range.
            * @param value The point within the range you want to calculate.
            * @returns A value between zero and one, representing where the "value" parameter falls within the range defined by a and b. 
            */
            public static InverseLerp ($a: number, $b: number, $value: number) : number
            /** Calculates the shortest difference between two given angles given in degrees.
            */
            public static DeltaAngle ($current: number, $target: number) : number
        }
        /** Option for who will receive an RPC, used by NetworkView.RPC.
        */
        enum RPCMode
        {  }
        /** The various test results the connection tester may return with.
        */
        enum ConnectionTesterStatus
        {  }
        /** Possible status messages returned by Network.Connect and in MonoBehaviour.OnFailedToConnect|OnFailedToConnect in case the error was not immediate.
        */
        enum NetworkConnectionError
        {  }
        /** The reason a disconnect event occured, like in MonoBehaviour.OnDisconnectedFromServer|OnDisconnectedFromServer.
        */
        enum NetworkDisconnection
        {  }
        /** Describes status messages from the master server as returned in MonoBehaviour.OnMasterServerEvent|OnMasterServerEvent.
        */
        enum MasterServerEvent
        {  }
        /** Different types of synchronization for the NetworkView component.
        */
        enum NetworkStateSynchronization
        {  }
        /** Describes the status of the network interface peer type as returned by Network.peerType.
        */
        enum NetworkPeerType
        {  }
        /** Describes different levels of log information the network layer supports.
        */
        enum NetworkLogLevel
        {  }
        /** Ping any given IP address (given in dot notation).
        */
        class Ping extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Has the ping function completed?
            */
            public get isDone(): boolean;
            /** This property contains the ping time result after isDone returns true.
            */
            public get time(): number;
            /** The IP target of the ping.
            */
            public get ip(): string;
            public DestroyPing () : void
            public constructor ($address: string)
            public constructor ()
        }
        /** An exception thrown by the PlayerPrefs class in a  web player build.
        */
        class PlayerPrefsException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ($error: string)
            public constructor ()
        }
        /** PlayerPrefs is a class that stores Player preferences between game sessions. It can store string, float and integer values into the user’s platform registry.
        */
        class PlayerPrefs extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Sets a single integer value for the preference identified by the given key. You can use PlayerPrefs.GetInt to retrieve this value.
            */
            public static SetInt ($key: string, $value: number) : void
            /** Returns the value corresponding to key in the preference file if it exists.
            */
            public static GetInt ($key: string, $defaultValue: number) : number
            /** Returns the value corresponding to key in the preference file if it exists.
            */
            public static GetInt ($key: string) : number
            /** Sets the float value of the preference identified by the given key. You can use PlayerPrefs.GetFloat to retrieve this value.
            */
            public static SetFloat ($key: string, $value: number) : void
            /** Returns the value corresponding to key in the preference file if it exists.
            */
            public static GetFloat ($key: string, $defaultValue: number) : number
            /** Returns the value corresponding to key in the preference file if it exists.
            */
            public static GetFloat ($key: string) : number
            /** Sets a single string value for the preference identified by the given key. You can use PlayerPrefs.GetString to retrieve this value. 
            */
            public static SetString ($key: string, $value: string) : void
            /** Returns the value corresponding to key in the preference file if it exists.
            */
            public static GetString ($key: string, $defaultValue: string) : string
            /** Returns the value corresponding to key in the preference file if it exists.
            */
            public static GetString ($key: string) : string
            /** Returns true if the given key exists in PlayerPrefs, otherwise returns false.
            */
            public static HasKey ($key: string) : boolean
            /** Removes the given key from the PlayerPrefs. If the key does not exist, DeleteKey has no impact.
            */
            public static DeleteKey ($key: string) : void
            public static DeleteAll () : void
            public static Save () : void
            public constructor ()
        }
        /** Base class to derive custom property attributes from. Use this to create custom attributes for script variables.
        */
        class PropertyAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** Optional field to specify the order that multiple DecorationDrawers should be drawn in.
            */
            public get order(): number;
            public set order(value: number);
        }
        /** Use this attribute to add a context menu to a field that calls a  named method.
        */
        class ContextMenuItemAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The name of the context menu item.
            */
            public name : string
            /** The name of the function that should be called.
            */
            public function : string
            public constructor ($name: string, $function: string)
            public constructor ()
        }
        /** Use this attribute on enum value declarations to change the display name shown in the Inspector.
        */
        class InspectorNameAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** Name to display in the Inspector.
            */
            public displayName : string
            public constructor ($displayName: string)
            public constructor ()
        }
        /** Specify a tooltip for a field in the Inspector window.
        */
        class TooltipAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The tooltip text.
            */
            public tooltip : string
            public constructor ($tooltip: string)
            public constructor ()
        }
        /** Use this PropertyAttribute to add some spacing in the Inspector.
        */
        class SpaceAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The spacing in pixels.
            */
            public height : number
            public constructor ()
            public constructor ($height: number)
        }
        /** Use this PropertyAttribute to add a header above some fields in the Inspector.
        */
        class HeaderAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The header text.
            */
            public header : string
            public constructor ($header: string)
            public constructor ()
        }
        /** Attribute used to make a float or int variable in a script be restricted to a specific range.
        */
        class RangeAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public min : number
            public max : number
            public constructor ($min: number, $max: number)
            public constructor ()
        }
        /** Attribute used to make a float or int variable in a script be restricted to a specific minimum value.
        */
        class MinAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The minimum allowed value.
            */
            public min : number
            public constructor ($min: number)
            public constructor ()
        }
        /** Attribute to make a string be edited with a multi-line textfield.
        */
        class MultilineAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public lines : number
            public constructor ()
            public constructor ($lines: number)
        }
        /** Attribute to make a string be edited with a height-flexible and scrollable text area.
        */
        class TextAreaAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The minimum amount of lines the text area will use.
            */
            public minLines : number
            /** The maximum amount of lines the text area can show before it starts using a scrollbar.
            */
            public maxLines : number
            public constructor ()
            public constructor ($minLines: number, $maxLines: number)
        }
        /** Attribute used to configure the usage of the ColorField and Color Picker for a color.
        */
        class ColorUsageAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** If false then the alpha bar is hidden in the ColorField and the alpha value is not shown in the Color Picker.
            */
            public showAlpha : boolean
            /** If set to true the Color is treated as a HDR color.
            */
            public hdr : boolean
            public constructor ($showAlpha: boolean)
            public constructor ($showAlpha: boolean, $hdr: boolean)
            public constructor ()
        }
        /** Attribute used to configure the usage of the GradientField and Gradient Editor for a gradient.
        */
        class GradientUsageAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** If set to true the Gradient uses HDR colors.
            */
            public hdr : boolean
            /** The color space the Gradient uses.
            */
            public colorSpace : UnityEngine.ColorSpace
            public constructor ($hdr: boolean)
            public constructor ($hdr: boolean, $colorSpace: UnityEngine.ColorSpace)
            public constructor ()
        }
        /** Attribute used to make a float, int, or string variable in a script be delayed.
        */
        class DelayedAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Disables reordering of an array or list in the Inspector window.
        */
        class NonReorderableAttribute extends UnityEngine.PropertyAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Easily generate random data for games.
        */
        class Random extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Gets or sets the full internal state of the random number generator.
            */
            public static get state(): UnityEngine.Random.State;
            public static set state(value: UnityEngine.Random.State);
            /** Returns a random float within [0.0..1.0] (range is inclusive) (Read Only).
            */
            public static get value(): number;
            /** Returns a random point inside or on a sphere with radius 1.0 (Read Only).
            */
            public static get insideUnitSphere(): UnityEngine.Vector3;
            /** Returns a random point inside or on a circle with radius 1.0 (Read Only).
            */
            public static get insideUnitCircle(): UnityEngine.Vector2;
            /** Returns a random point on the surface of a sphere with radius 1.0 (Read Only).
            */
            public static get onUnitSphere(): UnityEngine.Vector3;
            /** Returns a random rotation (Read Only).
            */
            public static get rotation(): UnityEngine.Quaternion;
            /** Returns a random rotation with uniform distribution (Read Only).
            */
            public static get rotationUniform(): UnityEngine.Quaternion;
            /** Initializes the random number generator state with a seed.
            * @param seed Seed used to initialize the random number generator.
            */
            public static InitState ($seed: number) : void
            /** Returns a random float within [minInclusive..maxInclusive] (range is inclusive).
            */
            public static Range ($minInclusive: number, $maxInclusive: number) : number
            /** Return a random int within [minInclusive..maxExclusive) (Read Only).
            */
            public static Range ($minInclusive: number, $maxExclusive: number) : number
            public static ColorHSV () : UnityEngine.Color
            /** Generates a random color from HSV and alpha ranges.
            * @param hueMin Minimum hue [0..1].
            * @param hueMax Maximum hue [0..1].
            * @param saturationMin Minimum saturation [0..1].
            * @param saturationMax Maximum saturation [0..1].
            * @param valueMin Minimum value [0..1].
            * @param valueMax Maximum value [0..1].
            * @param alphaMin Minimum alpha [0..1].
            * @param alphaMax Maximum alpha [0..1].
            * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
            */
            public static ColorHSV ($hueMin: number, $hueMax: number) : UnityEngine.Color
            /** Generates a random color from HSV and alpha ranges.
            * @param hueMin Minimum hue [0..1].
            * @param hueMax Maximum hue [0..1].
            * @param saturationMin Minimum saturation [0..1].
            * @param saturationMax Maximum saturation [0..1].
            * @param valueMin Minimum value [0..1].
            * @param valueMax Maximum value [0..1].
            * @param alphaMin Minimum alpha [0..1].
            * @param alphaMax Maximum alpha [0..1].
            * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
            */
            public static ColorHSV ($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number) : UnityEngine.Color
            /** Generates a random color from HSV and alpha ranges.
            * @param hueMin Minimum hue [0..1].
            * @param hueMax Maximum hue [0..1].
            * @param saturationMin Minimum saturation [0..1].
            * @param saturationMax Maximum saturation [0..1].
            * @param valueMin Minimum value [0..1].
            * @param valueMax Maximum value [0..1].
            * @param alphaMin Minimum alpha [0..1].
            * @param alphaMax Maximum alpha [0..1].
            * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
            */
            public static ColorHSV ($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number, $valueMin: number, $valueMax: number) : UnityEngine.Color
            /** Generates a random color from HSV and alpha ranges.
            * @param hueMin Minimum hue [0..1].
            * @param hueMax Maximum hue [0..1].
            * @param saturationMin Minimum saturation [0..1].
            * @param saturationMax Maximum saturation [0..1].
            * @param valueMin Minimum value [0..1].
            * @param valueMax Maximum value [0..1].
            * @param alphaMin Minimum alpha [0..1].
            * @param alphaMax Maximum alpha [0..1].
            * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
            */
            public static ColorHSV ($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number, $valueMin: number, $valueMax: number, $alphaMin: number, $alphaMax: number) : UnityEngine.Color
        }
        /** Attribute to specify an icon for a MonoBehaviour or ScriptableObject.
        */
        class IconAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** A project-relative path to a texture.
            */
            public get path(): string;
            public constructor ($path: string)
            public constructor ()
        }
        /** Derive from this base class to provide alternative implementations to the C# behavior of specific Resources methods.
        */
        class ResourcesAPI extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The specific ResourcesAPI instance to use to handle overridden Resources methods.
            */
            public static get overrideAPI(): UnityEngine.ResourcesAPI;
            public static set overrideAPI(value: UnityEngine.ResourcesAPI);
        }
        /** The Resources class allows you to find and access Objects including assets.
        */
        class Resources extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns a list of all objects of Type type.
            */
            public static FindObjectsOfTypeAll ($type: System.Type) : System.Array$1<UnityEngine.Object>
            /** Loads an asset stored at path in a Resources folder using an optional systemTypeInstance filter.
            * @param path Path to the target resource to load.
            * @param systemTypeInstance Type filter for objects returned.
            * @returns The requested asset returned as an Object. 
            */
            public static Load ($path: string) : UnityEngine.Object
            /** Loads an asset stored at path in a Resources folder using an optional systemTypeInstance filter.
            * @param path Path to the target resource to load.
            * @param systemTypeInstance Type filter for objects returned.
            * @returns The requested asset returned as an Object. 
            */
            public static Load ($path: string, $systemTypeInstance: System.Type) : UnityEngine.Object
            /** Asynchronously loads an asset stored at path in a Resources folder.
            * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
            */
            public static LoadAsync ($path: string) : UnityEngine.ResourceRequest
            /** Asynchronously loads an asset stored at path in a Resources folder.
            * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
            * @param systemTypeInstance Type filter for objects returned.
            */
            public static LoadAsync ($path: string, $type: System.Type) : UnityEngine.ResourceRequest
            /** Loads all assets in a folder or file at path in a Resources folder.
            * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
            * @param systemTypeInstance Type filter for objects returned.
            */
            public static LoadAll ($path: string, $systemTypeInstance: System.Type) : System.Array$1<UnityEngine.Object>
            /** Loads all assets in a folder or file at path in a Resources folder.
            * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
            */
            public static LoadAll ($path: string) : System.Array$1<UnityEngine.Object>
            public static GetBuiltinResource ($type: System.Type, $path: string) : UnityEngine.Object
            /** Unloads assetToUnload from memory.
            */
            public static UnloadAsset ($assetToUnload: UnityEngine.Object) : void
            public static UnloadUnusedAssets () : UnityEngine.AsyncOperation
            /** Translates an instance ID to an object reference.
            * @param instanceID Instance ID of an Object.
            * @returns Resolved reference or null if the instance ID didn't match anything. 
            */
            public static InstanceIDToObject ($instanceID: number) : UnityEngine.Object
            public static InstanceIDToObjectList ($instanceIDs: Unity.Collections.NativeArray$1<number>, $objects: System.Collections.Generic.List$1<UnityEngine.Object>) : void
            public constructor ()
        }
        /** Prevents MonoBehaviour of same type (or subtype) to be added more than once to a GameObject.
        */
        class DisallowMultipleComponent extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** The RequireComponent attribute automatically adds required components as dependencies.
        */
        class RequireComponent extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public m_Type0 : System.Type
            public m_Type1 : System.Type
            public m_Type2 : System.Type
            public constructor ($requiredComponent: System.Type)
            public constructor ($requiredComponent: System.Type, $requiredComponent2: System.Type)
            public constructor ($requiredComponent: System.Type, $requiredComponent2: System.Type, $requiredComponent3: System.Type)
            public constructor ()
        }
        /** The AddComponentMenu attribute allows you to place a script anywhere in the "Component" menu, instead of just the "Component->Scripts" menu.
        */
        class AddComponentMenu extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get componentMenu(): string;
            /** The order of the component in the component menu (lower is higher to the top).
            */
            public get componentOrder(): number;
            public constructor ($menuName: string)
            public constructor ($menuName: string, $order: number)
            public constructor ()
        }
        /** Mark a ScriptableObject-derived type to be automatically listed in the Assets/Create submenu, so that instances of the type can be easily created and stored in the project as ".asset" files.
        */
        class CreateAssetMenuAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The display name for this type shown in the Assets/Create menu.
            */
            public get menuName(): string;
            public set menuName(value: string);
            /** The default file name used by newly created instances of this type.
            */
            public get fileName(): string;
            public set fileName(value: string);
            /** The position of the menu item within the Assets/Create menu.
            */
            public get order(): number;
            public set order(value: number);
            public constructor ()
        }
        /** The ContextMenu attribute allows you to add commands to the context menu.
        */
        class ContextMenu extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public menuItem : string
            public validate : boolean
            public priority : number
            public constructor ($itemName: string)
            public constructor ($itemName: string, $isValidateFunction: boolean)
            public constructor ($itemName: string, $isValidateFunction: boolean, $priority: number)
            public constructor ()
        }
        /** Makes all instances of a script execute in Edit Mode.
        */
        class ExecuteInEditMode extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Makes instances of a script always execute, both as part of Play Mode and when editing.
        */
        class ExecuteAlways extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Flags a variable to not appear in the Inspector.
        */
        class HideInInspector extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Marks the methods you want to hide from the Console window callstack. When you hide these methods they are removed from the detail area of the selected message in the Console window.
        */
        class HideInCallstackAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Provide a custom documentation URL for a class.
        */
        class HelpURLAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** The documentation URL specified for this class.
            */
            public get URL(): string;
            public constructor ($url: string)
            public constructor ()
        }
        class DefaultExecutionOrder extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get order(): number;
            public constructor ($order: number)
            public constructor ()
        }
        /** Assembly level attribute. Any classes in an assembly with this attribute will be considered to be Editor Classes.
        */
        class AssemblyIsEditorAssembly extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Add this attribute to a class to prevent creating a Preset from the instances of the class.
        */
        class ExcludeFromPresetAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Base class for custom yield instructions to suspend coroutines.
        */
        class CustomYieldInstruction extends System.Object implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            /** Indicates if coroutine should be kept suspended.
            */
            public get keepWaiting(): boolean;
            public get Current(): any;
            public MoveNext () : boolean
            public Reset () : void
        }
        /** Add this attribute to a class to prevent the class and its inherited classes from being created with ObjectFactory methods.
        */
        class ExcludeFromObjectFactoryAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Specifies Layers to use in a Physics.Raycast.
        */
        class LayerMask extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Converts a layer mask value to an integer value.
            */
            public get value(): number;
            public set value(value: number);
            public static op_Implicit ($mask: UnityEngine.LayerMask) : number
            public static op_Implicit ($intVal: number) : UnityEngine.LayerMask
            /** Given a layer number, returns the name of the layer as defined in either a Builtin or a User Layer in the.
            */
            public static LayerToName ($layer: number) : string
            /** Given a layer name, returns the layer index as defined by either a Builtin or a User Layer in the.
            */
            public static NameToLayer ($layerName: string) : number
            /** Given a set of layer names as defined by either a Builtin or a User Layer in the, returns the equivalent layer mask for all of them.
            * @param layerNames List of layer names to convert to a layer mask.
            * @returns The layer mask created from the layerNames. 
            */
            public static GetMask (...layerNames: string[]) : number
        }
        /** Describes an integer range.
        */
        class RangeInt extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The starting index of the range, where 0 is the first position, 1 is the second, 2 is the third, and so on.
            */
            public start : number
            /** The length of the range.
            */
            public length : number
            /** The end index of the range (not inclusive).
            */
            public get end(): number;
            public constructor ($start: number, $length: number)
            public constructor ()
        }
        /** Set RuntimeInitializeOnLoadMethod type.
        */
        enum RuntimeInitializeLoadType
        { AfterSceneLoad = 0, BeforeSceneLoad = 1, AfterAssembliesLoaded = 2, BeforeSplashScreen = 3, SubsystemRegistration = 4 }
        /** Allow a runtime class method to be initialized when a game is loaded at runtime
        without action from the user.
        */
        class RuntimeInitializeOnLoadMethodAttribute extends UnityEngine.Scripting.PreserveAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** Set RuntimeInitializeOnLoadMethod type.
            */
            public get loadType(): UnityEngine.RuntimeInitializeLoadType;
            public constructor ()
            public constructor ($loadType: UnityEngine.RuntimeInitializeLoadType)
        }
        /** Add this attribute to a script class to mark its GameObject as a selection base object for Scene View picking.
        */
        class SelectionBaseAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class StackTraceUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ExtractStackTrace () : string
            public static ExtractStringFromException ($exception: any) : string
        }
        class UnityException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class MissingComponentException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class UnassignedReferenceException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class MissingReferenceException extends System.SystemException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        /** Represents a raw text or binary file asset.
        */
        class TextAsset extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The raw bytes of the text asset. (Read Only)
            */
            public get bytes(): System.Array$1<number>;
            /** The text contents of the file as a string. (Read Only)
            */
            public get text(): string;
            /** The size of the text asset data in bytes. (Read Only)
            */
            public get dataSize(): bigint;
            public constructor ()
            public constructor ($text: string)
        }
        /** Declares an assembly to be compatible (API wise) with a specific Unity API. Used by internal tools to avoid processing the assembly in order to decide whether assemblies may be using old Unity API.
        */
        class UnityAPICompatibilityVersionAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** Version of Unity API.
            */
            public get version(): string;
            public constructor ($version: string, $checkOnlyUnityVersion: boolean)
            public constructor ($version: string, $configurationAssembliesHashes: System.Array$1<string>)
            public constructor ()
        }
        /** Waits until the end of the frame after Unity has rendererd every Camera and GUI, just before displaying the frame on screen.
        */
        class WaitForEndOfFrame extends UnityEngine.YieldInstruction
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Waits until next fixed frame rate update function. See Also: MonoBehaviour.FixedUpdate.
        */
        class WaitForFixedUpdate extends UnityEngine.YieldInstruction
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Suspends the coroutine execution for the given amount of seconds using scaled time.
        */
        class WaitForSeconds extends UnityEngine.YieldInstruction
        {
            protected [__keep_incompatibility]: never;
            public constructor ($seconds: number)
            public constructor ()
        }
        /** Suspends the coroutine execution for the given amount of seconds using unscaled time.
        */
        class WaitForSecondsRealtime extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            /** The given amount of seconds that the yield instruction will wait for.
            */
            public get waitTime(): number;
            public set waitTime(value: number);
            public get keepWaiting(): boolean;
            public constructor ($time: number)
            public constructor ()
        }
        /** Suspends the coroutine execution until the supplied delegate evaluates to true.
        */
        class WaitUntil extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            public get keepWaiting(): boolean;
            public constructor ($predicate: System.Func$1<boolean>)
            public constructor ()
        }
        /** Suspends the coroutine execution until the supplied delegate evaluates to false.
        */
        class WaitWhile extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator
        {
            protected [__keep_incompatibility]: never;
            public get keepWaiting(): boolean;
            public constructor ($predicate: System.Func$1<boolean>)
            public constructor ()
        }
        /** Webplayer security related class. Not supported from 5.4.0 onwards.
        */
        class Security extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class Types extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** Force Unity to serialize a private field.
        */
        class SerializeField extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** A that instructs Unity to serialize a field as a reference instead of as a value.
        */
        class SerializeReference extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Prefer ScriptableObject derived type to use binary serialization regardless of project's asset serialization mode.
        */
        class PreferBinarySerialization extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Compute Shader asset.
        */
        class ComputeShader extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The local keyword space of this compute shader.
            */
            public get keywordSpace(): UnityEngine.Rendering.LocalKeywordSpace;
            /** An array containing names of the local shader keywords that are currently enabled for this compute shader.
            */
            public get shaderKeywords(): System.Array$1<string>;
            public set shaderKeywords(value: System.Array$1<string>);
            /** An array containing the local shader keywords that are currently enabled for this compute shader.
            */
            public get enabledKeywords(): System.Array$1<UnityEngine.Rendering.LocalKeyword>;
            public set enabledKeywords(value: System.Array$1<UnityEngine.Rendering.LocalKeyword>);
            /** Find ComputeShader kernel index.
            * @param name Name of kernel function.
            * @returns The Kernel index. If the kernel is not found, Unity logs a "FindKernel failed" error message and raises an ArgumentException. 
            */
            public FindKernel ($name: string) : number
            /** Checks whether a shader contains a given kernel.
            * @param name The name of the kernel to look for.
            * @returns True if the kernel is found, false otherwise. 
            */
            public HasKernel ($name: string) : boolean
            /** Set a float parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param val Value to set.
            */
            public SetFloat ($nameID: number, $val: number) : void
            /** Set an integer parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param val Value to set.
            */
            public SetInt ($nameID: number, $val: number) : void
            /** Set a vector parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param val Value to set.
            */
            public SetVector ($nameID: number, $val: UnityEngine.Vector4) : void
            /** Set a Matrix parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param val Value to set.
            */
            public SetMatrix ($nameID: number, $val: UnityEngine.Matrix4x4) : void
            /** Set a vector array parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param values Value to set.
            */
            public SetVectorArray ($nameID: number, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Set a Matrix array parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param values Value to set.
            */
            public SetMatrixArray ($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Set a texture parameter.
            * @param kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Name of the buffer variable in shader code.
            * @param texture Texture to set.
            * @param mipLevel Optional mipmap level of the read-write texture.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($kernelIndex: number, $nameID: number, $texture: UnityEngine.Texture, $mipLevel: number) : void
            /** Set a texture parameter from a global texture property.
            * @param kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Name of the buffer variable in shader code.
            * @param globalTextureName Global texture property to assign to shader.
            * @param globalTextureNameID Property name ID, use Shader.PropertyToID to get it.
            */
            public SetTextureFromGlobal ($kernelIndex: number, $nameID: number, $globalTextureNameID: number) : void
            /** Sets an input or output compute buffer.
            * @param kernelIndex For which kernel the buffer is being set. See FindKernel.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Name of the buffer variable in shader code.
            * @param buffer Buffer to set.
            */
            public SetBuffer ($kernelIndex: number, $nameID: number, $buffer: UnityEngine.ComputeBuffer) : void
            /** Sets an input or output compute buffer.
            * @param kernelIndex For which kernel the buffer is being set. See FindKernel.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Name of the buffer variable in shader code.
            * @param buffer Buffer to set.
            */
            public SetBuffer ($kernelIndex: number, $nameID: number, $buffer: UnityEngine.GraphicsBuffer) : void
            /** Get kernel thread group sizes.
            * @param kernelIndex Which kernel to query. A single compute shader asset can have multiple kernel entry points.
            * @param x Thread group size in the X dimension.
            * @param y Thread group size in the Y dimension.
            * @param z Thread group size in the Z dimension.
            */
            public GetKernelThreadGroupSizes ($kernelIndex: number, $x: $Ref<number>, $y: $Ref<number>, $z: $Ref<number>) : void
            /** Execute a compute shader.
            * @param kernelIndex Which kernel to execute. A single compute shader asset can have multiple kernel entry points.
            * @param threadGroupsX Number of work groups in the X dimension.
            * @param threadGroupsY Number of work groups in the Y dimension.
            * @param threadGroupsZ Number of work groups in the Z dimension.
            */
            public Dispatch ($kernelIndex: number, $threadGroupsX: number, $threadGroupsY: number, $threadGroupsZ: number) : void
            /** Enables a local shader keyword for this compute shader.
            * @param keyword The name of the Rendering.LocalKeyword to enable.
            */
            public EnableKeyword ($keyword: string) : void
            /** Disables a local shader keyword for this compute shader.
            * @param keyword The name of the Rendering.LocalKeyword to disable.
            */
            public DisableKeyword ($keyword: string) : void
            /** Checks whether a local shader keyword is enabled for this compute shader.
            * @param keyword The name of the Rendering.LocalKeyword to check.
            * @returns Returns true if the given Rendering.LocalKeyword is enabled for this compute shader. Otherwise, returns false. 
            */
            public IsKeywordEnabled ($keyword: string) : boolean
            /** Enables a local shader keyword for this compute shader.
            * @param keyword The name of the Rendering.LocalKeyword to enable.
            */
            public EnableKeyword ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : void
            /** Disables a local shader keyword for this compute shader.
            * @param keyword The name of the Rendering.LocalKeyword to disable.
            */
            public DisableKeyword ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : void
            /** Sets the state of a local shader keyword for this compute shader.
            * @param keyword The Rendering.LocalKeyword keyword to enable or disable.
            * @param value The desired keyword state.
            */
            public SetKeyword ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>, $value: boolean) : void
            /** Checks whether a local shader keyword is enabled for this compute shader.
            * @param keyword The name of the Rendering.LocalKeyword to check.
            * @returns Returns true if the given Rendering.LocalKeyword is enabled for this compute shader. Otherwise, returns false. 
            */
            public IsKeywordEnabled ($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>) : boolean
            /** Allows you to check whether the current end user device supports the features required to run the specified compute shader kernel.
            * @param kernelIndex Which kernel to query.
            * @returns True if the specified compute kernel is able to run on the current end user device, false otherwise. 
            */
            public IsSupported ($kernelIndex: number) : boolean
            /** Set a float parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param val Value to set.
            */
            public SetFloat ($name: string, $val: number) : void
            /** Set an integer parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param val Value to set.
            */
            public SetInt ($name: string, $val: number) : void
            /** Set a vector parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param val Value to set.
            */
            public SetVector ($name: string, $val: UnityEngine.Vector4) : void
            /** Set a Matrix parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param val Value to set.
            */
            public SetMatrix ($name: string, $val: UnityEngine.Matrix4x4) : void
            /** Set a vector array parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param values Value to set.
            */
            public SetVectorArray ($name: string, $values: System.Array$1<UnityEngine.Vector4>) : void
            /** Set a Matrix array parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param values Value to set.
            */
            public SetMatrixArray ($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>) : void
            /** Set multiple consecutive float parameters at once.
            * @param name Array variable name in the shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param values Value array to set.
            */
            public SetFloats ($name: string, ...values: number[]) : void
            /** Set multiple consecutive float parameters at once.
            * @param name Array variable name in the shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param values Value array to set.
            */
            public SetFloats ($nameID: number, ...values: number[]) : void
            /** Set multiple consecutive integer parameters at once.
            * @param name Array variable name in the shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param values Value array to set.
            */
            public SetInts ($name: string, ...values: number[]) : void
            /** Set multiple consecutive integer parameters at once.
            * @param name Array variable name in the shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param values Value array to set.
            */
            public SetInts ($nameID: number, ...values: number[]) : void
            /** Set a bool parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param val Value to set.
            */
            public SetBool ($name: string, $val: boolean) : void
            /** Set a bool parameter.
            * @param name Variable name in shader code.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param val Value to set.
            */
            public SetBool ($nameID: number, $val: boolean) : void
            /** Set a texture parameter.
            * @param kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Name of the buffer variable in shader code.
            * @param texture Texture to set.
            * @param mipLevel Optional mipmap level of the read-write texture.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($kernelIndex: number, $nameID: number, $texture: UnityEngine.Texture) : void
            /** Set a texture parameter.
            * @param kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Name of the buffer variable in shader code.
            * @param texture Texture to set.
            * @param mipLevel Optional mipmap level of the read-write texture.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($kernelIndex: number, $name: string, $texture: UnityEngine.Texture) : void
            /** Set a texture parameter.
            * @param kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Name of the buffer variable in shader code.
            * @param texture Texture to set.
            * @param mipLevel Optional mipmap level of the read-write texture.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($kernelIndex: number, $name: string, $texture: UnityEngine.Texture, $mipLevel: number) : void
            /** Set a texture parameter.
            * @param kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Name of the buffer variable in shader code.
            * @param texture Texture to set.
            * @param mipLevel Optional mipmap level of the read-write texture.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($kernelIndex: number, $nameID: number, $texture: UnityEngine.RenderTexture, $mipLevel: number, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Set a texture parameter.
            * @param kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Name of the buffer variable in shader code.
            * @param texture Texture to set.
            * @param mipLevel Optional mipmap level of the read-write texture.
            * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
            */
            public SetTexture ($kernelIndex: number, $name: string, $texture: UnityEngine.RenderTexture, $mipLevel: number, $element: UnityEngine.Rendering.RenderTextureSubElement) : void
            /** Set a texture parameter from a global texture property.
            * @param kernelIndex For which kernel the texture is being set. See FindKernel.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Name of the buffer variable in shader code.
            * @param globalTextureName Global texture property to assign to shader.
            * @param globalTextureNameID Property name ID, use Shader.PropertyToID to get it.
            */
            public SetTextureFromGlobal ($kernelIndex: number, $name: string, $globalTextureName: string) : void
            /** Sets an input or output compute buffer.
            * @param kernelIndex For which kernel the buffer is being set. See FindKernel.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Name of the buffer variable in shader code.
            * @param buffer Buffer to set.
            */
            public SetBuffer ($kernelIndex: number, $name: string, $buffer: UnityEngine.ComputeBuffer) : void
            /** Sets an input or output compute buffer.
            * @param kernelIndex For which kernel the buffer is being set. See FindKernel.
            * @param nameID Property name ID, use Shader.PropertyToID to get it.
            * @param name Name of the buffer variable in shader code.
            * @param buffer Buffer to set.
            */
            public SetBuffer ($kernelIndex: number, $name: string, $buffer: UnityEngine.GraphicsBuffer) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader.
            * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param name The name of the buffer to bind as constant buffer.
            * @param buffer The buffer to bind as constant buffer.
            * @param offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            */
            public SetConstantBuffer ($nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader.
            * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param name The name of the buffer to bind as constant buffer.
            * @param buffer The buffer to bind as constant buffer.
            * @param offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            */
            public SetConstantBuffer ($name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader.
            * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param name The name of the buffer to bind as constant buffer.
            * @param buffer The buffer to bind as constant buffer.
            * @param offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            */
            public SetConstantBuffer ($nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader.
            * @param nameID The ID of the property name for the constant buffer in shader code. Use Shader.PropertyToID to get this ID.
            * @param name The name of the buffer to bind as constant buffer.
            * @param buffer The buffer to bind as constant buffer.
            * @param offset The offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
            * @param size The number of bytes to bind.
            */
            public SetConstantBuffer ($name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number) : void
            /** Execute a compute shader.
            * @param kernelIndex Which kernel to execute. A single compute shader asset can have multiple kernel entry points.
            * @param argsBuffer Buffer with dispatch arguments.
            * @param argsOffset The byte offset into the buffer, where the draw arguments start.
            */
            public DispatchIndirect ($kernelIndex: number, $argsBuffer: UnityEngine.ComputeBuffer, $argsOffset: number) : void
            public DispatchIndirect ($kernelIndex: number, $argsBuffer: UnityEngine.ComputeBuffer) : void
            /** Execute a compute shader.
            * @param kernelIndex Which kernel to execute. A single compute shader asset can have multiple kernel entry points.
            * @param argsBuffer Buffer with dispatch arguments.
            * @param argsOffset The byte offset into the buffer, where the draw arguments start.
            */
            public DispatchIndirect ($kernelIndex: number, $argsBuffer: UnityEngine.GraphicsBuffer, $argsOffset: number) : void
            public DispatchIndirect ($kernelIndex: number, $argsBuffer: UnityEngine.GraphicsBuffer) : void
        }
        /** ShaderVariantCollection records which shader variants are actually used in each shader.
        */
        class ShaderVariantCollection extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Number of shaders in this collection (Read Only).
            */
            public get shaderCount(): number;
            /** Number of total varians in this collection (Read Only).
            */
            public get variantCount(): number;
            /** Is this ShaderVariantCollection already warmed up? (Read Only)
            */
            public get isWarmedUp(): boolean;
            public Clear () : void
            public WarmUp () : void
            public Add ($variant: UnityEngine.ShaderVariantCollection.ShaderVariant) : boolean
            public Remove ($variant: UnityEngine.ShaderVariantCollection.ShaderVariant) : boolean
            public Contains ($variant: UnityEngine.ShaderVariantCollection.ShaderVariant) : boolean
            public constructor ()
        }
        /** Defines the axes that can be snapped.
        */
        enum SnapAxis
        { None = 0, X = 1, Y = 2, Z = 4, All = 7 }
        /** Snap values to rounded increments.
        */
        class Snapping extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Rounds value to the closest multiple of snap.
            * @param val The value to round.
            * @param snap The increment to round to.
            * @returns The rounded value. 
            */
            public static Snap ($val: number, $snap: number) : number
            /** Rounds value to the closest multiple of snap.
            * @param val The value to round.
            * @param snap The increment to round to.
            * @returns The rounded value. 
            */
            public static Snap ($val: UnityEngine.Vector2, $snap: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Rounds value to the closest multiple of snap.
            * @param val The value to round.
            * @param snap The increment to round to.
            * @param axis Restrict snapping to the components on these axes.
            * @returns The rounded value. 
            */
            public static Snap ($val: UnityEngine.Vector3, $snap: UnityEngine.Vector3, $axis?: UnityEngine.SnapAxis) : UnityEngine.Vector3
        }
        /** StaticBatchingUtility can prepare your objects to take advantage of Unity's static batching.
        */
        class StaticBatchingUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Combines all children GameObjects of the staticBatchRoot for static batching.
            * @param staticBatchRoot The GameObject that should become the root of the combined batch.
            */
            public static Combine ($staticBatchRoot: UnityEngine.GameObject) : void
            /** SCombines all GameObjects in gos for static batching and treats staticBatchRoot as the root.
            * @param gos The GameObjects to prepare for static batching.
            * @param staticBatchRoot The GameObject that should become the root of the combined batch.
            */
            public static Combine ($gos: System.Array$1<UnityEngine.GameObject>, $staticBatchRoot: UnityEngine.GameObject) : void
            public constructor ()
        }
        /** Enumeration for SystemInfo.batteryStatus which represents the current status of the device's battery.
        */
        enum BatteryStatus
        { Unknown = 0, Charging = 1, Discharging = 2, NotCharging = 3, Full = 4 }
        /** Enumeration for SystemInfo.operatingSystemFamily.
        */
        enum OperatingSystemFamily
        { Other = 0, MacOSX = 1, Windows = 2, Linux = 3 }
        /** Enumeration for SystemInfo.deviceType, denotes a coarse grouping of kinds of devices.
        */
        enum DeviceType
        { Unknown = 0, Handheld = 1, Console = 2, Desktop = 3 }
        /** Access system and hardware information.
        */
        class SystemInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Value returned by SystemInfo string properties which are not supported on the current platform.
            */
            public static unsupportedIdentifier : string
            /** The current battery level (Read Only).
            */
            public static get batteryLevel(): number;
            /** Returns the current status of the device's battery (Read Only).
            */
            public static get batteryStatus(): UnityEngine.BatteryStatus;
            /** Operating system name with version (Read Only).
            */
            public static get operatingSystem(): string;
            /** Returns the operating system family the game is running on (Read Only).
            */
            public static get operatingSystemFamily(): UnityEngine.OperatingSystemFamily;
            /** Processor name (Read Only).
            */
            public static get processorType(): string;
            /** Processor frequency in MHz (Read Only).
            */
            public static get processorFrequency(): number;
            /** Number of processors present (Read Only).
            */
            public static get processorCount(): number;
            /** Amount of system memory present (Read Only).
            */
            public static get systemMemorySize(): number;
            /** A unique device identifier. It's guaranteed to be unique for every device (Read Only).
            */
            public static get deviceUniqueIdentifier(): string;
            /** The user defined name of the device (Read Only).
            */
            public static get deviceName(): string;
            /** The model of the device (Read Only).
            */
            public static get deviceModel(): string;
            /** Is an accelerometer available on the device?
            */
            public static get supportsAccelerometer(): boolean;
            /** Is a gyroscope available on the device?
            */
            public static get supportsGyroscope(): boolean;
            /** Is the device capable of reporting its location?
            */
            public static get supportsLocationService(): boolean;
            /** Is the device capable of providing the user haptic feedback by vibration?
            */
            public static get supportsVibration(): boolean;
            /** Is there an Audio device available for playback? (Read Only)
            */
            public static get supportsAudio(): boolean;
            /** Returns the kind of device the application is running on (Read Only).
            */
            public static get deviceType(): UnityEngine.DeviceType;
            /** Amount of video memory present (Read Only).
            */
            public static get graphicsMemorySize(): number;
            /** The name of the graphics device (Read Only).
            */
            public static get graphicsDeviceName(): string;
            /** The vendor of the graphics device (Read Only).
            */
            public static get graphicsDeviceVendor(): string;
            /** The identifier code of the graphics device (Read Only).
            */
            public static get graphicsDeviceID(): number;
            /** The identifier code of the graphics device vendor (Read Only).
            */
            public static get graphicsDeviceVendorID(): number;
            /** The graphics API type used by the graphics device (Read Only).
            */
            public static get graphicsDeviceType(): UnityEngine.Rendering.GraphicsDeviceType;
            /** Returns true if the texture UV coordinate convention for this platform has Y starting at the top of the image.
            */
            public static get graphicsUVStartsAtTop(): boolean;
            /** The graphics API type and driver version used by the graphics device (Read Only).
            */
            public static get graphicsDeviceVersion(): string;
            /** Graphics device shader capability level (Read Only).
            */
            public static get graphicsShaderLevel(): number;
            /** Is graphics device using multi-threaded rendering (Read Only)?
            */
            public static get graphicsMultiThreaded(): boolean;
            /** Application's actual rendering threading mode (Read Only).
            */
            public static get renderingThreadingMode(): UnityEngine.Rendering.RenderingThreadingMode;
            /** True if the GPU supports hidden surface removal.
            */
            public static get hasHiddenSurfaceRemovalOnGPU(): boolean;
            /** Returns true when the GPU has native support for indexing uniform arrays in fragment shaders without restrictions.
            */
            public static get hasDynamicUniformArrayIndexingInFragmentShaders(): boolean;
            /** Are built-in shadows supported? (Read Only)
            */
            public static get supportsShadows(): boolean;
            /** Is sampling raw depth from shadowmaps supported? (Read Only)
            */
            public static get supportsRawShadowDepthSampling(): boolean;
            /** Whether motion vectors are supported on this platform.
            */
            public static get supportsMotionVectors(): boolean;
            /** Are 3D (volume) textures supported? (Read Only)
            */
            public static get supports3DTextures(): boolean;
            /** Are compressed formats for 3D (volume) textures supported? (Read Only).
            */
            public static get supportsCompressed3DTextures(): boolean;
            /** Are 2D Array textures supported? (Read Only)
            */
            public static get supports2DArrayTextures(): boolean;
            /** Are 3D (volume) RenderTextures supported? (Read Only)
            */
            public static get supports3DRenderTextures(): boolean;
            /** Are Cubemap Array textures supported? (Read Only)
            */
            public static get supportsCubemapArrayTextures(): boolean;
            /** Returns true when anisotropic filtering is supported on the device.
            */
            public static get supportsAnisotropicFilter(): boolean;
            /** Support for various Graphics.CopyTexture cases (Read Only).
            */
            public static get copyTextureSupport(): UnityEngine.Rendering.CopyTextureSupport;
            /** Are compute shaders supported? (Read Only)
            */
            public static get supportsComputeShaders(): boolean;
            /** Are geometry shaders supported? (Read Only)
            */
            public static get supportsGeometryShaders(): boolean;
            /** Are tessellation shaders supported? (Read Only)
            */
            public static get supportsTessellationShaders(): boolean;
            /** Boolean that indicates if SV_RenderTargetArrayIndex can be used in a vertex shader (true if it can be used, false if not).
            */
            public static get supportsRenderTargetArrayIndexFromVertexShader(): boolean;
            /** Is GPU draw call instancing supported? (Read Only)
            */
            public static get supportsInstancing(): boolean;
            /** Does the hardware support quad topology? (Read Only)
            */
            public static get supportsHardwareQuadTopology(): boolean;
            /** Are 32-bit index buffers supported? (Read Only)
            */
            public static get supports32bitsIndexBuffer(): boolean;
            /** Are sparse textures supported? (Read Only)
            */
            public static get supportsSparseTextures(): boolean;
            /** How many simultaneous render targets (MRTs) are supported? (Read Only)
            */
            public static get supportedRenderTargetCount(): number;
            /** Returns true when the platform supports different blend modes when rendering to multiple render targets, or false otherwise.
            */
            public static get supportsSeparatedRenderTargetsBlend(): boolean;
            /** The maximum number of random write targets (UAV) that Unity supports simultaneously. (Read Only)
            */
            public static get supportedRandomWriteTargetCount(): number;
            /** Are multisampled textures supported? (Read Only)
            */
            public static get supportsMultisampledTextures(): number;
            /** Boolean that indicates whether multisampled texture arrays are supported (true if supported, false if not supported).
            */
            public static get supportsMultisampled2DArrayTextures(): boolean;
            /** Returns true if multisampled textures are resolved automatically
            */
            public static get supportsMultisampleAutoResolve(): boolean;
            /** Returns true if the 'Mirror Once' texture wrap mode is supported. (Read Only)
            */
            public static get supportsTextureWrapMirrorOnce(): number;
            /** This property is true if the current platform uses a reversed depth buffer (where values range from 1 at the near plane and 0 at far plane), and false if the depth buffer is normal (0 is near, 1 is far). (Read Only)
            */
            public static get usesReversedZBuffer(): boolean;
            /** What NPOT (non-power of two size) texture support does the GPU provide? (Read Only)
            */
            public static get npotSupport(): UnityEngine.NPOTSupport;
            /** Maximum texture size in pixels (Read Only).
            */
            public static get maxTextureSize(): number;
            /** Maximum 3D texture size in pixels (Read Only).
            */
            public static get maxTexture3DSize(): number;
            /** Maximum number of slices in a Texture array (Read Only).
            */
            public static get maxTextureArraySlices(): number;
            /** Maximum cubemap texture size in pixels (Read Only).
            */
            public static get maxCubemapSize(): number;
            /** Returns the maximum anisotropic level for anisotropic filtering that is supported on the device. 
            */
            public static get maxAnisotropyLevel(): number;
            /** Determines how many compute buffers Unity supports simultaneously in a vertex shader for reading. (Read Only)
            */
            public static get maxComputeBufferInputsVertex(): number;
            /** Determines how many compute buffers Unity supports simultaneously in a fragment shader for reading. (Read Only)
            */
            public static get maxComputeBufferInputsFragment(): number;
            /** Determines how many compute buffers Unity supports simultaneously in a geometry shader for reading. (Read Only)
            */
            public static get maxComputeBufferInputsGeometry(): number;
            /** Determines how many compute buffers Unity supports simultaneously in a domain shader for reading. (Read Only)
            */
            public static get maxComputeBufferInputsDomain(): number;
            /** Determines how many compute buffers Unity supports simultaneously in a hull shader for reading. (Read Only)
            */
            public static get maxComputeBufferInputsHull(): number;
            /** Determines how many compute buffers Unity supports simultaneously in a compute shader for reading. (Read Only)
            */
            public static get maxComputeBufferInputsCompute(): number;
            /** The largest total number of invocations in a single local work group that can be dispatched to a compute shader (Read Only).
            */
            public static get maxComputeWorkGroupSize(): number;
            /** The maximum number of work groups that a compute shader can use in X dimension (Read Only).
            */
            public static get maxComputeWorkGroupSizeX(): number;
            /** The maximum number of work groups that a compute shader can use in Y dimension (Read Only).
            */
            public static get maxComputeWorkGroupSizeY(): number;
            /** The maximum number of work groups that a compute shader can use in Z dimension (Read Only).
            */
            public static get maxComputeWorkGroupSizeZ(): number;
            /** Size of the compute thread group that supports efficient memory sharing on the GPU (Read Only).
            */
            public static get computeSubGroupSize(): number;
            /** Returns true when the platform supports asynchronous compute queues and false if otherwise.
            */
            public static get supportsAsyncCompute(): boolean;
            /** Specifies whether the current platform supports the GPU Recorder or not. (Read Only).
            */
            public static get supportsGpuRecorder(): boolean;
            /** true if the platform supports GraphicsFences, otherwise false.
            */
            public static get supportsGraphicsFence(): boolean;
            /** Returns true if asynchronous readback of GPU data is available for this device and false otherwise.
            */
            public static get supportsAsyncGPUReadback(): boolean;
            /** Checks if ray tracing is supported by the current configuration.
            */
            public static get supportsRayTracing(): boolean;
            /** Does the current renderer support binding constant buffers directly? (Read Only)
            */
            public static get supportsSetConstantBuffer(): boolean;
            /** Minimum buffer offset (in bytes) when binding a constant buffer using Shader.SetConstantBuffer or Material.SetConstantBuffer.
            */
            public static get constantBufferOffsetAlignment(): number;
            /** The maximum size of a graphics buffer (GraphicsBuffer, ComputeBuffer, vertex/index buffer, etc.) in bytes (Read Only).
            */
            public static get maxGraphicsBufferSize(): bigint;
            /** Returns true if the GPU supports partial mipmap chains (Read Only).
            */
            public static get hasMipMaxLevel(): boolean;
            /** Is streaming of texture mip maps supported? (Read Only)
            */
            public static get supportsMipStreaming(): boolean;
            /** True if the Graphics API takes RenderBufferLoadAction and RenderBufferStoreAction into account, false if otherwise.
            */
            public static get usesLoadStoreActions(): boolean;
            /** Returns a bitwise combination of HDRDisplaySupportFlags describing the support for HDR displays on the system.
            */
            public static get hdrDisplaySupportFlags(): UnityEngine.HDRDisplaySupportFlags;
            /** Is conservative rasterization supported? (Read Only)
            */
            public static get supportsConservativeRaster(): boolean;
            /** Boolean that indicates whether Multiview is supported (true if supported, false if not supported). (Read Only)
            */
            public static get supportsMultiview(): boolean;
            /** This property is true if the graphics API of the target build platform takes RenderBufferStoreAction.StoreAndResolve into account, false if otherwise.
            */
            public static get supportsStoreAndResolveAction(): boolean;
            /** Returns true if the platform supports multisample resolve of depth textures.
            */
            public static get supportsMultisampleResolveDepth(): boolean;
            /** Is render texture format supported?
            * @param format The format to look up.
            * @returns True if the format is supported. 
            */
            public static SupportsRenderTextureFormat ($format: UnityEngine.RenderTextureFormat) : boolean
            /** Is blending supported on render texture format?
            * @param format The format to look up.
            * @returns True if blending is supported on the given format. 
            */
            public static SupportsBlendingOnRenderTextureFormat ($format: UnityEngine.RenderTextureFormat) : boolean
            /** Tests if a RenderTextureFormat can be used with RenderTexture.enableRandomWrite.
            * @param format The format to look up.
            * @returns True if the format can be used for random access writes. 
            */
            public static SupportsRandomWriteOnRenderTextureFormat ($format: UnityEngine.RenderTextureFormat) : boolean
            /** Is texture format supported on this device?
            * @param format The TextureFormat format to look up.
            * @returns True if the format is supported. 
            */
            public static SupportsTextureFormat ($format: UnityEngine.TextureFormat) : boolean
            /** Indicates whether the given combination of a vertex attribute format and dimension is supported on this device.
            * @param format The VertexAttributeFormat format to look up.
            * @param dimension The dimension of vertex data to check for.
            * @returns True if the format with the given dimension is supported. 
            */
            public static SupportsVertexAttributeFormat ($format: UnityEngine.Rendering.VertexAttributeFormat, $dimension: number) : boolean
            public static IsFormatSupported ($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.FormatUsage) : boolean
            public static GetCompatibleFormat ($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.FormatUsage) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** Returns the platform-specific GraphicsFormat that is associated with the DefaultFormat.
            * @param format The DefaultFormat format to look up.
            */
            public static GetGraphicsFormat ($format: UnityEngine.Experimental.Rendering.DefaultFormat) : UnityEngine.Experimental.Rendering.GraphicsFormat
            /** Checks if the target platform supports the MSAA samples count in the RenderTextureDescriptor argument.
            * @param desc The RenderTextureDescriptor to check.
            * @returns If the target platform supports the given MSAA samples count of RenderTextureDescriptor, returns the given MSAA samples count. Otherwise returns a lower fallback MSAA samples count value that the target platform supports. 
            */
            public static GetRenderTextureSupportedMSAASampleCount ($desc: UnityEngine.RenderTextureDescriptor) : number
            public constructor ()
        }
        class UnityEventQueueSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GenerateEventIdForPayload ($eventPayloadName: string) : string
            public static GetGlobalEventQueue () : System.IntPtr
            public constructor ()
        }
        /** Representation of a Position, and a Rotation in 3D Space
        */
        class Pose extends System.ValueType implements System.IEquatable$1<UnityEngine.Pose>
        {
            protected [__keep_incompatibility]: never;
            /** The position component of the pose.
            */
            public position : UnityEngine.Vector3
            /** The rotation component of the pose.
            */
            public rotation : UnityEngine.Quaternion
            /** Returns the forward vector of the pose.
            */
            public get forward(): UnityEngine.Vector3;
            /** Returns the right vector of the pose.
            */
            public get right(): UnityEngine.Vector3;
            /** Returns the up vector of the pose.
            */
            public get up(): UnityEngine.Vector3;
            /** Shorthand for pose which represents zero position, and an identity rotation.
            */
            public static get identity(): UnityEngine.Pose;
            public ToString () : string
            public ToString ($format: string) : string
            /** Transforms the current pose into the local space of the provided pose.
            */
            public GetTransformedBy ($lhs: UnityEngine.Pose) : UnityEngine.Pose
            /** Transforms the current pose into the local space of the provided pose.
            */
            public GetTransformedBy ($lhs: UnityEngine.Transform) : UnityEngine.Pose
            public Equals ($obj: any) : boolean
            public Equals ($other: UnityEngine.Pose) : boolean
            public static op_Equality ($a: UnityEngine.Pose, $b: UnityEngine.Pose) : boolean
            public static op_Inequality ($a: UnityEngine.Pose, $b: UnityEngine.Pose) : boolean
            public constructor ($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion)
            public static Equals ($objA: any, $objB: any) : boolean
            public constructor ()
        }
        /** Controls the from a script.
        */
        class FrameDebugger extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Queries whether the is enabled.
            */
            public static get enabled(): boolean;
        }
        /** An enumeration of transform properties that can be driven on a RectTransform by an object.
        */
        enum DrivenTransformProperties
        { None = 0, All = -1, AnchoredPositionX = 2, AnchoredPositionY = 4, AnchoredPositionZ = 8, Rotation = 16, ScaleX = 32, ScaleY = 64, ScaleZ = 128, AnchorMinX = 256, AnchorMinY = 512, AnchorMaxX = 1024, AnchorMaxY = 2048, SizeDeltaX = 4096, SizeDeltaY = 8192, PivotX = 16384, PivotY = 32768, AnchoredPosition = 6, AnchoredPosition3D = 14, Scale = 224, AnchorMin = 768, AnchorMax = 3072, Anchors = 3840, SizeDelta = 12288, Pivot = 49152 }
        /** A component can be designed to drive a RectTransform. The DrivenRectTransformTracker struct is used to specify which RectTransforms it is driving.
        */
        class DrivenRectTransformTracker extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Add a RectTransform to be driven.
            * @param driver The object to drive properties.
            * @param rectTransform The RectTransform to be driven.
            * @param drivenProperties The properties to be driven.
            */
            public Add ($driver: UnityEngine.Object, $rectTransform: UnityEngine.RectTransform, $drivenProperties: UnityEngine.DrivenTransformProperties) : void
            public Clear () : void
        }
        /** Position, size, anchor and pivot information for a rectangle.
        */
        class RectTransform extends UnityEngine.Transform implements System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            /** The calculated rectangle in the local space of the Transform.
            */
            public get rect(): UnityEngine.Rect;
            /** The normalized position in the parent RectTransform that the lower left corner is anchored to.
            */
            public get anchorMin(): UnityEngine.Vector2;
            public set anchorMin(value: UnityEngine.Vector2);
            /** The normalized position in the parent RectTransform that the upper right corner is anchored to.
            */
            public get anchorMax(): UnityEngine.Vector2;
            public set anchorMax(value: UnityEngine.Vector2);
            /** The position of the pivot of this RectTransform relative to the anchor reference point.
            */
            public get anchoredPosition(): UnityEngine.Vector2;
            public set anchoredPosition(value: UnityEngine.Vector2);
            /** The size of this RectTransform relative to the distances between the anchors.
            */
            public get sizeDelta(): UnityEngine.Vector2;
            public set sizeDelta(value: UnityEngine.Vector2);
            /** The normalized position in this RectTransform that it rotates around.
            */
            public get pivot(): UnityEngine.Vector2;
            public set pivot(value: UnityEngine.Vector2);
            /** The 3D position of the pivot of this RectTransform relative to the anchor reference point.
            */
            public get anchoredPosition3D(): UnityEngine.Vector3;
            public set anchoredPosition3D(value: UnityEngine.Vector3);
            /** The offset of the lower left corner of the rectangle relative to the lower left anchor.
            */
            public get offsetMin(): UnityEngine.Vector2;
            public set offsetMin(value: UnityEngine.Vector2);
            /** The offset of the upper right corner of the rectangle relative to the upper right anchor.
            */
            public get offsetMax(): UnityEngine.Vector2;
            public set offsetMax(value: UnityEngine.Vector2);
            /** The object that is driving the values of this RectTransform. Value is null if not driven.
            */
            public get drivenByObject(): UnityEngine.Object;
            public static add_reapplyDrivenProperties ($value: UnityEngine.RectTransform.ReapplyDrivenProperties) : void
            public static remove_reapplyDrivenProperties ($value: UnityEngine.RectTransform.ReapplyDrivenProperties) : void
            public ForceUpdateRectTransforms () : void
            /** Get the corners of the calculated rectangle in the local space of its Transform.
            * @param fourCornersArray The array that corners are filled into.
            */
            public GetLocalCorners ($fourCornersArray: System.Array$1<UnityEngine.Vector3>) : void
            /** Get the corners of the calculated rectangle in world space.
            * @param fourCornersArray The array that corners are filled into.
            */
            public GetWorldCorners ($fourCornersArray: System.Array$1<UnityEngine.Vector3>) : void
            public SetInsetAndSizeFromParentEdge ($edge: UnityEngine.RectTransform.Edge, $inset: number, $size: number) : void
            public SetSizeWithCurrentAnchors ($axis: UnityEngine.RectTransform.Axis, $size: number) : void
            public constructor ()
        }
        /** SpriteRenderer draw mode.
        */
        enum SpriteDrawMode
        { Simple = 0, Sliced = 1, Tiled = 2 }
        /** Tiling mode for SpriteRenderer.tileMode.
        */
        enum SpriteTileMode
        { Continuous = 0, Adaptive = 1 }
        /** This enum controls the mode under which the sprite will interact with the masking system.
        */
        enum SpriteMaskInteraction
        { None = 0, VisibleInsideMask = 1, VisibleOutsideMask = 2 }
        /** Renders a Sprite for 2D graphics.
        */
        class SpriteRenderer extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
            /** The Sprite to render.
            */
            public get sprite(): UnityEngine.Sprite;
            public set sprite(value: UnityEngine.Sprite);
            /** The current draw mode of the Sprite Renderer.
            */
            public get drawMode(): UnityEngine.SpriteDrawMode;
            public set drawMode(value: UnityEngine.SpriteDrawMode);
            /** Property to set or get the size to render when the SpriteRenderer.drawMode is set to SpriteDrawMode.Sliced or SpriteDrawMode.Tiled.
            */
            public get size(): UnityEngine.Vector2;
            public set size(value: UnityEngine.Vector2);
            /** The current threshold for Sprite Renderer tiling.
            */
            public get adaptiveModeThreshold(): number;
            public set adaptiveModeThreshold(value: number);
            /** The current tile mode of the Sprite Renderer.
            */
            public get tileMode(): UnityEngine.SpriteTileMode;
            public set tileMode(value: UnityEngine.SpriteTileMode);
            /** Rendering color for the Sprite graphic.
            */
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            /** Specifies how the sprite interacts with the masks.
            */
            public get maskInteraction(): UnityEngine.SpriteMaskInteraction;
            public set maskInteraction(value: UnityEngine.SpriteMaskInteraction);
            /** Flips the sprite on the X axis.
            */
            public get flipX(): boolean;
            public set flipX(value: boolean);
            /** Flips the sprite on the Y axis.
            */
            public get flipY(): boolean;
            public set flipY(value: boolean);
            /** Determines the position of the Sprite used for sorting the SpriteRenderer.
            */
            public get spriteSortPoint(): UnityEngine.SpriteSortPoint;
            public set spriteSortPoint(value: UnityEngine.SpriteSortPoint);
            public RegisterSpriteChangeCallback ($callback: UnityEngine.Events.UnityAction$1<UnityEngine.SpriteRenderer>) : void
            public UnregisterSpriteChangeCallback ($callback: UnityEngine.Events.UnityAction$1<UnityEngine.SpriteRenderer>) : void
            public constructor ()
        }
        /** Represents a Sprite object for use in 2D gameplay.
        */
        class Sprite extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** Bounds of the Sprite, specified by its center and extents in world space units.
            */
            public get bounds(): UnityEngine.Bounds;
            /** Location of the Sprite on the original Texture, specified in pixels.
            */
            public get rect(): UnityEngine.Rect;
            /** Returns the border sizes of the sprite.
            */
            public get border(): UnityEngine.Vector4;
            /** Get the reference to the used texture. If packed this will point to the atlas, if not packed will point to the source sprite.
            */
            public get texture(): UnityEngine.Texture2D;
            /** The number of pixels in the sprite that correspond to one unit in world space. (Read Only)
            */
            public get pixelsPerUnit(): number;
            /** The Variant scale of texture used by the Sprite. This is useful to check when a Variant SpriteAtlas is being used by Sprites.
            */
            public get spriteAtlasTextureScale(): number;
            /** Returns the texture that contains the alpha channel from the source texture. Unity generates this texture under the hood for sprites that have alpha in the source, and need to be compressed using techniques like ETC1.
            Returns NULL if there is no associated alpha texture for the source sprite. This is the case if the sprite has not been setup to use ETC1 compression.
            */
            public get associatedAlphaSplitTexture(): UnityEngine.Texture2D;
            /** Location of the Sprite's center point in the Rect on the original Texture, specified in pixels.
            */
            public get pivot(): UnityEngine.Vector2;
            public get isUsingPlaceholder(): boolean;
            /** Returns true if this Sprite is packed in an atlas.
            */
            public get packed(): boolean;
            /** If Sprite is packed (see Sprite.packed), returns its SpritePackingMode.
            */
            public get packingMode(): UnityEngine.SpritePackingMode;
            /** If Sprite is packed (see Sprite.packed), returns its SpritePackingRotation.
            */
            public get packingRotation(): UnityEngine.SpritePackingRotation;
            /** Get the rectangle this sprite uses on its texture. Raises an exception if this sprite is tightly packed in an atlas.
            */
            public get textureRect(): UnityEngine.Rect;
            /** Gets the offset of the rectangle this sprite uses on its texture to the original sprite bounds. If sprite mesh type is FullRect, offset is zero.
            */
            public get textureRectOffset(): UnityEngine.Vector2;
            /** Returns a copy of the array containing sprite mesh vertex positions.
            */
            public get vertices(): System.Array$1<UnityEngine.Vector2>;
            /** Returns a copy of the array containing sprite mesh triangles.
            */
            public get triangles(): System.Array$1<number>;
            /** The base texture coordinates of the sprite mesh.
            */
            public get uv(): System.Array$1<UnityEngine.Vector2>;
            public GetPhysicsShapeCount () : number
            /** The number of points in the selected physics shape for the Sprite.
            * @param shapeIdx The index of the physics shape to retrieve the number of points from.
            * @returns The number of points in the selected physics shape for the Sprite. 
            */
            public GetPhysicsShapePointCount ($shapeIdx: number) : number
            public GetPhysicsShape ($shapeIdx: number, $physicsShape: System.Collections.Generic.List$1<UnityEngine.Vector2>) : number
            public OverridePhysicsShape ($physicsShapes: System.Collections.Generic.IList$1<System.Array$1<UnityEngine.Vector2>>) : void
            /** Sets up new Sprite geometry.
            * @param vertices Array of vertex positions in Sprite Rect space.
            * @param triangles Array of sprite mesh triangle indices.
            */
            public OverrideGeometry ($vertices: System.Array$1<UnityEngine.Vector2>, $triangles: System.Array$1<number>) : void
            /** Create a new Sprite object.
            * @param texture Texture from which to obtain the sprite graphic.
            * @param rect Rectangular section of the texture to use for the sprite.
            * @param pivot Sprite's pivot point relative to its graphic rectangle.
            * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
            * @param extrude Amount by which the sprite mesh should be expanded outwards.
            * @param meshType Controls the type of mesh generated for the sprite.
            * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
            * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType, $border: UnityEngine.Vector4, $generateFallbackPhysicsShape: boolean) : UnityEngine.Sprite
            /** Create a new Sprite object.
            * @param texture Texture from which to obtain the sprite graphic.
            * @param rect Rectangular section of the texture to use for the sprite.
            * @param pivot Sprite's pivot point relative to its graphic rectangle.
            * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
            * @param extrude Amount by which the sprite mesh should be expanded outwards.
            * @param meshType Controls the type of mesh generated for the sprite.
            * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
            * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType, $border: UnityEngine.Vector4) : UnityEngine.Sprite
            /** Create a new Sprite object.
            * @param texture Texture from which to obtain the sprite graphic.
            * @param rect Rectangular section of the texture to use for the sprite.
            * @param pivot Sprite's pivot point relative to its graphic rectangle.
            * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
            * @param extrude Amount by which the sprite mesh should be expanded outwards.
            * @param meshType Controls the type of mesh generated for the sprite.
            * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
            * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType) : UnityEngine.Sprite
            /** Create a new Sprite object.
            * @param texture Texture from which to obtain the sprite graphic.
            * @param rect Rectangular section of the texture to use for the sprite.
            * @param pivot Sprite's pivot point relative to its graphic rectangle.
            * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
            * @param extrude Amount by which the sprite mesh should be expanded outwards.
            * @param meshType Controls the type of mesh generated for the sprite.
            * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
            * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number) : UnityEngine.Sprite
            /** Create a new Sprite object.
            * @param texture Texture from which to obtain the sprite graphic.
            * @param rect Rectangular section of the texture to use for the sprite.
            * @param pivot Sprite's pivot point relative to its graphic rectangle.
            * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
            * @param extrude Amount by which the sprite mesh should be expanded outwards.
            * @param meshType Controls the type of mesh generated for the sprite.
            * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
            * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number) : UnityEngine.Sprite
            /** Create a new Sprite object.
            * @param texture Texture from which to obtain the sprite graphic.
            * @param rect Rectangular section of the texture to use for the sprite.
            * @param pivot Sprite's pivot point relative to its graphic rectangle.
            * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
            * @param extrude Amount by which the sprite mesh should be expanded outwards.
            * @param meshType Controls the type of mesh generated for the sprite.
            * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
            * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
            */
            public static Create ($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2) : UnityEngine.Sprite
        }
        /** Determines the position of the Sprite used for sorting the Renderer.
        */
        enum SpriteSortPoint
        { Center = 0, Pivot = 1 }
        /** Defines the type of mesh generated for a sprite.
        */
        enum SpriteMeshType
        { FullRect = 0, Tight = 1 }
        /** How a Sprite's graphic rectangle is aligned with its pivot point.
        */
        enum SpriteAlignment
        { Center = 0, TopLeft = 1, TopCenter = 2, TopRight = 3, LeftCenter = 4, RightCenter = 5, BottomLeft = 6, BottomCenter = 7, BottomRight = 8, Custom = 9 }
        /** Sprite packing modes for the Sprite Packer.
        */
        enum SpritePackingMode
        { Tight = 0, Rectangle = 1 }
        /** Sprite rotation modes for the Sprite Packer.
        */
        enum SpritePackingRotation
        { None = 0, FlipHorizontal = 1, FlipVertical = 2, Rotate180 = 3, Any = 15 }
        /** Encapsulates a Texture2D and its shader property name to give Sprite-based renderers access to a secondary texture, in addition to the main Sprite texture.
        */
        class SecondarySpriteTexture extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The shader property name of the secondary Sprite texture. Use this name to identify and sample the texture in the shader.
            */
            public name : string
            /** The texture to be used as a secondary Sprite texture.
            */
            public texture : UnityEngine.Texture2D
        }
        /** Generic access to the Social API.
        */
        class Social extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** This is the currently active social platform. 
            */
            public static get Active(): UnityEngine.SocialPlatforms.ISocialPlatform;
            public static set Active(value: UnityEngine.SocialPlatforms.ISocialPlatform);
            /** The local user (potentially not logged in).
            */
            public static get localUser(): UnityEngine.SocialPlatforms.ILocalUser;
            public static LoadUsers ($userIDs: System.Array$1<string>, $callback: System.Action$1<System.Array$1<UnityEngine.SocialPlatforms.IUserProfile>>) : void
            public static ReportProgress ($achievementID: string, $progress: number, $callback: System.Action$1<boolean>) : void
            public static LoadAchievementDescriptions ($callback: System.Action$1<System.Array$1<UnityEngine.SocialPlatforms.IAchievementDescription>>) : void
            public static LoadAchievements ($callback: System.Action$1<System.Array$1<UnityEngine.SocialPlatforms.IAchievement>>) : void
            public static ReportScore ($score: bigint, $board: string, $callback: System.Action$1<boolean>) : void
            public static LoadScores ($leaderboardID: string, $callback: System.Action$1<System.Array$1<UnityEngine.SocialPlatforms.IScore>>) : void
            public static CreateLeaderboard () : UnityEngine.SocialPlatforms.ILeaderboard
            public static CreateAchievement () : UnityEngine.SocialPlatforms.IAchievement
            public static ShowAchievementsUI () : void
            public static ShowLeaderboardUI () : void
        }
        /** An abstract class that defines a grid layout.
        */
        class GridLayout extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The size of each cell in the layout.
            */
            public get cellSize(): UnityEngine.Vector3;
            /** The size of the gap between each cell in the layout.
            */
            public get cellGap(): UnityEngine.Vector3;
            /** The layout of the cells.
            */
            public get cellLayout(): UnityEngine.GridLayout.CellLayout;
            /** The cell swizzle for the layout.
            */
            public get cellSwizzle(): UnityEngine.GridLayout.CellSwizzle;
            /** Returns the local bounds for a cell at the location.
            * @param cellPosition Location of the cell.
            * @returns Local bounds of cell at the location. 
            */
            public GetBoundsLocal ($cellPosition: UnityEngine.Vector3Int) : UnityEngine.Bounds
            /** Returns the local bounds for the groups of cells at the location.
            * @param origin Origin of the group of cells.
            * @param size Size of the group of cells.
            * @returns Local bounds of the group of cells at the location. 
            */
            public GetBoundsLocal ($origin: UnityEngine.Vector3, $size: UnityEngine.Vector3) : UnityEngine.Bounds
            /** Converts a cell position to local position space.
            * @param cellPosition Cell position to convert.
            * @returns Local position of the cell position. 
            */
            public CellToLocal ($cellPosition: UnityEngine.Vector3Int) : UnityEngine.Vector3
            /** Converts a local position to cell position.
            * @param localPosition Local Position to convert.
            * @returns Cell position of the local position. 
            */
            public LocalToCell ($localPosition: UnityEngine.Vector3) : UnityEngine.Vector3Int
            /** Converts an interpolated cell position in floats to local position space.
            * @param cellPosition Interpolated cell position to convert.
            * @returns Local position of the cell position. 
            */
            public CellToLocalInterpolated ($cellPosition: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Converts a local position to cell position.
            * @param localPosition Local Position to convert.
            * @returns Interpolated cell position of the local position. 
            */
            public LocalToCellInterpolated ($localPosition: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Converts a cell position to world position space.
            * @param cellPosition Cell position to convert.
            * @returns World position of the cell position. 
            */
            public CellToWorld ($cellPosition: UnityEngine.Vector3Int) : UnityEngine.Vector3
            /** Converts a world position to cell position.
            * @param worldPosition World Position to convert.
            * @returns Cell position of the world position. 
            */
            public WorldToCell ($worldPosition: UnityEngine.Vector3) : UnityEngine.Vector3Int
            /** Converts a local position to world position.
            * @param localPosition Local Position to convert.
            * @returns World position of the local position. 
            */
            public LocalToWorld ($localPosition: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Converts a world position to local position.
            * @param worldPosition World Position to convert.
            * @returns Local position of the world position. 
            */
            public WorldToLocal ($worldPosition: UnityEngine.Vector3) : UnityEngine.Vector3
            public GetLayoutCellCenter () : UnityEngine.Vector3
            public constructor ()
        }
        /** Grid is the base class for plotting a layout of uniformly spaced points and lines.
        */
        class Grid extends UnityEngine.GridLayout
        {
            protected [__keep_incompatibility]: never;
            /** The size of each cell in the Grid.
            */
            public get cellSize(): UnityEngine.Vector3;
            public set cellSize(value: UnityEngine.Vector3);
            /** The size of the gap between each cell in the Grid.
            */
            public get cellGap(): UnityEngine.Vector3;
            public set cellGap(value: UnityEngine.Vector3);
            /** The layout of the cells in the Grid.
            */
            public get cellLayout(): UnityEngine.GridLayout.CellLayout;
            public set cellLayout(value: UnityEngine.GridLayout.CellLayout);
            /** The cell swizzle for the Grid.
            */
            public get cellSwizzle(): UnityEngine.GridLayout.CellSwizzle;
            public set cellSwizzle(value: UnityEngine.GridLayout.CellSwizzle);
            /** Get the logical center coordinate of a grid cell in local space.
            * @param position Grid cell position.
            * @returns Center of the cell transformed into local space coordinates. 
            */
            public GetCellCenterLocal ($position: UnityEngine.Vector3Int) : UnityEngine.Vector3
            /** Get the logical center coordinate of a grid cell in world space.
            * @param position Grid cell position.
            * @returns Center of the cell transformed into world space coordinates. 
            */
            public GetCellCenterWorld ($position: UnityEngine.Vector3Int) : UnityEngine.Vector3
            public static Swizzle ($swizzle: UnityEngine.GridLayout.CellSwizzle, $position: UnityEngine.Vector3) : UnityEngine.Vector3
            public static InverseSwizzle ($swizzle: UnityEngine.GridLayout.CellSwizzle, $position: UnityEngine.Vector3) : UnityEngine.Vector3
            public constructor ()
        }
        /** Types of UnityGUI input and processing events.
        */
        enum EventType
        { MouseDown = 0, MouseUp = 1, MouseMove = 2, MouseDrag = 3, KeyDown = 4, KeyUp = 5, ScrollWheel = 6, Repaint = 7, Layout = 8, DragUpdated = 9, DragPerform = 10, DragExited = 15, Ignore = 11, Used = 12, ValidateCommand = 13, ExecuteCommand = 14, ContextClick = 16, MouseEnterWindow = 20, MouseLeaveWindow = 21, TouchDown = 30, TouchUp = 31, TouchMove = 32, TouchEnter = 33, TouchLeave = 34, TouchStationary = 35, mouseDown = 0, mouseUp = 1, mouseMove = 2, mouseDrag = 3, keyDown = 4, keyUp = 5, scrollWheel = 6, repaint = 7, layout = 8, dragUpdated = 9, dragPerform = 10, ignore = 11, used = 12 }
        /** Pointer types.
        */
        enum PointerType
        { Mouse = 0, Touch = 1, Pen = 2 }
        /** Types of modifier key that can be active during a keystroke event.
        */
        enum EventModifiers
        { None = 0, Shift = 1, Control = 2, Alt = 4, Command = 8, Numeric = 16, CapsLock = 32, FunctionKey = 64 }
        /** The GUI class is the interface for Unity's GUI with manual positioning.
        */
        class GUI extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Applies a global tint to the GUI. The tint affects backgrounds and text colors.
            */
            public static get color(): UnityEngine.Color;
            public static set color(value: UnityEngine.Color);
            /** Global tinting color for all background elements rendered by the GUI.
            */
            public static get backgroundColor(): UnityEngine.Color;
            public static set backgroundColor(value: UnityEngine.Color);
            /** Tinting color for all text rendered by the GUI.
            */
            public static get contentColor(): UnityEngine.Color;
            public static set contentColor(value: UnityEngine.Color);
            /** Returns true if any controls changed the value of the input data.
            */
            public static get changed(): boolean;
            public static set changed(value: boolean);
            /** Is the GUI enabled?
            */
            public static get enabled(): boolean;
            public static set enabled(value: boolean);
            /** The sorting depth of the currently executing GUI behaviour.
            */
            public static get depth(): number;
            public static set depth(value: number);
            /** The global skin to use.
            */
            public static get skin(): UnityEngine.GUISkin;
            public static set skin(value: UnityEngine.GUISkin);
            /** The GUI transform matrix.
            */
            public static get matrix(): UnityEngine.Matrix4x4;
            public static set matrix(value: UnityEngine.Matrix4x4);
            /** The tooltip of the control the mouse is currently over, or which has keyboard focus. (Read Only).
            */
            public static get tooltip(): string;
            public static set tooltip(value: string);
            /** Set the name of the next control.
            */
            public static SetNextControlName ($name: string) : void
            public static GetNameOfFocusedControl () : string
            /** Move keyboard focus to a named control.
            * @param name Name set using SetNextControlName.
            */
            public static FocusControl ($name: string) : void
            /** Make a window draggable.
            * @param position The part of the window that can be dragged. This is clipped to the actual window.
            */
            public static DragWindow ($position: UnityEngine.Rect) : void
            /** Bring a specific window to front of the floating windows.
            * @param windowID The identifier used when you created the window in the Window call.
            */
            public static BringWindowToFront ($windowID: number) : void
            /** Bring a specific window to back of the floating windows.
            * @param windowID The identifier used when you created the window in the Window call.
            */
            public static BringWindowToBack ($windowID: number) : void
            /** Make a window become the active window.
            * @param windowID The identifier used when you created the window in the Window call.
            */
            public static FocusWindow ($windowID: number) : void
            public static UnfocusWindow () : void
            /** Make a text or texture label on screen.
            * @param position Rectangle on the screen to use for the label.
            * @param text Text to display on the label.
            * @param image Texture to display on the label.
            * @param content Text, image and tooltip for this label.
            * @param style The style to use. If left out, the label style from the current GUISkin is used.
            */
            public static Label ($position: UnityEngine.Rect, $text: string) : void
            /** Make a text or texture label on screen.
            * @param position Rectangle on the screen to use for the label.
            * @param text Text to display on the label.
            * @param image Texture to display on the label.
            * @param content Text, image and tooltip for this label.
            * @param style The style to use. If left out, the label style from the current GUISkin is used.
            */
            public static Label ($position: UnityEngine.Rect, $image: UnityEngine.Texture) : void
            /** Make a text or texture label on screen.
            * @param position Rectangle on the screen to use for the label.
            * @param text Text to display on the label.
            * @param image Texture to display on the label.
            * @param content Text, image and tooltip for this label.
            * @param style The style to use. If left out, the label style from the current GUISkin is used.
            */
            public static Label ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent) : void
            /** Make a text or texture label on screen.
            * @param position Rectangle on the screen to use for the label.
            * @param text Text to display on the label.
            * @param image Texture to display on the label.
            * @param content Text, image and tooltip for this label.
            * @param style The style to use. If left out, the label style from the current GUISkin is used.
            */
            public static Label ($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle) : void
            /** Make a text or texture label on screen.
            * @param position Rectangle on the screen to use for the label.
            * @param text Text to display on the label.
            * @param image Texture to display on the label.
            * @param content Text, image and tooltip for this label.
            * @param style The style to use. If left out, the label style from the current GUISkin is used.
            */
            public static Label ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle) : void
            /** Make a text or texture label on screen.
            * @param position Rectangle on the screen to use for the label.
            * @param text Text to display on the label.
            * @param image Texture to display on the label.
            * @param content Text, image and tooltip for this label.
            * @param style The style to use. If left out, the label style from the current GUISkin is used.
            */
            public static Label ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle) : void
            /** Draw a texture within a rectangle.
            * @param position Rectangle on the screen to draw the texture within.
            * @param image Texture to display.
            * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
            * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
            * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
            */
            public static DrawTexture ($position: UnityEngine.Rect, $image: UnityEngine.Texture) : void
            /** Draw a texture within a rectangle.
            * @param position Rectangle on the screen to draw the texture within.
            * @param image Texture to display.
            * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
            * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
            * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
            */
            public static DrawTexture ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $scaleMode: UnityEngine.ScaleMode) : void
            /** Draw a texture within a rectangle.
            * @param position Rectangle on the screen to draw the texture within.
            * @param image Texture to display.
            * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
            * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
            * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
            */
            public static DrawTexture ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $scaleMode: UnityEngine.ScaleMode, $alphaBlend: boolean) : void
            /** Draw a texture within a rectangle.
            * @param position Rectangle on the screen to draw the texture within.
            * @param image Texture to display.
            * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
            * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
            * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
            */
            public static DrawTexture ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $scaleMode: UnityEngine.ScaleMode, $alphaBlend: boolean, $imageAspect: number) : void
            /** Draws a border with rounded corners within a rectangle. The texture is used to pattern the border.  Note that this method only works on shader model 2.5 and above.
            * @param position Rectangle on the screen to draw the texture within.
            * @param image Texture to display.
            * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
            * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
            * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
            * @param color A tint color to apply on the texture.
            * @param borderWidth The width of the border. If 0, the full texture is drawn.
            * @param borderWidths The width of the borders (left, top, right and bottom). If Vector4.zero, the full texture is drawn.
            * @param borderRadius The radius for rounded corners. If 0, corners will not be rounded.
            * @param borderRadiuses The radiuses for rounded corners (top-left, top-right, bottom-right and bottom-left). If Vector4.zero, corners will not be rounded.
            */
            public static DrawTexture ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $scaleMode: UnityEngine.ScaleMode, $alphaBlend: boolean, $imageAspect: number, $color: UnityEngine.Color, $borderWidth: number, $borderRadius: number) : void
            /** Draws a border with rounded corners within a rectangle. The texture is used to pattern the border.  Note that this method only works on shader model 2.5 and above.
            * @param position Rectangle on the screen to draw the texture within.
            * @param image Texture to display.
            * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
            * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
            * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
            * @param color A tint color to apply on the texture.
            * @param borderWidth The width of the border. If 0, the full texture is drawn.
            * @param borderWidths The width of the borders (left, top, right and bottom). If Vector4.zero, the full texture is drawn.
            * @param borderRadius The radius for rounded corners. If 0, corners will not be rounded.
            * @param borderRadiuses The radiuses for rounded corners (top-left, top-right, bottom-right and bottom-left). If Vector4.zero, corners will not be rounded.
            */
            public static DrawTexture ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $scaleMode: UnityEngine.ScaleMode, $alphaBlend: boolean, $imageAspect: number, $color: UnityEngine.Color, $borderWidths: UnityEngine.Vector4, $borderRadius: number) : void
            public static DrawTexture ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $scaleMode: UnityEngine.ScaleMode, $alphaBlend: boolean, $imageAspect: number, $color: UnityEngine.Color, $borderWidths: UnityEngine.Vector4, $borderRadiuses: UnityEngine.Vector4) : void
            /** Draw a texture within a rectangle with the given texture coordinates.
            * @param position Rectangle on the screen to draw the texture within.
            * @param image Texture to display.
            * @param texCoords How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
            * @param alphaBlend Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display.
            */
            public static DrawTextureWithTexCoords ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $texCoords: UnityEngine.Rect) : void
            /** Draw a texture within a rectangle with the given texture coordinates.
            * @param position Rectangle on the screen to draw the texture within.
            * @param image Texture to display.
            * @param texCoords How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
            * @param alphaBlend Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display.
            */
            public static DrawTextureWithTexCoords ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $texCoords: UnityEngine.Rect, $alphaBlend: boolean) : void
            /** Create a Box on the GUI Layer.
            * @param position Rectangle on the screen to use for the box.
            * @param text Text to display on the box.
            * @param image Texture to display on the box.
            * @param content Text, image and tooltip for this box.
            * @param style The style to use. If left out, the box style from the current GUISkin is used.
            */
            public static Box ($position: UnityEngine.Rect, $text: string) : void
            /** Create a Box on the GUI Layer.
            * @param position Rectangle on the screen to use for the box.
            * @param text Text to display on the box.
            * @param image Texture to display on the box.
            * @param content Text, image and tooltip for this box.
            * @param style The style to use. If left out, the box style from the current GUISkin is used.
            */
            public static Box ($position: UnityEngine.Rect, $image: UnityEngine.Texture) : void
            /** Create a Box on the GUI Layer.
            * @param position Rectangle on the screen to use for the box.
            * @param text Text to display on the box.
            * @param image Texture to display on the box.
            * @param content Text, image and tooltip for this box.
            * @param style The style to use. If left out, the box style from the current GUISkin is used.
            */
            public static Box ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent) : void
            /** Create a Box on the GUI Layer.
            * @param position Rectangle on the screen to use for the box.
            * @param text Text to display on the box.
            * @param image Texture to display on the box.
            * @param content Text, image and tooltip for this box.
            * @param style The style to use. If left out, the box style from the current GUISkin is used.
            */
            public static Box ($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle) : void
            /** Create a Box on the GUI Layer.
            * @param position Rectangle on the screen to use for the box.
            * @param text Text to display on the box.
            * @param image Texture to display on the box.
            * @param content Text, image and tooltip for this box.
            * @param style The style to use. If left out, the box style from the current GUISkin is used.
            */
            public static Box ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle) : void
            /** Create a Box on the GUI Layer.
            * @param position Rectangle on the screen to use for the box.
            * @param text Text to display on the box.
            * @param image Texture to display on the box.
            * @param content Text, image and tooltip for this box.
            * @param style The style to use. If left out, the box style from the current GUISkin is used.
            */
            public static Box ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle) : void
            /** Make a single press button. The user clicks them and something happens immediately.
            * @param position Rectangle on the screen to use for the button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns true when the users clicks the button. 
            */
            public static Button ($position: UnityEngine.Rect, $text: string) : boolean
            /** Make a single press button. The user clicks them and something happens immediately.
            * @param position Rectangle on the screen to use for the button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns true when the users clicks the button. 
            */
            public static Button ($position: UnityEngine.Rect, $image: UnityEngine.Texture) : boolean
            /** Make a single press button. The user clicks them and something happens immediately.
            * @param position Rectangle on the screen to use for the button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns true when the users clicks the button. 
            */
            public static Button ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent) : boolean
            /** Make a single press button. The user clicks them and something happens immediately.
            * @param position Rectangle on the screen to use for the button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns true when the users clicks the button. 
            */
            public static Button ($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle) : boolean
            /** Make a single press button. The user clicks them and something happens immediately.
            * @param position Rectangle on the screen to use for the button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns true when the users clicks the button. 
            */
            public static Button ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle) : boolean
            /** Make a single press button. The user clicks them and something happens immediately.
            * @param position Rectangle on the screen to use for the button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns true when the users clicks the button. 
            */
            public static Button ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle) : boolean
            /** Make a button that is active as long as the user holds it down.
            * @param position Rectangle on the screen to use for the button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns True when the users clicks the button. 
            */
            public static RepeatButton ($position: UnityEngine.Rect, $text: string) : boolean
            /** Make a button that is active as long as the user holds it down.
            * @param position Rectangle on the screen to use for the button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns True when the users clicks the button. 
            */
            public static RepeatButton ($position: UnityEngine.Rect, $image: UnityEngine.Texture) : boolean
            /** Make a button that is active as long as the user holds it down.
            * @param position Rectangle on the screen to use for the button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns True when the users clicks the button. 
            */
            public static RepeatButton ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent) : boolean
            /** Make a button that is active as long as the user holds it down.
            * @param position Rectangle on the screen to use for the button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns True when the users clicks the button. 
            */
            public static RepeatButton ($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle) : boolean
            /** Make a button that is active as long as the user holds it down.
            * @param position Rectangle on the screen to use for the button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns True when the users clicks the button. 
            */
            public static RepeatButton ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle) : boolean
            /** Make a button that is active as long as the user holds it down.
            * @param position Rectangle on the screen to use for the button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns True when the users clicks the button. 
            */
            public static RepeatButton ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle) : boolean
            /** Make a single-line text field where the user can edit a string.
            * @param position Rectangle on the screen to use for the text field.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @returns The edited string. 
            */
            public static TextField ($position: UnityEngine.Rect, $text: string) : string
            /** Make a single-line text field where the user can edit a string.
            * @param position Rectangle on the screen to use for the text field.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @returns The edited string. 
            */
            public static TextField ($position: UnityEngine.Rect, $text: string, $maxLength: number) : string
            /** Make a single-line text field where the user can edit a string.
            * @param position Rectangle on the screen to use for the text field.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @returns The edited string. 
            */
            public static TextField ($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle) : string
            /** Make a single-line text field where the user can edit a string.
            * @param position Rectangle on the screen to use for the text field.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @returns The edited string. 
            */
            public static TextField ($position: UnityEngine.Rect, $text: string, $maxLength: number, $style: UnityEngine.GUIStyle) : string
            /** Make a text field where the user can enter a password.
            * @param position Rectangle on the screen to use for the text field.
            * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maskChar Character to mask the password with.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @returns The edited password. 
            */
            public static PasswordField ($position: UnityEngine.Rect, $password: string, $maskChar: number) : string
            /** Make a text field where the user can enter a password.
            * @param position Rectangle on the screen to use for the text field.
            * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maskChar Character to mask the password with.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @returns The edited password. 
            */
            public static PasswordField ($position: UnityEngine.Rect, $password: string, $maskChar: number, $maxLength: number) : string
            /** Make a text field where the user can enter a password.
            * @param position Rectangle on the screen to use for the text field.
            * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maskChar Character to mask the password with.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @returns The edited password. 
            */
            public static PasswordField ($position: UnityEngine.Rect, $password: string, $maskChar: number, $style: UnityEngine.GUIStyle) : string
            /** Make a text field where the user can enter a password.
            * @param position Rectangle on the screen to use for the text field.
            * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maskChar Character to mask the password with.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @returns The edited password. 
            */
            public static PasswordField ($position: UnityEngine.Rect, $password: string, $maskChar: number, $maxLength: number, $style: UnityEngine.GUIStyle) : string
            /** Make a Multi-line text area where the user can edit a string.
            * @param position Rectangle on the screen to use for the text field.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
            * @returns The edited string. 
            */
            public static TextArea ($position: UnityEngine.Rect, $text: string) : string
            /** Make a Multi-line text area where the user can edit a string.
            * @param position Rectangle on the screen to use for the text field.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
            * @returns The edited string. 
            */
            public static TextArea ($position: UnityEngine.Rect, $text: string, $maxLength: number) : string
            /** Make a Multi-line text area where the user can edit a string.
            * @param position Rectangle on the screen to use for the text field.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
            * @returns The edited string. 
            */
            public static TextArea ($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle) : string
            /** Make a Multi-line text area where the user can edit a string.
            * @param position Rectangle on the screen to use for the text field.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
            * @returns The edited string. 
            */
            public static TextArea ($position: UnityEngine.Rect, $text: string, $maxLength: number, $style: UnityEngine.GUIStyle) : string
            /** Make an on/off toggle button.
            * @param position Rectangle on the screen to use for the button.
            * @param value Is this button on or off?
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
            * @returns The new value of the button. 
            */
            public static Toggle ($position: UnityEngine.Rect, $value: boolean, $text: string) : boolean
            /** Make an on/off toggle button.
            * @param position Rectangle on the screen to use for the button.
            * @param value Is this button on or off?
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
            * @returns The new value of the button. 
            */
            public static Toggle ($position: UnityEngine.Rect, $value: boolean, $image: UnityEngine.Texture) : boolean
            /** Make an on/off toggle button.
            * @param position Rectangle on the screen to use for the button.
            * @param value Is this button on or off?
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
            * @returns The new value of the button. 
            */
            public static Toggle ($position: UnityEngine.Rect, $value: boolean, $content: UnityEngine.GUIContent) : boolean
            /** Make an on/off toggle button.
            * @param position Rectangle on the screen to use for the button.
            * @param value Is this button on or off?
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
            * @returns The new value of the button. 
            */
            public static Toggle ($position: UnityEngine.Rect, $value: boolean, $text: string, $style: UnityEngine.GUIStyle) : boolean
            /** Make an on/off toggle button.
            * @param position Rectangle on the screen to use for the button.
            * @param value Is this button on or off?
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
            * @returns The new value of the button. 
            */
            public static Toggle ($position: UnityEngine.Rect, $value: boolean, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle) : boolean
            /** Make an on/off toggle button.
            * @param position Rectangle on the screen to use for the button.
            * @param value Is this button on or off?
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
            * @returns The new value of the button. 
            */
            public static Toggle ($position: UnityEngine.Rect, $value: boolean, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle) : boolean
            public static Toggle ($position: UnityEngine.Rect, $id: number, $value: boolean, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle) : boolean
            /** Make a toolbar.
            * @param position Rectangle on the screen to use for the toolbar.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the toolbar buttons.
            * @param images An array of textures on the toolbar buttons.
            * @param contents An array of text, image and tooltips for the toolbar buttons.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param buttonSize Determines how toolbar button size is calculated.
            * @returns The index of the selected button. 
            */
            public static Toolbar ($position: UnityEngine.Rect, $selected: number, $texts: System.Array$1<string>) : number
            /** Make a toolbar.
            * @param position Rectangle on the screen to use for the toolbar.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the toolbar buttons.
            * @param images An array of textures on the toolbar buttons.
            * @param contents An array of text, image and tooltips for the toolbar buttons.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param buttonSize Determines how toolbar button size is calculated.
            * @returns The index of the selected button. 
            */
            public static Toolbar ($position: UnityEngine.Rect, $selected: number, $images: System.Array$1<UnityEngine.Texture>) : number
            /** Make a toolbar.
            * @param position Rectangle on the screen to use for the toolbar.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the toolbar buttons.
            * @param images An array of textures on the toolbar buttons.
            * @param contents An array of text, image and tooltips for the toolbar buttons.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param buttonSize Determines how toolbar button size is calculated.
            * @returns The index of the selected button. 
            */
            public static Toolbar ($position: UnityEngine.Rect, $selected: number, $contents: System.Array$1<UnityEngine.GUIContent>) : number
            /** Make a toolbar.
            * @param position Rectangle on the screen to use for the toolbar.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the toolbar buttons.
            * @param images An array of textures on the toolbar buttons.
            * @param contents An array of text, image and tooltips for the toolbar buttons.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param buttonSize Determines how toolbar button size is calculated.
            * @returns The index of the selected button. 
            */
            public static Toolbar ($position: UnityEngine.Rect, $selected: number, $texts: System.Array$1<string>, $style: UnityEngine.GUIStyle) : number
            /** Make a toolbar.
            * @param position Rectangle on the screen to use for the toolbar.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the toolbar buttons.
            * @param images An array of textures on the toolbar buttons.
            * @param contents An array of text, image and tooltips for the toolbar buttons.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param buttonSize Determines how toolbar button size is calculated.
            * @returns The index of the selected button. 
            */
            public static Toolbar ($position: UnityEngine.Rect, $selected: number, $images: System.Array$1<UnityEngine.Texture>, $style: UnityEngine.GUIStyle) : number
            /** Make a toolbar.
            * @param position Rectangle on the screen to use for the toolbar.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the toolbar buttons.
            * @param images An array of textures on the toolbar buttons.
            * @param contents An array of text, image and tooltips for the toolbar buttons.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param buttonSize Determines how toolbar button size is calculated.
            * @returns The index of the selected button. 
            */
            public static Toolbar ($position: UnityEngine.Rect, $selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $style: UnityEngine.GUIStyle) : number
            public static Toolbar ($position: UnityEngine.Rect, $selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $style: UnityEngine.GUIStyle, $buttonSize: UnityEngine.GUI.ToolbarButtonSize) : number
            /** Make a grid of buttons.
            * @param position Rectangle on the screen to use for the grid.
            * @param selected The index of the selected grid button.
            * @param texts An array of strings to show on the grid buttons.
            * @param images An array of textures on the grid buttons.
            * @param contents An array of text, image and tooltips for the grid button.
            * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns The index of the selected button. 
            */
            public static SelectionGrid ($position: UnityEngine.Rect, $selected: number, $texts: System.Array$1<string>, $xCount: number) : number
            /** Make a grid of buttons.
            * @param position Rectangle on the screen to use for the grid.
            * @param selected The index of the selected grid button.
            * @param texts An array of strings to show on the grid buttons.
            * @param images An array of textures on the grid buttons.
            * @param contents An array of text, image and tooltips for the grid button.
            * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns The index of the selected button. 
            */
            public static SelectionGrid ($position: UnityEngine.Rect, $selected: number, $images: System.Array$1<UnityEngine.Texture>, $xCount: number) : number
            /** Make a grid of buttons.
            * @param position Rectangle on the screen to use for the grid.
            * @param selected The index of the selected grid button.
            * @param texts An array of strings to show on the grid buttons.
            * @param images An array of textures on the grid buttons.
            * @param contents An array of text, image and tooltips for the grid button.
            * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns The index of the selected button. 
            */
            public static SelectionGrid ($position: UnityEngine.Rect, $selected: number, $content: System.Array$1<UnityEngine.GUIContent>, $xCount: number) : number
            /** Make a grid of buttons.
            * @param position Rectangle on the screen to use for the grid.
            * @param selected The index of the selected grid button.
            * @param texts An array of strings to show on the grid buttons.
            * @param images An array of textures on the grid buttons.
            * @param contents An array of text, image and tooltips for the grid button.
            * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns The index of the selected button. 
            */
            public static SelectionGrid ($position: UnityEngine.Rect, $selected: number, $texts: System.Array$1<string>, $xCount: number, $style: UnityEngine.GUIStyle) : number
            /** Make a grid of buttons.
            * @param position Rectangle on the screen to use for the grid.
            * @param selected The index of the selected grid button.
            * @param texts An array of strings to show on the grid buttons.
            * @param images An array of textures on the grid buttons.
            * @param contents An array of text, image and tooltips for the grid button.
            * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns The index of the selected button. 
            */
            public static SelectionGrid ($position: UnityEngine.Rect, $selected: number, $images: System.Array$1<UnityEngine.Texture>, $xCount: number, $style: UnityEngine.GUIStyle) : number
            /** Make a grid of buttons.
            * @param position Rectangle on the screen to use for the grid.
            * @param selected The index of the selected grid button.
            * @param texts An array of strings to show on the grid buttons.
            * @param images An array of textures on the grid buttons.
            * @param contents An array of text, image and tooltips for the grid button.
            * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @returns The index of the selected button. 
            */
            public static SelectionGrid ($position: UnityEngine.Rect, $selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $xCount: number, $style: UnityEngine.GUIStyle) : number
            /** A horizontal slider the user can drag to change a value between a min and a max.
            * @param position Rectangle on the screen to use for the slider.
            * @param value The value the slider shows. This determines the position of the draggable thumb.
            * @param leftValue The value at the left end of the slider.
            * @param rightValue The value at the right end of the slider.
            * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
            * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
            * @returns The value that has been set by the user. 
            */
            public static HorizontalSlider ($position: UnityEngine.Rect, $value: number, $leftValue: number, $rightValue: number) : number
            /** A horizontal slider the user can drag to change a value between a min and a max.
            * @param position Rectangle on the screen to use for the slider.
            * @param value The value the slider shows. This determines the position of the draggable thumb.
            * @param leftValue The value at the left end of the slider.
            * @param rightValue The value at the right end of the slider.
            * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
            * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
            * @returns The value that has been set by the user. 
            */
            public static HorizontalSlider ($position: UnityEngine.Rect, $value: number, $leftValue: number, $rightValue: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle) : number
            public static HorizontalSlider ($position: UnityEngine.Rect, $value: number, $leftValue: number, $rightValue: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle, $thumbExtent: UnityEngine.GUIStyle) : number
            /** A vertical slider the user can drag to change a value between a min and a max.
            * @param position Rectangle on the screen to use for the slider.
            * @param value The value the slider shows. This determines the position of the draggable thumb.
            * @param topValue The value at the top end of the slider.
            * @param bottomValue The value at the bottom end of the slider.
            * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
            * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
            * @returns The value that has been set by the user. 
            */
            public static VerticalSlider ($position: UnityEngine.Rect, $value: number, $topValue: number, $bottomValue: number) : number
            /** A vertical slider the user can drag to change a value between a min and a max.
            * @param position Rectangle on the screen to use for the slider.
            * @param value The value the slider shows. This determines the position of the draggable thumb.
            * @param topValue The value at the top end of the slider.
            * @param bottomValue The value at the bottom end of the slider.
            * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
            * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
            * @returns The value that has been set by the user. 
            */
            public static VerticalSlider ($position: UnityEngine.Rect, $value: number, $topValue: number, $bottomValue: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle) : number
            public static VerticalSlider ($position: UnityEngine.Rect, $value: number, $topValue: number, $bottomValue: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle, $thumbExtent: UnityEngine.GUIStyle) : number
            public static Slider ($position: UnityEngine.Rect, $value: number, $size: number, $start: number, $end: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle, $horiz: boolean, $id: number, $thumbExtent?: UnityEngine.GUIStyle) : number
            /** Make a horizontal scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.
            * @param position Rectangle on the screen to use for the scrollbar.
            * @param value The position between min and max.
            * @param size How much can we see?
            * @param leftValue The value at the left end of the scrollbar.
            * @param rightValue The value at the right end of the scrollbar.
            * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
            */
            public static HorizontalScrollbar ($position: UnityEngine.Rect, $value: number, $size: number, $leftValue: number, $rightValue: number) : number
            /** Make a horizontal scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.
            * @param position Rectangle on the screen to use for the scrollbar.
            * @param value The position between min and max.
            * @param size How much can we see?
            * @param leftValue The value at the left end of the scrollbar.
            * @param rightValue The value at the right end of the scrollbar.
            * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
            */
            public static HorizontalScrollbar ($position: UnityEngine.Rect, $value: number, $size: number, $leftValue: number, $rightValue: number, $style: UnityEngine.GUIStyle) : number
            /** Make a vertical scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.
            * @param position Rectangle on the screen to use for the scrollbar.
            * @param value The position between min and max.
            * @param size How much can we see?
            * @param topValue The value at the top of the scrollbar.
            * @param bottomValue The value at the bottom of the scrollbar.
            * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
            */
            public static VerticalScrollbar ($position: UnityEngine.Rect, $value: number, $size: number, $topValue: number, $bottomValue: number) : number
            /** Make a vertical scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.
            * @param position Rectangle on the screen to use for the scrollbar.
            * @param value The position between min and max.
            * @param size How much can we see?
            * @param topValue The value at the top of the scrollbar.
            * @param bottomValue The value at the bottom of the scrollbar.
            * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
            */
            public static VerticalScrollbar ($position: UnityEngine.Rect, $value: number, $size: number, $topValue: number, $bottomValue: number, $style: UnityEngine.GUIStyle) : number
            public static BeginClip ($position: UnityEngine.Rect, $scrollOffset: UnityEngine.Vector2, $renderOffset: UnityEngine.Vector2, $resetOffset: boolean) : void
            /** Begin a group. Must be matched with a call to EndGroup.
            * @param position Rectangle on the screen to use for the group.
            * @param text Text to display on the group.
            * @param image Texture to display on the group.
            * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
            * @param style The style to use for the background.
            */
            public static BeginGroup ($position: UnityEngine.Rect) : void
            /** Begin a group. Must be matched with a call to EndGroup.
            * @param position Rectangle on the screen to use for the group.
            * @param text Text to display on the group.
            * @param image Texture to display on the group.
            * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
            * @param style The style to use for the background.
            */
            public static BeginGroup ($position: UnityEngine.Rect, $text: string) : void
            /** Begin a group. Must be matched with a call to EndGroup.
            * @param position Rectangle on the screen to use for the group.
            * @param text Text to display on the group.
            * @param image Texture to display on the group.
            * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
            * @param style The style to use for the background.
            */
            public static BeginGroup ($position: UnityEngine.Rect, $image: UnityEngine.Texture) : void
            /** Begin a group. Must be matched with a call to EndGroup.
            * @param position Rectangle on the screen to use for the group.
            * @param text Text to display on the group.
            * @param image Texture to display on the group.
            * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
            * @param style The style to use for the background.
            */
            public static BeginGroup ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent) : void
            /** Begin a group. Must be matched with a call to EndGroup.
            * @param position Rectangle on the screen to use for the group.
            * @param text Text to display on the group.
            * @param image Texture to display on the group.
            * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
            * @param style The style to use for the background.
            */
            public static BeginGroup ($position: UnityEngine.Rect, $style: UnityEngine.GUIStyle) : void
            /** Begin a group. Must be matched with a call to EndGroup.
            * @param position Rectangle on the screen to use for the group.
            * @param text Text to display on the group.
            * @param image Texture to display on the group.
            * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
            * @param style The style to use for the background.
            */
            public static BeginGroup ($position: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle) : void
            /** Begin a group. Must be matched with a call to EndGroup.
            * @param position Rectangle on the screen to use for the group.
            * @param text Text to display on the group.
            * @param image Texture to display on the group.
            * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
            * @param style The style to use for the background.
            */
            public static BeginGroup ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle) : void
            /** Begin a group. Must be matched with a call to EndGroup.
            * @param position Rectangle on the screen to use for the group.
            * @param text Text to display on the group.
            * @param image Texture to display on the group.
            * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
            * @param style The style to use for the background.
            */
            public static BeginGroup ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle) : void
            public static EndGroup () : void
            public static BeginClip ($position: UnityEngine.Rect) : void
            public static EndClip () : void
            /** Begin a scrolling view inside your GUI.
            * @param position Rectangle on the screen to use for the ScrollView.
            * @param scrollPosition The pixel distance that the view is scrolled in the X and Y directions.
            * @param viewRect The rectangle used inside the scrollview.
            * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            * @param alwaysShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when viewRect is wider than position.
            * @param alwaysShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when viewRect is taller than position.
            * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
            */
            public static BeginScrollView ($position: UnityEngine.Rect, $scrollPosition: UnityEngine.Vector2, $viewRect: UnityEngine.Rect) : UnityEngine.Vector2
            /** Begin a scrolling view inside your GUI.
            * @param position Rectangle on the screen to use for the ScrollView.
            * @param scrollPosition The pixel distance that the view is scrolled in the X and Y directions.
            * @param viewRect The rectangle used inside the scrollview.
            * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            * @param alwaysShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when viewRect is wider than position.
            * @param alwaysShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when viewRect is taller than position.
            * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
            */
            public static BeginScrollView ($position: UnityEngine.Rect, $scrollPosition: UnityEngine.Vector2, $viewRect: UnityEngine.Rect, $alwaysShowHorizontal: boolean, $alwaysShowVertical: boolean) : UnityEngine.Vector2
            /** Begin a scrolling view inside your GUI.
            * @param position Rectangle on the screen to use for the ScrollView.
            * @param scrollPosition The pixel distance that the view is scrolled in the X and Y directions.
            * @param viewRect The rectangle used inside the scrollview.
            * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            * @param alwaysShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when viewRect is wider than position.
            * @param alwaysShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when viewRect is taller than position.
            * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
            */
            public static BeginScrollView ($position: UnityEngine.Rect, $scrollPosition: UnityEngine.Vector2, $viewRect: UnityEngine.Rect, $horizontalScrollbar: UnityEngine.GUIStyle, $verticalScrollbar: UnityEngine.GUIStyle) : UnityEngine.Vector2
            /** Begin a scrolling view inside your GUI.
            * @param position Rectangle on the screen to use for the ScrollView.
            * @param scrollPosition The pixel distance that the view is scrolled in the X and Y directions.
            * @param viewRect The rectangle used inside the scrollview.
            * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            * @param alwaysShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when viewRect is wider than position.
            * @param alwaysShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when viewRect is taller than position.
            * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
            */
            public static BeginScrollView ($position: UnityEngine.Rect, $scrollPosition: UnityEngine.Vector2, $viewRect: UnityEngine.Rect, $alwaysShowHorizontal: boolean, $alwaysShowVertical: boolean, $horizontalScrollbar: UnityEngine.GUIStyle, $verticalScrollbar: UnityEngine.GUIStyle) : UnityEngine.Vector2
            public static EndScrollView () : void
            /** Ends a scrollview started with a call to BeginScrollView.
            */
            public static EndScrollView ($handleScrollWheel: boolean) : void
            /** Scrolls all enclosing scrollviews so they try to make position visible.
            */
            public static ScrollTo ($position: UnityEngine.Rect) : void
            public static ScrollTowards ($position: UnityEngine.Rect, $maxDelta: number) : boolean
            public static Window ($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $text: string) : UnityEngine.Rect
            public static Window ($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $image: UnityEngine.Texture) : UnityEngine.Rect
            public static Window ($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $content: UnityEngine.GUIContent) : UnityEngine.Rect
            public static Window ($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $text: string, $style: UnityEngine.GUIStyle) : UnityEngine.Rect
            public static Window ($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle) : UnityEngine.Rect
            public static Window ($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $title: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle) : UnityEngine.Rect
            public static ModalWindow ($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $text: string) : UnityEngine.Rect
            public static ModalWindow ($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $image: UnityEngine.Texture) : UnityEngine.Rect
            public static ModalWindow ($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $content: UnityEngine.GUIContent) : UnityEngine.Rect
            public static ModalWindow ($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $text: string, $style: UnityEngine.GUIStyle) : UnityEngine.Rect
            public static ModalWindow ($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle) : UnityEngine.Rect
            public static ModalWindow ($id: number, $clientRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle) : UnityEngine.Rect
            public static DragWindow () : void
            public constructor ()
        }
        /** Defines how GUI looks and behaves.
        */
        class GUISkin extends UnityEngine.ScriptableObject
        {
            protected [__keep_incompatibility]: never;
            /** The default font to use for all styles.
            */
            public get font(): UnityEngine.Font;
            public set font(value: UnityEngine.Font);
            /** Style used by default for GUI.Box controls.
            */
            public get box(): UnityEngine.GUIStyle;
            public set box(value: UnityEngine.GUIStyle);
            /** Style used by default for GUI.Label controls.
            */
            public get label(): UnityEngine.GUIStyle;
            public set label(value: UnityEngine.GUIStyle);
            /** Style used by default for GUI.TextField controls.
            */
            public get textField(): UnityEngine.GUIStyle;
            public set textField(value: UnityEngine.GUIStyle);
            /** Style used by default for GUI.TextArea controls.
            */
            public get textArea(): UnityEngine.GUIStyle;
            public set textArea(value: UnityEngine.GUIStyle);
            /** Style used by default for GUI.Button controls.
            */
            public get button(): UnityEngine.GUIStyle;
            public set button(value: UnityEngine.GUIStyle);
            /** Style used by default for GUI.Toggle controls.
            */
            public get toggle(): UnityEngine.GUIStyle;
            public set toggle(value: UnityEngine.GUIStyle);
            /** Style used by default for Window controls (See Also: GUI.Window).
            */
            public get window(): UnityEngine.GUIStyle;
            public set window(value: UnityEngine.GUIStyle);
            /** Style used by default for the background part of GUI.HorizontalSlider controls.
            */
            public get horizontalSlider(): UnityEngine.GUIStyle;
            public set horizontalSlider(value: UnityEngine.GUIStyle);
            /** Style used by default for the thumb that is dragged in GUI.HorizontalSlider controls.
            */
            public get horizontalSliderThumb(): UnityEngine.GUIStyle;
            public set horizontalSliderThumb(value: UnityEngine.GUIStyle);
            /** Style used by default for the background part of GUI.VerticalSlider controls.
            */
            public get verticalSlider(): UnityEngine.GUIStyle;
            public set verticalSlider(value: UnityEngine.GUIStyle);
            /** Style used by default for the thumb that is dragged in GUI.VerticalSlider controls.
            */
            public get verticalSliderThumb(): UnityEngine.GUIStyle;
            public set verticalSliderThumb(value: UnityEngine.GUIStyle);
            /** Style used by default for the background part of GUI.HorizontalScrollbar controls.
            */
            public get horizontalScrollbar(): UnityEngine.GUIStyle;
            public set horizontalScrollbar(value: UnityEngine.GUIStyle);
            /** Style used by default for the thumb that is dragged in GUI.HorizontalScrollbar controls.
            */
            public get horizontalScrollbarThumb(): UnityEngine.GUIStyle;
            public set horizontalScrollbarThumb(value: UnityEngine.GUIStyle);
            /** Style used by default for the left button on GUI.HorizontalScrollbar controls.
            */
            public get horizontalScrollbarLeftButton(): UnityEngine.GUIStyle;
            public set horizontalScrollbarLeftButton(value: UnityEngine.GUIStyle);
            /** Style used by default for the right button on GUI.HorizontalScrollbar controls.
            */
            public get horizontalScrollbarRightButton(): UnityEngine.GUIStyle;
            public set horizontalScrollbarRightButton(value: UnityEngine.GUIStyle);
            /** Style used by default for the background part of GUI.VerticalScrollbar controls.
            */
            public get verticalScrollbar(): UnityEngine.GUIStyle;
            public set verticalScrollbar(value: UnityEngine.GUIStyle);
            /** Style used by default for the thumb that is dragged in GUI.VerticalScrollbar controls.
            */
            public get verticalScrollbarThumb(): UnityEngine.GUIStyle;
            public set verticalScrollbarThumb(value: UnityEngine.GUIStyle);
            /** Style used by default for the up button on GUI.VerticalScrollbar controls.
            */
            public get verticalScrollbarUpButton(): UnityEngine.GUIStyle;
            public set verticalScrollbarUpButton(value: UnityEngine.GUIStyle);
            /** Style used by default for the down button on GUI.VerticalScrollbar controls.
            */
            public get verticalScrollbarDownButton(): UnityEngine.GUIStyle;
            public set verticalScrollbarDownButton(value: UnityEngine.GUIStyle);
            /** Style used by default for the background of ScrollView controls (see GUI.BeginScrollView).
            */
            public get scrollView(): UnityEngine.GUIStyle;
            public set scrollView(value: UnityEngine.GUIStyle);
            /** Array of GUI styles for specific needs.
            */
            public get customStyles(): System.Array$1<UnityEngine.GUIStyle>;
            public set customStyles(value: System.Array$1<UnityEngine.GUIStyle>);
            /** Generic settings for how controls should behave with this skin.
            */
            public get settings(): UnityEngine.GUISettings;
            /** Get a named GUIStyle.
            */
            public GetStyle ($styleName: string) : UnityEngine.GUIStyle
            /** Try to search for a GUIStyle. This functions returns NULL and does not give an error.
            */
            public FindStyle ($styleName: string) : UnityEngine.GUIStyle
            public GetEnumerator () : System.Collections.IEnumerator
            public constructor ()
        }
        /** The contents of a GUI element.
        */
        class GUIContent extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Shorthand for empty content.
            */
            public static none : UnityEngine.GUIContent
            /** The text contained.
            */
            public get text(): string;
            public set text(value: string);
            /** The icon image contained.
            */
            public get image(): UnityEngine.Texture;
            public set image(value: UnityEngine.Texture);
            /** The tooltip of this element.
            */
            public get tooltip(): string;
            public set tooltip(value: string);
            public constructor ()
            public constructor ($text: string)
            public constructor ($image: UnityEngine.Texture)
            public constructor ($text: string, $image: UnityEngine.Texture)
            public constructor ($text: string, $tooltip: string)
            public constructor ($image: UnityEngine.Texture, $tooltip: string)
            public constructor ($text: string, $image: UnityEngine.Texture, $tooltip: string)
            public constructor ($src: UnityEngine.GUIContent)
        }
        /** Styling information for GUI elements.
        */
        class GUIStyle extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The font to use for rendering. If null, the default font for the current GUISkin is used instead.
            */
            public get font(): UnityEngine.Font;
            public set font(value: UnityEngine.Font);
            /** How image and text of the GUIContent is combined.
            */
            public get imagePosition(): UnityEngine.ImagePosition;
            public set imagePosition(value: UnityEngine.ImagePosition);
            /** Text alignment.
            */
            public get alignment(): UnityEngine.TextAnchor;
            public set alignment(value: UnityEngine.TextAnchor);
            /** Should the text be wordwrapped?
            */
            public get wordWrap(): boolean;
            public set wordWrap(value: boolean);
            /** What to do when the contents to be rendered is too large to fit within the area given.
            */
            public get clipping(): UnityEngine.TextClipping;
            public set clipping(value: UnityEngine.TextClipping);
            /** Pixel offset to apply to the content of this GUIstyle.
            */
            public get contentOffset(): UnityEngine.Vector2;
            public set contentOffset(value: UnityEngine.Vector2);
            /** If non-0, any GUI elements rendered with this style will have the width specified here.
            */
            public get fixedWidth(): number;
            public set fixedWidth(value: number);
            /** If non-0, any GUI elements rendered with this style will have the height specified here.
            */
            public get fixedHeight(): number;
            public set fixedHeight(value: number);
            /** Can GUI elements of this style be stretched horizontally for better layouting?
            */
            public get stretchWidth(): boolean;
            public set stretchWidth(value: boolean);
            /** Can GUI elements of this style be stretched vertically for better layout?
            */
            public get stretchHeight(): boolean;
            public set stretchHeight(value: boolean);
            /** The font size to use (for dynamic fonts).
            */
            public get fontSize(): number;
            public set fontSize(value: number);
            /** The font style to use (for dynamic fonts).
            */
            public get fontStyle(): UnityEngine.FontStyle;
            public set fontStyle(value: UnityEngine.FontStyle);
            /** Enable HTML-style tags for Text Formatting Markup.
            */
            public get richText(): boolean;
            public set richText(value: boolean);
            /** The name of this GUIStyle. Used for getting them based on name.
            */
            public get name(): string;
            public set name(value: string);
            /** Rendering settings for when the component is displayed normally.
            */
            public get normal(): UnityEngine.GUIStyleState;
            public set normal(value: UnityEngine.GUIStyleState);
            /** Rendering settings for when the mouse is hovering over the control.
            */
            public get hover(): UnityEngine.GUIStyleState;
            public set hover(value: UnityEngine.GUIStyleState);
            /** Rendering settings for when the control is pressed down.
            */
            public get active(): UnityEngine.GUIStyleState;
            public set active(value: UnityEngine.GUIStyleState);
            /** Rendering settings for when the control is turned on.
            */
            public get onNormal(): UnityEngine.GUIStyleState;
            public set onNormal(value: UnityEngine.GUIStyleState);
            /** Rendering settings for when the control is turned on and the mouse is hovering it.
            */
            public get onHover(): UnityEngine.GUIStyleState;
            public set onHover(value: UnityEngine.GUIStyleState);
            /** Rendering settings for when the element is turned on and pressed down.
            */
            public get onActive(): UnityEngine.GUIStyleState;
            public set onActive(value: UnityEngine.GUIStyleState);
            /** Rendering settings for when the element has keyboard focus.
            */
            public get focused(): UnityEngine.GUIStyleState;
            public set focused(value: UnityEngine.GUIStyleState);
            /** Rendering settings for when the element has keyboard and is turned on.
            */
            public get onFocused(): UnityEngine.GUIStyleState;
            public set onFocused(value: UnityEngine.GUIStyleState);
            /** The borders of all background images.
            */
            public get border(): UnityEngine.RectOffset;
            public set border(value: UnityEngine.RectOffset);
            /** The margins between elements rendered in this style and any other GUI elements.
            */
            public get margin(): UnityEngine.RectOffset;
            public set margin(value: UnityEngine.RectOffset);
            /** Space from the edge of GUIStyle to the start of the contents.
            */
            public get padding(): UnityEngine.RectOffset;
            public set padding(value: UnityEngine.RectOffset);
            /** Extra space to be added to the background image.
            */
            public get overflow(): UnityEngine.RectOffset;
            public set overflow(value: UnityEngine.RectOffset);
            /** The height of one line of text with this style, measured in pixels. (Read Only)
            */
            public get lineHeight(): number;
            /** Shortcut for an empty GUIStyle.
            */
            public static get none(): UnityEngine.GUIStyle;
            public get isHeightDependantOnWidth(): boolean;
            /** Draw this GUIStyle on to the screen, internal version.
            */
            public Draw ($position: UnityEngine.Rect, $isHover: boolean, $isActive: boolean, $on: boolean, $hasKeyboardFocus: boolean) : void
            /** Draw the GUIStyle with a text string inside.
            */
            public Draw ($position: UnityEngine.Rect, $text: string, $isHover: boolean, $isActive: boolean, $on: boolean, $hasKeyboardFocus: boolean) : void
            /** Draw the GUIStyle with an image inside. If the image is too large to fit within the content area of the style it is scaled down.
            */
            public Draw ($position: UnityEngine.Rect, $image: UnityEngine.Texture, $isHover: boolean, $isActive: boolean, $on: boolean, $hasKeyboardFocus: boolean) : void
            /** Draw the GUIStyle with text and an image inside. If the image is too large to fit within the content area of the style it is scaled down.
            */
            public Draw ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $isHover: boolean, $isActive: boolean, $on: boolean, $hasKeyboardFocus: boolean) : void
            /** Draw the GUIStyle with text and an image inside. If the image is too large to fit within the content area of the style it is scaled down.
            */
            public Draw ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $controlID: number) : void
            /** Draw the GUIStyle with text and an image inside. If the image is too large to fit within the content area of the style it is scaled down.
            */
            public Draw ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $controlID: number, $on: boolean) : void
            public Draw ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $controlID: number, $on: boolean, $hover: boolean) : void
            /** Draw this GUIStyle with selected content.
            */
            public DrawCursor ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $controlID: number, $character: number) : void
            /** Draw this GUIStyle with selected content.
            */
            public DrawWithTextSelection ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $controlID: number, $firstSelectedCharacter: number, $lastSelectedCharacter: number) : void
            public static op_Implicit ($str: string) : UnityEngine.GUIStyle
            /** Get the pixel position of a given string index.
            */
            public GetCursorPixelPosition ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $cursorStringIndex: number) : UnityEngine.Vector2
            /** Get the cursor position (indexing into contents.text) when the user clicked at cursorPixelPosition.
            */
            public GetCursorStringIndex ($position: UnityEngine.Rect, $content: UnityEngine.GUIContent, $cursorPixelPosition: UnityEngine.Vector2) : number
            /** Calculate the size of some content if it is rendered with this style.
            */
            public CalcSize ($content: UnityEngine.GUIContent) : UnityEngine.Vector2
            /** Calculate the size of an element formatted with this style, and a given space to content.
            */
            public CalcScreenSize ($contentSize: UnityEngine.Vector2) : UnityEngine.Vector2
            /** How tall this element will be when rendered with content and a specific width.
            */
            public CalcHeight ($content: UnityEngine.GUIContent, $width: number) : number
            /** Calculate the minimum and maximum widths for this style rendered with content.
            */
            public CalcMinMaxWidth ($content: UnityEngine.GUIContent, $minWidth: $Ref<number>, $maxWidth: $Ref<number>) : void
            public constructor ()
            public constructor ($other: UnityEngine.GUIStyle)
        }
        /** Scaling mode to draw textures with.
        */
        enum ScaleMode
        { StretchToFill = 0, ScaleAndCrop = 1, ScaleToFit = 2 }
        /** Used by GUIUtility.GetControlID to inform the IMGUI system if a given control can get keyboard focus. This allows the IMGUI system to give focus appropriately when a user presses tab for cycling between controls.
        */
        enum FocusType
        { Native = 0, Keyboard = 1, Passive = 2 }
        /** The GUILayout class is the interface for Unity gui with automatic layout.
        */
        class GUILayout extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Make an auto-layout label.
            * @param text Text to display on the label.
            * @param image Texture to display on the label.
            * @param content Text, image and tooltip for this label.
            * @param style The style to use. If left out, the label style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static Label ($image: UnityEngine.Texture, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Make an auto-layout label.
            * @param text Text to display on the label.
            * @param image Texture to display on the label.
            * @param content Text, image and tooltip for this label.
            * @param style The style to use. If left out, the label style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static Label ($text: string, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Make an auto-layout label.
            * @param text Text to display on the label.
            * @param image Texture to display on the label.
            * @param content Text, image and tooltip for this label.
            * @param style The style to use. If left out, the label style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static Label ($content: UnityEngine.GUIContent, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Make an auto-layout label.
            * @param text Text to display on the label.
            * @param image Texture to display on the label.
            * @param content Text, image and tooltip for this label.
            * @param style The style to use. If left out, the label style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static Label ($image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Make an auto-layout label.
            * @param text Text to display on the label.
            * @param image Texture to display on the label.
            * @param content Text, image and tooltip for this label.
            * @param style The style to use. If left out, the label style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static Label ($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Make an auto-layout label.
            * @param text Text to display on the label.
            * @param image Texture to display on the label.
            * @param content Text, image and tooltip for this label.
            * @param style The style to use. If left out, the label style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static Label ($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Make an auto-layout box.
            * @param text Text to display on the box.
            * @param image Texture to display on the box.
            * @param content Text, image and tooltip for this box.
            * @param style The style to use. If left out, the box style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static Box ($image: UnityEngine.Texture, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Make an auto-layout box.
            * @param text Text to display on the box.
            * @param image Texture to display on the box.
            * @param content Text, image and tooltip for this box.
            * @param style The style to use. If left out, the box style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static Box ($text: string, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Make an auto-layout box.
            * @param text Text to display on the box.
            * @param image Texture to display on the box.
            * @param content Text, image and tooltip for this box.
            * @param style The style to use. If left out, the box style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static Box ($content: UnityEngine.GUIContent, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Make an auto-layout box.
            * @param text Text to display on the box.
            * @param image Texture to display on the box.
            * @param content Text, image and tooltip for this box.
            * @param style The style to use. If left out, the box style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static Box ($image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Make an auto-layout box.
            * @param text Text to display on the box.
            * @param image Texture to display on the box.
            * @param content Text, image and tooltip for this box.
            * @param style The style to use. If left out, the box style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static Box ($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Make an auto-layout box.
            * @param text Text to display on the box.
            * @param image Texture to display on the box.
            * @param content Text, image and tooltip for this box.
            * @param style The style to use. If left out, the box style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static Box ($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Make a single press button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns true when the users clicks the button. 
            */
            public static Button ($image: UnityEngine.Texture, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a single press button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns true when the users clicks the button. 
            */
            public static Button ($text: string, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a single press button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns true when the users clicks the button. 
            */
            public static Button ($content: UnityEngine.GUIContent, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a single press button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns true when the users clicks the button. 
            */
            public static Button ($image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a single press button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns true when the users clicks the button. 
            */
            public static Button ($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a single press button.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns true when the users clicks the button. 
            */
            public static Button ($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a repeating button. The button returns true as long as the user holds down the mouse.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns true when the holds down the mouse. 
            */
            public static RepeatButton ($image: UnityEngine.Texture, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a repeating button. The button returns true as long as the user holds down the mouse.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns true when the holds down the mouse. 
            */
            public static RepeatButton ($text: string, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a repeating button. The button returns true as long as the user holds down the mouse.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns true when the holds down the mouse. 
            */
            public static RepeatButton ($content: UnityEngine.GUIContent, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a repeating button. The button returns true as long as the user holds down the mouse.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns true when the holds down the mouse. 
            */
            public static RepeatButton ($image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a repeating button. The button returns true as long as the user holds down the mouse.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns true when the holds down the mouse. 
            */
            public static RepeatButton ($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a repeating button. The button returns true as long as the user holds down the mouse.
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns true when the holds down the mouse. 
            */
            public static RepeatButton ($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a single-line text field where the user can edit a string.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The edited string. 
            */
            public static TextField ($text: string, ...options: UnityEngine.GUILayoutOption[]) : string
            /** Make a single-line text field where the user can edit a string.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The edited string. 
            */
            public static TextField ($text: string, $maxLength: number, ...options: UnityEngine.GUILayoutOption[]) : string
            /** Make a single-line text field where the user can edit a string.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The edited string. 
            */
            public static TextField ($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : string
            /** Make a single-line text field where the user can edit a string.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The edited string. 
            */
            public static TextField ($text: string, $maxLength: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : string
            /** Make a text field where the user can enter a password.
            * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maskChar Character to mask the password with.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @returns The edited password. 
            */
            public static PasswordField ($password: string, $maskChar: number, ...options: UnityEngine.GUILayoutOption[]) : string
            /** Make a text field where the user can enter a password.
            * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maskChar Character to mask the password with.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @returns The edited password. 
            */
            public static PasswordField ($password: string, $maskChar: number, $maxLength: number, ...options: UnityEngine.GUILayoutOption[]) : string
            /** Make a text field where the user can enter a password.
            * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maskChar Character to mask the password with.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @returns The edited password. 
            */
            public static PasswordField ($password: string, $maskChar: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : string
            /** Make a text field where the user can enter a password.
            * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maskChar Character to mask the password with.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @returns The edited password. 
            */
            public static PasswordField ($password: string, $maskChar: number, $maxLength: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : string
            /** Make a multi-line text field where the user can edit a string.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.&amp;lt;br&amp;gt;
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The edited string. 
            */
            public static TextArea ($text: string, ...options: UnityEngine.GUILayoutOption[]) : string
            /** Make a multi-line text field where the user can edit a string.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.&amp;lt;br&amp;gt;
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The edited string. 
            */
            public static TextArea ($text: string, $maxLength: number, ...options: UnityEngine.GUILayoutOption[]) : string
            /** Make a multi-line text field where the user can edit a string.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.&amp;lt;br&amp;gt;
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The edited string. 
            */
            public static TextArea ($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : string
            /** Make a multi-line text field where the user can edit a string.
            * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
            * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
            * @param style The style to use. If left out, the textField style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.&amp;lt;br&amp;gt;
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The edited string. 
            */
            public static TextArea ($text: string, $maxLength: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : string
            /** Make an on/off toggle button.
            * @param value Is the button on or off?
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The new value of the button. 
            */
            public static Toggle ($value: boolean, $image: UnityEngine.Texture, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make an on/off toggle button.
            * @param value Is the button on or off?
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The new value of the button. 
            */
            public static Toggle ($value: boolean, $text: string, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make an on/off toggle button.
            * @param value Is the button on or off?
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The new value of the button. 
            */
            public static Toggle ($value: boolean, $content: UnityEngine.GUIContent, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make an on/off toggle button.
            * @param value Is the button on or off?
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The new value of the button. 
            */
            public static Toggle ($value: boolean, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make an on/off toggle button.
            * @param value Is the button on or off?
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The new value of the button. 
            */
            public static Toggle ($value: boolean, $text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make an on/off toggle button.
            * @param value Is the button on or off?
            * @param text Text to display on the button.
            * @param image Texture to display on the button.
            * @param content Text, image and tooltip for this button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The new value of the button. 
            */
            public static Toggle ($value: boolean, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : boolean
            /** Make a toolbar.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the buttons.
            * @param images An array of textures on the buttons.
            * @param contents An array of text, image and tooltips for the button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @param buttonSize Determines how toolbar button size is calculated.
            * @returns The index of the selected button. 
            */
            public static Toolbar ($selected: number, $texts: System.Array$1<string>, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a toolbar.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the buttons.
            * @param images An array of textures on the buttons.
            * @param contents An array of text, image and tooltips for the button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @param buttonSize Determines how toolbar button size is calculated.
            * @returns The index of the selected button. 
            */
            public static Toolbar ($selected: number, $images: System.Array$1<UnityEngine.Texture>, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a toolbar.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the buttons.
            * @param images An array of textures on the buttons.
            * @param contents An array of text, image and tooltips for the button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @param buttonSize Determines how toolbar button size is calculated.
            * @returns The index of the selected button. 
            */
            public static Toolbar ($selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a toolbar.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the buttons.
            * @param images An array of textures on the buttons.
            * @param contents An array of text, image and tooltips for the button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @param buttonSize Determines how toolbar button size is calculated.
            * @returns The index of the selected button. 
            */
            public static Toolbar ($selected: number, $texts: System.Array$1<string>, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a toolbar.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the buttons.
            * @param images An array of textures on the buttons.
            * @param contents An array of text, image and tooltips for the button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @param buttonSize Determines how toolbar button size is calculated.
            * @returns The index of the selected button. 
            */
            public static Toolbar ($selected: number, $images: System.Array$1<UnityEngine.Texture>, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : number
            public static Toolbar ($selected: number, $texts: System.Array$1<string>, $style: UnityEngine.GUIStyle, $buttonSize: UnityEngine.GUI.ToolbarButtonSize, ...options: UnityEngine.GUILayoutOption[]) : number
            public static Toolbar ($selected: number, $images: System.Array$1<UnityEngine.Texture>, $style: UnityEngine.GUIStyle, $buttonSize: UnityEngine.GUI.ToolbarButtonSize, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a toolbar.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the buttons.
            * @param images An array of textures on the buttons.
            * @param contents An array of text, image and tooltips for the button.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @param buttonSize Determines how toolbar button size is calculated.
            * @returns The index of the selected button. 
            */
            public static Toolbar ($selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : number
            public static Toolbar ($selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $style: UnityEngine.GUIStyle, $buttonSize: UnityEngine.GUI.ToolbarButtonSize, ...options: UnityEngine.GUILayoutOption[]) : number
            public static Toolbar ($selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $enabled: System.Array$1<boolean>, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : number
            public static Toolbar ($selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $enabled: System.Array$1<boolean>, $style: UnityEngine.GUIStyle, $buttonSize: UnityEngine.GUI.ToolbarButtonSize, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a Selection Grid.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the buttons.
            * @param images An array of textures on the buttons.
            * @param contents An array of text, image and tooltips for the button.
            * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The index of the selected button. 
            */
            public static SelectionGrid ($selected: number, $texts: System.Array$1<string>, $xCount: number, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a Selection Grid.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the buttons.
            * @param images An array of textures on the buttons.
            * @param contents An array of text, image and tooltips for the button.
            * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The index of the selected button. 
            */
            public static SelectionGrid ($selected: number, $images: System.Array$1<UnityEngine.Texture>, $xCount: number, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a Selection Grid.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the buttons.
            * @param images An array of textures on the buttons.
            * @param contents An array of text, image and tooltips for the button.
            * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The index of the selected button. 
            */
            public static SelectionGrid ($selected: number, $content: System.Array$1<UnityEngine.GUIContent>, $xCount: number, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a Selection Grid.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the buttons.
            * @param images An array of textures on the buttons.
            * @param contents An array of text, image and tooltips for the button.
            * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The index of the selected button. 
            */
            public static SelectionGrid ($selected: number, $texts: System.Array$1<string>, $xCount: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a Selection Grid.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the buttons.
            * @param images An array of textures on the buttons.
            * @param contents An array of text, image and tooltips for the button.
            * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The index of the selected button. 
            */
            public static SelectionGrid ($selected: number, $images: System.Array$1<UnityEngine.Texture>, $xCount: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a Selection Grid.
            * @param selected The index of the selected button.
            * @param texts An array of strings to show on the buttons.
            * @param images An array of textures on the buttons.
            * @param contents An array of text, image and tooltips for the button.
            * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
            * @param style The style to use. If left out, the button style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The index of the selected button. 
            */
            public static SelectionGrid ($selected: number, $contents: System.Array$1<UnityEngine.GUIContent>, $xCount: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : number
            /** A horizontal slider the user can drag to change a value between a min and a max.
            * @param value The value the slider shows. This determines the position of the draggable thumb.
            * @param leftValue The value at the left end of the slider.
            * @param rightValue The value at the right end of the slider.
            * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
            * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
            * @returns The value that has been set by the user. 
            */
            public static HorizontalSlider ($value: number, $leftValue: number, $rightValue: number, ...options: UnityEngine.GUILayoutOption[]) : number
            /** A horizontal slider the user can drag to change a value between a min and a max.
            * @param value The value the slider shows. This determines the position of the draggable thumb.
            * @param leftValue The value at the left end of the slider.
            * @param rightValue The value at the right end of the slider.
            * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
            * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
            * @returns The value that has been set by the user. 
            */
            public static HorizontalSlider ($value: number, $leftValue: number, $rightValue: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : number
            /** A vertical slider the user can drag to change a value between a min and a max.
            * @param value The value the slider shows. This determines the position of the draggable thumb.
            * @param topValue The value at the top end of the slider.
            * @param bottomValue The value at the bottom end of the slider.
            * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
            * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
            * @returns The value that has been set by the user. 
            */
            public static VerticalSlider ($value: number, $leftValue: number, $rightValue: number, ...options: UnityEngine.GUILayoutOption[]) : number
            /** A vertical slider the user can drag to change a value between a min and a max.
            * @param value The value the slider shows. This determines the position of the draggable thumb.
            * @param topValue The value at the top end of the slider.
            * @param bottomValue The value at the bottom end of the slider.
            * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
            * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
            * @returns The value that has been set by the user. 
            */
            public static VerticalSlider ($value: number, $leftValue: number, $rightValue: number, $slider: UnityEngine.GUIStyle, $thumb: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a horizontal scrollbar.
            * @param value The position between min and max.
            * @param size How much can we see?
            * @param leftValue The value at the left end of the scrollbar.
            * @param rightValue The value at the right end of the scrollbar.
            * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
            * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
            */
            public static HorizontalScrollbar ($value: number, $size: number, $leftValue: number, $rightValue: number, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a horizontal scrollbar.
            * @param value The position between min and max.
            * @param size How much can we see?
            * @param leftValue The value at the left end of the scrollbar.
            * @param rightValue The value at the right end of the scrollbar.
            * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
            * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
            */
            public static HorizontalScrollbar ($value: number, $size: number, $leftValue: number, $rightValue: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a vertical scrollbar.
            * @param value The position between min and max.
            * @param size How much can we see?
            * @param topValue The value at the top end of the scrollbar.
            * @param bottomValue The value at the bottom end of the scrollbar.
            * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
            * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
            */
            public static VerticalScrollbar ($value: number, $size: number, $topValue: number, $bottomValue: number, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Make a vertical scrollbar.
            * @param value The position between min and max.
            * @param size How much can we see?
            * @param topValue The value at the top end of the scrollbar.
            * @param bottomValue The value at the bottom end of the scrollbar.
            * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
            * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
            */
            public static VerticalScrollbar ($value: number, $size: number, $topValue: number, $bottomValue: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : number
            /** Insert a space in the current layout group.
            */
            public static Space ($pixels: number) : void
            public static FlexibleSpace () : void
            /** Begin a Horizontal control group.
            * @param text Text to display on group.
            * @param image Texture to display on group.
            * @param content Text, image, and tooltip for this group.
            * @param style The style to use for background image and padding values. If left out, the background is transparent.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static BeginHorizontal (...options: UnityEngine.GUILayoutOption[]) : void
            /** Begin a Horizontal control group.
            * @param text Text to display on group.
            * @param image Texture to display on group.
            * @param content Text, image, and tooltip for this group.
            * @param style The style to use for background image and padding values. If left out, the background is transparent.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static BeginHorizontal ($style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Begin a Horizontal control group.
            * @param text Text to display on group.
            * @param image Texture to display on group.
            * @param content Text, image, and tooltip for this group.
            * @param style The style to use for background image and padding values. If left out, the background is transparent.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static BeginHorizontal ($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Begin a Horizontal control group.
            * @param text Text to display on group.
            * @param image Texture to display on group.
            * @param content Text, image, and tooltip for this group.
            * @param style The style to use for background image and padding values. If left out, the background is transparent.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static BeginHorizontal ($image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Begin a Horizontal control group.
            * @param text Text to display on group.
            * @param image Texture to display on group.
            * @param content Text, image, and tooltip for this group.
            * @param style The style to use for background image and padding values. If left out, the background is transparent.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static BeginHorizontal ($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            public static EndHorizontal () : void
            /** Begin a vertical control group.
            * @param text Text to display on group.
            * @param image Texture to display on group.
            * @param content Text, image, and tooltip for this group.
            * @param style The style to use for background image and padding values. If left out, the background is transparent.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static BeginVertical (...options: UnityEngine.GUILayoutOption[]) : void
            /** Begin a vertical control group.
            * @param text Text to display on group.
            * @param image Texture to display on group.
            * @param content Text, image, and tooltip for this group.
            * @param style The style to use for background image and padding values. If left out, the background is transparent.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static BeginVertical ($style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Begin a vertical control group.
            * @param text Text to display on group.
            * @param image Texture to display on group.
            * @param content Text, image, and tooltip for this group.
            * @param style The style to use for background image and padding values. If left out, the background is transparent.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static BeginVertical ($text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Begin a vertical control group.
            * @param text Text to display on group.
            * @param image Texture to display on group.
            * @param content Text, image, and tooltip for this group.
            * @param style The style to use for background image and padding values. If left out, the background is transparent.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static BeginVertical ($image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            /** Begin a vertical control group.
            * @param text Text to display on group.
            * @param image Texture to display on group.
            * @param content Text, image, and tooltip for this group.
            * @param style The style to use for background image and padding values. If left out, the background is transparent.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            */
            public static BeginVertical ($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : void
            public static EndVertical () : void
            /** Begin a GUILayout block of GUI controls in a fixed screen area.
            * @param text Optional text to display in the area.
            * @param image Optional texture to display in the area.
            * @param content Optional text, image and tooltip top display for this area.
            * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
            */
            public static BeginArea ($screenRect: UnityEngine.Rect) : void
            /** Begin a GUILayout block of GUI controls in a fixed screen area.
            * @param text Optional text to display in the area.
            * @param image Optional texture to display in the area.
            * @param content Optional text, image and tooltip top display for this area.
            * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
            */
            public static BeginArea ($screenRect: UnityEngine.Rect, $text: string) : void
            /** Begin a GUILayout block of GUI controls in a fixed screen area.
            * @param text Optional text to display in the area.
            * @param image Optional texture to display in the area.
            * @param content Optional text, image and tooltip top display for this area.
            * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
            */
            public static BeginArea ($screenRect: UnityEngine.Rect, $image: UnityEngine.Texture) : void
            /** Begin a GUILayout block of GUI controls in a fixed screen area.
            * @param text Optional text to display in the area.
            * @param image Optional texture to display in the area.
            * @param content Optional text, image and tooltip top display for this area.
            * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
            */
            public static BeginArea ($screenRect: UnityEngine.Rect, $content: UnityEngine.GUIContent) : void
            /** Begin a GUILayout block of GUI controls in a fixed screen area.
            * @param text Optional text to display in the area.
            * @param image Optional texture to display in the area.
            * @param content Optional text, image and tooltip top display for this area.
            * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
            */
            public static BeginArea ($screenRect: UnityEngine.Rect, $style: UnityEngine.GUIStyle) : void
            /** Begin a GUILayout block of GUI controls in a fixed screen area.
            * @param text Optional text to display in the area.
            * @param image Optional texture to display in the area.
            * @param content Optional text, image and tooltip top display for this area.
            * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
            */
            public static BeginArea ($screenRect: UnityEngine.Rect, $text: string, $style: UnityEngine.GUIStyle) : void
            /** Begin a GUILayout block of GUI controls in a fixed screen area.
            * @param text Optional text to display in the area.
            * @param image Optional texture to display in the area.
            * @param content Optional text, image and tooltip top display for this area.
            * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
            */
            public static BeginArea ($screenRect: UnityEngine.Rect, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle) : void
            /** Begin a GUILayout block of GUI controls in a fixed screen area.
            * @param text Optional text to display in the area.
            * @param image Optional texture to display in the area.
            * @param content Optional text, image and tooltip top display for this area.
            * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
            */
            public static BeginArea ($screenRect: UnityEngine.Rect, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle) : void
            public static EndArea () : void
            /** Begin an automatically laid out scrollview.
            * @param scrollPosition The position to use display.
            * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
            * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
            * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
            */
            public static BeginScrollView ($scrollPosition: UnityEngine.Vector2, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Vector2
            /** Begin an automatically laid out scrollview.
            * @param scrollPosition The position to use display.
            * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
            * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
            * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
            */
            public static BeginScrollView ($scrollPosition: UnityEngine.Vector2, $alwaysShowHorizontal: boolean, $alwaysShowVertical: boolean, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Vector2
            /** Begin an automatically laid out scrollview.
            * @param scrollPosition The position to use display.
            * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
            * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
            * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
            */
            public static BeginScrollView ($scrollPosition: UnityEngine.Vector2, $horizontalScrollbar: UnityEngine.GUIStyle, $verticalScrollbar: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Vector2
            /** Begin an automatically laid out scrollview.
            * @param scrollPosition The position to use display.
            * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
            * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
            * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
            */
            public static BeginScrollView ($scrollPosition: UnityEngine.Vector2, $style: UnityEngine.GUIStyle) : UnityEngine.Vector2
            /** Begin an automatically laid out scrollview.
            * @param scrollPosition The position to use display.
            * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
            * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
            * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
            */
            public static BeginScrollView ($scrollPosition: UnityEngine.Vector2, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Vector2
            /** Begin an automatically laid out scrollview.
            * @param scrollPosition The position to use display.
            * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
            * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
            * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
            */
            public static BeginScrollView ($scrollPosition: UnityEngine.Vector2, $alwaysShowHorizontal: boolean, $alwaysShowVertical: boolean, $horizontalScrollbar: UnityEngine.GUIStyle, $verticalScrollbar: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Vector2
            /** Begin an automatically laid out scrollview.
            * @param scrollPosition The position to use display.
            * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
            * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
            * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
            * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
            * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
            */
            public static BeginScrollView ($scrollPosition: UnityEngine.Vector2, $alwaysShowHorizontal: boolean, $alwaysShowVertical: boolean, $horizontalScrollbar: UnityEngine.GUIStyle, $verticalScrollbar: UnityEngine.GUIStyle, $background: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Vector2
            public static EndScrollView () : void
            public static Window ($id: number, $screenRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $text: string, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            public static Window ($id: number, $screenRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $image: UnityEngine.Texture, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            public static Window ($id: number, $screenRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $content: UnityEngine.GUIContent, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            public static Window ($id: number, $screenRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $text: string, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            public static Window ($id: number, $screenRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $image: UnityEngine.Texture, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            public static Window ($id: number, $screenRect: UnityEngine.Rect, $func: UnityEngine.GUI.WindowFunction, $content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            /** Option passed to a control to give it an absolute width.
            */
            public static Width ($width: number) : UnityEngine.GUILayoutOption
            /** Option passed to a control to specify a minimum width.
            */
            public static MinWidth ($minWidth: number) : UnityEngine.GUILayoutOption
            /** Option passed to a control to specify a maximum width.
            */
            public static MaxWidth ($maxWidth: number) : UnityEngine.GUILayoutOption
            /** Option passed to a control to give it an absolute height.
            */
            public static Height ($height: number) : UnityEngine.GUILayoutOption
            /** Option passed to a control to specify a minimum height.
            */
            public static MinHeight ($minHeight: number) : UnityEngine.GUILayoutOption
            /** Option passed to a control to specify a maximum height.
            */
            public static MaxHeight ($maxHeight: number) : UnityEngine.GUILayoutOption
            /** Option passed to a control to allow or disallow horizontal expansion.
            */
            public static ExpandWidth ($expand: boolean) : UnityEngine.GUILayoutOption
            /** Option passed to a control to allow or disallow vertical expansion.
            */
            public static ExpandHeight ($expand: boolean) : UnityEngine.GUILayoutOption
            public constructor ()
        }
        /** Class internally used to pass layout options into GUILayout functions. You don't use these directly, but construct them with the layouting functions in the GUILayout class.
        */
        class GUILayoutOption extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** Utility functions for implementing and extending the GUILayout class.
        */
        class GUILayoutUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Reserve layout space for a rectangle for displaying some contents with a specific style.
            * @param content The content to make room for displaying.
            * @param style The GUIStyle to layout for.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns A rectangle that is large enough to contain content when rendered in style. 
            */
            public static GetRect ($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle) : UnityEngine.Rect
            /** Reserve layout space for a rectangle for displaying some contents with a specific style.
            * @param content The content to make room for displaying.
            * @param style The GUIStyle to layout for.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns A rectangle that is large enough to contain content when rendered in style. 
            */
            public static GetRect ($content: UnityEngine.GUIContent, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            /** Reserve layout space for a rectangle with a fixed content area.
            * @param width The width of the area you want.
            * @param height The height of the area you want.
            * @param style An optional GUIStyle to layout for. If specified, the style's padding value will be added to your sizes & its margin value will be used for spacing.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The rectangle to put your control in. 
            */
            public static GetRect ($width: number, $height: number) : UnityEngine.Rect
            /** Reserve layout space for a rectangle with a fixed content area.
            * @param width The width of the area you want.
            * @param height The height of the area you want.
            * @param style An optional GUIStyle to layout for. If specified, the style's padding value will be added to your sizes & its margin value will be used for spacing.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The rectangle to put your control in. 
            */
            public static GetRect ($width: number, $height: number, $style: UnityEngine.GUIStyle) : UnityEngine.Rect
            /** Reserve layout space for a rectangle with a fixed content area.
            * @param width The width of the area you want.
            * @param height The height of the area you want.
            * @param style An optional GUIStyle to layout for. If specified, the style's padding value will be added to your sizes & its margin value will be used for spacing.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The rectangle to put your control in. 
            */
            public static GetRect ($width: number, $height: number, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            /** Reserve layout space for a rectangle with a fixed content area.
            * @param width The width of the area you want.
            * @param height The height of the area you want.
            * @param style An optional GUIStyle to layout for. If specified, the style's padding value will be added to your sizes & its margin value will be used for spacing.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The rectangle to put your control in. 
            */
            public static GetRect ($width: number, $height: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            /** Reserve layout space for a flexible rect.
            * @param minWidth The minimum width of the area passed back.
            * @param maxWidth The maximum width of the area passed back.
            * @param minHeight The minimum width of the area passed back.
            * @param maxHeight The maximum width of the area passed back.
            * @param style An optional style. If specified, the style's padding value will be added to the sizes requested & the style's margin values will be used for spacing.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns A rectangle with size between minWidth & maxWidth on both axes. 
            */
            public static GetRect ($minWidth: number, $maxWidth: number, $minHeight: number, $maxHeight: number) : UnityEngine.Rect
            /** Reserve layout space for a flexible rect.
            * @param minWidth The minimum width of the area passed back.
            * @param maxWidth The maximum width of the area passed back.
            * @param minHeight The minimum width of the area passed back.
            * @param maxHeight The maximum width of the area passed back.
            * @param style An optional style. If specified, the style's padding value will be added to the sizes requested & the style's margin values will be used for spacing.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns A rectangle with size between minWidth & maxWidth on both axes. 
            */
            public static GetRect ($minWidth: number, $maxWidth: number, $minHeight: number, $maxHeight: number, $style: UnityEngine.GUIStyle) : UnityEngine.Rect
            /** Reserve layout space for a flexible rect.
            * @param minWidth The minimum width of the area passed back.
            * @param maxWidth The maximum width of the area passed back.
            * @param minHeight The minimum width of the area passed back.
            * @param maxHeight The maximum width of the area passed back.
            * @param style An optional style. If specified, the style's padding value will be added to the sizes requested & the style's margin values will be used for spacing.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns A rectangle with size between minWidth & maxWidth on both axes. 
            */
            public static GetRect ($minWidth: number, $maxWidth: number, $minHeight: number, $maxHeight: number, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            /** Reserve layout space for a flexible rect.
            * @param minWidth The minimum width of the area passed back.
            * @param maxWidth The maximum width of the area passed back.
            * @param minHeight The minimum width of the area passed back.
            * @param maxHeight The maximum width of the area passed back.
            * @param style An optional style. If specified, the style's padding value will be added to the sizes requested & the style's margin values will be used for spacing.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns A rectangle with size between minWidth & maxWidth on both axes. 
            */
            public static GetRect ($minWidth: number, $maxWidth: number, $minHeight: number, $maxHeight: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            public static GetLastRect () : UnityEngine.Rect
            /** Reserve layout space for a rectangle with a specific aspect ratio.
            * @param aspect The aspect ratio of the element (width / height).
            * @param style An optional style. If specified, the style's padding value will be added to the sizes of the returned rectangle & the style's margin values will be used for spacing.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The rect for the control. 
            */
            public static GetAspectRect ($aspect: number) : UnityEngine.Rect
            /** Reserve layout space for a rectangle with a specific aspect ratio.
            * @param aspect The aspect ratio of the element (width / height).
            * @param style An optional style. If specified, the style's padding value will be added to the sizes of the returned rectangle & the style's margin values will be used for spacing.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The rect for the control. 
            */
            public static GetAspectRect ($aspect: number, $style: UnityEngine.GUIStyle) : UnityEngine.Rect
            /** Reserve layout space for a rectangle with a specific aspect ratio.
            * @param aspect The aspect ratio of the element (width / height).
            * @param style An optional style. If specified, the style's padding value will be added to the sizes of the returned rectangle & the style's margin values will be used for spacing.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The rect for the control. 
            */
            public static GetAspectRect ($aspect: number, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            /** Reserve layout space for a rectangle with a specific aspect ratio.
            * @param aspect The aspect ratio of the element (width / height).
            * @param style An optional style. If specified, the style's padding value will be added to the sizes of the returned rectangle & the style's margin values will be used for spacing.
            * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
            See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
            GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
            * @returns The rect for the control. 
            */
            public static GetAspectRect ($aspect: number, $style: UnityEngine.GUIStyle, ...options: UnityEngine.GUILayoutOption[]) : UnityEngine.Rect
            public constructor ()
        }
        /** General settings for how the GUI behaves.
        */
        class GUISettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Should double-clicking select words in text fields.
            */
            public get doubleClickSelectsWord(): boolean;
            public set doubleClickSelectsWord(value: boolean);
            /** Should triple-clicking select whole text in text fields.
            */
            public get tripleClickSelectsLine(): boolean;
            public set tripleClickSelectsLine(value: boolean);
            /** The color of the cursor in text fields.
            */
            public get cursorColor(): UnityEngine.Color;
            public set cursorColor(value: UnityEngine.Color);
            /** The speed of text field cursor flashes.
            */
            public get cursorFlashSpeed(): number;
            public set cursorFlashSpeed(value: number);
            /** The color of the selection rect in text fields.
            */
            public get selectionColor(): UnityEngine.Color;
            public set selectionColor(value: UnityEngine.Color);
            public constructor ()
        }
        /** Script interface for.
        */
        class Font extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The material used for the font display.
            */
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get fontNames(): System.Array$1<string>;
            public set fontNames(value: System.Array$1<string>);
            /** Is the font a dynamic font.
            */
            public get dynamic(): boolean;
            /** The ascent of the font.
            */
            public get ascent(): number;
            /** The default size of the font.
            */
            public get fontSize(): number;
            /** Access an array of all characters contained in the font texture.
            */
            public get characterInfo(): System.Array$1<UnityEngine.CharacterInfo>;
            public set characterInfo(value: System.Array$1<UnityEngine.CharacterInfo>);
            /** The line height of the font.
            */
            public get lineHeight(): number;
            public static add_textureRebuilt ($value: System.Action$1<UnityEngine.Font>) : void
            public static remove_textureRebuilt ($value: System.Action$1<UnityEngine.Font>) : void
            /** Creates a Font object which lets you render a font installed on the user machine.
            * @param fontname The name of the OS font to use for this font object.
            * @param size The default character size of the generated font.
            * @param fontnames Am array of names of OS fonts to use for this font object. When rendering characters using this font object, the first font which is installed on the machine, which contains the requested character will be used.
            * @returns The generate Font object. 
            */
            public static CreateDynamicFontFromOSFont ($fontname: string, $size: number) : UnityEngine.Font
            /** Creates a Font object which lets you render a font installed on the user machine.
            * @param fontname The name of the OS font to use for this font object.
            * @param size The default character size of the generated font.
            * @param fontnames Am array of names of OS fonts to use for this font object. When rendering characters using this font object, the first font which is installed on the machine, which contains the requested character will be used.
            * @returns The generate Font object. 
            */
            public static CreateDynamicFontFromOSFont ($fontnames: System.Array$1<string>, $size: number) : UnityEngine.Font
            /** Returns the maximum number of verts that the text generator may return for a given string.
            * @param str Input string.
            */
            public static GetMaxVertsForString ($str: string) : number
            /** Does this font have a specific character?
            * @param c The character to check for.
            * @returns Whether or not the font has the character specified. 
            */
            public HasCharacter ($c: number) : boolean
            public static GetOSInstalledFontNames () : System.Array$1<string>
            public static GetPathsToOSFonts () : System.Array$1<string>
            /** Get rendering info for a specific character.
            * @param ch The character you need rendering information for.
            * @param info Returns the CharacterInfo struct with the rendering information for the character (if available).
            * @param size The size of the character (default value of zero will use font default size).
            * @param style The style of the character.
            */
            public GetCharacterInfo ($ch: number, $info: $Ref<UnityEngine.CharacterInfo>, $size: number, $style: UnityEngine.FontStyle) : boolean
            /** Get rendering info for a specific character.
            * @param ch The character you need rendering information for.
            * @param info Returns the CharacterInfo struct with the rendering information for the character (if available).
            * @param size The size of the character (default value of zero will use font default size).
            * @param style The style of the character.
            */
            public GetCharacterInfo ($ch: number, $info: $Ref<UnityEngine.CharacterInfo>, $size: number) : boolean
            /** Get rendering info for a specific character.
            * @param ch The character you need rendering information for.
            * @param info Returns the CharacterInfo struct with the rendering information for the character (if available).
            * @param size The size of the character (default value of zero will use font default size).
            * @param style The style of the character.
            */
            public GetCharacterInfo ($ch: number, $info: $Ref<UnityEngine.CharacterInfo>) : boolean
            /** Request characters to be added to the font texture (dynamic fonts only).
            * @param characters The characters which are needed to be in the font texture.
            * @param size The size of the requested characters (the default value of zero will use the font's default size).
            * @param style The style of the requested characters.
            */
            public RequestCharactersInTexture ($characters: string, $size: number, $style: UnityEngine.FontStyle) : void
            public RequestCharactersInTexture ($characters: string, $size: number) : void
            public RequestCharactersInTexture ($characters: string) : void
            public constructor ()
            public constructor ($name: string)
        }
        /** Specialized values for the given states used by GUIStyle objects.
        */
        class GUIStyleState extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The background image used by GUI elements in this given state.
            */
            public get background(): UnityEngine.Texture2D;
            public set background(value: UnityEngine.Texture2D);
            /** The text color used by GUI elements in this state.
            */
            public get textColor(): UnityEngine.Color;
            public set textColor(value: UnityEngine.Color);
            public constructor ()
        }
        /** How image and text is placed inside GUIStyle.
        */
        enum ImagePosition
        { ImageLeft = 0, ImageAbove = 1, ImageOnly = 2, TextOnly = 3 }
        /** Where the anchor of the text is placed.
        */
        enum TextAnchor
        { UpperLeft = 0, UpperCenter = 1, UpperRight = 2, MiddleLeft = 3, MiddleCenter = 4, MiddleRight = 5, LowerLeft = 6, LowerCenter = 7, LowerRight = 8 }
        /** Different methods for how the GUI system handles text being too large to fit the rectangle allocated.
        */
        enum TextClipping
        { Overflow = 0, Clip = 1 }
        /** Font Style applied to GUI Texts, Text Meshes or GUIStyles.
        */
        enum FontStyle
        { Normal = 0, Bold = 1, Italic = 2, BoldAndItalic = 3 }
        /** Allows to control for which display the OnGUI is called.
        */
        class GUITargetAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($displayIndex: number)
            public constructor ($displayIndex: number, $displayIndex1: number)
            public constructor ($displayIndex: number, $displayIndex1: number, ...displayIndexList: number[])
        }
        /** Utility class for making new GUI controls.
        */
        class GUIUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** A global property, which is true if a ModalWindow is being displayed, false otherwise.
            */
            public static get hasModalWindow(): boolean;
            /** Get access to the system-wide clipboard.
            */
            public static get systemCopyBuffer(): string;
            public static set systemCopyBuffer(value: string);
            /** The controlID of the current hot control.
            */
            public static get hotControl(): number;
            public static set hotControl(value: number);
            /** The controlID of the control that has keyboard focus.
            */
            public static get keyboardControl(): number;
            public static set keyboardControl(value: number);
            /** Get a unique ID for a control, using an integer as a hint to help ensure correct matching of IDs to controls.
            */
            public static GetControlID ($hint: number, $focusType: UnityEngine.FocusType, $rect: UnityEngine.Rect) : number
            /** Align a local space rectangle to the pixel grid.
            * @param local The local space rectangle that needs to be processed.
            * @param widthInPixels Width, in pixel units, of the axis-aligned bounding box that encompasses the aligned points.
            * @param heightInPixels Height, in pixel units, of the axis-aligned bounding box that encompasses the aligned points.
            * @returns The aligned rectangle in local space. 
            */
            public static AlignRectToDevice ($rect: UnityEngine.Rect, $widthInPixels: $Ref<number>, $heightInPixels: $Ref<number>) : UnityEngine.Rect
            /** Get a unique ID for a control.
            */
            public static GetControlID ($focus: UnityEngine.FocusType) : number
            /** Get a unique ID for a control, using a the label content as a hint to help ensure correct matching of IDs to controls.
            */
            public static GetControlID ($contents: UnityEngine.GUIContent, $focus: UnityEngine.FocusType) : number
            /** Get a unique ID for a control.
            */
            public static GetControlID ($focus: UnityEngine.FocusType, $position: UnityEngine.Rect) : number
            /** Get a unique ID for a control, using a the label content as a hint to help ensure correct matching of IDs to controls.
            */
            public static GetControlID ($contents: UnityEngine.GUIContent, $focus: UnityEngine.FocusType, $position: UnityEngine.Rect) : number
            /** Get a unique ID for a control, using an integer as a hint to help ensure correct matching of IDs to controls.
            */
            public static GetControlID ($hint: number, $focus: UnityEngine.FocusType) : number
            /** Get a state object from a controlID.
            */
            public static GetStateObject ($t: System.Type, $controlID: number) : any
            /** Get an existing state object from a controlID.
            */
            public static QueryStateObject ($t: System.Type, $controlID: number) : any
            public static ExitGUI () : void
            /** Convert a point from GUI position to screen space.
            */
            public static GUIToScreenPoint ($guiPoint: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Convert a rect from GUI position to screen space.
            */
            public static GUIToScreenRect ($guiRect: UnityEngine.Rect) : UnityEngine.Rect
            /** Convert a point from screen space to GUI position.
            */
            public static ScreenToGUIPoint ($screenPoint: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Convert a rect from screen space to GUI position.
            */
            public static ScreenToGUIRect ($screenRect: UnityEngine.Rect) : UnityEngine.Rect
            /** Helper function to rotate the GUI around a point.
            */
            public static RotateAroundPivot ($angle: number, $pivotPoint: UnityEngine.Vector2) : void
            /** Helper function to scale the GUI around a point.
            */
            public static ScaleAroundPivot ($scale: UnityEngine.Vector2, $pivotPoint: UnityEngine.Vector2) : void
            /** Align a local space rectangle to the pixel grid.
            * @param local The local space rectangle that needs to be processed.
            * @param widthInPixels Width, in pixel units, of the axis-aligned bounding box that encompasses the aligned points.
            * @param heightInPixels Height, in pixel units, of the axis-aligned bounding box that encompasses the aligned points.
            * @returns The aligned rectangle in local space. 
            */
            public static AlignRectToDevice ($rect: UnityEngine.Rect) : UnityEngine.Rect
            public constructor ()
        }
        /** An exception that will prevent all subsequent immediate mode GUI functions from evaluating for the remainder of the GUI loop.
        */
        class ExitGUIException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class TextEditor extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public keyboardOnScreen : UnityEngine.TouchScreenKeyboard
            public controlID : number
            public style : UnityEngine.GUIStyle
            public multiline : boolean
            public hasHorizontalCursorPos : boolean
            public isPasswordField : boolean
            public scrollOffset : UnityEngine.Vector2
            public graphicalCursorPos : UnityEngine.Vector2
            public graphicalSelectCursorPos : UnityEngine.Vector2
            public get text(): string;
            public set text(value: string);
            public get position(): UnityEngine.Rect;
            public set position(value: UnityEngine.Rect);
            public get cursorIndex(): number;
            public set cursorIndex(value: number);
            public get selectIndex(): number;
            public set selectIndex(value: number);
            public get doubleClickSnapping(): UnityEngine.TextEditor.DblClickSnapping;
            public set doubleClickSnapping(value: UnityEngine.TextEditor.DblClickSnapping);
            public get altCursorPosition(): number;
            public set altCursorPosition(value: number);
            public get hasSelection(): boolean;
            public get SelectedText(): string;
            public OnFocus () : void
            public OnLostFocus () : void
            public HandleKeyEvent ($e: UnityEngine.Event) : boolean
            public DeleteLineBack () : boolean
            public DeleteWordBack () : boolean
            public DeleteWordForward () : boolean
            public Delete () : boolean
            public CanPaste () : boolean
            public Backspace () : boolean
            public SelectAll () : void
            public SelectNone () : void
            public DeleteSelection () : boolean
            public ReplaceSelection ($replace: string) : void
            public Insert ($c: number) : void
            public MoveSelectionToAltCursor () : void
            public MoveRight () : void
            public MoveLeft () : void
            public MoveUp () : void
            public MoveDown () : void
            public MoveLineStart () : void
            public MoveLineEnd () : void
            public MoveGraphicalLineStart () : void
            public MoveGraphicalLineEnd () : void
            public MoveTextStart () : void
            public MoveTextEnd () : void
            public MoveParagraphForward () : void
            public MoveParagraphBackward () : void
            public MoveCursorToPosition ($cursorPosition: UnityEngine.Vector2) : void
            public MoveAltCursorToPosition ($cursorPosition: UnityEngine.Vector2) : void
            public IsOverSelection ($cursorPosition: UnityEngine.Vector2) : boolean
            public SelectToPosition ($cursorPosition: UnityEngine.Vector2) : void
            public SelectLeft () : void
            public SelectRight () : void
            public SelectUp () : void
            public SelectDown () : void
            public SelectTextEnd () : void
            public SelectTextStart () : void
            public MouseDragSelectsWholeWords ($on: boolean) : void
            public DblClickSnap ($snapping: UnityEngine.TextEditor.DblClickSnapping) : void
            public MoveWordRight () : void
            public MoveToStartOfNextWord () : void
            public MoveToEndOfPreviousWord () : void
            public SelectToStartOfNextWord () : void
            public SelectToEndOfPreviousWord () : void
            public FindStartOfNextWord ($p: number) : number
            public MoveWordLeft () : void
            public SelectWordRight () : void
            public SelectWordLeft () : void
            public ExpandSelectGraphicalLineStart () : void
            public ExpandSelectGraphicalLineEnd () : void
            public SelectGraphicalLineStart () : void
            public SelectGraphicalLineEnd () : void
            public SelectParagraphForward () : void
            public SelectParagraphBackward () : void
            public SelectCurrentWord () : void
            public SelectCurrentParagraph () : void
            public UpdateScrollOffsetIfNeeded ($evt: UnityEngine.Event) : void
            public DrawCursor ($newText: string) : void
            public SaveBackup () : void
            public Undo () : void
            public Cut () : boolean
            public Copy () : void
            public Paste () : boolean
            public DetectFocusChange () : void
            public constructor ()
        }
        /** This class provides utility and extension methods to convert image data from or to PNG, EXR, TGA, and JPEG formats.
        */
        class ImageConversion extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Enables legacy PNG runtime import behavior.
            */
            public static get EnableLegacyPngGammaRuntimeLoadBehavior(): boolean;
            public static set EnableLegacyPngGammaRuntimeLoadBehavior(value: boolean);
            /** Encodes the specified texture in TGA format.
            * @param tex The texture to encode.
            */
            public static EncodeToTGA ($tex: UnityEngine.Texture2D) : System.Array$1<number>
            /** Encodes this texture into PNG format.
            * @param tex The texture to convert.
            */
            public static EncodeToPNG ($tex: UnityEngine.Texture2D) : System.Array$1<number>
            /** Encodes this texture into JPG format.
            * @param tex Text texture to convert.
            * @param quality JPG quality to encode with. The range is 1 through 100. 1 is the lowest quality. The default is 75.
            */
            public static EncodeToJPG ($tex: UnityEngine.Texture2D, $quality: number) : System.Array$1<number>
            /** Encodes this texture into JPG format.
            * @param tex Text texture to convert.
            * @param quality JPG quality to encode with. The range is 1 through 100. 1 is the lowest quality. The default is 75.
            */
            public static EncodeToJPG ($tex: UnityEngine.Texture2D) : System.Array$1<number>
            public static EncodeToEXR ($tex: UnityEngine.Texture2D, $flags: UnityEngine.Texture2D.EXRFlags) : System.Array$1<number>
            public static EncodeToEXR ($tex: UnityEngine.Texture2D) : System.Array$1<number>
            /** Loads PNG or JPG image byte array into a texture.
            * @param tex The texture to load the image into.
            * @param data The byte array containing the image data to load.
            * @param markNonReadable Set to false by default, pass true to optionally mark the texture as non-readable.
            * @returns Returns true if the data can be loaded, false otherwise. 
            */
            public static LoadImage ($tex: UnityEngine.Texture2D, $data: System.Array$1<number>, $markNonReadable: boolean) : boolean
            public static LoadImage ($tex: UnityEngine.Texture2D, $data: System.Array$1<number>) : boolean
            /** Encodes this array into TGA format.
            * @param array The byte array to convert.
            * @param format The pixel format of the image data.
            * @param width The width of the image data in pixels.
            * @param height The height of the image data in pixels.
            * @param rowBytes The length of a single row in bytes. The default is 0, which means Unity calculates the length automatically.
            */
            public static EncodeArrayToTGA ($array: System.Array, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $width: number, $height: number, $rowBytes?: number) : System.Array$1<number>
            /** Encodes this array into PNG format.
            * @param array The byte array to convert.
            * @param format The pixel format of the image data.
            * @param width The width of the image data in pixels.
            * @param height The height of the image data in pixels.
            * @param rowBytes The length of a single row in bytes. The default is 0, which means Unity calculates the length automatically.
            */
            public static EncodeArrayToPNG ($array: System.Array, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $width: number, $height: number, $rowBytes?: number) : System.Array$1<number>
            /** Encodes this array into JPG format.
            * @param array The byte array to convert.
            * @param format The pixel format of the image data.
            * @param width The width of the image data in pixels.
            * @param height The height of the image data in pixels.
            * @param rowBytes The length of a single row in bytes. The default is 0, which means Unity calculates the length automatically.
            * @param quality JPG quality to encode with. The range is 1 through 100. 1 is the lowest quality. The default is 75.
            */
            public static EncodeArrayToJPG ($array: System.Array, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $width: number, $height: number, $rowBytes?: number, $quality?: number) : System.Array$1<number>
            public static EncodeArrayToEXR ($array: System.Array, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $width: number, $height: number, $rowBytes?: number, $flags?: UnityEngine.Texture2D.EXRFlags) : System.Array$1<number>
        }
        /** Describes phase of a finger touch.
        */
        enum TouchPhase
        { Began = 0, Moved = 1, Stationary = 2, Ended = 3, Canceled = 4 }
        /** Controls IME input.
        */
        enum IMECompositionMode
        { Auto = 0, On = 1, Off = 2 }
        /** Describes whether a touch is direct, indirect (or remote), or from a stylus.
        */
        enum TouchType
        { Direct = 0, Indirect = 1, Stylus = 2 }
        /** Structure describing the status of a finger touching the screen.
        */
        class Touch extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The unique index for the touch.
            */
            public get fingerId(): number;
            public set fingerId(value: number);
            /** The position of the touch in screen space pixel coordinates.
            */
            public get position(): UnityEngine.Vector2;
            public set position(value: UnityEngine.Vector2);
            /** The first position of the touch contact in screen space pixel coordinates.
            */
            public get rawPosition(): UnityEngine.Vector2;
            public set rawPosition(value: UnityEngine.Vector2);
            /** The position delta since last change in pixel coordinates.
            */
            public get deltaPosition(): UnityEngine.Vector2;
            public set deltaPosition(value: UnityEngine.Vector2);
            /** Amount of time that has passed since the last recorded change in Touch values.
            */
            public get deltaTime(): number;
            public set deltaTime(value: number);
            /** Number of taps.
            */
            public get tapCount(): number;
            public set tapCount(value: number);
            /** Describes the phase of the touch.
            */
            public get phase(): UnityEngine.TouchPhase;
            public set phase(value: UnityEngine.TouchPhase);
            /** The current amount of pressure being applied to a touch.  1.0f is considered to be the pressure of an average touch.  If Input.touchPressureSupported returns false, the value of this property will always be 1.0f.
            */
            public get pressure(): number;
            public set pressure(value: number);
            /** The maximum possible pressure value for a platform.  If Input.touchPressureSupported returns false, the value of this property will always be 1.0f.
            */
            public get maximumPossiblePressure(): number;
            public set maximumPossiblePressure(value: number);
            /** A value that indicates whether a touch was of Direct, Indirect (or remote), or Stylus type.
            */
            public get type(): UnityEngine.TouchType;
            public set type(value: UnityEngine.TouchType);
            /** Value of 0 radians indicates that the stylus is parallel to the surface, pi/2 indicates that it is perpendicular.
            */
            public get altitudeAngle(): number;
            public set altitudeAngle(value: number);
            /** Value of 0 radians indicates that the stylus is pointed along the x-axis of the device.
            */
            public get azimuthAngle(): number;
            public set azimuthAngle(value: number);
            /** An estimated value of the radius of a touch.  Add radiusVariance to get the maximum touch size, subtract it to get the minimum touch size.
            */
            public get radius(): number;
            public set radius(value: number);
            /** This value determines the accuracy of the touch radius. Add this value to the radius to get the maximum touch size, subtract it to get the minimum touch size.
            */
            public get radiusVariance(): number;
            public set radiusVariance(value: number);
        }
        /** Describes physical orientation of the device as determined by the OS.
        */
        enum DeviceOrientation
        { Unknown = 0, Portrait = 1, PortraitUpsideDown = 2, LandscapeLeft = 3, LandscapeRight = 4, FaceUp = 5, FaceDown = 6 }
        /** Structure describing acceleration status of the device.
        */
        class AccelerationEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Value of acceleration.
            */
            public get acceleration(): UnityEngine.Vector3;
            /** Amount of time passed since last accelerometer measurement.
            */
            public get deltaTime(): number;
        }
        /** Interface into the Gyroscope.
        */
        class Gyroscope extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Returns rotation rate as measured by the device's gyroscope.
            */
            public get rotationRate(): UnityEngine.Vector3;
            /** Returns unbiased rotation rate as measured by the device's gyroscope.
            */
            public get rotationRateUnbiased(): UnityEngine.Vector3;
            /** Returns the gravity acceleration vector expressed in the device's reference frame.
            */
            public get gravity(): UnityEngine.Vector3;
            /** Returns the acceleration that the user is giving to the device.
            */
            public get userAcceleration(): UnityEngine.Vector3;
            /** Returns the attitude (ie, orientation in space) of the device.
            */
            public get attitude(): UnityEngine.Quaternion;
            /** Sets or retrieves the enabled status of this gyroscope.
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            /** Sets or retrieves gyroscope interval in seconds.
            */
            public get updateInterval(): number;
            public set updateInterval(value: number);
        }
        /** Structure describing device location.
        */
        class LocationInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Geographical device location latitude.
            */
            public get latitude(): number;
            /** Geographical device location longitude.
            */
            public get longitude(): number;
            /** Geographical device location altitude.
            */
            public get altitude(): number;
            /** Horizontal accuracy of the location.
            */
            public get horizontalAccuracy(): number;
            /** Vertical accuracy of the location.
            */
            public get verticalAccuracy(): number;
            /** Timestamp (in seconds since 1970) when location was last time updated.
            */
            public get timestamp(): number;
        }
        /** Describes the location service status for a device.
        */
        enum LocationServiceStatus
        { Stopped = 0, Initializing = 1, Running = 2, Failed = 3 }
        /** Provides methods that allow an application to access the device's location.
        */
        class LocationService extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Indicates whether the device allows access the application to access the location service.
            */
            public get isEnabledByUser(): boolean;
            /** Returns the location service status.
            */
            public get status(): UnityEngine.LocationServiceStatus;
            /** The last geographical location that the device registered.
            */
            public get lastData(): UnityEngine.LocationInfo;
            /** Starts location service updates.
            * @param desiredAccuracyInMeters 
            The service accuracy you want to use, in meters. This determines the accuracy of the device's last location coordinates. Higher values like 500 don't require the device to use its GPS chip and
            thus save battery power. Lower values like 5-10 provide the best accuracy but require the GPS chip and thus use more battery power. The default value is 10 meters.
            * @param updateDistanceInMeters 
            The minimum distance, in meters, that the device must move laterally before Unity updates Input.location. Higher values like 500 produce fewer updates and are less resource intensive to process. The default is 10 meters.
            */
            public Start ($desiredAccuracyInMeters: number, $updateDistanceInMeters: number) : void
            /** Starts location service updates.
            * @param desiredAccuracyInMeters 
            The service accuracy you want to use, in meters. This determines the accuracy of the device's last location coordinates. Higher values like 500 don't require the device to use its GPS chip and
            thus save battery power. Lower values like 5-10 provide the best accuracy but require the GPS chip and thus use more battery power. The default value is 10 meters.
            * @param updateDistanceInMeters 
            The minimum distance, in meters, that the device must move laterally before Unity updates Input.location. Higher values like 500 produce fewer updates and are less resource intensive to process. The default is 10 meters.
            */
            public Start ($desiredAccuracyInMeters: number) : void
            public Start () : void
            public Stop () : void
            public constructor ()
        }
        /** Interface into compass functionality.
        */
        class Compass extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The heading in degrees relative to the magnetic North Pole. (Read Only)
            */
            public get magneticHeading(): number;
            /** The heading in degrees relative to the geographic North Pole. (Read Only)
            */
            public get trueHeading(): number;
            /** Accuracy of heading reading in degrees.
            */
            public get headingAccuracy(): number;
            /** The raw geomagnetic data measured in microteslas. (Read Only)
            */
            public get rawVector(): UnityEngine.Vector3;
            /** Timestamp (in seconds since 1970) when the heading was last time updated. (Read Only)
            */
            public get timestamp(): number;
            /** Used to enable or disable compass. Note, that if you want Input.compass.trueHeading property to contain a valid value, you must also enable location updates by calling Input.location.Start().
            */
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public constructor ()
        }
        /** Interface into the Input system.
        */
        class Input extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Enables/Disables mouse simulation with touches. By default this option is enabled.
            */
            public static get simulateMouseWithTouches(): boolean;
            public static set simulateMouseWithTouches(value: boolean);
            /** Is any key or mouse button currently held down? (Read Only)
            */
            public static get anyKey(): boolean;
            /** Returns true the first frame the user hits any key or mouse button. (Read Only)
            */
            public static get anyKeyDown(): boolean;
            /** Returns the keyboard input entered this frame. (Read Only)
            */
            public static get inputString(): string;
            /** The current mouse position in pixel coordinates. (Read Only).
            */
            public static get mousePosition(): UnityEngine.Vector3;
            /** The current mouse scroll delta. (Read Only)
            */
            public static get mouseScrollDelta(): UnityEngine.Vector2;
            /** Controls enabling and disabling of IME input composition.
            */
            public static get imeCompositionMode(): UnityEngine.IMECompositionMode;
            public static set imeCompositionMode(value: UnityEngine.IMECompositionMode);
            /** The current IME composition string being typed by the user.
            */
            public static get compositionString(): string;
            /** Does the user have an IME keyboard input source selected?
            */
            public static get imeIsSelected(): boolean;
            /** The current text input position used by IMEs to open windows.
            */
            public static get compositionCursorPos(): UnityEngine.Vector2;
            public static set compositionCursorPos(value: UnityEngine.Vector2);
            /** Indicates if a mouse device is detected.
            */
            public static get mousePresent(): boolean;
            /** Number of touches. Guaranteed not to change throughout the frame. (Read Only)
            */
            public static get touchCount(): number;
            /** Bool value which let's users check if touch pressure is supported.
            */
            public static get touchPressureSupported(): boolean;
            /** Returns true when Stylus Touch is supported by a device or platform.
            */
            public static get stylusTouchSupported(): boolean;
            /** Returns whether the device on which application is currently running supports touch input.
            */
            public static get touchSupported(): boolean;
            /** Property indicating whether the system handles multiple touches.
            */
            public static get multiTouchEnabled(): boolean;
            public static set multiTouchEnabled(value: boolean);
            /** Device physical orientation as reported by OS. (Read Only)
            */
            public static get deviceOrientation(): UnityEngine.DeviceOrientation;
            /** Last measured linear acceleration of a device in three-dimensional space. (Read Only)
            */
            public static get acceleration(): UnityEngine.Vector3;
            /** This property controls if input sensors should be compensated for screen orientation.
            */
            public static get compensateSensors(): boolean;
            public static set compensateSensors(value: boolean);
            /** Number of acceleration measurements which occurred during last frame.
            */
            public static get accelerationEventCount(): number;
            /** Should  Back button quit the application?
            Only usable on Android, Windows Phone or Windows Tablets.
            */
            public static get backButtonLeavesApp(): boolean;
            public static set backButtonLeavesApp(value: boolean);
            /** Property for accessing device location (handheld devices only). (Read Only)
            */
            public static get location(): UnityEngine.LocationService;
            /** Property for accessing compass (handheld devices only). (Read Only)
            */
            public static get compass(): UnityEngine.Compass;
            /** Returns default gyroscope.
            */
            public static get gyro(): UnityEngine.Gyroscope;
            /** Returns list of objects representing status of all touches during last frame. (Read Only) (Allocates temporary variables).
            */
            public static get touches(): System.Array$1<UnityEngine.Touch>;
            /** Returns list of acceleration measurements which occurred during the last frame. (Read Only) (Allocates temporary variables).
            */
            public static get accelerationEvents(): System.Array$1<UnityEngine.AccelerationEvent>;
            /** Returns the value of the virtual axis identified by axisName.
            */
            public static GetAxis ($axisName: string) : number
            /** Returns the value of the virtual axis identified by axisName with no smoothing filtering applied.
            */
            public static GetAxisRaw ($axisName: string) : number
            /** Returns true while the virtual button identified by buttonName is held down.
            * @param buttonName The name of the button such as Jump.
            * @returns True when an axis has been pressed and not released. 
            */
            public static GetButton ($buttonName: string) : boolean
            /** Returns true during the frame the user pressed down the virtual button identified by buttonName.
            */
            public static GetButtonDown ($buttonName: string) : boolean
            /** Returns true the first frame the user releases the virtual button identified by buttonName.
            */
            public static GetButtonUp ($buttonName: string) : boolean
            /** Returns whether the given mouse button is held down.
            */
            public static GetMouseButton ($button: number) : boolean
            /** Returns true during the frame the user pressed the given mouse button.
            */
            public static GetMouseButtonDown ($button: number) : boolean
            /** Returns true during the frame the user releases the given mouse button.
            */
            public static GetMouseButtonUp ($button: number) : boolean
            public static ResetInputAxes () : void
            public static GetJoystickNames () : System.Array$1<string>
            /** Call Input.GetTouch to obtain a Touch struct.
            * @param index The touch input on the device screen.
            * @returns Touch details in the struct. 
            */
            public static GetTouch ($index: number) : UnityEngine.Touch
            /** Returns specific acceleration measurement which occurred during last frame. (Does not allocate temporary variables).
            */
            public static GetAccelerationEvent ($index: number) : UnityEngine.AccelerationEvent
            /** Returns true while the user holds down the key identified by the key KeyCode enum parameter.
            */
            public static GetKey ($key: UnityEngine.KeyCode) : boolean
            /** Returns true while the user holds down the key identified by name.
            */
            public static GetKey ($name: string) : boolean
            /** Returns true during the frame the user releases the key identified by the key KeyCode enum parameter.
            */
            public static GetKeyUp ($key: UnityEngine.KeyCode) : boolean
            /** Returns true during the frame the user releases the key identified by name.
            */
            public static GetKeyUp ($name: string) : boolean
            /** Returns true during the frame the user starts pressing down the key identified by the key KeyCode enum parameter.
            */
            public static GetKeyDown ($key: UnityEngine.KeyCode) : boolean
            /** Returns true during the frame the user starts pressing down the key identified by name.
            */
            public static GetKeyDown ($name: string) : boolean
            public constructor ()
        }
        /** Utility functions for working with JSON data.
        */
        class JsonUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Generate a JSON representation of the public fields of an object.
            * @param obj The object to convert to JSON form.
            * @param prettyPrint If true, format the output for readability. If false, format the output for minimum size. Default is false.
            * @returns The object's data in JSON format. 
            */
            public static ToJson ($obj: any) : string
            /** Generate a JSON representation of the public fields of an object.
            * @param obj The object to convert to JSON form.
            * @param prettyPrint If true, format the output for readability. If false, format the output for minimum size. Default is false.
            * @returns The object's data in JSON format. 
            */
            public static ToJson ($obj: any, $prettyPrint: boolean) : string
            /** Create an object from its JSON representation.
            * @param json The JSON representation of the object.
            * @param type The type of object represented by the Json.
            * @returns An instance of the object. 
            */
            public static FromJson ($json: string, $type: System.Type) : any
            /** Overwrite data in an object by reading from its JSON representation.
            * @param json The JSON representation of the object.
            * @param objectToOverwrite The object that should be overwritten.
            */
            public static FromJsonOverwrite ($json: string, $objectToOverwrite: any) : void
        }
        /** An asset to represent a table of localized strings for one specific locale.
        */
        class LocalizationAsset extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** ISO Code used to identify the locale. ex: en-uk, zh-hans, ja
            */
            public get localeIsoCode(): string;
            public set localeIsoCode(value: string);
            /** Is this asset used to localize UI components of the Unity Editor
            */
            public get isEditorAsset(): boolean;
            public set isEditorAsset(value: boolean);
            /** Set the localized string for the specified key
            * @param original Original string acting as key.
            * @param localized Localized string matching the original in the LocalizationAsset locale
            */
            public SetLocalizedString ($original: string, $localized: string) : void
            /** Get the localized string for the specified key.
            * @param original Original string acting as key.
            * @returns Localized string matching the original in the LocalizationAsset locale 
            */
            public GetLocalizedString ($original: string) : string
            public constructor ()
        }
        /** The mode in which particles are emitted.
        */
        enum ParticleSystemEmissionType
        { Time = 0, Distance = 1 }
        /** The particle curve mode.
        */
        enum ParticleSystemCurveMode
        { Constant = 0, Curve = 1, TwoCurves = 2, TwoConstants = 3 }
        /** Control how a Particle System calculates its velocity.
        */
        enum ParticleSystemEmitterVelocityMode
        { Transform = 0, Rigidbody = 1, Custom = 2 }
        /** The action to perform when the Particle System stops.
        */
        enum ParticleSystemStopAction
        { None = 0, Disable = 1, Destroy = 2, Callback = 3 }
        /** Control how particles are removed from the Particle System.
        */
        enum ParticleSystemRingBufferMode
        { Disabled = 0, PauseUntilReplaced = 1, LoopUntilReplaced = 2 }
        /** The action to perform when the Particle System is offscreen.
        */
        enum ParticleSystemCullingMode
        { Automatic = 0, PauseAndCatchup = 1, Pause = 2, AlwaysSimulate = 3 }
        /** The emission shape.
        */
        enum ParticleSystemShapeType
        { Sphere = 0, SphereShell = 1, Hemisphere = 2, HemisphereShell = 3, Cone = 4, Box = 5, Mesh = 6, ConeShell = 7, ConeVolume = 8, ConeVolumeShell = 9, Circle = 10, CircleEdge = 11, SingleSidedEdge = 12, MeshRenderer = 13, SkinnedMeshRenderer = 14, BoxShell = 15, BoxEdge = 16, Donut = 17, Rectangle = 18, Sprite = 19, SpriteRenderer = 20 }
        /** The mode used to generate new points in a shape.
        */
        enum ParticleSystemShapeMultiModeValue
        { Random = 0, Loop = 1, PingPong = 2, BurstSpread = 3 }
        /** The mesh emission type.
        */
        enum ParticleSystemMeshShapeType
        { Vertex = 0, Edge = 1, Triangle = 2 }
        /** Renders meshes inserted by the MeshFilter or TextMesh.
        */
        class MeshRenderer extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
        }
        /** The texture channel.
        */
        enum ParticleSystemShapeTextureChannel
        { Red = 0, Green = 1, Blue = 2, Alpha = 3 }
        /** The type of collisions to use for a given Particle System.
        */
        enum ParticleSystemCollisionType
        { Planes = 0, World = 1 }
        /** Whether to use 2D or 3D colliders for particle collisions.
        */
        enum ParticleSystemCollisionMode
        { Collision3D = 0, Collision2D = 1 }
        /** Quality of world collisions. Medium and low quality are approximate and may leak particles.
        */
        enum ParticleSystemCollisionQuality
        { High = 0, Medium = 1, Low = 2 }
        /** What action to perform when the particle trigger module passes a test.
        */
        enum ParticleSystemOverlapAction
        { Ignore = 0, Kill = 1, Callback = 2 }
        /** Whether collider information is available when using the ParticleSystem::GetTriggerParticles method.
        */
        enum ParticleSystemColliderQueryMode
        { Disabled = 0, One = 1, All = 2 }
        /** The events that cause new particles to be spawned.
        */
        enum ParticleSystemSubEmitterType
        { Birth = 0, Collision = 1, Death = 2, Trigger = 3, Manual = 4 }
        /** The properties of sub-emitter particles.
        */
        enum ParticleSystemSubEmitterProperties
        { InheritNothing = 0, InheritEverything = 31, InheritColor = 1, InheritSize = 2, InheritRotation = 4, InheritLifetime = 8, InheritDuration = 16 }
        /** The animation mode.
        */
        enum ParticleSystemAnimationMode
        { Grid = 0, Sprites = 1 }
        /** Control how animation frames are selected.
        */
        enum ParticleSystemAnimationTimeMode
        { Lifetime = 0, Speed = 1, FPS = 2 }
        /** The animation type.
        */
        enum ParticleSystemAnimationType
        { WholeSheet = 0, SingleRow = 1 }
        /** The mode used for selecting rows of an animation in the Texture Sheet Animation Module.
        */
        enum ParticleSystemAnimationRowMode
        { Custom = 0, Random = 1, MeshIndex = 2 }
        /** The particle gradient mode.
        */
        enum ParticleSystemGradientMode
        { Color = 0, Gradient = 1, TwoColors = 2, TwoGradients = 3, RandomColor = 4 }
        /** How to apply emitter velocity to particles.
        */
        enum ParticleSystemInheritVelocityMode
        { Initial = 0, Current = 1 }
        /** The particle GameObject filtering mode that specifies which objects are used by specific Particle System modules.
        */
        enum ParticleSystemGameObjectFilter
        { LayerMask = 0, List = 1, LayerMaskAndList = 2 }
        /** Script interface for Particle System Force Fields.
        */
        class ParticleSystemForceField extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Selects the type of shape used for influencing particles.
            */
            public get shape(): UnityEngine.ParticleSystemForceFieldShape;
            public set shape(value: UnityEngine.ParticleSystemForceFieldShape);
            /** Setting a value greater than 0 creates a hollow Force Field shape. This will cause particles to not be affected by the Force Field when closer to the center of the volume than the startRange property.
            */
            public get startRange(): number;
            public set startRange(value: number);
            /** Determines the size of the shape used for influencing particles.
            */
            public get endRange(): number;
            public set endRange(value: number);
            /** Describes the length of the Cylinder when using the Cylinder Force Field shape to influence particles.
            */
            public get length(): number;
            public set length(value: number);
            /** When using the gravity force, set this value between 0 and 1 to control the focal point of the gravity effect.
            */
            public get gravityFocus(): number;
            public set gravityFocus(value: number);
            /** Apply randomness to the Force Field axis that particles will travel around.
            */
            public get rotationRandomness(): UnityEngine.Vector2;
            public set rotationRandomness(value: UnityEngine.Vector2);
            /** When using Drag, the drag strength will be multiplied by the size of the particles if this toggle is enabled.
            */
            public get multiplyDragByParticleSize(): boolean;
            public set multiplyDragByParticleSize(value: boolean);
            /** When using Drag, the drag strength will be multiplied by the speed of the particles if this toggle is enabled.
            */
            public get multiplyDragByParticleVelocity(): boolean;
            public set multiplyDragByParticleVelocity(value: boolean);
            /** Apply forces to particles within the volume of the Force Field, by using a 3D texture containing vector field data.
            */
            public get vectorField(): UnityEngine.Texture3D;
            public set vectorField(value: UnityEngine.Texture3D);
            /** Apply a linear force along the local X axis to particles within the volume of the Force Field.
            */
            public get directionX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set directionX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            /** Apply a linear force along the local Y axis to particles within the volume of the Force Field.
            */
            public get directionY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set directionY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            /** Apply a linear force along the local Z axis to particles within the volume of the Force Field.
            */
            public get directionZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set directionZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            /** Apply gravity to particles within the volume of the Force Field.
            */
            public get gravity(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set gravity(value: UnityEngine.ParticleSystem.MinMaxCurve);
            /** The speed at which particles are propelled around a vortex.
            */
            public get rotationSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set rotationSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            /** Controls how strongly particles are dragged into the vortex motion.
            */
            public get rotationAttraction(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set rotationAttraction(value: UnityEngine.ParticleSystem.MinMaxCurve);
            /** Apply drag to particles within the volume of the Force Field.
            */
            public get drag(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set drag(value: UnityEngine.ParticleSystem.MinMaxCurve);
            /** The speed at which particles are propelled through the vector field.
            */
            public get vectorFieldSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set vectorFieldSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            /** Controls how strongly particles are dragged into the vector field motion.
            */
            public get vectorFieldAttraction(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set vectorFieldAttraction(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public constructor ()
        }
        /** The quality of the generated noise.
        */
        enum ParticleSystemNoiseQuality
        { Low = 0, Medium = 1, High = 2 }
        /** Choose how Particle Trails are generated.
        */
        enum ParticleSystemTrailMode
        { PerParticle = 0, Ribbon = 1 }
        /** Choose how textures are applied to Particle Trails.
        */
        enum ParticleSystemTrailTextureMode
        { Stretch = 0, Tile = 1, DistributePerSegment = 2, RepeatPerSegment = 3 }
        /** Which mode CustomDataModule uses to generate its data.
        */
        enum ParticleSystemCustomDataMode
        { Disabled = 0, Vector = 1, Color = 2 }
        /** Method extension for Physics in Particle System.
        */
        class ParticlePhysicsExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Safe array size for use with ParticleSystem.GetCollisionEvents.
            */
            public static GetSafeCollisionEventSize ($ps: UnityEngine.ParticleSystem) : number
            public static GetCollisionEvents ($ps: UnityEngine.ParticleSystem, $go: UnityEngine.GameObject, $collisionEvents: System.Collections.Generic.List$1<UnityEngine.ParticleCollisionEvent>) : number
            /** Safe array size for use with ParticleSystem.GetTriggerParticles.
            * @param ps Particle system.
            * @param type Type of trigger to return size for.
            * @returns Number of particles with this trigger event type. 
            */
            public static GetSafeTriggerParticlesSize ($ps: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemTriggerEventType) : number
            public static GetTriggerParticles ($ps: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>) : number
            public static GetTriggerParticles ($ps: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>, $colliderData: $Ref<UnityEngine.ParticleSystem.ColliderData>) : number
            public static SetTriggerParticles ($ps: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>, $offset: number, $count: number) : void
            public static SetTriggerParticles ($ps: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemTriggerEventType, $particles: System.Collections.Generic.List$1<UnityEngine.ParticleSystem.Particle>) : void
        }
        /** Information about a particle collision.
        */
        class ParticleCollisionEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Intersection point of the collision in world coordinates.
            */
            public get intersection(): UnityEngine.Vector3;
            /** Geometry normal at the intersection point of the collision.
            */
            public get normal(): UnityEngine.Vector3;
            /** Incident velocity at the intersection point of the collision.
            */
            public get velocity(): UnityEngine.Vector3;
            /** The Collider or Collider2D for the GameObject struck by the particles.
            */
            public get colliderComponent(): UnityEngine.Component;
        }
        /** The different types of particle triggers.
        */
        enum ParticleSystemTriggerEventType
        { Inside = 0, Outside = 1, Enter = 2, Exit = 3 }
        /** The rendering mode for particle systems.
        */
        enum ParticleSystemRenderMode
        { Billboard = 0, Stretch = 1, HorizontalBillboard = 2, VerticalBillboard = 3, Mesh = 4, None = 5 }
        /** Sets which method Unity uses to randomly assign Meshes to particles.
        */
        enum ParticleSystemMeshDistribution
        { UniformRandom = 0, NonUniformRandom = 1 }
        /** The sorting mode for particle systems.
        */
        enum ParticleSystemSortMode
        { None = 0, Distance = 1, OldestInFront = 2, YoungestInFront = 3, Depth = 4 }
        /** How particles are aligned when rendered.
        */
        enum ParticleSystemRenderSpace
        { View = 0, World = 1, Local = 2, Facing = 3, Velocity = 4 }
        /** All possible Particle System vertex shader inputs.
        */
        enum ParticleSystemVertexStream
        { Position = 0, Normal = 1, Tangent = 2, Color = 3, UV = 4, UV2 = 5, UV3 = 6, UV4 = 7, AnimBlend = 8, AnimFrame = 9, Center = 10, VertexID = 11, SizeX = 12, SizeXY = 13, SizeXYZ = 14, Rotation = 15, Rotation3D = 16, RotationSpeed = 17, RotationSpeed3D = 18, Velocity = 19, Speed = 20, AgePercent = 21, InvStartLifetime = 22, StableRandomX = 23, StableRandomXY = 24, StableRandomXYZ = 25, StableRandomXYZW = 26, VaryingRandomX = 27, VaryingRandomXY = 28, VaryingRandomXYZ = 29, VaryingRandomXYZW = 30, Custom1X = 31, Custom1XY = 32, Custom1XYZ = 33, Custom1XYZW = 34, Custom2X = 35, Custom2XY = 36, Custom2XYZ = 37, Custom2XYZW = 38, NoiseSumX = 39, NoiseSumXY = 40, NoiseSumXYZ = 41, NoiseImpulseX = 42, NoiseImpulseXY = 43, NoiseImpulseXYZ = 44, MeshIndex = 45 }
        /** The type of shape used for influencing particles in the Force Field Component.
        */
        enum ParticleSystemForceFieldShape
        { Sphere = 0, Hemisphere = 1, Cylinder = 2, Box = 3 }
        /** All possible Particle System vertex shader inputs.
        */
        enum ParticleSystemVertexStreams
        { Position = 1, Normal = 2, Tangent = 4, Color = 8, UV = 16, UV2BlendAndFrame = 32, CenterAndVertexID = 64, Size = 128, Rotation = 256, Velocity = 512, Lifetime = 1024, Custom1 = 2048, Custom2 = 4096, Random = 8192, None = 0, All = 2147483647 }
        /** Use these flags to constrain motion of Rigidbodies.
        */
        enum RigidbodyConstraints
        { None = 0, FreezePositionX = 2, FreezePositionY = 4, FreezePositionZ = 8, FreezeRotationX = 16, FreezeRotationY = 32, FreezeRotationZ = 64, FreezePosition = 14, FreezeRotation = 112, FreezeAll = 126 }
        /** Use ForceMode to specify how to apply a force using Rigidbody.AddForce or ArticulationBody.AddForce.
        */
        enum ForceMode
        { Force = 0, Acceleration = 5, Impulse = 1, VelocityChange = 2 }
        /** Determines how to snap physics joints back to its constrained position when it drifts off too much.
        */
        enum JointProjectionMode
        { None = 0, PositionAndRotation = 1, PositionOnly = 2 }
        /** Cooking options that are available with MeshCollider.
        */
        enum MeshColliderCookingOptions
        { None = 0, InflateConvexMesh = 1, CookForFasterSimulation = 2, EnableMeshCleaning = 4, WeldColocatedVertices = 8, UseFastMidphase = 16 }
        /** WheelFrictionCurve is used by the WheelCollider to describe friction properties of the wheel tire.
        */
        class WheelFrictionCurve extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Extremum point slip (default 1).
            */
            public get extremumSlip(): number;
            public set extremumSlip(value: number);
            /** Force at the extremum slip (default 20000).
            */
            public get extremumValue(): number;
            public set extremumValue(value: number);
            /** Asymptote point slip (default 2).
            */
            public get asymptoteSlip(): number;
            public set asymptoteSlip(value: number);
            /** Force at the asymptote slip (default 10000).
            */
            public get asymptoteValue(): number;
            public set asymptoteValue(value: number);
            /** Multiplier for the extremumValue and asymptoteValue values (default 1).
            */
            public get stiffness(): number;
            public set stiffness(value: number);
        }
        /** The limits defined by the CharacterJoint.
        */
        class SoftJointLimit extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The limit position/angle of the joint (in degrees).
            */
            public get limit(): number;
            public set limit(value: number);
            /** When the joint hits the limit, it can be made to bounce off it.
            */
            public get bounciness(): number;
            public set bounciness(value: number);
            /** Determines how far ahead in space the solver can "see" the joint limit.
            */
            public get contactDistance(): number;
            public set contactDistance(value: number);
        }
        /** The configuration of the spring attached to the joint's limits: linear and angular. Used by CharacterJoint and ConfigurableJoint.
        */
        class SoftJointLimitSpring extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The stiffness of the spring limit. When stiffness is zero the limit is hard, otherwise soft.
            */
            public get spring(): number;
            public set spring(value: number);
            /** The damping of the spring limit. In effect when the stiffness of the sprint limit is not zero.
            */
            public get damper(): number;
            public set damper(value: number);
        }
        /** How the joint's movement will behave along its local X axis.
        */
        class JointDrive extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Strength of a rubber-band pull toward the defined direction. Only used if mode includes Position.
            */
            public get positionSpring(): number;
            public set positionSpring(value: number);
            /** Resistance strength against the Position Spring. Only used if mode includes Position.
            */
            public get positionDamper(): number;
            public set positionDamper(value: number);
            /** Amount of force applied to push the object toward the defined direction.
            */
            public get maximumForce(): number;
            public set maximumForce(value: number);
        }
        /** The ConfigurableJoint attempts to attain position / velocity targets based on this flag.
        */
        enum JointDriveMode
        { None = 0, Position = 1, Velocity = 2, PositionAndVelocity = 3 }
        /** Rigidbody interpolation mode.
        */
        enum RigidbodyInterpolation
        { None = 0, Interpolate = 1, Extrapolate = 2 }
        /** The JointMotor is used to motorize a joint.
        */
        class JointMotor extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The motor will apply a force up to force to achieve targetVelocity.
            */
            public get targetVelocity(): number;
            public set targetVelocity(value: number);
            /** The motor will apply a force.
            */
            public get force(): number;
            public set force(value: number);
            /** If freeSpin is enabled the motor will only accelerate but never slow down.
            */
            public get freeSpin(): boolean;
            public set freeSpin(value: boolean);
        }
        /** JointSpring is used add a spring force to HingeJoint and PhysicMaterial.
        */
        class JointSpring extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The spring forces used to reach the target position.
            */
            public spring : number
            /** The damper force uses to dampen the spring.
            */
            public damper : number
            /** The target position the joint attempts to reach.
            */
            public targetPosition : number
        }
        /** JointLimits is used by the HingeJoint to limit the joints angle.
        */
        class JointLimits extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The lower angular limit (in degrees) of the joint.
            */
            public get min(): number;
            public set min(value: number);
            /** The upper angular limit (in degrees) of the joint.
            */
            public get max(): number;
            public set max(value: number);
            /** Determines the size of the bounce when the joint hits it's limit. Also known as restitution.
            */
            public get bounciness(): number;
            public set bounciness(value: number);
            /** The minimum impact velocity which will cause the joint to bounce.
            */
            public get bounceMinVelocity(): number;
            public set bounceMinVelocity(value: number);
            /** Distance inside the limit value at which the limit will be considered to be active by the solver.
            */
            public get contactDistance(): number;
            public set contactDistance(value: number);
        }
        /** ControllerColliderHit is used by CharacterController.OnControllerColliderHit to give detailed information about the collision and how to deal with it.
        */
        class ControllerColliderHit extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The controller that hit the collider.
            */
            public get controller(): UnityEngine.CharacterController;
            /** The collider that was hit by the controller.
            */
            public get collider(): UnityEngine.Collider;
            /** The rigidbody that was hit by the controller.
            */
            public get rigidbody(): UnityEngine.Rigidbody;
            /** The game object that was hit by the controller.
            */
            public get gameObject(): UnityEngine.GameObject;
            /** The transform that was hit by the controller.
            */
            public get transform(): UnityEngine.Transform;
            /** The impact point in world space.
            */
            public get point(): UnityEngine.Vector3;
            /** The normal of the surface we collided with in world space.
            */
            public get normal(): UnityEngine.Vector3;
            /** The direction the CharacterController was moving in when the collision occured.
            */
            public get moveDirection(): UnityEngine.Vector3;
            /** How far the character has travelled until it hit the collider.
            */
            public get moveLength(): number;
            public constructor ()
        }
        /** A CharacterController allows you to easily do movement constrained by collisions without having to deal with a rigidbody.
        */
        class CharacterController extends UnityEngine.Collider
        {
            protected [__keep_incompatibility]: never;
            /** The current relative velocity of the Character (see notes).
            */
            public get velocity(): UnityEngine.Vector3;
            /** Was the CharacterController touching the ground during the last move?
            */
            public get isGrounded(): boolean;
            /** What part of the capsule collided with the environment during the last CharacterController.Move call.
            */
            public get collisionFlags(): UnityEngine.CollisionFlags;
            /** The radius of the character's capsule.
            */
            public get radius(): number;
            public set radius(value: number);
            /** The height of the character's capsule.
            */
            public get height(): number;
            public set height(value: number);
            /** The center of the character's capsule relative to the transform's position.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** The character controllers slope limit in degrees.
            */
            public get slopeLimit(): number;
            public set slopeLimit(value: number);
            /** The character controllers step offset in meters.
            */
            public get stepOffset(): number;
            public set stepOffset(value: number);
            /** The character's collision skin width.
            */
            public get skinWidth(): number;
            public set skinWidth(value: number);
            /** Gets or sets the minimum move distance of the character controller.
            */
            public get minMoveDistance(): number;
            public set minMoveDistance(value: number);
            /** Determines whether other rigidbodies or character controllers collide with this character controller (by default this is always enabled).
            */
            public get detectCollisions(): boolean;
            public set detectCollisions(value: boolean);
            /** Enables or disables overlap recovery.
            Enables or disables overlap recovery. Used to depenetrate character controllers from static objects when an overlap is detected.
            */
            public get enableOverlapRecovery(): boolean;
            public set enableOverlapRecovery(value: boolean);
            /** Moves the character with speed.
            */
            public SimpleMove ($speed: UnityEngine.Vector3) : boolean
            /** Supplies the movement of a GameObject with an attached CharacterController component.
            */
            public Move ($motion: UnityEngine.Vector3) : UnityEngine.CollisionFlags
            public constructor ()
        }
        /** Control of an object's position through physics simulation.
        */
        class Rigidbody extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** The velocity vector of the rigidbody. It represents the rate of change of Rigidbody position.
            */
            public get velocity(): UnityEngine.Vector3;
            public set velocity(value: UnityEngine.Vector3);
            /** The angular velocity vector of the rigidbody measured in radians per second.
            */
            public get angularVelocity(): UnityEngine.Vector3;
            public set angularVelocity(value: UnityEngine.Vector3);
            /** The drag of the object.
            */
            public get drag(): number;
            public set drag(value: number);
            /** The angular drag of the object.
            */
            public get angularDrag(): number;
            public set angularDrag(value: number);
            /** The mass of the rigidbody.
            */
            public get mass(): number;
            public set mass(value: number);
            /** Controls whether gravity affects this rigidbody.
            */
            public get useGravity(): boolean;
            public set useGravity(value: boolean);
            /** Maximum velocity of a rigidbody when moving out of penetrating state.
            */
            public get maxDepenetrationVelocity(): number;
            public set maxDepenetrationVelocity(value: number);
            /** Controls whether physics affects the rigidbody.
            */
            public get isKinematic(): boolean;
            public set isKinematic(value: boolean);
            /** Controls whether physics will change the rotation of the object.
            */
            public get freezeRotation(): boolean;
            public set freezeRotation(value: boolean);
            /** Controls which degrees of freedom are allowed for the simulation of this Rigidbody.
            */
            public get constraints(): UnityEngine.RigidbodyConstraints;
            public set constraints(value: UnityEngine.RigidbodyConstraints);
            /** The Rigidbody's collision detection mode.
            */
            public get collisionDetectionMode(): UnityEngine.CollisionDetectionMode;
            public set collisionDetectionMode(value: UnityEngine.CollisionDetectionMode);
            /** The center of mass relative to the transform's origin.
            */
            public get centerOfMass(): UnityEngine.Vector3;
            public set centerOfMass(value: UnityEngine.Vector3);
            /** The center of mass of the rigidbody in world space (Read Only).
            */
            public get worldCenterOfMass(): UnityEngine.Vector3;
            /** The rotation of the inertia tensor.
            */
            public get inertiaTensorRotation(): UnityEngine.Quaternion;
            public set inertiaTensorRotation(value: UnityEngine.Quaternion);
            /** The inertia tensor of this body, defined as a diagonal matrix in a reference frame positioned at this body's center of mass and rotated by Rigidbody.inertiaTensorRotation.
            */
            public get inertiaTensor(): UnityEngine.Vector3;
            public set inertiaTensor(value: UnityEngine.Vector3);
            /** Should collision detection be enabled? (By default always enabled).
            */
            public get detectCollisions(): boolean;
            public set detectCollisions(value: boolean);
            /** The position of the rigidbody.
            */
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            /** The rotation of the Rigidbody.
            */
            public get rotation(): UnityEngine.Quaternion;
            public set rotation(value: UnityEngine.Quaternion);
            /** Interpolation allows you to smooth out the effect of running physics at a fixed frame rate.
            */
            public get interpolation(): UnityEngine.RigidbodyInterpolation;
            public set interpolation(value: UnityEngine.RigidbodyInterpolation);
            /** The solverIterations determines how accurately Rigidbody joints and collision contacts are resolved. Overrides Physics.defaultSolverIterations. Must be positive.
            */
            public get solverIterations(): number;
            public set solverIterations(value: number);
            /** The mass-normalized energy threshold, below which objects start going to sleep.
            */
            public get sleepThreshold(): number;
            public set sleepThreshold(value: number);
            /** The maximimum angular velocity of the rigidbody measured in radians per second. (Default 7) range { 0, infinity }.
            */
            public get maxAngularVelocity(): number;
            public set maxAngularVelocity(value: number);
            /** The solverVelocityIterations affects how how accurately Rigidbody joints and collision contacts are resolved. Overrides Physics.defaultSolverVelocityIterations. Must be positive.
            */
            public get solverVelocityIterations(): number;
            public set solverVelocityIterations(value: number);
            /** Sets the mass based on the attached colliders assuming a constant density.
            */
            public SetDensity ($density: number) : void
            /** Moves the kinematic Rigidbody towards position.
            * @param position Provides the new position for the Rigidbody object.
            */
            public MovePosition ($position: UnityEngine.Vector3) : void
            /** Rotates the rigidbody to rotation.
            * @param rot The new rotation for the Rigidbody.
            */
            public MoveRotation ($rot: UnityEngine.Quaternion) : void
            public Sleep () : void
            public IsSleeping () : boolean
            public WakeUp () : void
            public ResetCenterOfMass () : void
            public ResetInertiaTensor () : void
            /** The velocity relative to the rigidbody at the point relativePoint.
            */
            public GetRelativePointVelocity ($relativePoint: UnityEngine.Vector3) : UnityEngine.Vector3
            /** The velocity of the rigidbody at the point worldPoint in global space.
            */
            public GetPointVelocity ($worldPoint: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Adds a force to the Rigidbody.
            * @param force Force vector in world coordinates.
            * @param mode Type of force to apply.
            */
            public AddForce ($force: UnityEngine.Vector3, $mode: UnityEngine.ForceMode) : void
            /** Adds a force to the Rigidbody.
            * @param force Force vector in world coordinates.
            * @param mode Type of force to apply.
            */
            public AddForce ($force: UnityEngine.Vector3) : void
            /** Adds a force to the Rigidbody.
            * @param x Size of force along the world x-axis.
            * @param y Size of force along the world y-axis.
            * @param z Size of force along the world z-axis.
            * @param mode Type of force to apply.
            */
            public AddForce ($x: number, $y: number, $z: number, $mode: UnityEngine.ForceMode) : void
            /** Adds a force to the Rigidbody.
            * @param x Size of force along the world x-axis.
            * @param y Size of force along the world y-axis.
            * @param z Size of force along the world z-axis.
            * @param mode Type of force to apply.
            */
            public AddForce ($x: number, $y: number, $z: number) : void
            /** Adds a force to the rigidbody relative to its coordinate system.
            * @param force Force vector in local coordinates.
            * @param mode Type of force to apply.
            */
            public AddRelativeForce ($force: UnityEngine.Vector3, $mode: UnityEngine.ForceMode) : void
            /** Adds a force to the rigidbody relative to its coordinate system.
            * @param force Force vector in local coordinates.
            * @param mode Type of force to apply.
            */
            public AddRelativeForce ($force: UnityEngine.Vector3) : void
            /** Adds a force to the rigidbody relative to its coordinate system.
            * @param x Size of force along the local x-axis.
            * @param y Size of force along the local y-axis.
            * @param z Size of force along the local z-axis.
            * @param mode Type of force to apply.
            */
            public AddRelativeForce ($x: number, $y: number, $z: number, $mode: UnityEngine.ForceMode) : void
            /** Adds a force to the rigidbody relative to its coordinate system.
            * @param x Size of force along the local x-axis.
            * @param y Size of force along the local y-axis.
            * @param z Size of force along the local z-axis.
            * @param mode Type of force to apply.
            */
            public AddRelativeForce ($x: number, $y: number, $z: number) : void
            /** Adds a torque to the rigidbody.
            * @param torque Torque vector in world coordinates.
            * @param mode The type of torque to apply.
            */
            public AddTorque ($torque: UnityEngine.Vector3, $mode: UnityEngine.ForceMode) : void
            /** Adds a torque to the rigidbody.
            * @param torque Torque vector in world coordinates.
            * @param mode The type of torque to apply.
            */
            public AddTorque ($torque: UnityEngine.Vector3) : void
            /** Adds a torque to the rigidbody.
            * @param x Size of torque along the world x-axis.
            * @param y Size of torque along the world y-axis.
            * @param z Size of torque along the world z-axis.
            * @param mode The type of torque to apply.
            */
            public AddTorque ($x: number, $y: number, $z: number, $mode: UnityEngine.ForceMode) : void
            /** Adds a torque to the rigidbody.
            * @param x Size of torque along the world x-axis.
            * @param y Size of torque along the world y-axis.
            * @param z Size of torque along the world z-axis.
            * @param mode The type of torque to apply.
            */
            public AddTorque ($x: number, $y: number, $z: number) : void
            /** Adds a torque to the rigidbody relative to its coordinate system.
            * @param torque Torque vector in local coordinates.
            * @param mode Type of force to apply.
            */
            public AddRelativeTorque ($torque: UnityEngine.Vector3, $mode: UnityEngine.ForceMode) : void
            /** Adds a torque to the rigidbody relative to its coordinate system.
            * @param torque Torque vector in local coordinates.
            * @param mode Type of force to apply.
            */
            public AddRelativeTorque ($torque: UnityEngine.Vector3) : void
            /** Adds a torque to the rigidbody relative to its coordinate system.
            * @param x Size of torque along the local x-axis.
            * @param y Size of torque along the local y-axis.
            * @param z Size of torque along the local z-axis.
            * @param mode Type of force to apply.
            */
            public AddRelativeTorque ($x: number, $y: number, $z: number, $mode: UnityEngine.ForceMode) : void
            /** Adds a torque to the rigidbody relative to its coordinate system.
            * @param x Size of torque along the local x-axis.
            * @param y Size of torque along the local y-axis.
            * @param z Size of torque along the local z-axis.
            * @param mode Type of force to apply.
            */
            public AddRelativeTorque ($x: number, $y: number, $z: number) : void
            /** Applies force at position. As a result this will apply a torque and force on the object.
            * @param force Force vector in world coordinates.
            * @param position Position in world coordinates.
            * @param mode Type of force to apply.
            */
            public AddForceAtPosition ($force: UnityEngine.Vector3, $position: UnityEngine.Vector3, $mode: UnityEngine.ForceMode) : void
            /** Applies force at position. As a result this will apply a torque and force on the object.
            * @param force Force vector in world coordinates.
            * @param position Position in world coordinates.
            * @param mode Type of force to apply.
            */
            public AddForceAtPosition ($force: UnityEngine.Vector3, $position: UnityEngine.Vector3) : void
            /** Applies a force to a rigidbody that simulates explosion effects.
            * @param explosionForce The force of the explosion (which may be modified by distance).
            * @param explosionPosition The centre of the sphere within which the explosion has its effect.
            * @param explosionRadius The radius of the sphere within which the explosion has its effect.
            * @param upwardsModifier Adjustment to the apparent position of the explosion to make it seem to lift objects.
            * @param mode The method used to apply the force to its targets.
            */
            public AddExplosionForce ($explosionForce: number, $explosionPosition: UnityEngine.Vector3, $explosionRadius: number, $upwardsModifier: number, $mode: UnityEngine.ForceMode) : void
            /** Applies a force to a rigidbody that simulates explosion effects.
            * @param explosionForce The force of the explosion (which may be modified by distance).
            * @param explosionPosition The centre of the sphere within which the explosion has its effect.
            * @param explosionRadius The radius of the sphere within which the explosion has its effect.
            * @param upwardsModifier Adjustment to the apparent position of the explosion to make it seem to lift objects.
            * @param mode The method used to apply the force to its targets.
            */
            public AddExplosionForce ($explosionForce: number, $explosionPosition: UnityEngine.Vector3, $explosionRadius: number, $upwardsModifier: number) : void
            /** Applies a force to a rigidbody that simulates explosion effects.
            * @param explosionForce The force of the explosion (which may be modified by distance).
            * @param explosionPosition The centre of the sphere within which the explosion has its effect.
            * @param explosionRadius The radius of the sphere within which the explosion has its effect.
            * @param upwardsModifier Adjustment to the apparent position of the explosion to make it seem to lift objects.
            * @param mode The method used to apply the force to its targets.
            */
            public AddExplosionForce ($explosionForce: number, $explosionPosition: UnityEngine.Vector3, $explosionRadius: number) : void
            /** The closest point to the bounding box of the attached colliders.
            */
            public ClosestPointOnBounds ($position: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Tests if a rigidbody would collide with anything, if it was moved through the Scene.
            * @param direction The direction into which to sweep the rigidbody.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit (See Also: RaycastHit).
            * @param maxDistance The length of the sweep.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns True when the rigidbody sweep intersects any collider, otherwise false. 
            */
            public SweepTest ($direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public SweepTest ($direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number) : boolean
            public SweepTest ($direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>) : boolean
            /** Like Rigidbody.SweepTest, but returns all hits.
            * @param direction The direction into which to sweep the rigidbody.
            * @param maxDistance The length of the sweep.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns An array of all colliders hit in the sweep. 
            */
            public SweepTestAll ($direction: UnityEngine.Vector3, $maxDistance: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : System.Array$1<UnityEngine.RaycastHit>
            public SweepTestAll ($direction: UnityEngine.Vector3, $maxDistance: number) : System.Array$1<UnityEngine.RaycastHit>
            public SweepTestAll ($direction: UnityEngine.Vector3) : System.Array$1<UnityEngine.RaycastHit>
            public constructor ()
        }
        /** Describes how physics materials of the colliding objects are combined.
        The friction force as well as the residual bounce impulse are applied symmertrically to both of the colliders in contact, so each pair of overlapping colliders must have a single set of friction and bouciness settings. However, one can set arbitrary physics materials to any colliders. For that particular reason, there is a mechanism that allows the combination of two different sets of properties that correspond to each of the colliders in contact into one set to be used in the solver.
        Specifying Average, Maximum, Minimum or Multiply as the physics material combine mode, you directly set the function that is used to combine the settings corresponding to the two overlapping colliders into one set of settings that can be used to apply the material effect.
        Note that there is a special case when the two overlapping colliders have physics materials with different combine modes set. In this particular case, the function that has the highest priority is used. The priority order is as follows: Average < Minimum < Multiply < Maximum. For example, if one material has Average set but the other one has Maximum, then the combine function to be used is Maximum, since it has higher priority.
        */
        enum PhysicMaterialCombine
        { Average = 0, Minimum = 2, Multiply = 1, Maximum = 3 }
        /** Describes a collision.
        */
        class Collision extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The relative linear velocity of the two colliding objects (Read Only).
            */
            public get relativeVelocity(): UnityEngine.Vector3;
            /** The Rigidbody we hit (Read Only). This is null if the object we hit is a collider with no rigidbody attached.
            */
            public get rigidbody(): UnityEngine.Rigidbody;
            /** The ArticulationBody of the collider that your GameObject collides with (Read Only).
            */
            public get articulationBody(): UnityEngine.ArticulationBody;
            /** The Rigidbody or ArticulationBody of the collider that your Component collides with (Read Only).
            */
            public get body(): UnityEngine.Component;
            /** The Collider we hit (Read Only).
            */
            public get collider(): UnityEngine.Collider;
            /** The Transform of the object we hit (Read Only).
            */
            public get transform(): UnityEngine.Transform;
            /** The GameObject whose collider you are colliding with. (Read Only).
            */
            public get gameObject(): UnityEngine.GameObject;
            /** Gets the number of contacts for this collision.
            */
            public get contactCount(): number;
            /** The contact points generated by the physics engine. You should avoid using this as it produces memory garbage. Use GetContact or GetContacts instead.
            */
            public get contacts(): System.Array$1<UnityEngine.ContactPoint>;
            /** The total impulse applied to this contact pair to resolve the collision.
            */
            public get impulse(): UnityEngine.Vector3;
            /** Gets the contact point at the specified index.
            * @param index The index of the contact to retrieve.
            * @returns The contact at the specified index. 
            */
            public GetContact ($index: number) : UnityEngine.ContactPoint
            /** Retrieves all contact points for this collision.
            * @param contacts An array of ContactPoint used to receive the results.
            * @returns Returns the number of contacts placed in the contacts array. 
            */
            public GetContacts ($contacts: System.Array$1<UnityEngine.ContactPoint>) : number
            public GetContacts ($contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint>) : number
            public constructor ()
        }
        /** A body that forms part of a Physics articulation.
        */
        class ArticulationBody extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The type of joint connecting this body to its parent body.
            */
            public get jointType(): UnityEngine.ArticulationJointType;
            public set jointType(value: UnityEngine.ArticulationJointType);
            /** Position of the anchor relative to this body.
            */
            public get anchorPosition(): UnityEngine.Vector3;
            public set anchorPosition(value: UnityEngine.Vector3);
            /** Position of the anchor relative to this body's parent.
            */
            public get parentAnchorPosition(): UnityEngine.Vector3;
            public set parentAnchorPosition(value: UnityEngine.Vector3);
            /** Rotation of the anchor relative to this body.
            */
            public get anchorRotation(): UnityEngine.Quaternion;
            public set anchorRotation(value: UnityEngine.Quaternion);
            /** Rotation of the anchor relative to this body's parent.
            */
            public get parentAnchorRotation(): UnityEngine.Quaternion;
            public set parentAnchorRotation(value: UnityEngine.Quaternion);
            /** Indicates whether this body is the root body of the articulation (Read Only).
            */
            public get isRoot(): boolean;
            /** Whether the parent anchor should be computed automatically or not.
            */
            public get matchAnchors(): boolean;
            public set matchAnchors(value: boolean);
            /** The type of lock along X axis of movement.
            */
            public get linearLockX(): UnityEngine.ArticulationDofLock;
            public set linearLockX(value: UnityEngine.ArticulationDofLock);
            /** The type of lock along Y axis of movement.
            */
            public get linearLockY(): UnityEngine.ArticulationDofLock;
            public set linearLockY(value: UnityEngine.ArticulationDofLock);
            /** The type of lock along Z axis of movement.
            */
            public get linearLockZ(): UnityEngine.ArticulationDofLock;
            public set linearLockZ(value: UnityEngine.ArticulationDofLock);
            /** The magnitude of the conical swing angle relative to Y axis.
            */
            public get swingYLock(): UnityEngine.ArticulationDofLock;
            public set swingYLock(value: UnityEngine.ArticulationDofLock);
            /** The magnitude of the conical swing angle relative to Z axis.
            */
            public get swingZLock(): UnityEngine.ArticulationDofLock;
            public set swingZLock(value: UnityEngine.ArticulationDofLock);
            /** The type of lock for twist movement.
            */
            public get twistLock(): UnityEngine.ArticulationDofLock;
            public set twistLock(value: UnityEngine.ArticulationDofLock);
            /** The properties of drive along or around X.
            */
            public get xDrive(): UnityEngine.ArticulationDrive;
            public set xDrive(value: UnityEngine.ArticulationDrive);
            /** The properties of drive along or around Y.
            */
            public get yDrive(): UnityEngine.ArticulationDrive;
            public set yDrive(value: UnityEngine.ArticulationDrive);
            /** The properties of drive along or around Z.
            */
            public get zDrive(): UnityEngine.ArticulationDrive;
            public set zDrive(value: UnityEngine.ArticulationDrive);
            /** Allows you to specify that this body is not movable.
            */
            public get immovable(): boolean;
            public set immovable(value: boolean);
            /** Controls whether gravity affects this articulation body.
            */
            public get useGravity(): boolean;
            public set useGravity(value: boolean);
            /** Damping factor that affects how this body resists linear motion.
            */
            public get linearDamping(): number;
            public set linearDamping(value: number);
            /** Damping factor that affects how this body resists rotations.
            */
            public get angularDamping(): number;
            public set angularDamping(value: number);
            /** Allows you to specify the amount of friction that is applied as a result of the parent body moving relative to this body.
            */
            public get jointFriction(): number;
            public set jointFriction(value: number);
            /** Linear velocity of the body defined in world space.
            */
            public get velocity(): UnityEngine.Vector3;
            public set velocity(value: UnityEngine.Vector3);
            /** The angular velocity of the body defined in world space.
            */
            public get angularVelocity(): UnityEngine.Vector3;
            public set angularVelocity(value: UnityEngine.Vector3);
            /** The mass of this articulation body.
            */
            public get mass(): number;
            public set mass(value: number);
            /** The center of mass of the body defined in local space.
            */
            public get centerOfMass(): UnityEngine.Vector3;
            public set centerOfMass(value: UnityEngine.Vector3);
            /** The center of mass of the body defined in world space (Read Only).
            */
            public get worldCenterOfMass(): UnityEngine.Vector3;
            /** The inertia tensor of this body.
            */
            public get inertiaTensor(): UnityEngine.Vector3;
            public set inertiaTensor(value: UnityEngine.Vector3);
            /** The rotation of the inertia tensor.
            */
            public get inertiaTensorRotation(): UnityEngine.Quaternion;
            public set inertiaTensorRotation(value: UnityEngine.Quaternion);
            /** The mass-normalized energy threshold, below which objects start going to sleep.
            */
            public get sleepThreshold(): number;
            public set sleepThreshold(value: number);
            /** The solverIterations determines how accurately articulation body joints and collision contacts are resolved.
            */
            public get solverIterations(): number;
            public set solverIterations(value: number);
            /** The solverVelocityIterations affects how accurately articulation body joints and collision contacts are resolved during bounce.
            */
            public get solverVelocityIterations(): number;
            public set solverVelocityIterations(value: number);
            /** The maximimum angular velocity of the articulation body measured in radians per second.
            */
            public get maxAngularVelocity(): number;
            public set maxAngularVelocity(value: number);
            /** The maximum linear velocity of the articulation body measured in meters per second.
            */
            public get maxLinearVelocity(): number;
            public set maxLinearVelocity(value: number);
            /** The maximum joint velocity of the articulation body joint in reduced coordinates.
            */
            public get maxJointVelocity(): number;
            public set maxJointVelocity(value: number);
            /** The maximum velocity of an articulation body when moving out of penetrating state.
            */
            public get maxDepenetrationVelocity(): number;
            public set maxDepenetrationVelocity(value: number);
            /** The joint position in reduced coordinates.
            */
            public get jointPosition(): UnityEngine.ArticulationReducedSpace;
            public set jointPosition(value: UnityEngine.ArticulationReducedSpace);
            /** The joint velocity in reduced coordinates.
            */
            public get jointVelocity(): UnityEngine.ArticulationReducedSpace;
            public set jointVelocity(value: UnityEngine.ArticulationReducedSpace);
            /** The joint acceleration in reduced coordinates.
            */
            public get jointAcceleration(): UnityEngine.ArticulationReducedSpace;
            public set jointAcceleration(value: UnityEngine.ArticulationReducedSpace);
            /** The joint force in reduced coordinates.
            */
            public get jointForce(): UnityEngine.ArticulationReducedSpace;
            public set jointForce(value: UnityEngine.ArticulationReducedSpace);
            /** The amount of degrees of freedom of a body.
            */
            public get dofCount(): number;
            /** The index of the body in the hierarchy of articulation bodies.
            */
            public get index(): number;
            /** The ArticulationBody's collision detection mode.
            */
            public get collisionDetectionMode(): UnityEngine.CollisionDetectionMode;
            public set collisionDetectionMode(value: UnityEngine.CollisionDetectionMode);
            /** Applies a force to the ArticulationBody.
            * @param force The force vector to apply.
            * @param mode The type of force to apply.
            */
            public AddForce ($force: UnityEngine.Vector3, $mode: UnityEngine.ForceMode) : void
            /** Applies a force to the ArticulationBody.
            * @param force The force vector to apply.
            * @param mode The type of force to apply.
            */
            public AddForce ($force: UnityEngine.Vector3) : void
            /** Applies a force to the Articulation Body, relative to its local coordinate system.
            * @param force The force vector in local coordinates.
            * @param mode The type of force to apply.
            */
            public AddRelativeForce ($force: UnityEngine.Vector3, $mode: UnityEngine.ForceMode) : void
            /** Applies a force to the Articulation Body, relative to its local coordinate system.
            * @param force The force vector in local coordinates.
            * @param mode The type of force to apply.
            */
            public AddRelativeForce ($force: UnityEngine.Vector3) : void
            /** Add torque to the articulation body.
            * @param torque The torque to apply.
            * @param mode The type of torque to apply.
            */
            public AddTorque ($torque: UnityEngine.Vector3, $mode: UnityEngine.ForceMode) : void
            /** Add torque to the articulation body.
            * @param torque The torque to apply.
            * @param mode The type of torque to apply.
            */
            public AddTorque ($torque: UnityEngine.Vector3) : void
            /** Applies a torque to the articulation body, relative to its local coordinate system.
            * @param torque The torque vector in local coordinates.
            * @param mode The type of torque to apply.
            */
            public AddRelativeTorque ($torque: UnityEngine.Vector3, $mode: UnityEngine.ForceMode) : void
            /** Applies a torque to the articulation body, relative to its local coordinate system.
            * @param torque The torque vector in local coordinates.
            * @param mode The type of torque to apply.
            */
            public AddRelativeTorque ($torque: UnityEngine.Vector3) : void
            /** Applies a force at a specific position, resulting in applying a torque and force on the object.
            * @param force The force vector in world coordinates.
            * @param position A position in world coordinates.
            * @param mode The type of force to apply.
            */
            public AddForceAtPosition ($force: UnityEngine.Vector3, $position: UnityEngine.Vector3, $mode: UnityEngine.ForceMode) : void
            /** Applies a force at a specific position, resulting in applying a torque and force on the object.
            * @param force The force vector in world coordinates.
            * @param position A position in world coordinates.
            * @param mode The type of force to apply.
            */
            public AddForceAtPosition ($force: UnityEngine.Vector3, $position: UnityEngine.Vector3) : void
            public ResetCenterOfMass () : void
            public ResetInertiaTensor () : void
            public Sleep () : void
            public IsSleeping () : boolean
            public WakeUp () : void
            /** Teleport the root body of the articulation to a new pose.
            * @param position The new position of the root articulation body.
            * @param rotation The new orientation of the root articulation body.
            */
            public TeleportRoot ($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : void
            /** Return the point on the articulation body that is closest to a given one.
            * @param point The point of interest.
            * @returns The point on the surfaces of all Colliders attached to this articulation body that is closest to the given one. 
            */
            public GetClosestPoint ($point: UnityEngine.Vector3) : UnityEngine.Vector3
            /** The velocity relative to the articulation body at the point relativePoint.
            */
            public GetRelativePointVelocity ($relativePoint: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Gets the velocity of the articulation body at the specified worldPoint in global space.
            */
            public GetPointVelocity ($worldPoint: UnityEngine.Vector3) : UnityEngine.Vector3
            /** Calculates and writes dense Jacobian matrix of the articulation body hierarchy to the supplied struct.
            * @param jacobian Supplied struct to read back and store Jacobian matrix values. 
            * @returns Number of elements in Jacobian matrix. 
            */
            public GetDenseJacobian ($jacobian: $Ref<UnityEngine.ArticulationJacobian>) : number
            public GetJointPositions ($positions: System.Collections.Generic.List$1<number>) : number
            public SetJointPositions ($positions: System.Collections.Generic.List$1<number>) : void
            public GetJointVelocities ($velocities: System.Collections.Generic.List$1<number>) : number
            public SetJointVelocities ($velocities: System.Collections.Generic.List$1<number>) : void
            public GetJointAccelerations ($accelerations: System.Collections.Generic.List$1<number>) : number
            public SetJointAccelerations ($accelerations: System.Collections.Generic.List$1<number>) : void
            public GetJointForces ($forces: System.Collections.Generic.List$1<number>) : number
            public SetJointForces ($forces: System.Collections.Generic.List$1<number>) : void
            public GetDriveTargets ($targets: System.Collections.Generic.List$1<number>) : number
            public SetDriveTargets ($targets: System.Collections.Generic.List$1<number>) : void
            public GetDriveTargetVelocities ($targetVelocities: System.Collections.Generic.List$1<number>) : number
            public SetDriveTargetVelocities ($targetVelocities: System.Collections.Generic.List$1<number>) : void
            public GetDofStartIndices ($dofStartIndices: System.Collections.Generic.List$1<number>) : number
            public SnapAnchorToClosestContact () : void
            public constructor ()
        }
        /** Describes a contact point where the collision occurs.
        */
        class ContactPoint extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The point of contact.
            */
            public get point(): UnityEngine.Vector3;
            /** Normal of the contact point.
            */
            public get normal(): UnityEngine.Vector3;
            /** The first collider in contact at the point.
            */
            public get thisCollider(): UnityEngine.Collider;
            /** The other collider in contact at the point.
            */
            public get otherCollider(): UnityEngine.Collider;
            /** The distance between the colliders at the contact point.
            */
            public get separation(): number;
        }
        /** CollisionFlags is a bitmask returned by CharacterController.Move.
        */
        enum CollisionFlags
        { None = 0, Sides = 1, Above = 2, Below = 4, CollidedSides = 1, CollidedAbove = 2, CollidedBelow = 4 }
        /** Overrides the global Physics.queriesHitTriggers.
        */
        enum QueryTriggerInteraction
        { UseGlobal = 0, Ignore = 1, Collide = 2 }
        /** The collision detection mode constants used for Rigidbody.collisionDetectionMode.
        */
        enum CollisionDetectionMode
        { Discrete = 0, Continuous = 1, ContinuousDynamic = 2, ContinuousSpeculative = 3 }
        /** Constrains movement for a ConfigurableJoint along the 6 axes.
        */
        enum ConfigurableJointMotion
        { Locked = 0, Limited = 1, Free = 2 }
        /** Control ConfigurableJoint's rotation with either X & YZ or Slerp Drive.
        */
        enum RotationDriveMode
        { XYAndZ = 0, Slerp = 1 }
        /** The type of the joint that restricts movement of the two connected articulation bodies.
        */
        enum ArticulationJointType
        { FixedJoint = 0, PrismaticJoint = 1, RevoluteJoint = 2, SphericalJoint = 3 }
        /** The lock type applied to a particular degree of freedom of an articulation body.
        */
        enum ArticulationDofLock
        { LockedMotion = 0, LimitedMotion = 1, FreeMotion = 2 }
        /** Drive applies forces and torques to the connected bodies.
        */
        class ArticulationDrive extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The lower limit of motion for a particular degree of freedom.
            */
            public lowerLimit : number
            /** The upper limit of motion for a particular degree of freedom.
            */
            public upperLimit : number
            /** The stiffness of the spring connected to this drive.
            */
            public stiffness : number
            /** The damping of the spring attached to this drive.
            */
            public damping : number
            /** The maximum force this drive can apply to a body.
            */
            public forceLimit : number
            /** The target value the drive will try to reach.
            */
            public target : number
            /** The velocity of the body this drive will try to reach.
            */
            public targetVelocity : number
        }
        /** Coordinates in reduced space.
        */
        class ArticulationReducedSpace extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The number of degrees of freedom of a body.
            */
            public dofCount : number
            public get_Item ($i: number) : number
            public set_Item ($i: number, $value: number) : void
            public constructor ($a: number)
            public constructor ($a: number, $b: number)
            public constructor ($a: number, $b: number, $c: number)
            public constructor ()
        }
        /** The floating point dense Jacobian matrix of the articulation body hierarchy.
        */
        class ArticulationJacobian extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Number of rows of the matrix is equal to the number of articulation bodies in hierarchy times 6: 3 rows of linearpositional DOF and 3 rows of angularrotational DOF for each body.
            */
            public get rows(): number;
            public set rows(value: number);
            /** Number of columns of the matrix is equal to the total number of all joint degrees of freedom(DOF), plus 6 if ArticulationBody.immovable is false.
            */
            public get columns(): number;
            public set columns(value: number);
            /** List of floats representing Jacobian matrix.
            */
            public get elements(): System.Collections.Generic.List$1<number>;
            public set elements(value: System.Collections.Generic.List$1<number>);
            public constructor ($rows: number, $cols: number)
            public constructor ()
        }
        /** Global physics properties and helper methods.
        */
        class Physics extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Layer mask constant to select ignore raycast layer.
            */
            public static IgnoreRaycastLayer : number
            /** Layer mask constant to select default raycast layers.
            */
            public static DefaultRaycastLayers : number
            /** Layer mask constant to select all layers.
            */
            public static AllLayers : number
            /** The gravity applied to all rigid bodies in the Scene.
            */
            public static get gravity(): UnityEngine.Vector3;
            public static set gravity(value: UnityEngine.Vector3);
            /** The default contact offset of the newly created colliders.
            */
            public static get defaultContactOffset(): number;
            public static set defaultContactOffset(value: number);
            /** The mass-normalized energy threshold, below which objects start going to sleep.
            */
            public static get sleepThreshold(): number;
            public static set sleepThreshold(value: number);
            /** Specifies whether queries (raycasts, spherecasts, overlap tests, etc.) hit Triggers by default.
            */
            public static get queriesHitTriggers(): boolean;
            public static set queriesHitTriggers(value: boolean);
            /** Whether physics queries should hit back-face triangles.
            */
            public static get queriesHitBackfaces(): boolean;
            public static set queriesHitBackfaces(value: boolean);
            /** Two colliding objects with a relative velocity below this will not bounce (default 2). Must be positive.
            */
            public static get bounceThreshold(): number;
            public static set bounceThreshold(value: number);
            /** The maximum default velocity needed to move a Rigidbody's collider out of another collider's surface penetration. Must be positive.
            */
            public static get defaultMaxDepenetrationVelocity(): number;
            public static set defaultMaxDepenetrationVelocity(value: number);
            /** The defaultSolverIterations determines how accurately Rigidbody joints and collision contacts are resolved. (default 6). Must be positive.
            */
            public static get defaultSolverIterations(): number;
            public static set defaultSolverIterations(value: number);
            /** The defaultSolverVelocityIterations affects how accurately the Rigidbody joints and collision contacts are resolved. (default 1). Must be positive.
            */
            public static get defaultSolverVelocityIterations(): number;
            public static set defaultSolverVelocityIterations(value: number);
            /** Default maximum angular speed of the dynamic Rigidbody, in radians (default 50).
            */
            public static get defaultMaxAngularSpeed(): number;
            public static set defaultMaxAngularSpeed(value: number);
            /** Enables an improved patch friction mode that guarantees static and dynamic friction do not exceed analytical results.
            */
            public static get improvedPatchFriction(): boolean;
            public static set improvedPatchFriction(value: boolean);
            /** The PhysicsScene automatically created when Unity starts.
            */
            public static get defaultPhysicsScene(): UnityEngine.PhysicsScene;
            /** Sets whether the physics should be simulated automatically or not.
            */
            public static get autoSimulation(): boolean;
            public static set autoSimulation(value: boolean);
            /** Whether or not to automatically sync transform changes with the physics system whenever a Transform component changes.
            */
            public static get autoSyncTransforms(): boolean;
            public static set autoSyncTransforms(value: boolean);
            /** Determines whether the garbage collector should reuse only a single instance of a Collision type for all collision callbacks.
            */
            public static get reuseCollisionCallbacks(): boolean;
            public static set reuseCollisionCallbacks(value: boolean);
            /** Sets the minimum separation distance for cloth inter-collision.
            */
            public static get interCollisionDistance(): number;
            public static set interCollisionDistance(value: number);
            /** Sets the cloth inter-collision stiffness.
            */
            public static get interCollisionStiffness(): number;
            public static set interCollisionStiffness(value: number);
            public static get interCollisionSettingsToggle(): boolean;
            public static set interCollisionSettingsToggle(value: boolean);
            /** Cloth Gravity setting.
            Set gravity for all cloth components.
            */
            public static get clothGravity(): UnityEngine.Vector3;
            public static set clothGravity(value: UnityEngine.Vector3);
            public static add_ContactModifyEvent ($value: System.Action$2<UnityEngine.PhysicsScene, Unity.Collections.NativeArray$1<UnityEngine.ModifiableContactPair>>) : void
            public static remove_ContactModifyEvent ($value: System.Action$2<UnityEngine.PhysicsScene, Unity.Collections.NativeArray$1<UnityEngine.ModifiableContactPair>>) : void
            public static add_ContactModifyEventCCD ($value: System.Action$2<UnityEngine.PhysicsScene, Unity.Collections.NativeArray$1<UnityEngine.ModifiableContactPair>>) : void
            public static remove_ContactModifyEventCCD ($value: System.Action$2<UnityEngine.PhysicsScene, Unity.Collections.NativeArray$1<UnityEngine.ModifiableContactPair>>) : void
            /** Makes the collision detection system ignore all collisions between collider1 and collider2.
            * @param collider1 Any collider.
            * @param collider2 Another collider you want to have collider1 to start or stop ignoring collisions with.
            * @param ignore Whether or not the collisions between the two colliders should be ignored or not.
            */
            public static IgnoreCollision ($collider1: UnityEngine.Collider, $collider2: UnityEngine.Collider, $ignore: boolean) : void
            public static IgnoreCollision ($collider1: UnityEngine.Collider, $collider2: UnityEngine.Collider) : void
            /** Makes the collision detection system ignore all collisions between any collider in layer1 and any collider in layer2.
            Note that IgnoreLayerCollision will reset the trigger state of affected colliders, so you might receive OnTriggerExit and OnTriggerEnter messages in response to calling this.
            */
            public static IgnoreLayerCollision ($layer1: number, $layer2: number, $ignore: boolean) : void
            public static IgnoreLayerCollision ($layer1: number, $layer2: number) : void
            /** Are collisions between layer1 and layer2 being ignored?
            */
            public static GetIgnoreLayerCollision ($layer1: number, $layer2: number) : boolean
            /** Checks whether the collision detection system will ignore all collisionstriggers between collider1 and collider2/ or not.
            * @param collider1 The first collider to compare to collider2.
            * @param collider2 The second collider to compare to collider1.
            * @returns Whether the collision detection system will ignore all collisionstriggers between collider1 and collider2/ or not. 
            */
            public static GetIgnoreCollision ($collider1: UnityEngine.Collider, $collider2: UnityEngine.Collider) : boolean
            /** Casts a ray, from point origin, in direction direction, of length maxDistance, against all colliders in the Scene.
            * @param origin The starting point of the ray in world coordinates.
            * @param direction The direction of the ray.
            * @param maxDistance The max distance the ray should check for collisions.
            * @param layerMask A that is used to selectively ignore Colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns Returns true if the ray intersects with a Collider, otherwise false. 
            */
            public static Raycast ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static Raycast ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number) : boolean
            public static Raycast ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance: number) : boolean
            public static Raycast ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3) : boolean
            /** Casts a ray against all colliders in the Scene and returns detailed information on what was hit.
            * @param origin The starting point of the ray in world coordinates.
            * @param direction The direction of the ray.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the closest collider was hit. (See Also: RaycastHit).
            * @param maxDistance The max distance the ray should check for collisions.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns Returns true when the ray intersects any collider, otherwise false. 
            */
            public static Raycast ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static Raycast ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number) : boolean
            public static Raycast ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number) : boolean
            public static Raycast ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>) : boolean
            /** Same as above using ray.origin and ray.direction instead of origin and direction.
            * @param ray The starting point and direction of the ray.
            * @param maxDistance The max distance the ray should check for collisions.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns Returns true when the ray intersects any collider, otherwise false. 
            */
            public static Raycast ($ray: UnityEngine.Ray, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static Raycast ($ray: UnityEngine.Ray, $maxDistance: number, $layerMask: number) : boolean
            public static Raycast ($ray: UnityEngine.Ray, $maxDistance: number) : boolean
            public static Raycast ($ray: UnityEngine.Ray) : boolean
            /** Same as above using ray.origin and ray.direction instead of origin and direction.
            * @param ray The starting point and direction of the ray.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the closest collider was hit. (See Also: RaycastHit).
            * @param maxDistance The max distance the ray should check for collisions.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns Returns true when the ray intersects any collider, otherwise false. 
            */
            public static Raycast ($ray: UnityEngine.Ray, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static Raycast ($ray: UnityEngine.Ray, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number) : boolean
            public static Raycast ($ray: UnityEngine.Ray, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number) : boolean
            public static Raycast ($ray: UnityEngine.Ray, $hitInfo: $Ref<UnityEngine.RaycastHit>) : boolean
            /** Returns true if there is any collider intersecting the line between start and end.
            * @param start Start point.
            * @param end End point.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            */
            public static Linecast ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static Linecast ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $layerMask: number) : boolean
            public static Linecast ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3) : boolean
            /** Returns true if there is any collider intersecting the line between start and end.
            * @param start Start point.
            * @param end End point.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
            */
            public static Linecast ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static Linecast ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $layerMask: number) : boolean
            public static Linecast ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>) : boolean
            /** Casts a capsule against all colliders in the Scene and returns detailed information on what was hit.
            * @param point1 The center of the sphere at the start of the capsule.
            * @param point2 The center of the sphere at the end of the capsule.
            * @param radius The radius of the capsule.
            * @param direction The direction into which to sweep the capsule.
            * @param maxDistance The max length of the sweep.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns True when the capsule sweep intersects any collider, otherwise false. 
            */
            public static CapsuleCast ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static CapsuleCast ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number) : boolean
            public static CapsuleCast ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number) : boolean
            public static CapsuleCast ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3) : boolean
            /** * @param point1 The center of the sphere at the start of the capsule.
            * @param point2 The center of the sphere at the end of the capsule.
            * @param radius The radius of the capsule.
            * @param direction The direction into which to sweep the capsule.
            * @param maxDistance The max length of the sweep.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            */
            public static CapsuleCast ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static CapsuleCast ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number) : boolean
            public static CapsuleCast ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number) : boolean
            public static CapsuleCast ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>) : boolean
            /** Casts a sphere along a ray and returns detailed information on what was hit.
            * @param origin The center of the sphere at the start of the sweep.
            * @param radius The radius of the sphere.
            * @param direction The direction into which to sweep the sphere.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
            * @param maxDistance The max length of the cast.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns True when the sphere sweep intersects any collider, otherwise false. 
            */
            public static SphereCast ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static SphereCast ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number) : boolean
            public static SphereCast ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number) : boolean
            public static SphereCast ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>) : boolean
            /** Casts a sphere along a ray and returns detailed information on what was hit.
            * @param ray The starting point and direction of the ray into which the sphere sweep is cast.
            * @param radius The radius of the sphere.
            * @param maxDistance The max length of the cast.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns True when the sphere sweep intersects any collider, otherwise false. 
            */
            public static SphereCast ($ray: UnityEngine.Ray, $radius: number, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static SphereCast ($ray: UnityEngine.Ray, $radius: number, $maxDistance: number, $layerMask: number) : boolean
            public static SphereCast ($ray: UnityEngine.Ray, $radius: number, $maxDistance: number) : boolean
            public static SphereCast ($ray: UnityEngine.Ray, $radius: number) : boolean
            /** * @param ray The starting point and direction of the ray into which the sphere sweep is cast.
            * @param radius The radius of the sphere.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
            * @param maxDistance The max length of the cast.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            */
            public static SphereCast ($ray: UnityEngine.Ray, $radius: number, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static SphereCast ($ray: UnityEngine.Ray, $radius: number, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number) : boolean
            public static SphereCast ($ray: UnityEngine.Ray, $radius: number, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance: number) : boolean
            public static SphereCast ($ray: UnityEngine.Ray, $radius: number, $hitInfo: $Ref<UnityEngine.RaycastHit>) : boolean
            /** Casts the box along a ray and returns detailed information on what was hit.
            * @param center Center of the box.
            * @param halfExtents Half the size of the box in each dimension.
            * @param direction The direction in which to cast the box.
            * @param orientation Rotation of the box.
            * @param maxDistance The max length of the cast.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns True, if any intersections were found. 
            */
            public static BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number) : boolean
            public static BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $maxDistance: number) : boolean
            public static BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion) : boolean
            public static BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3) : boolean
            /** Casts the box along a ray and returns detailed information on what was hit.
            * @param center Center of the box.
            * @param halfExtents Half the size of the box in each dimension.
            * @param direction The direction in which to cast the box.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
            * @param orientation Rotation of the box.
            * @param maxDistance The max length of the cast.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns True, if any intersections were found. 
            */
            public static BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number) : boolean
            public static BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance: number) : boolean
            public static BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion) : boolean
            public static BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>) : boolean
            /** See Also: Raycast.
            * @param origin The starting point of the ray in world coordinates.
            * @param direction The direction of the ray.
            * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
            * @param layermask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            */
            public static RaycastAll ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : System.Array$1<UnityEngine.RaycastHit>
            public static RaycastAll ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number) : System.Array$1<UnityEngine.RaycastHit>
            public static RaycastAll ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance: number) : System.Array$1<UnityEngine.RaycastHit>
            public static RaycastAll ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3) : System.Array$1<UnityEngine.RaycastHit>
            /** Casts a ray through the Scene and returns all hits. Note that order of the results is undefined.
            * @param ray The starting point and direction of the ray.
            * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns An array of RaycastHit objects. Note that the order of the results is undefined. 
            */
            public static RaycastAll ($ray: UnityEngine.Ray, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : System.Array$1<UnityEngine.RaycastHit>
            public static RaycastAll ($ray: UnityEngine.Ray, $maxDistance: number, $layerMask: number) : System.Array$1<UnityEngine.RaycastHit>
            public static RaycastAll ($ray: UnityEngine.Ray, $maxDistance: number) : System.Array$1<UnityEngine.RaycastHit>
            public static RaycastAll ($ray: UnityEngine.Ray) : System.Array$1<UnityEngine.RaycastHit>
            /** Cast a ray through the Scene and store the hits into the buffer.
            * @param ray The starting point and direction of the ray.
            * @param results The buffer to store the hits into.
            * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns The amount of hits stored into the results buffer. 
            */
            public static RaycastNonAlloc ($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : number
            public static RaycastNonAlloc ($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number) : number
            public static RaycastNonAlloc ($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number) : number
            public static RaycastNonAlloc ($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit>) : number
            /** Cast a ray through the Scene and store the hits into the buffer.
            * @param origin The starting point and direction of the ray.
            * @param results The buffer to store the hits into.
            * @param direction The direction of the ray.
            * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @returns The amount of hits stored into the results buffer. 
            */
            public static RaycastNonAlloc ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : number
            public static RaycastNonAlloc ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number) : number
            public static RaycastNonAlloc ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number) : number
            public static RaycastNonAlloc ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>) : number
            /** Like Physics.CapsuleCast, but this function will return all hits the capsule sweep intersects.
            * @param point1 The center of the sphere at the start of the capsule.
            * @param point2 The center of the sphere at the end of the capsule.
            * @param radius The radius of the capsule.
            * @param direction The direction into which to sweep the capsule.
            * @param maxDistance The max length of the sweep.
            * @param layermask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns An array of all colliders hit in the sweep. 
            */
            public static CapsuleCastAll ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : System.Array$1<UnityEngine.RaycastHit>
            public static CapsuleCastAll ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number) : System.Array$1<UnityEngine.RaycastHit>
            public static CapsuleCastAll ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number) : System.Array$1<UnityEngine.RaycastHit>
            public static CapsuleCastAll ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3) : System.Array$1<UnityEngine.RaycastHit>
            /** Like Physics.SphereCast, but this function will return all hits the sphere sweep intersects.
            * @param origin The center of the sphere at the start of the sweep.
            * @param radius The radius of the sphere.
            * @param direction The direction in which to sweep the sphere.
            * @param maxDistance The max length of the sweep.
            * @param layerMask A that is used to selectively ignore colliders when casting a sphere.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns An array of all colliders hit in the sweep. 
            */
            public static SphereCastAll ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : System.Array$1<UnityEngine.RaycastHit>
            public static SphereCastAll ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number, $layerMask: number) : System.Array$1<UnityEngine.RaycastHit>
            public static SphereCastAll ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $maxDistance: number) : System.Array$1<UnityEngine.RaycastHit>
            public static SphereCastAll ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3) : System.Array$1<UnityEngine.RaycastHit>
            /** Like Physics.SphereCast, but this function will return all hits the sphere sweep intersects.
            * @param ray The starting point and direction of the ray into which the sphere sweep is cast.
            * @param radius The radius of the sphere.
            * @param maxDistance The max length of the sweep.
            * @param layerMask A that is used to selectively ignore colliders when casting a sphere.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            */
            public static SphereCastAll ($ray: UnityEngine.Ray, $radius: number, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : System.Array$1<UnityEngine.RaycastHit>
            public static SphereCastAll ($ray: UnityEngine.Ray, $radius: number, $maxDistance: number, $layerMask: number) : System.Array$1<UnityEngine.RaycastHit>
            public static SphereCastAll ($ray: UnityEngine.Ray, $radius: number, $maxDistance: number) : System.Array$1<UnityEngine.RaycastHit>
            public static SphereCastAll ($ray: UnityEngine.Ray, $radius: number) : System.Array$1<UnityEngine.RaycastHit>
            /** Check the given capsule against the physics world and return all overlapping colliders.
            * @param point0 The center of the sphere at the start of the capsule.
            * @param point1 The center of the sphere at the end of the capsule.
            * @param radius The radius of the capsule.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns Colliders touching or inside the capsule. 
            */
            public static OverlapCapsule ($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : System.Array$1<UnityEngine.Collider>
            public static OverlapCapsule ($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number, $layerMask: number) : System.Array$1<UnityEngine.Collider>
            public static OverlapCapsule ($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number) : System.Array$1<UnityEngine.Collider>
            /** Computes and stores colliders touching or inside the sphere.
            * @param position Center of the sphere.
            * @param radius Radius of the sphere.
            * @param layerMask A defines which layers of colliders to include in the query.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns Returns an array with all colliders touching or inside the sphere. 
            */
            public static OverlapSphere ($position: UnityEngine.Vector3, $radius: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : System.Array$1<UnityEngine.Collider>
            public static OverlapSphere ($position: UnityEngine.Vector3, $radius: number, $layerMask: number) : System.Array$1<UnityEngine.Collider>
            public static OverlapSphere ($position: UnityEngine.Vector3, $radius: number) : System.Array$1<UnityEngine.Collider>
            /** Simulate physics in the Scene.
            * @param step The time to advance physics by.
            */
            public static Simulate ($step: number) : void
            public static SyncTransforms () : void
            /** Compute the minimal translation required to separate the given colliders apart at specified poses.
            * @param colliderA The first collider.
            * @param positionA Position of the first collider.
            * @param rotationA Rotation of the first collider.
            * @param colliderB The second collider.
            * @param positionB Position of the second collider.
            * @param rotationB Rotation of the second collider.
            * @param direction Direction along which the translation required to separate the colliders apart is minimal.
            * @param distance The distance along direction that is required to separate the colliders apart.
            * @returns True, if the colliders overlap at the given poses. 
            */
            public static ComputePenetration ($colliderA: UnityEngine.Collider, $positionA: UnityEngine.Vector3, $rotationA: UnityEngine.Quaternion, $colliderB: UnityEngine.Collider, $positionB: UnityEngine.Vector3, $rotationB: UnityEngine.Quaternion, $direction: $Ref<UnityEngine.Vector3>, $distance: $Ref<number>) : boolean
            /** Returns a point on the given collider that is closest to the specified location.
            * @param point Location you want to find the closest point to.
            * @param collider The collider that you find the closest point on.
            * @param position The position of the collider.
            * @param rotation The rotation of the collider.
            * @returns The point on the collider that is closest to the specified location. 
            */
            public static ClosestPoint ($point: UnityEngine.Vector3, $collider: UnityEngine.Collider, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion) : UnityEngine.Vector3
            /** Computes and stores colliders touching or inside the sphere into the provided buffer.
            * @param position Center of the sphere.
            * @param radius Radius of the sphere.
            * @param results The buffer to store the results into.
            * @param layerMask A defines which layers of colliders to include in the query.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns Returns the amount of colliders stored into the results buffer. 
            */
            public static OverlapSphereNonAlloc ($position: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : number
            public static OverlapSphereNonAlloc ($position: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>, $layerMask: number) : number
            public static OverlapSphereNonAlloc ($position: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>) : number
            /** Returns true if there are any colliders overlapping the sphere defined by position and radius in world coordinates.
            * @param position Center of the sphere.
            * @param radius Radius of the sphere.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            */
            public static CheckSphere ($position: UnityEngine.Vector3, $radius: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static CheckSphere ($position: UnityEngine.Vector3, $radius: number, $layerMask: number) : boolean
            public static CheckSphere ($position: UnityEngine.Vector3, $radius: number) : boolean
            /** Casts a capsule against all colliders in the Scene and returns detailed information on what was hit into the buffer.
            * @param point1 The center of the sphere at the start of the capsule.
            * @param point2 The center of the sphere at the end of the capsule.
            * @param radius The radius of the capsule.
            * @param direction The direction into which to sweep the capsule.
            * @param results The buffer to store the hits into.
            * @param maxDistance The max length of the sweep.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns The amount of hits stored into the buffer. 
            */
            public static CapsuleCastNonAlloc ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : number
            public static CapsuleCastNonAlloc ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number) : number
            public static CapsuleCastNonAlloc ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number) : number
            public static CapsuleCastNonAlloc ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>) : number
            /** Cast sphere along the direction and store the results into buffer.
            * @param origin The center of the sphere at the start of the sweep.
            * @param radius The radius of the sphere.
            * @param direction The direction in which to sweep the sphere.
            * @param results The buffer to save the hits into.
            * @param maxDistance The max length of the sweep.
            * @param layerMask A that is used to selectively ignore colliders when casting a sphere.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns The amount of hits stored into the results buffer. 
            */
            public static SphereCastNonAlloc ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : number
            public static SphereCastNonAlloc ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number) : number
            public static SphereCastNonAlloc ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number) : number
            public static SphereCastNonAlloc ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>) : number
            /** Cast sphere along the direction and store the results into buffer.
            * @param ray The starting point and direction of the ray into which the sphere sweep is cast.
            * @param radius The radius of the sphere.
            * @param results The buffer to save the results to.
            * @param maxDistance The max length of the sweep.
            * @param layerMask A that is used to selectively ignore colliders when casting a sphere.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns The amount of hits stored into the results buffer. 
            */
            public static SphereCastNonAlloc ($ray: UnityEngine.Ray, $radius: number, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : number
            public static SphereCastNonAlloc ($ray: UnityEngine.Ray, $radius: number, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number, $layerMask: number) : number
            public static SphereCastNonAlloc ($ray: UnityEngine.Ray, $radius: number, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance: number) : number
            public static SphereCastNonAlloc ($ray: UnityEngine.Ray, $radius: number, $results: System.Array$1<UnityEngine.RaycastHit>) : number
            /** Checks if any colliders overlap a capsule-shaped volume in world space.
            * @param start The center of the sphere at the start of the capsule.
            * @param end The center of the sphere at the end of the capsule.
            * @param radius The radius of the capsule.
            * @param layermask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            */
            public static CheckCapsule ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $radius: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static CheckCapsule ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $radius: number, $layerMask: number) : boolean
            public static CheckCapsule ($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $radius: number) : boolean
            /** Check whether the given box overlaps with other colliders or not.
            * @param center Center of the box.
            * @param halfExtents Half the size of the box in each dimension.
            * @param orientation Rotation of the box.
            * @param layermask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns True, if the box overlaps with any colliders. 
            */
            public static CheckBox ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $layermask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : boolean
            public static CheckBox ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $layerMask: number) : boolean
            public static CheckBox ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion) : boolean
            public static CheckBox ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3) : boolean
            /** Find all colliders touching or inside of the given box.
            * @param center Center of the box.
            * @param halfExtents Half of the size of the box in each dimension.
            * @param orientation Rotation of the box.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns Colliders that overlap with the given box. 
            */
            public static OverlapBox ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : System.Array$1<UnityEngine.Collider>
            public static OverlapBox ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $layerMask: number) : System.Array$1<UnityEngine.Collider>
            public static OverlapBox ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion) : System.Array$1<UnityEngine.Collider>
            public static OverlapBox ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3) : System.Array$1<UnityEngine.Collider>
            /** Find all colliders touching or inside of the given box, and store them into the buffer.
            * @param center Center of the box.
            * @param halfExtents Half of the size of the box in each dimension.
            * @param results The buffer to store the results in.
            * @param orientation Rotation of the box.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns The amount of colliders stored in results. 
            */
            public static OverlapBoxNonAlloc ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.Collider>, $orientation: UnityEngine.Quaternion, $mask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : number
            public static OverlapBoxNonAlloc ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.Collider>, $orientation: UnityEngine.Quaternion, $mask: number) : number
            public static OverlapBoxNonAlloc ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.Collider>, $orientation: UnityEngine.Quaternion) : number
            public static OverlapBoxNonAlloc ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.Collider>) : number
            /** Cast the box along the direction, and store hits in the provided buffer.
            * @param center Center of the box.
            * @param halfExtents Half the size of the box in each dimension.
            * @param direction The direction in which to cast the box.
            * @param results The buffer to store the results in.
            * @param orientation Rotation of the box.
            * @param maxDistance The max length of the cast.
            * @param layermask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns The amount of hits stored to the results buffer. 
            */
            public static BoxCastNonAlloc ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : number
            public static BoxCastNonAlloc ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion) : number
            public static BoxCastNonAlloc ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance: number) : number
            public static BoxCastNonAlloc ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number) : number
            public static BoxCastNonAlloc ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>) : number
            /** Like Physics.BoxCast, but returns all hits.
            * @param center Center of the box.
            * @param halfExtents Half the size of the box in each dimension.
            * @param direction The direction in which to cast the box.
            * @param orientation Rotation of the box.
            * @param maxDistance The max length of the cast.
            * @param layermask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns All colliders that were hit. 
            */
            public static BoxCastAll ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : System.Array$1<UnityEngine.RaycastHit>
            public static BoxCastAll ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $maxDistance: number, $layerMask: number) : System.Array$1<UnityEngine.RaycastHit>
            public static BoxCastAll ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $maxDistance: number) : System.Array$1<UnityEngine.RaycastHit>
            public static BoxCastAll ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion) : System.Array$1<UnityEngine.RaycastHit>
            public static BoxCastAll ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3) : System.Array$1<UnityEngine.RaycastHit>
            /** Check the given capsule against the physics world and return all overlapping colliders in the user-provided buffer.
            * @param point0 The center of the sphere at the start of the capsule.
            * @param point1 The center of the sphere at the end of the capsule.
            * @param radius The radius of the capsule.
            * @param results The buffer to store the results into.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns The amount of entries written to the buffer. 
            */
            public static OverlapCapsuleNonAlloc ($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : number
            public static OverlapCapsuleNonAlloc ($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>, $layerMask: number) : number
            public static OverlapCapsuleNonAlloc ($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>) : number
            /** Rebuild the broadphase interest regions as well as set the world boundaries.
            * @param worldBounds Boundaries of the physics world.
            * @param subdivisions How many cells to create along x and z axis.
            */
            public static RebuildBroadphaseRegions ($worldBounds: UnityEngine.Bounds, $subdivisions: number) : void
            /** Prepares the Mesh for use with a MeshCollider.
            * @param meshID The instance ID of the Mesh to bake collision data from.
            * @param convex A flag to indicate whether to bake convex geometry or not.
            */
            public static BakeMesh ($meshID: number, $convex: boolean) : void
            public constructor ()
        }
        /** Represents a single instance of a 3D physics Scene.
        */
        class PhysicsScene extends System.ValueType implements System.IEquatable$1<UnityEngine.PhysicsScene>
        {
            protected [__keep_incompatibility]: never;
            public static op_Equality ($lhs: UnityEngine.PhysicsScene, $rhs: UnityEngine.PhysicsScene) : boolean
            public static op_Inequality ($lhs: UnityEngine.PhysicsScene, $rhs: UnityEngine.PhysicsScene) : boolean
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.PhysicsScene) : boolean
            public IsValid () : boolean
            public IsEmpty () : boolean
            /** Simulate physics associated with this PhysicsScene.
            * @param step The time to advance physics by.
            * @returns Whether the simulation was run or not.  Running the simulation during physics callbacks will always fail. 
            */
            public Simulate ($step: number) : void
            /** Casts a ray, from point origin, in direction direction, of length maxDistance, against all colliders in the Scene.
            * @param origin The starting point of the ray in world coordinates.
            * @param direction The direction of the ray.
            * @param maxDistance The max distance the ray should check for collisions.
            * @param layerMask A that is used to selectively ignore Colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns True if the ray intersects with a Collider, otherwise false. 
            */
            public Raycast ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction) : boolean
            /** Casts a ray, from point origin, in direction direction, of length maxDistance, against all colliders in the Scene.
            * @param origin The starting point of the ray in world coordinates.
            * @param direction The direction of the ray.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
            * @param maxDistance The max distance the ray should check for collisions.
            * @param layerMask A that is used to selectively ignore Colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns True if the ray intersects with a Collider, otherwise false. 
            */
            public Raycast ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction) : boolean
            /** Casts a ray, from point origin, in direction direction, of length maxDistance, against all colliders in the Scene.
            * @param origin The starting point and direction of the ray.
            * @param direction The direction of the ray.
            * @param raycastHits The buffer to store the hits into.
            * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction The amount of hits stored into the results buffer.
            * @returns True if the ray intersects with a Collider, otherwise false. 
            */
            public Raycast ($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $raycastHits: System.Array$1<UnityEngine.RaycastHit>, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction) : number
            /** Casts a capsule against all colliders in this physics scene and returns detailed information on what was hit.
            * @param point1 The center of the sphere at the start of the capsule.
            * @param point2 The center of the sphere at the end of the capsule.
            * @param radius The radius of the capsule.
            * @param direction The direction into which to sweep the capsule.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
            * @param maxDistance The max length of the sweep.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns True when the capsule sweep intersects any collider, otherwise false. 
            */
            public CapsuleCast ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction) : boolean
            /** Casts a capsule against all colliders in this physics scene and returns detailed information on what was hit.
            * @param point1 The center of the sphere at the start of the capsule.
            * @param point2 The center of the sphere at the end of the capsule.
            * @param radius The radius of the capsule.
            * @param direction The direction into which to sweep the capsule.
            * @param results The buffer to store the results in.
            * @param maxDistance The max length of the sweep.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns The amount of hits stored to the results buffer. 
            */
            public CapsuleCast ($point1: UnityEngine.Vector3, $point2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction) : number
            /** Check the given capsule against the physics world and return all overlapping colliders in the user-provided buffer.
            * @param point0 The center of the sphere at the start of the capsule.
            * @param point1 The center of the sphere at the end of the capsule.
            * @param radius The radius of the capsule.
            * @param results The buffer to store the results into.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns The amount of entries written to the buffer. 
            */
            public OverlapCapsule ($point0: UnityEngine.Vector3, $point1: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction) : number
            /** Casts a sphere along a ray and returns detailed information on what was hit.
            * @param origin The center of the sphere at the start of the sweep.
            * @param radius The radius of the sphere.
            * @param direction The direction into which to sweep the sphere.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
            * @param maxDistance The max length of the cast.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns True when the sphere sweep intersects any collider, otherwise false. 
            */
            public SphereCast ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction) : boolean
            /** Cast sphere along the direction and store the results into buffer.
            * @param origin The center of the sphere at the start of the sweep.
            * @param radius The radius of the sphere.
            * @param direction The direction into which to sweep the sphere.
            * @param results The buffer to save the results to.
            * @param maxDistance The max length of the cast.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction A that is used to selectively ignore colliders when casting a capsule.
            * @returns The amount of hits stored into the results buffer. 
            */
            public SphereCast ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction) : number
            /** Computes and stores colliders touching or inside the sphere into the provided buffer.
            * @param position Center of the sphere.
            * @param radius Radius of the sphere.
            * @param results The buffer to store the results into.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns The amount of colliders stored into the results buffer. 
            */
            public OverlapSphere ($position: UnityEngine.Vector3, $radius: number, $results: System.Array$1<UnityEngine.Collider>, $layerMask: number, $queryTriggerInteraction: UnityEngine.QueryTriggerInteraction) : number
            /** Casts the box along a ray and returns detailed information on what was hit.
            * @param center Center of the box.
            * @param halfExtents Half the size of the box in each dimension.
            * @param direction The direction in which to cast the box.
            * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
            * @param orientation Rotation of the box.
            * @param maxDistance The max length of the cast.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns True, if any intersections were found. 
            */
            public BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction) : boolean
            public BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $hitInfo: $Ref<UnityEngine.RaycastHit>) : boolean
            /** Find all colliders touching or inside of the given box, and store them into the buffer.
            * @param center Center of the box.
            * @param halfExtents Half of the size of the box in each dimension.
            * @param results The buffer to store the results in.
            * @param orientation Rotation of the box.
            * @param layerMask A that is used to selectively ignore colliders when casting a ray.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns The amount of colliders stored in results. 
            */
            public OverlapBox ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.Collider>, $orientation: UnityEngine.Quaternion, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction) : number
            public OverlapBox ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.Collider>) : number
            /** Casts the box along a ray and returns detailed information on what was hit.
            * @param center Center of the box.
            * @param halfExtents Half the size of the box in each dimension.
            * @param direction The direction in which to cast the box.
            * @param results The buffer to store the results in.
            * @param orientation Rotation of the box.
            * @param maxDistance The max length of the cast.
            * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
            * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
            * @returns The amount of hits stored to the results buffer. 
            */
            public BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>, $orientation: UnityEngine.Quaternion, $maxDistance?: number, $layerMask?: number, $queryTriggerInteraction?: UnityEngine.QueryTriggerInteraction) : number
            public BoxCast ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $results: System.Array$1<UnityEngine.RaycastHit>) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        /** A light-weight proxy that allows to access the contact buffers directly.
        */
        class ModifiableContactPair extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** World-space rotation of the first collider in this contact pair as seen by the solver.
            */
            public rotation : UnityEngine.Quaternion
            /** World-space position of the first collider in this contact pair as seen by the solver.
            */
            public position : UnityEngine.Vector3
            /** World-space rotation of the second collider in this contact pair as seen by the solver.
            */
            public otherRotation : UnityEngine.Quaternion
            /** World-space position of the second collider in this contact pair as seen by the solver.
            */
            public otherPosition : UnityEngine.Vector3
            /** Instance ID of the first Collider in this contact pair.
            */
            public get colliderInstanceID(): number;
            /** Instance ID of the second collider in this contact pair.
            */
            public get otherColliderInstanceID(): number;
            /** Instance ID of the first body in this contact pair.
            */
            public get bodyInstanceID(): number;
            /** Instance ID of the second body in this contact pair.
            */
            public get otherBodyInstanceID(): number;
            /** The amount of the contact points generated for this contact pair.
            */
            public get contactCount(): number;
            /** Mass-related properties of this contact pair, such as the mass ratio.
            */
            public get massProperties(): UnityEngine.ModifiableMassProperties;
            public set massProperties(value: UnityEngine.ModifiableMassProperties);
            /** Get the location of a particular contact point in this contact pair.
            * @param i Index of the contact point.
            * @returns The location of a contact point. 
            */
            public GetPoint ($i: number) : UnityEngine.Vector3
            /** Set the location of a particular contact point in this contact pair.
            * @param i Index of the contact point.
            * @param v The location of a contact point.
            */
            public SetPoint ($i: number, $v: UnityEngine.Vector3) : void
            /** Get the normal at a particular contact point in this contact pair.
            * @param i Index of the contact point.
            * @returns Normal at the contact point. 
            */
            public GetNormal ($i: number) : UnityEngine.Vector3
            /** Set the normal at a particular contact point in this contact pair.
            * @param i Index of the contact point.
            * @param normal Normal at the contact point.
            */
            public SetNormal ($i: number, $normal: UnityEngine.Vector3) : void
            /** Get the separation value at a particular contact point in this contact pair.
            * @param i Index of the contact point.
            * @returns The separation at a contact point. 
            */
            public GetSeparation ($i: number) : number
            /** Set the separation value at a particular contact point in this contact pair.
            * @param i Index of the contact point.
            * @param separation The separation at a contact point.
            */
            public SetSeparation ($i: number, $separation: number) : void
            /** Get the target velocity the solver should aim reaching at a particular contact point in this contact pair.
            * @param i Index of the contact point.
            * @returns The target velocity at a contact point. 
            */
            public GetTargetVelocity ($i: number) : UnityEngine.Vector3
            /** Set the target velocity the solver should aim reaching at a particular contact point in this contact pair.
            * @param i Index of the contact point.
            * @param velocity The target velocity at a contact point.
            */
            public SetTargetVelocity ($i: number, $velocity: UnityEngine.Vector3) : void
            /** Get the restitution value for the specified contact point in this contact pair.
            * @param i Index of the contact point.
            * @returns Bounciness value for the specified contact point. 
            */
            public GetBounciness ($i: number) : number
            /** Set the restitution value for the specified contact point in this contact pair.
            * @param i Index of the contact point.
            * @param bounciness Bounciness value for the specified contact point.
            */
            public SetBounciness ($i: number, $bounciness: number) : void
            /** Get the static friction coefficient at a particular point of the contact pair.
            * @param i Index of the contact point.
            * @returns The static friction coefficient at a contact point. 
            */
            public GetStaticFriction ($i: number) : number
            /** Set the static friction coefficient at a particular point of the contact pair.
            * @param i Index of the contact point.
            * @param staticFriction The static friction coefficient at a contact point.
            */
            public SetStaticFriction ($i: number, $staticFriction: number) : void
            /** Get the value of the dynamic friction for a specified contact point in this contact pair.
            * @param i Index of the contact point.
            * @returns Dynamic friction coefficient. 
            */
            public GetDynamicFriction ($i: number) : number
            /** Set the value of the dynamic friction for a specified contact point in this contact pair.
            * @param i Index of the contact point.
            * @param dynamicFriction Dynamic friction coefficient.
            */
            public SetDynamicFriction ($i: number, $dynamicFriction: number) : void
            /** Get the maximum impulse that the solver can apply at a particular contact point in this contact pair.
            * @param i Index of the contact point.
            * @returns The maximum impulse that can be applied. 
            */
            public GetMaxImpulse ($i: number) : number
            /** Set the maximum impulse that the solver can apply at a particular contact point in this contact pair.
            * @param i Index of the contact point.
            * @param value The maximum impulse that can be applied.
            */
            public SetMaxImpulse ($i: number, $value: number) : void
            /** Ignore the specified contact point in this contact pair.
            * @param i Index of the contact point.
            */
            public IgnoreContact ($i: number) : void
            /** Get the index of a face a particular contact point belongs to in this contact pair. Use this with Mesh.triangles.
            * @param i Index of the contact point.
            * @returns Index of a face this contact point belongs to. 
            */
            public GetFaceIndex ($i: number) : number
        }
        /** Structure used to get information back from a raycast.
        */
        class RaycastHit extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The Collider that was hit.
            */
            public get collider(): UnityEngine.Collider;
            /** Instance ID of the Collider that was hit.
            */
            public get colliderInstanceID(): number;
            /** The impact point in world space where the ray hit the collider.
            */
            public get point(): UnityEngine.Vector3;
            public set point(value: UnityEngine.Vector3);
            /** The normal of the surface the ray hit.
            */
            public get normal(): UnityEngine.Vector3;
            public set normal(value: UnityEngine.Vector3);
            /** The barycentric coordinate of the triangle we hit.
            */
            public get barycentricCoordinate(): UnityEngine.Vector3;
            public set barycentricCoordinate(value: UnityEngine.Vector3);
            /** The distance from the ray's origin to the impact point.
            */
            public get distance(): number;
            public set distance(value: number);
            /** The index of the triangle that was hit.
            */
            public get triangleIndex(): number;
            /** The uv texture coordinate at the collision location.
            */
            public get textureCoord(): UnityEngine.Vector2;
            /** The secondary uv texture coordinate at the impact point.
            */
            public get textureCoord2(): UnityEngine.Vector2;
            /** The Transform of the rigidbody or collider that was hit.
            */
            public get transform(): UnityEngine.Transform;
            /** The Rigidbody of the collider that was hit. If the collider is not attached to a rigidbody then it is null.
            */
            public get rigidbody(): UnityEngine.Rigidbody;
            /** The ArticulationBody of the collider that was hit. If the collider is not attached to an articulation body then it is null.
            */
            public get articulationBody(): UnityEngine.ArticulationBody;
            /** The uv lightmap coordinate at the impact point.
            */
            public get lightmapCoord(): UnityEngine.Vector2;
        }
        /** Mass-related modifiable properties of a contact pair.
        */
        class ModifiableMassProperties extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The inverse mass scaling that the solver should apply to the first body of this contact pair.
            */
            public inverseMassScale : number
            /** The inverse inertia scaling that the solver should apply to the first body of this contact pair.
            */
            public inverseInertiaScale : number
            /** The inverse mass scaling that the solver should apply to the second body of this contact pair.
            */
            public otherInverseMassScale : number
            /** The inverse inertia scaling that the solver should apply to the second body of this contact pair.
            */
            public otherInverseInertiaScale : number
        }
        /** Physics material describes how to handle colliding objects (friction, bounciness).
        */
        class PhysicMaterial extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** How bouncy is the surface? A value of 0 will not bounce. A value of 1 will bounce without any loss of energy.
            */
            public get bounciness(): number;
            public set bounciness(value: number);
            /** The friction used when already moving.  This value is usually between 0 and 1.
            */
            public get dynamicFriction(): number;
            public set dynamicFriction(value: number);
            /** The friction coefficient used when an object is lying on a surface.
            */
            public get staticFriction(): number;
            public set staticFriction(value: number);
            /** Determines how the friction is combined.
            */
            public get frictionCombine(): UnityEngine.PhysicMaterialCombine;
            public set frictionCombine(value: UnityEngine.PhysicMaterialCombine);
            /** Determines how the bounciness is combined.
            */
            public get bounceCombine(): UnityEngine.PhysicMaterialCombine;
            public set bounceCombine(value: UnityEngine.PhysicMaterialCombine);
            public constructor ()
            public constructor ($name: string)
        }
        /** A mesh collider allows you to do between meshes and primitives.
        */
        class MeshCollider extends UnityEngine.Collider
        {
            protected [__keep_incompatibility]: never;
            /** The mesh object used for collision detection.
            */
            public get sharedMesh(): UnityEngine.Mesh;
            public set sharedMesh(value: UnityEngine.Mesh);
            /** Use a convex collider from the mesh.
            */
            public get convex(): boolean;
            public set convex(value: boolean);
            /** Options used to enable or disable certain features in mesh cooking.
            */
            public get cookingOptions(): UnityEngine.MeshColliderCookingOptions;
            public set cookingOptions(value: UnityEngine.MeshColliderCookingOptions);
            public constructor ()
        }
        /** A box-shaped primitive collider.
        */
        class BoxCollider extends UnityEngine.Collider
        {
            protected [__keep_incompatibility]: never;
            /** The center of the box, measured in the object's local space.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** The size of the box, measured in the object's local space.
            */
            public get size(): UnityEngine.Vector3;
            public set size(value: UnityEngine.Vector3);
            public constructor ()
        }
        /** A force applied constantly.
        */
        class ConstantForce extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The force applied to the rigidbody every frame.
            */
            public get force(): UnityEngine.Vector3;
            public set force(value: UnityEngine.Vector3);
            /** The force - relative to the rigid bodies coordinate system - applied every frame.
            */
            public get relativeForce(): UnityEngine.Vector3;
            public set relativeForce(value: UnityEngine.Vector3);
            /** The torque applied to the rigidbody every frame.
            */
            public get torque(): UnityEngine.Vector3;
            public set torque(value: UnityEngine.Vector3);
            /** The torque - relative to the rigid bodies coordinate system - applied every frame.
            */
            public get relativeTorque(): UnityEngine.Vector3;
            public set relativeTorque(value: UnityEngine.Vector3);
            public constructor ()
        }
        /** Joint is the base class for all joints.
        */
        class Joint extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** A reference to another rigidbody this joint connects to.
            */
            public get connectedBody(): UnityEngine.Rigidbody;
            public set connectedBody(value: UnityEngine.Rigidbody);
            /** A reference to an articulation body this joint connects to.
            */
            public get connectedArticulationBody(): UnityEngine.ArticulationBody;
            public set connectedArticulationBody(value: UnityEngine.ArticulationBody);
            /** The Direction of the axis around which the body is constrained.
            */
            public get axis(): UnityEngine.Vector3;
            public set axis(value: UnityEngine.Vector3);
            /** The Position of the anchor around which the joints motion is constrained.
            */
            public get anchor(): UnityEngine.Vector3;
            public set anchor(value: UnityEngine.Vector3);
            /** Position of the anchor relative to the connected Rigidbody.
            */
            public get connectedAnchor(): UnityEngine.Vector3;
            public set connectedAnchor(value: UnityEngine.Vector3);
            /** Should the connectedAnchor be calculated automatically?
            */
            public get autoConfigureConnectedAnchor(): boolean;
            public set autoConfigureConnectedAnchor(value: boolean);
            /** The force that needs to be applied for this joint to break.
            */
            public get breakForce(): number;
            public set breakForce(value: number);
            /** The torque that needs to be applied for this joint to break. To be able to break, a joint must be _Locked_ or _Limited_ on the axis of rotation where the torque is being applied. This means that some joints cannot break, such as an unconstrained Configurable Joint.
            */
            public get breakTorque(): number;
            public set breakTorque(value: number);
            /** Enable collision between bodies connected with the joint.
            */
            public get enableCollision(): boolean;
            public set enableCollision(value: boolean);
            /** Toggle preprocessing for this joint.
            */
            public get enablePreprocessing(): boolean;
            public set enablePreprocessing(value: boolean);
            /** The scale to apply to the inverse mass and inertia tensor of the body prior to solving the constraints.
            */
            public get massScale(): number;
            public set massScale(value: number);
            /** The scale to apply to the inverse mass and inertia tensor of the connected body prior to solving the constraints.
            */
            public get connectedMassScale(): number;
            public set connectedMassScale(value: number);
            /** The force applied by the solver to satisfy all constraints.
            */
            public get currentForce(): UnityEngine.Vector3;
            /** The torque applied by the solver to satisfy all constraints.
            */
            public get currentTorque(): UnityEngine.Vector3;
            public constructor ()
        }
        /** The HingeJoint groups together 2 rigid bodies, constraining them to move like connected by a hinge.
        */
        class HingeJoint extends UnityEngine.Joint
        {
            protected [__keep_incompatibility]: never;
            /** The motor will apply a force up to a maximum force to achieve the target velocity in degrees per second.
            */
            public get motor(): UnityEngine.JointMotor;
            public set motor(value: UnityEngine.JointMotor);
            /** Limit of angular rotation (in degrees) on the hinge joint.
            */
            public get limits(): UnityEngine.JointLimits;
            public set limits(value: UnityEngine.JointLimits);
            /** The spring attempts to reach a target angle by adding spring and damping forces.
            */
            public get spring(): UnityEngine.JointSpring;
            public set spring(value: UnityEngine.JointSpring);
            /** Enables the joint's motor. Disabled by default.
            */
            public get useMotor(): boolean;
            public set useMotor(value: boolean);
            /** Enables the joint's limits. Disabled by default.
            */
            public get useLimits(): boolean;
            public set useLimits(value: boolean);
            /** Enables the joint's spring. Disabled by default.
            */
            public get useSpring(): boolean;
            public set useSpring(value: boolean);
            /** The angular velocity of the joint in degrees per second. (Read Only)
            */
            public get velocity(): number;
            /** The current angle in degrees of the joint relative to its rest position. (Read Only)
            */
            public get angle(): number;
            public constructor ()
        }
        /** The spring joint ties together 2 rigid bodies, spring forces will be automatically applied to keep the object at the given distance.
        */
        class SpringJoint extends UnityEngine.Joint
        {
            protected [__keep_incompatibility]: never;
            /** The spring force used to keep the two objects together.
            */
            public get spring(): number;
            public set spring(value: number);
            /** The damper force used to dampen the spring force.
            */
            public get damper(): number;
            public set damper(value: number);
            /** The minimum distance between the bodies relative to their initial distance.
            */
            public get minDistance(): number;
            public set minDistance(value: number);
            /** The maximum distance between the bodies relative to their initial distance.
            */
            public get maxDistance(): number;
            public set maxDistance(value: number);
            /** The maximum allowed error between the current spring length and the length defined by minDistance and maxDistance.
            */
            public get tolerance(): number;
            public set tolerance(value: number);
            public constructor ()
        }
        /** The Fixed joint groups together 2 rigidbodies, making them stick together in their bound position.
        */
        class FixedJoint extends UnityEngine.Joint
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Character Joints are mainly used for Ragdoll effects.
        */
        class CharacterJoint extends UnityEngine.Joint
        {
            protected [__keep_incompatibility]: never;
            /** The secondary axis around which the joint can rotate.
            */
            public get swingAxis(): UnityEngine.Vector3;
            public set swingAxis(value: UnityEngine.Vector3);
            /** The configuration of the spring attached to the twist limits of the joint.
            */
            public get twistLimitSpring(): UnityEngine.SoftJointLimitSpring;
            public set twistLimitSpring(value: UnityEngine.SoftJointLimitSpring);
            /** The configuration of the spring attached to the swing limits of the joint.
            */
            public get swingLimitSpring(): UnityEngine.SoftJointLimitSpring;
            public set swingLimitSpring(value: UnityEngine.SoftJointLimitSpring);
            /** The lower limit around the primary axis of the character joint.
            */
            public get lowTwistLimit(): UnityEngine.SoftJointLimit;
            public set lowTwistLimit(value: UnityEngine.SoftJointLimit);
            /** The upper limit around the primary axis of the character joint.
            */
            public get highTwistLimit(): UnityEngine.SoftJointLimit;
            public set highTwistLimit(value: UnityEngine.SoftJointLimit);
            /** The angular limit of rotation (in degrees) around the primary axis of the character joint.
            */
            public get swing1Limit(): UnityEngine.SoftJointLimit;
            public set swing1Limit(value: UnityEngine.SoftJointLimit);
            /** The angular limit of rotation (in degrees) around the primary axis of the character joint.
            */
            public get swing2Limit(): UnityEngine.SoftJointLimit;
            public set swing2Limit(value: UnityEngine.SoftJointLimit);
            /** Brings violated constraints back into alignment even when the solver fails.
            */
            public get enableProjection(): boolean;
            public set enableProjection(value: boolean);
            /** Set the linear tolerance threshold for projection.
            */
            public get projectionDistance(): number;
            public set projectionDistance(value: number);
            /** Set the angular tolerance threshold (in degrees) for projection.
            */
            public get projectionAngle(): number;
            public set projectionAngle(value: number);
            public constructor ()
        }
        /** The configurable joint is an extremely flexible joint giving you complete control over rotation and linear motion.
        */
        class ConfigurableJoint extends UnityEngine.Joint
        {
            protected [__keep_incompatibility]: never;
            /** The joint's secondary axis.
            */
            public get secondaryAxis(): UnityEngine.Vector3;
            public set secondaryAxis(value: UnityEngine.Vector3);
            /** Allow movement along the X axis to be Free, completely Locked, or Limited according to Linear Limit.
            */
            public get xMotion(): UnityEngine.ConfigurableJointMotion;
            public set xMotion(value: UnityEngine.ConfigurableJointMotion);
            /** Allow movement along the Y axis to be Free, completely Locked, or Limited according to Linear Limit.
            */
            public get yMotion(): UnityEngine.ConfigurableJointMotion;
            public set yMotion(value: UnityEngine.ConfigurableJointMotion);
            /** Allow movement along the Z axis to be Free, completely Locked, or Limited according to Linear Limit.
            */
            public get zMotion(): UnityEngine.ConfigurableJointMotion;
            public set zMotion(value: UnityEngine.ConfigurableJointMotion);
            /** Allow rotation around the X axis to be Free, completely Locked, or Limited according to Low and High Angular XLimit.
            */
            public get angularXMotion(): UnityEngine.ConfigurableJointMotion;
            public set angularXMotion(value: UnityEngine.ConfigurableJointMotion);
            /** Allow rotation around the Y axis to be Free, completely Locked, or Limited according to Angular YLimit.
            */
            public get angularYMotion(): UnityEngine.ConfigurableJointMotion;
            public set angularYMotion(value: UnityEngine.ConfigurableJointMotion);
            /** Allow rotation around the Z axis to be Free, completely Locked, or Limited according to Angular ZLimit.
            */
            public get angularZMotion(): UnityEngine.ConfigurableJointMotion;
            public set angularZMotion(value: UnityEngine.ConfigurableJointMotion);
            /** The configuration of the spring attached to the linear limit of the joint.
            */
            public get linearLimitSpring(): UnityEngine.SoftJointLimitSpring;
            public set linearLimitSpring(value: UnityEngine.SoftJointLimitSpring);
            /** The configuration of the spring attached to the angular X limit of the joint.
            */
            public get angularXLimitSpring(): UnityEngine.SoftJointLimitSpring;
            public set angularXLimitSpring(value: UnityEngine.SoftJointLimitSpring);
            /** The configuration of the spring attached to the angular Y and angular Z limits of the joint.
            */
            public get angularYZLimitSpring(): UnityEngine.SoftJointLimitSpring;
            public set angularYZLimitSpring(value: UnityEngine.SoftJointLimitSpring);
            /** Boundary defining movement restriction, based on distance from the joint's origin.
            */
            public get linearLimit(): UnityEngine.SoftJointLimit;
            public set linearLimit(value: UnityEngine.SoftJointLimit);
            /** Boundary defining lower rotation restriction, based on delta from original rotation.
            */
            public get lowAngularXLimit(): UnityEngine.SoftJointLimit;
            public set lowAngularXLimit(value: UnityEngine.SoftJointLimit);
            /** Boundary defining upper rotation restriction, based on delta from original rotation.
            */
            public get highAngularXLimit(): UnityEngine.SoftJointLimit;
            public set highAngularXLimit(value: UnityEngine.SoftJointLimit);
            /** Boundary defining rotation restriction, based on delta from original rotation.
            */
            public get angularYLimit(): UnityEngine.SoftJointLimit;
            public set angularYLimit(value: UnityEngine.SoftJointLimit);
            /** Boundary defining rotation restriction, based on delta from original rotation.
            */
            public get angularZLimit(): UnityEngine.SoftJointLimit;
            public set angularZLimit(value: UnityEngine.SoftJointLimit);
            /** The desired position that the joint should move into.
            */
            public get targetPosition(): UnityEngine.Vector3;
            public set targetPosition(value: UnityEngine.Vector3);
            /** The desired velocity that the joint should move along.
            */
            public get targetVelocity(): UnityEngine.Vector3;
            public set targetVelocity(value: UnityEngine.Vector3);
            /** Definition of how the joint's movement will behave along its local X axis.
            */
            public get xDrive(): UnityEngine.JointDrive;
            public set xDrive(value: UnityEngine.JointDrive);
            /** Definition of how the joint's movement will behave along its local Y axis.
            */
            public get yDrive(): UnityEngine.JointDrive;
            public set yDrive(value: UnityEngine.JointDrive);
            /** Definition of how the joint's movement will behave along its local Z axis.
            */
            public get zDrive(): UnityEngine.JointDrive;
            public set zDrive(value: UnityEngine.JointDrive);
            /** This is a Quaternion. It defines the desired rotation that the joint should rotate into.
            */
            public get targetRotation(): UnityEngine.Quaternion;
            public set targetRotation(value: UnityEngine.Quaternion);
            /** This is a Vector3. It defines the desired angular velocity that the joint should rotate into.
            */
            public get targetAngularVelocity(): UnityEngine.Vector3;
            public set targetAngularVelocity(value: UnityEngine.Vector3);
            /** Control the object's rotation with either X & YZ or Slerp Drive by itself.
            */
            public get rotationDriveMode(): UnityEngine.RotationDriveMode;
            public set rotationDriveMode(value: UnityEngine.RotationDriveMode);
            /** Definition of how the joint's rotation will behave around its local X axis. Only used if Rotation Drive Mode is Swing & Twist.
            */
            public get angularXDrive(): UnityEngine.JointDrive;
            public set angularXDrive(value: UnityEngine.JointDrive);
            /** Definition of how the joint's rotation will behave around its local Y and Z axes. Only used if Rotation Drive Mode is Swing & Twist.
            */
            public get angularYZDrive(): UnityEngine.JointDrive;
            public set angularYZDrive(value: UnityEngine.JointDrive);
            /** Definition of how the joint's rotation will behave around all local axes. Only used if Rotation Drive Mode is Slerp Only.
            */
            public get slerpDrive(): UnityEngine.JointDrive;
            public set slerpDrive(value: UnityEngine.JointDrive);
            /** Brings violated constraints back into alignment even when the solver fails. Projection is not a physical process and does not preserve momentum or respect collision geometry. It is best avoided if practical, but can be useful in improving simulation quality where joint separation results in unacceptable artifacts.
            */
            public get projectionMode(): UnityEngine.JointProjectionMode;
            public set projectionMode(value: UnityEngine.JointProjectionMode);
            /** Set the linear tolerance threshold for projection.
            If the joint separates by more than this distance along its locked degrees of freedom, the solver
            will move the bodies to close the distance.
            Setting a very small tolerance may result in simulation jitter or other artifacts.
            Sometimes it is not possible to project (for example when the joints form a cycle).
            */
            public get projectionDistance(): number;
            public set projectionDistance(value: number);
            /** Set the angular tolerance threshold (in degrees) for projection.
            If the joint deviates by more than this angle around its locked angular degrees of freedom,
            the solver will move the bodies to close the angle.
            Setting a very small tolerance may result in simulation jitter or other artifacts.
            Sometimes it is not possible to project (for example when the joints form a cycle).
            */
            public get projectionAngle(): number;
            public set projectionAngle(value: number);
            /** If enabled, all Target values will be calculated in world space instead of the object's local space.
            */
            public get configuredInWorldSpace(): boolean;
            public set configuredInWorldSpace(value: boolean);
            /** Enable this property to swap the order in which the physics engine processes the Rigidbodies involved in the joint. This results in different joint motion but has no impact on Rigidbodies and anchors.
            */
            public get swapBodies(): boolean;
            public set swapBodies(value: boolean);
            public constructor ()
        }
        /** Scene extensions to access the underlying physics scene.
        */
        class PhysicsSceneExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** An extension method that returns the 3D physics Scene from the Scene.
            * @param scene The Scene from which to return the 3D physics Scene.
            * @returns The 3D physics Scene used by the Scene. 
            */
            public static GetPhysicsScene ($scene: UnityEngine.SceneManagement.Scene) : UnityEngine.PhysicsScene
        }
        /** Struct used to set up a raycast command to be performed asynchronously during a job.
        */
        class RaycastCommand extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The starting point of the ray in world coordinates.
            */
            public get from(): UnityEngine.Vector3;
            public set from(value: UnityEngine.Vector3);
            /** The direction of the ray.
            */
            public get direction(): UnityEngine.Vector3;
            public set direction(value: UnityEngine.Vector3);
            /** The maximum distance the ray should check for collisions.
            */
            public get distance(): number;
            public set distance(value: number);
            /** A LayerMask that is used to selectively ignore Colliders when casting a ray.
            */
            public get layerMask(): number;
            public set layerMask(value: number);
            /** The maximum number of Colliders the ray can hit.
            */
            public get maxHits(): number;
            public set maxHits(value: number);
            /** The physics scene this command is run in.
            */
            public get physicsScene(): UnityEngine.PhysicsScene;
            public set physicsScene(value: UnityEngine.PhysicsScene);
            public static ScheduleBatch ($commands: Unity.Collections.NativeArray$1<UnityEngine.RaycastCommand>, $results: Unity.Collections.NativeArray$1<UnityEngine.RaycastHit>, $minCommandsPerJob: number, $dependsOn?: Unity.Jobs.JobHandle) : Unity.Jobs.JobHandle
            public constructor ($from: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $distance?: number, $layerMask?: number, $maxHits?: number)
            public constructor ($physicsScene: UnityEngine.PhysicsScene, $from: UnityEngine.Vector3, $direction: UnityEngine.Vector3, $distance?: number, $layerMask?: number, $maxHits?: number)
            public constructor ()
        }
        /** Use this struct to set up a sphere cast command that is performed asynchronously during a job.
        */
        class SpherecastCommand extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The starting point of the sphere cast in world coordinates.
            */
            public get origin(): UnityEngine.Vector3;
            public set origin(value: UnityEngine.Vector3);
            /** The radius of the casting sphere.
            */
            public get radius(): number;
            public set radius(value: number);
            /** The direction of the sphere cast.
            */
            public get direction(): UnityEngine.Vector3;
            public set direction(value: UnityEngine.Vector3);
            /** The maximum distance the sphere should check for collisions.
            */
            public get distance(): number;
            public set distance(value: number);
            /** The LayerMask that selectively ignores Colliders when casting a sphere.
            */
            public get layerMask(): number;
            public set layerMask(value: number);
            /** The physics scene this command is run in.
            */
            public get physicsScene(): UnityEngine.PhysicsScene;
            public set physicsScene(value: UnityEngine.PhysicsScene);
            public static ScheduleBatch ($commands: Unity.Collections.NativeArray$1<UnityEngine.SpherecastCommand>, $results: Unity.Collections.NativeArray$1<UnityEngine.RaycastHit>, $minCommandsPerJob: number, $dependsOn?: Unity.Jobs.JobHandle) : Unity.Jobs.JobHandle
            public constructor ($origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $distance?: number, $layerMask?: number)
            public constructor ($physicsScene: UnityEngine.PhysicsScene, $origin: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $distance?: number, $layerMask?: number)
            public constructor ()
        }
        /** Use this struct to set up a capsule cast command that is performed asynchronously during a job.
        */
        class CapsulecastCommand extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The center of the sphere at the start of the capsule.
            */
            public get point1(): UnityEngine.Vector3;
            public set point1(value: UnityEngine.Vector3);
            /** The center of the sphere at the end of the capsule.
            */
            public get point2(): UnityEngine.Vector3;
            public set point2(value: UnityEngine.Vector3);
            /** The radius of the capsule.
            */
            public get radius(): number;
            public set radius(value: number);
            /** The direction of the capsule cast.
            */
            public get direction(): UnityEngine.Vector3;
            public set direction(value: UnityEngine.Vector3);
            /** The maximum distance the capsule cast checks for collision.
            */
            public get distance(): number;
            public set distance(value: number);
            /** A LayerMask that selectively ignores Colliders when casting a capsule.
            */
            public get layerMask(): number;
            public set layerMask(value: number);
            /** The physics scene this command is run in.
            */
            public get physicsScene(): UnityEngine.PhysicsScene;
            public set physicsScene(value: UnityEngine.PhysicsScene);
            public static ScheduleBatch ($commands: Unity.Collections.NativeArray$1<UnityEngine.CapsulecastCommand>, $results: Unity.Collections.NativeArray$1<UnityEngine.RaycastHit>, $minCommandsPerJob: number, $dependsOn?: Unity.Jobs.JobHandle) : Unity.Jobs.JobHandle
            public constructor ($p1: UnityEngine.Vector3, $p2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $distance?: number, $layerMask?: number)
            public constructor ($physicsScene: UnityEngine.PhysicsScene, $p1: UnityEngine.Vector3, $p2: UnityEngine.Vector3, $radius: number, $direction: UnityEngine.Vector3, $distance?: number, $layerMask?: number)
            public constructor ()
        }
        /** Use this struct to set up a box cast command to be performed asynchronously during a job.
        */
        class BoxcastCommand extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Center of the box.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** Half the size of the box in each dimension.
            */
            public get halfExtents(): UnityEngine.Vector3;
            public set halfExtents(value: UnityEngine.Vector3);
            /** Rotation of the box.
            */
            public get orientation(): UnityEngine.Quaternion;
            public set orientation(value: UnityEngine.Quaternion);
            /** The direction in which to sweep the box.
            */
            public get direction(): UnityEngine.Vector3;
            public set direction(value: UnityEngine.Vector3);
            /** The maximum distance of the sweep.
            */
            public get distance(): number;
            public set distance(value: number);
            /** A LayerMask that is used to selectively ignore Colliders when casting a box.
            */
            public get layerMask(): number;
            public set layerMask(value: number);
            /** The physics scene this command is run in.
            */
            public get physicsScene(): UnityEngine.PhysicsScene;
            public set physicsScene(value: UnityEngine.PhysicsScene);
            public static ScheduleBatch ($commands: Unity.Collections.NativeArray$1<UnityEngine.BoxcastCommand>, $results: Unity.Collections.NativeArray$1<UnityEngine.RaycastHit>, $minCommandsPerJob: number, $dependsOn?: Unity.Jobs.JobHandle) : Unity.Jobs.JobHandle
            public constructor ($center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $direction: UnityEngine.Vector3, $distance?: number, $layerMask?: number)
            public constructor ($physicsScene: UnityEngine.PhysicsScene, $center: UnityEngine.Vector3, $halfExtents: UnityEngine.Vector3, $orientation: UnityEngine.Quaternion, $direction: UnityEngine.Vector3, $distance?: number, $layerMask?: number)
            public constructor ()
        }
        /** Represents a single instance of a 2D physics Scene.
        */
        class PhysicsScene2D extends System.ValueType implements System.IEquatable$1<UnityEngine.PhysicsScene2D>
        {
            protected [__keep_incompatibility]: never;
            public static op_Equality ($lhs: UnityEngine.PhysicsScene2D, $rhs: UnityEngine.PhysicsScene2D) : boolean
            public static op_Inequality ($lhs: UnityEngine.PhysicsScene2D, $rhs: UnityEngine.PhysicsScene2D) : boolean
            public Equals ($other: any) : boolean
            public Equals ($other: UnityEngine.PhysicsScene2D) : boolean
            public IsValid () : boolean
            public IsEmpty () : boolean
            /** Simulate physics associated with this PhysicsScene.
            * @param step The time to advance physics by.
            * @returns Whether the simulation was run or not.  Running the simulation during physics callbacks will always fail. 
            */
            public Simulate ($step: number) : boolean
            /** Casts a line segment against colliders in the PhysicsScene2D, returning the first intersection only.
            * @param start The start point of the line in world space.
            * @param end The end point of the line in world space.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns The cast results returned. 
            */
            public Linecast ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask?: number) : UnityEngine.RaycastHit2D
            /** Casts a line segment against colliders in the PhysicsScene2D, returning the first intersection only.
            * @param start The start point of the line in world space.
            * @param end The end point of the line in world space.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns The cast results returned. 
            */
            public Linecast ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D) : UnityEngine.RaycastHit2D
            /** Casts a line segment against colliders in the PhysicsScene2D.
            * @param start The start point of the line in world space.
            * @param end The end point of the line in world space.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Returns the number of results placed in the results array. 
            */
            public Linecast ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask?: number) : number
            /** Casts a line segment against colliders in the PhysicsScene2D.
            * @param start The start point of the line in world space.
            * @param end The end point of the line in world space.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Returns the number of results placed in the results array. 
            */
            public Linecast ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public Linecast ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>) : number
            /** Casts a ray against colliders in the PhysicsScene2D, returning the first intersection only.
            * @param origin The point in 2D space where the ray originates.
            * @param direction The vector representing the direction of the ray.
            * @param distance Maximum distance over which to cast the ray.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth, or normal angle.
            * @returns The cast results returned. 
            */
            public Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask?: number) : UnityEngine.RaycastHit2D
            /** Casts a ray against colliders in the PhysicsScene2D, returning the first intersection only.
            * @param origin The point in 2D space where the ray originates.
            * @param direction The vector representing the direction of the ray.
            * @param distance Maximum distance over which to cast the ray.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth, or normal angle.
            * @returns The cast results returned. 
            */
            public Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D) : UnityEngine.RaycastHit2D
            /** Casts a ray against colliders the PhysicsScene2D, returning all intersections.
            * @param origin The point in 2D space where the ray originates.
            * @param direction The vector representing the direction of the ray.
            * @param distance Maximum distance over which to cast the ray.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth, or normal angle.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @returns Returns the number of results placed in the results array. 
            */
            public Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask?: number) : number
            /** Casts a ray against colliders the PhysicsScene2D, returning all intersections.
            * @param origin The point in 2D space where the ray originates.
            * @param direction The vector representing the direction of the ray.
            * @param distance Maximum distance over which to cast the ray.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth, or normal angle.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @returns Returns the number of results placed in the results array. 
            */
            public Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>) : number
            /** Casts a circle against colliders in the PhysicsScene2D, returning the first intersection only.
            * @param origin The point in 2D space where the circle originates.
            * @param radius The radius of the circle.
            * @param direction Vector representing the direction to cast the circle.
            * @param distance Maximum distance over which to cast the circle.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns The cast results returned. 
            */
            public CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask?: number) : UnityEngine.RaycastHit2D
            /** Casts a circle against colliders in the PhysicsScene2D, returning the first intersection only.
            * @param origin The point in 2D space where the circle originates.
            * @param radius The radius of the circle.
            * @param direction Vector representing the direction to cast the circle.
            * @param distance Maximum distance over which to cast the circle.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns The cast results returned. 
            */
            public CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D) : UnityEngine.RaycastHit2D
            /** Casts a circle against the colliders in the PhysicsScene2D, returning all intersections.
            * @param origin The point in 2D space where the circle originates.
            * @param radius The radius of the circle.
            * @param direction Vector representing the direction to cast the circle.
            * @param distance Maximum distance over which to cast the circle.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Returns the number of results placed in the results array. 
            */
            public CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask?: number) : number
            /** Casts a circle against the colliders in the PhysicsScene2D, returning all intersections.
            * @param origin The point in 2D space where the circle originates.
            * @param radius The radius of the circle.
            * @param direction Vector representing the direction to cast the circle.
            * @param distance Maximum distance over which to cast the circle.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Returns the number of results placed in the results array. 
            */
            public CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>) : number
            /** Casts a box against colliders in the PhysicsScene2D, returning the first intersection only.
            * @param origin The point in 2D space where the box originates.
            * @param size The size of the box.
            * @param angle The angle of the box (in degrees).
            * @param direction Vector representing the direction to cast the box.
            * @param distance Maximum distance over which to cast the box.
            * @param layerMask Filter to detect colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns The cast results returned. 
            */
            public BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask?: number) : UnityEngine.RaycastHit2D
            /** Casts a box against colliders in the PhysicsScene2D, returning the first intersection only.
            * @param origin The point in 2D space where the box originates.
            * @param size The size of the box.
            * @param angle The angle of the box (in degrees).
            * @param direction Vector representing the direction to cast the box.
            * @param distance Maximum distance over which to cast the box.
            * @param layerMask Filter to detect colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns The cast results returned. 
            */
            public BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D) : UnityEngine.RaycastHit2D
            /** Casts a box against the colliders in the PhysicsScene2D, returning all intersections.
            * @param origin The point in 2D space where the box originates.
            * @param size The size of the box.
            * @param angle The angle of the box (in degrees).
            * @param direction Vector representing the direction to cast the box.
            * @param distance Maximum distance over which to cast the box.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to detect colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Returns the number of results placed in the results array. 
            */
            public BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask?: number) : number
            /** Casts a box against the colliders in the PhysicsScene2D, returning all intersections.
            * @param origin The point in 2D space where the box originates.
            * @param size The size of the box.
            * @param angle The angle of the box (in degrees).
            * @param direction Vector representing the direction to cast the box.
            * @param distance Maximum distance over which to cast the box.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to detect colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Returns the number of results placed in the results array. 
            */
            public BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>) : number
            /** Casts a capsule against colliders in the PhysicsScene2D, returning the first intersection only.
            * @param origin The point in 2D space where the capsule originates.
            * @param size The size of the capsule.
            * @param capsuleDirection The direction of the capsule.
            * @param angle The angle of the capsule (in degrees).
            * @param direction Vector representing the direction to cast the capsule.
            * @param distance Maximum distance over which to cast the capsule.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns The cast results returned. 
            */
            public CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask?: number) : UnityEngine.RaycastHit2D
            /** Casts a capsule against colliders in the PhysicsScene2D, returning the first intersection only.
            * @param origin The point in 2D space where the capsule originates.
            * @param size The size of the capsule.
            * @param capsuleDirection The direction of the capsule.
            * @param angle The angle of the capsule (in degrees).
            * @param direction Vector representing the direction to cast the capsule.
            * @param distance Maximum distance over which to cast the capsule.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns The cast results returned. 
            */
            public CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D) : UnityEngine.RaycastHit2D
            /** Casts a capsule against the Colliders in the PhysicsScene2D, returning all intersections.
            * @param origin The point in 2D space where the capsule originates.
            * @param size The size of the capsule.
            * @param capsuleDirection The direction of the capsule.
            * @param angle The angle of the capsule (in degrees).
            * @param direction Vector representing the direction to cast the capsule.
            * @param distance Maximum distance over which to cast the capsule.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Returns the number of results placed in the results array. 
            */
            public CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask?: number) : number
            /** Casts a capsule against the Colliders in the PhysicsScene2D, returning all intersections.
            * @param origin The point in 2D space where the capsule originates.
            * @param size The size of the capsule.
            * @param capsuleDirection The direction of the capsule.
            * @param angle The angle of the capsule (in degrees).
            * @param direction Vector representing the direction to cast the capsule.
            * @param distance Maximum distance over which to cast the capsule.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask The filter used to detect Colliders only on certain layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Returns the number of results placed in the results array. 
            */
            public CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>) : number
            /** Cast a 3D ray against the colliders in the PhysicsScene2D, returning the first intersection only.
            * @param ray The 3D ray defining origin and direction to test.
            * @param distance Maximum distance over which to cast the ray.
            * @param layerMask Filter to detect colliders only on certain layers.
            * @returns The cast results returned. 
            */
            public GetRayIntersection ($ray: UnityEngine.Ray, $distance: number, $layerMask?: number) : UnityEngine.RaycastHit2D
            /** Cast a 3D ray against the colliders in the PhysicsScene2D, returning all intersections.
            * @param ray The 3D ray defining origin and direction to test.
            * @param distance Maximum distance over which to cast the ray.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to detect colliders only on certain layers.
            * @returns The number of results returned. 
            */
            public GetRayIntersection ($ray: UnityEngine.Ray, $distance: number, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask?: number) : number
            /** Checks a point against Colliders in the PhysicsScene2D, returning the first intersection only.
            * @param point A point in world space.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns The collider overlapping the point. 
            */
            public OverlapPoint ($point: UnityEngine.Vector2, $layerMask?: number) : UnityEngine.Collider2D
            /** Checks a point against Colliders in the PhysicsScene2D, returning the first intersection only.
            * @param point A point in world space.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns The collider overlapping the point. 
            */
            public OverlapPoint ($point: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D) : UnityEngine.Collider2D
            /** Checks a point against Colliders in the PhysicsScene2D, returning all intersections.
            * @param point A point in world space.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns Returns the number of results placed in the results array. 
            */
            public OverlapPoint ($point: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask?: number) : number
            /** Checks a point against Colliders in the PhysicsScene2D, returning all intersections.
            * @param point A point in world space.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns Returns the number of results placed in the results array. 
            */
            public OverlapPoint ($point: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public OverlapPoint ($point: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            /** Checks a circle against Colliders in the PhysicsScene2D, returning the first intersection only.
            * @param point The centre of the circle.
            * @param radius The radius of the circle.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns The collider overlapping the circle. 
            */
            public OverlapCircle ($point: UnityEngine.Vector2, $radius: number, $layerMask?: number) : UnityEngine.Collider2D
            /** Checks a circle against Colliders in the PhysicsScene2D, returning the first intersection only.
            * @param point The centre of the circle.
            * @param radius The radius of the circle.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns The collider overlapping the circle. 
            */
            public OverlapCircle ($point: UnityEngine.Vector2, $radius: number, $contactFilter: UnityEngine.ContactFilter2D) : UnityEngine.Collider2D
            /** Checks a circle against Colliders in the PhysicsScene2D, returning all intersections.
            * @param point The centre of the circle.
            * @param radius The radius of the circle.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns Returns the number of results placed in the results array. 
            */
            public OverlapCircle ($point: UnityEngine.Vector2, $radius: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask?: number) : number
            /** Checks a circle against Colliders in the PhysicsScene2D, returning all intersections.
            * @param point The centre of the circle.
            * @param radius The radius of the circle.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns Returns the number of results placed in the results array. 
            */
            public OverlapCircle ($point: UnityEngine.Vector2, $radius: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public OverlapCircle ($point: UnityEngine.Vector2, $radius: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            /** Checks a box against Colliders in the PhysicsScene2D, returning the first intersection only.
            * @param point The center of the box.
            * @param size The size of the box.
            * @param angle The angle of the box.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns The collider overlapping the box. 
            */
            public OverlapBox ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask?: number) : UnityEngine.Collider2D
            /** Checks a box against Colliders in the PhysicsScene2D, returning the first intersection only.
            * @param point The center of the box.
            * @param size The size of the box.
            * @param angle The angle of the box.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns The collider overlapping the box. 
            */
            public OverlapBox ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $contactFilter: UnityEngine.ContactFilter2D) : UnityEngine.Collider2D
            /** Checks a box against Colliders in the PhysicsScene2D, returning all intersections.
            * @param point The center of the box.
            * @param size The size of the box.
            * @param angle The angle of the box.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns Returns the number of results placed in the results array. 
            */
            public OverlapBox ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask?: number) : number
            /** Checks a box against Colliders in the PhysicsScene2D, returning all intersections.
            * @param point The center of the box.
            * @param size The size of the box.
            * @param angle The angle of the box.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns Returns the number of results placed in the results array. 
            */
            public OverlapBox ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public OverlapBox ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            /** Checks an area (non-rotated box) against Colliders in the PhysicsScene2D, returning the first intersection only.
            * @param pointA One corner of the rectangle.
            * @param pointB The corner of the rectangle diagonally opposite the pointA corner.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns The collider overlapping the area. 
            */
            public OverlapArea ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask?: number) : UnityEngine.Collider2D
            /** Checks an area (non-rotated box) against Colliders in the PhysicsScene2D, returning the first intersection only.
            * @param pointA One corner of the rectangle.
            * @param pointB The corner of the rectangle diagonally opposite the pointA corner.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns The collider overlapping the area. 
            */
            public OverlapArea ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D) : UnityEngine.Collider2D
            /** Checks an area (non-rotated box) against Colliders in the PhysicsScene2D, returning all intersections.
            * @param pointA One corner of the rectangle.
            * @param pointB The corner of the rectangle diagonally opposite the pointA corner.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns Returns the number of results placed in the results array. 
            */
            public OverlapArea ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask?: number) : number
            /** Checks an area (non-rotated box) against Colliders in the PhysicsScene2D, returning all intersections.
            * @param pointA One corner of the rectangle.
            * @param pointB The corner of the rectangle diagonally opposite the pointA corner.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns Returns the number of results placed in the results array. 
            */
            public OverlapArea ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public OverlapArea ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            /** Checks a capsule against Colliders in the PhysicsScene2D, returning the first intersection only.
            * @param point The center of the capsule.
            * @param size The size of the capsule.
            * @param direction The direction of the capsule.
            * @param angle The angle of the capsule.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns The collider overlapping the capsule. 
            */
            public OverlapCapsule ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask?: number) : UnityEngine.Collider2D
            /** Checks a capsule against Colliders in the PhysicsScene2D, returning the first intersection only.
            * @param point The center of the capsule.
            * @param size The size of the capsule.
            * @param direction The direction of the capsule.
            * @param angle The angle of the capsule.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns The collider overlapping the capsule. 
            */
            public OverlapCapsule ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $contactFilter: UnityEngine.ContactFilter2D) : UnityEngine.Collider2D
            /** Checks a capsule against Colliders in the PhysicsScene2D, returning all intersections.
            * @param point The center of the capsule.
            * @param size The size of the capsule.
            * @param direction The direction of the capsule.
            * @param angle The angle of the capsule.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns Returns the number of results placed in the results array. 
            */
            public OverlapCapsule ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask?: number) : number
            /** Checks a capsule against Colliders in the PhysicsScene2D, returning all intersections.
            * @param point The center of the capsule.
            * @param size The size of the capsule.
            * @param direction The direction of the capsule.
            * @param angle The angle of the capsule.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns Returns the number of results placed in the results array. 
            */
            public OverlapCapsule ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public OverlapCapsule ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            /** Checks a Collider against Colliders in the PhysicsScene2D, returning all intersections.
            * @param collider The Collider that defines the area used to query for other Collider overlaps.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapCollider ($collider: UnityEngine.Collider2D, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask?: number) : number
            /** Checks a Collider against Colliders in the PhysicsScene2D, returning all intersections.
            * @param collider The Collider that defines the area used to query for other Collider overlaps.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param layerMask Filter to check objects only on specific layers.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask and Z depth. Note that the normal angle is not used for overlap testing.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapCollider ($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public static OverlapCollider ($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        /** Returns information about an object detected by a raycast in 2D physics.
        */
        class RaycastHit2D extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The centroid of the primitive used to perform the cast.
            */
            public get centroid(): UnityEngine.Vector2;
            public set centroid(value: UnityEngine.Vector2);
            /** The point in world space where the ray hit the collider's surface.
            */
            public get point(): UnityEngine.Vector2;
            public set point(value: UnityEngine.Vector2);
            /** The normal vector of the surface hit by the ray.
            */
            public get normal(): UnityEngine.Vector2;
            public set normal(value: UnityEngine.Vector2);
            /** The distance from the ray origin to the impact point.
            */
            public get distance(): number;
            public set distance(value: number);
            /** Fraction of the distance along the ray that the hit occurred.
            */
            public get fraction(): number;
            public set fraction(value: number);
            /** The collider hit by the ray.
            */
            public get collider(): UnityEngine.Collider2D;
            /** The Rigidbody2D attached to the object that was hit.
            */
            public get rigidbody(): UnityEngine.Rigidbody2D;
            /** The Transform of the object that was hit.
            */
            public get transform(): UnityEngine.Transform;
            public static op_Implicit ($hit: UnityEngine.RaycastHit2D) : boolean
            public CompareTo ($other: UnityEngine.RaycastHit2D) : number
        }
        /** A set of parameters for filtering contact results. Define the angle by referring to their position in world space, where 0 degrees is parallel to the positive x-axis, 90 degrees is parallel to the positive y-axis, 180 degrees is parallel to the negative x-axis, and 270 degrees is parallel to the negative y-axis.
        */
        class ContactFilter2D extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Sets to filter contact results based on trigger collider involvement.
            */
            public useTriggers : boolean
            /** Sets the contact filter to filter results by layer mask.
            */
            public useLayerMask : boolean
            /** Sets the contact filter to filter the results by depth using minDepth and maxDepth.
            */
            public useDepth : boolean
            /** Sets the contact filter to filter within the minDepth and maxDepth range, or outside that range.
            */
            public useOutsideDepth : boolean
            /** Sets the contact filter to filter the results by the collision's normal angle using minNormalAngle and maxNormalAngle.
            */
            public useNormalAngle : boolean
            /** Sets the contact filter to filter within the minNormalAngle and maxNormalAngle range, or outside that range.
            */
            public useOutsideNormalAngle : boolean
            /** Sets the contact filter to filter the results that only include Collider2D on the layers defined by the layer mask.
            */
            public layerMask : UnityEngine.LayerMask
            /** Sets the contact filter to filter the results to only include Collider2D with a Z coordinate (depth) greater than this value.
            */
            public minDepth : number
            /** Sets the contact filter to filter the results to only include Collider2D with a Z coordinate (depth) less than this value.
            */
            public maxDepth : number
            /** Sets the contact filter to filter the results to only include contacts with collision normal angles that are greater than this angle.
            */
            public minNormalAngle : number
            /** Sets the contact filter to filter the results to only include contacts with collision normal angles that are less than this angle.
            */
            public maxNormalAngle : number
            public static NormalAngleUpperLimit : number
            /** Given the current state of the contact filter, determine whether it would filter anything.
            */
            public get isFiltering(): boolean;
            public NoFilter () : UnityEngine.ContactFilter2D
            public ClearLayerMask () : void
            /** Sets the layerMask filter property using the layerMask parameter provided and also enables layer mask filtering by setting useLayerMask to true.
            * @param layerMask The value used to set the layerMask.
            */
            public SetLayerMask ($layerMask: UnityEngine.LayerMask) : void
            public ClearDepth () : void
            /** Sets the minDepth and maxDepth filter properties and turns on depth filtering by setting useDepth to true.
            * @param minDepth The value used to set minDepth.
            * @param maxDepth The value used to set maxDepth.
            */
            public SetDepth ($minDepth: number, $maxDepth: number) : void
            public ClearNormalAngle () : void
            /** Sets the minNormalAngle and maxNormalAngle filter properties and turns on normal angle filtering by setting useNormalAngle to true.
            * @param minNormalAngle The value used to set the minNormalAngle.
            * @param maxNormalAngle The value used to set the maxNormalAngle.
            */
            public SetNormalAngle ($minNormalAngle: number, $maxNormalAngle: number) : void
            /** Checks if the collider is a trigger and should be filtered by the useTriggers to be filtered.
            * @param collider The Collider2D used to check for a trigger.
            * @returns Returns true when collider is excluded by the filter and false if otherwise. 
            */
            public IsFilteringTrigger ($collider: UnityEngine.Collider2D) : boolean
            /** Checks if the GameObject.layer for obj is included in the layerMask to be filtered.
            * @param obj The GameObject used to check the GameObject.layer.
            * @returns Returns true when obj is excluded by the filter and false if otherwise. 
            */
            public IsFilteringLayerMask ($obj: UnityEngine.GameObject) : boolean
            /** Checks if the Transform for obj is within the depth range to be filtered.
            * @param obj The GameObject used to check the z-position (depth) of Transform.position.
            * @returns Returns true when obj is excluded by the filter and false if otherwise. 
            */
            public IsFilteringDepth ($obj: UnityEngine.GameObject) : boolean
            /** Checks if the angle of normal is within the normal angle range to be filtered.
            * @param normal The normal used to calculate an angle.
            * @returns Returns true when normal is excluded by the filter and false if otherwise. 
            */
            public IsFilteringNormalAngle ($normal: UnityEngine.Vector2) : boolean
            /** Checks if the angle is within the normal angle range to be filtered.
            * @param angle The angle used for comparison in the filter.
            * @returns Returns true when angle is excluded by the filter and false if otherwise. 
            */
            public IsFilteringNormalAngle ($angle: number) : boolean
        }
        /** The direction that the capsule sides can extend.
        */
        enum CapsuleDirection2D
        { Vertical = 0, Horizontal = 1 }
        /** Parent class for collider types used with 2D gameplay.
        */
        class Collider2D extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The density of the collider used to calculate its mass (when auto mass is enabled).
            */
            public get density(): number;
            public set density(value: number);
            /** Is this collider configured as a trigger?
            */
            public get isTrigger(): boolean;
            public set isTrigger(value: boolean);
            /** Whether the collider is used by an attached effector or not.
            */
            public get usedByEffector(): boolean;
            public set usedByEffector(value: boolean);
            /** Sets whether the Collider will be used or not used by a CompositeCollider2D.
            */
            public get usedByComposite(): boolean;
            public set usedByComposite(value: boolean);
            /** Get the CompositeCollider2D that is available to be attached to the collider.
            */
            public get composite(): UnityEngine.CompositeCollider2D;
            /** The local offset of the collider geometry.
            */
            public get offset(): UnityEngine.Vector2;
            public set offset(value: UnityEngine.Vector2);
            /** The Rigidbody2D attached to the Collider2D.
            */
            public get attachedRigidbody(): UnityEngine.Rigidbody2D;
            /** The number of active PhysicsShape2D the Collider2D is currently using.
            */
            public get shapeCount(): number;
            /** The world space bounding area of the collider.
            */
            public get bounds(): UnityEngine.Bounds;
            /** The error state that indicates the state of the physics shapes the 2D Collider tried to create. (Read Only)
            */
            public get errorState(): UnityEngine.ColliderErrorState2D;
            /** The PhysicsMaterial2D that is applied to this collider.
            */
            public get sharedMaterial(): UnityEngine.PhysicsMaterial2D;
            public set sharedMaterial(value: UnityEngine.PhysicsMaterial2D);
            /** Get the friction used by the collider.
            */
            public get friction(): number;
            /** Get the bounciness used by the collider.
            */
            public get bounciness(): number;
            /** Creates a planar Mesh that is identical to the area defined by the Collider2D geometry.
            * @param useBodyPosition Should the mesh be transformed by the position of the attached Rigidbody2D?
            * @param useBodyRotation Should the mesh be transformed by the rotation of the attached Rigidbody2D?
            * @returns The planar Mesh created that matches the collider geometry or NULL if no Mesh could be created. 
            */
            public CreateMesh ($useBodyPosition: boolean, $useBodyRotation: boolean) : UnityEngine.Mesh
            public GetShapeHash () : number
            /** Gets all the PhysicsShape2D used by the Collider2D.
            * @param physicsShapeGroup The PhysicsShapeGroup2D to store the retrieved PhysicsShape2D in.
            * @returns Returns the number of PhysicsShape2D retrieved from the Collider2D. 
            */
            public GetShapes ($physicsShapeGroup: UnityEngine.PhysicsShapeGroup2D) : number
            /** Gets the specified range of the PhysicsShape2D used by the Collider2D.
            * @param physicsShapeGroup The PhysicsShapeGroup2D to store the retrieved PhysicsShape2D in.
            * @param shapeIndex The index of the first shape to retrieve. This should be in the range of 0 to Collider2D.shapeCount-1.
            * @param shapeCount The number of shapes to retrieve. The shapeIndex + shapeCount must be less than or equal to Collider2D.shapeCount.
            * @returns Returns the number of PhysicsShape2D retrieved from the Collider2D. In all cases this should be the same number as shapeCount . 
            */
            public GetShapes ($physicsShapeGroup: UnityEngine.PhysicsShapeGroup2D, $shapeIndex: number, $shapeCount?: number) : number
            /** Check whether this collider is touching the collider or not.
            * @param collider The collider to check if it is touching this collider.
            * @returns Whether this collider is touching the collider or not. 
            */
            public IsTouching ($collider: UnityEngine.Collider2D) : boolean
            /** Check whether this collider is touching the collider or not with the results filtered by the contactFilter.
            * @param collider The collider to check if it is touching this collider.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Whether this collider is touching the collider or not. 
            */
            public IsTouching ($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D) : boolean
            /** Check whether this collider is touching other colliders or not with the results filtered by the contactFilter.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Whether this collider is touching the collider or not. 
            */
            public IsTouching ($contactFilter: UnityEngine.ContactFilter2D) : boolean
            public IsTouchingLayers () : boolean
            /** Checks whether this collider is touching any colliders on the specified layerMask or not.
            * @param layerMask Any colliders on any of these layers count as touching.
            * @returns Whether this collider is touching any collider on the specified layerMask or not. 
            */
            public IsTouchingLayers ($layerMask: number) : boolean
            /** Check if a collider overlaps a point in space.
            * @param point A point in world space.
            * @returns Does point overlap the collider? 
            */
            public OverlapPoint ($point: UnityEngine.Vector2) : boolean
            /** Calculates the minimum separation of this collider against another collider.
            * @param collider A collider used to calculate the minimum separation against this collider.
            * @returns The minimum separation of collider and this collider. 
            */
            public Distance ($collider: UnityEngine.Collider2D) : UnityEngine.ColliderDistance2D
            /** Get a list of all colliders that overlap this collider.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth.  Note that normal angle is not used for overlap testing.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @returns Returns the number of results placed in the results array. 
            */
            public OverlapCollider ($contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public OverlapCollider ($contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            /** Retrieves all contact points for this Collider.
            * @param contacts An array of ContactPoint2D used to receive the results.
            * @returns Returns the number of contacts placed in the contacts array. 
            */
            public GetContacts ($contacts: System.Array$1<UnityEngine.ContactPoint2D>) : number
            public GetContacts ($contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>) : number
            /** Retrieves all contact points for this Collider, with the results filtered by the contactFilter.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param contacts An array of ContactPoint2D used to receive the results.
            * @returns Returns the number of contacts placed in the contacts array. 
            */
            public GetContacts ($contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>) : number
            public GetContacts ($contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>) : number
            /** Retrieves all colliders in contact with this Collider.
            * @param colliders An array of Collider2D used to receive the results.
            * @returns Returns the number of contacts placed in the colliders array. 
            */
            public GetContacts ($colliders: System.Array$1<UnityEngine.Collider2D>) : number
            public GetContacts ($colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            /** Retrieves all colliders in contact with this Collider, with the results filtered by the contactFilter.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param colliders An array of Collider2D used to receive the results.
            * @returns Returns the number of colliders placed in the colliders array. 
            */
            public GetContacts ($contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Array$1<UnityEngine.Collider2D>) : number
            public GetContacts ($contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            public Cast ($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public Cast ($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            /** Casts the Collider shape into the Scene starting at the Collider position ignoring the Collider itself.
            * @param direction Vector representing the direction to cast the shape.
            * @param results Array to receive results.
            * @param distance Maximum distance over which to cast the shape.
            * @param ignoreSiblingColliders Determines whether the cast should ignore Colliders attached to the same Rigidbody2D (known as sibling Colliders).
            * @returns The number of results returned. 
            */
            public Cast ($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $ignoreSiblingColliders: boolean) : number
            public Cast ($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public Cast ($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            /** Casts the Collider shape into the Scene starting at the Collider position ignoring the Collider itself.
            * @param direction Vector representing the direction to cast the shape.
            * @param contactFilter Filter results defined by the contact filter.
            * @param results Array to receive results.
            * @param distance Maximum distance over which to cast the shape.
            * @param ignoreSiblingColliders Determines whether the cast should ignore Colliders attached to the same Rigidbody2D (known as sibling Colliders).
            * @returns The number of results returned. 
            */
            public Cast ($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $ignoreSiblingColliders: boolean) : number
            public Cast ($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number, $ignoreSiblingColliders?: boolean) : number
            public Raycast ($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public Raycast ($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            public Raycast ($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number) : number
            public Raycast ($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number) : number
            /** Casts a ray into the Scene that starts at the Collider position and ignores the Collider itself.
            * @param direction Vector representing the direction of the ray.
            * @param results Array to receive results.
            * @param distance Maximum distance over which to cast the ray.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than this value.
            * @param contactFilter Filter results defined by the contact filter.
            * @returns The number of results returned. 
            */
            public Raycast ($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : number
            public Raycast ($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            /** Casts a ray into the Scene that starts at the Collider position and ignores the Collider itself.
            * @param direction Vector representing the direction of the ray.
            * @param results Array to receive results.
            * @param distance Maximum distance over which to cast the ray.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than this value.
            * @param contactFilter Filter results defined by the contact filter.
            * @returns The number of results returned. 
            */
            public Raycast ($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            public Raycast ($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number) : number
            /** Returns a point on the perimeter of this Collider that is closest to the specified position.
            * @param position The position from which to find the closest point on this Collider.
            * @returns A point on the perimeter of this Collider that is closest to the specified position. 
            */
            public ClosestPoint ($position: UnityEngine.Vector2) : UnityEngine.Vector2
            public constructor ()
        }
        /** Scene extensions to access the underlying physics scene.
        */
        class PhysicsSceneExtensions2D extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** An extension method that returns the 2D physics Scene from the Scene.
            * @param scene The Scene from which to return the 2D physics Scene.
            * @returns The 2D physics Scene used by the Scene. 
            */
            public static GetPhysicsScene2D ($scene: UnityEngine.SceneManagement.Scene) : UnityEngine.PhysicsScene2D
        }
        /** Global settings and helpers for 2D physics.
        */
        class Physics2D extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Layer mask constant for the default layer that ignores raycasts.
            */
            public static IgnoreRaycastLayer : number
            /** Layer mask constant that includes all layers participating in raycasts by default.
            */
            public static DefaultRaycastLayers : number
            /** Layer mask constant that includes all layers.
            */
            public static AllLayers : number
            /** The maximum number of vertices allowed per primitive polygon shape type (PhysicsShapeType2D.Polygon). (Read Only)
            */
            public static MaxPolygonShapeVertices : number
            /** The PhysicsScene2D automatically created when Unity starts.
            */
            public static get defaultPhysicsScene(): UnityEngine.PhysicsScene2D;
            /** The number of iterations of the physics solver when considering objects' velocities.
            */
            public static get velocityIterations(): number;
            public static set velocityIterations(value: number);
            /** The number of iterations of the physics solver when considering objects' positions.
            */
            public static get positionIterations(): number;
            public static set positionIterations(value: number);
            /** Acceleration due to gravity.
            */
            public static get gravity(): UnityEngine.Vector2;
            public static set gravity(value: UnityEngine.Vector2);
            /** Do raycasts detect Colliders configured as triggers?
            */
            public static get queriesHitTriggers(): boolean;
            public static set queriesHitTriggers(value: boolean);
            /** Set the raycasts or linecasts that start inside Colliders to detect or not detect those Colliders.
            */
            public static get queriesStartInColliders(): boolean;
            public static set queriesStartInColliders(value: boolean);
            /** Use this to control whether or not the appropriate OnCollisionExit2D or OnTriggerExit2D callbacks should be called when a Collider2D is disabled.
            */
            public static get callbacksOnDisable(): boolean;
            public static set callbacksOnDisable(value: boolean);
            /** Determines whether the garbage collector should reuse only a single instance of a Collision2D type for all collision callbacks.
            */
            public static get reuseCollisionCallbacks(): boolean;
            public static set reuseCollisionCallbacks(value: boolean);
            /** Set whether to automatically sync changes to the Transform component with the physics engine.
            */
            public static get autoSyncTransforms(): boolean;
            public static set autoSyncTransforms(value: boolean);
            /** Controls when Unity executes the 2D physics simulation.
            */
            public static get simulationMode(): UnityEngine.SimulationMode2D;
            public static set simulationMode(value: UnityEngine.SimulationMode2D);
            /** A set of options that control how physics operates when using the job system to multithread the physics simulation.
            */
            public static get jobOptions(): UnityEngine.PhysicsJobOptions2D;
            public static set jobOptions(value: UnityEngine.PhysicsJobOptions2D);
            /** Any collisions with a relative linear velocity below this threshold will be treated as inelastic.
            */
            public static get velocityThreshold(): number;
            public static set velocityThreshold(value: number);
            /** The maximum linear position correction used when solving constraints.  This helps to prevent overshoot.
            */
            public static get maxLinearCorrection(): number;
            public static set maxLinearCorrection(value: number);
            /** The maximum angular position correction used when solving constraints.  This helps to prevent overshoot.
            */
            public static get maxAngularCorrection(): number;
            public static set maxAngularCorrection(value: number);
            /** The maximum linear speed of a rigid-body per physics update.  Increasing this can cause numerical problems.
            */
            public static get maxTranslationSpeed(): number;
            public static set maxTranslationSpeed(value: number);
            /** The maximum angular speed of a rigid-body per physics update.  Increasing this can cause numerical problems.
            */
            public static get maxRotationSpeed(): number;
            public static set maxRotationSpeed(value: number);
            /** The default contact offset of the newly created Colliders.
            */
            public static get defaultContactOffset(): number;
            public static set defaultContactOffset(value: number);
            /** The scale factor that controls how fast overlaps are resolved.
            */
            public static get baumgarteScale(): number;
            public static set baumgarteScale(value: number);
            /** The scale factor that controls how fast TOI overlaps are resolved.
            */
            public static get baumgarteTOIScale(): number;
            public static set baumgarteTOIScale(value: number);
            /** The time in seconds that a rigid-body must be still before it will go to sleep.
            */
            public static get timeToSleep(): number;
            public static set timeToSleep(value: number);
            /** A rigid-body cannot sleep if its linear velocity is above this tolerance.
            */
            public static get linearSleepTolerance(): number;
            public static set linearSleepTolerance(value: number);
            /** A Rigidbody cannot sleep if its angular velocity is above this tolerance threshold.
            */
            public static get angularSleepTolerance(): number;
            public static set angularSleepTolerance(value: number);
            /** Enable to always show the Collider Gizmos even when they are not selected.
            */
            public static get alwaysShowColliders(): boolean;
            public static set alwaysShowColliders(value: boolean);
            /** Should the Collider Gizmos show the sleep-state for each Collider?
            */
            public static get showColliderSleep(): boolean;
            public static set showColliderSleep(value: boolean);
            /** Should the Collider Gizmos show current contacts for each Collider?
            */
            public static get showColliderContacts(): boolean;
            public static set showColliderContacts(value: boolean);
            /** Should the Collider Gizmos show the AABBs for each Collider?
            */
            public static get showColliderAABB(): boolean;
            public static set showColliderAABB(value: boolean);
            /** The scale of the contact arrow used by the Collider Gizmos.
            */
            public static get contactArrowScale(): number;
            public static set contactArrowScale(value: number);
            /** The color used by the Gizmos to show all awake Colliders (Collider is awake when the body is awake).
            */
            public static get colliderAwakeColor(): UnityEngine.Color;
            public static set colliderAwakeColor(value: UnityEngine.Color);
            /** The color used by the Gizmos to show all asleep Colliders (Collider is asleep when the body is asleep).
            */
            public static get colliderAsleepColor(): UnityEngine.Color;
            public static set colliderAsleepColor(value: UnityEngine.Color);
            /** The color used by the Gizmos to show all Collider contacts.
            */
            public static get colliderContactColor(): UnityEngine.Color;
            public static set colliderContactColor(value: UnityEngine.Color);
            /** Set the color used by the Gizmos to show all Collider axis-aligned bounding boxes (AABBs).
            */
            public static get colliderAABBColor(): UnityEngine.Color;
            public static set colliderAABBColor(value: UnityEngine.Color);
            /** Simulate physics in the Scene.
            * @param step The time to advance physics by.
            * @returns Whether the simulation was run or not.  Running the simulation during physics callbacks will always fail. 
            */
            public static Simulate ($step: number) : boolean
            public static SyncTransforms () : void
            public static IgnoreCollision ($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D) : void
            /** Makes the collision detection system ignore all collisionstriggers between collider1 and collider2/.
            * @param collider1 The first Collider to compare to collider2.
            * @param collider2 The second Collider to compare to collider1.
            * @param ignore Whether collisionstriggers between collider1 and collider2/ should be ignored or not.
            */
            public static IgnoreCollision ($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D, $ignore: boolean) : void
            /** Checks whether the collision detection system will ignore all collisionstriggers between collider1 and collider2/ or not.
            * @param collider1 The first Collider to compare to collider2.
            * @param collider2 The second Collider to compare to collider1.
            * @returns Whether the collision detection system will ignore all collisionstriggers between collider1 and collider2/ or not. 
            */
            public static GetIgnoreCollision ($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D) : boolean
            public static IgnoreLayerCollision ($layer1: number, $layer2: number) : void
            /** Choose whether to detect or ignore collisions between a specified pair of layers.
            * @param layer1 ID of the first layer.
            * @param layer2 ID of the second layer.
            * @param ignore Should collisions between these layers be ignored?
            */
            public static IgnoreLayerCollision ($layer1: number, $layer2: number, $ignore: boolean) : void
            /** Checks whether collisions between the specified layers be ignored or not.
            * @param layer1 ID of first layer.
            * @param layer2 ID of second layer.
            * @returns Whether collisions between the specified layers be ignored or not. 
            */
            public static GetIgnoreLayerCollision ($layer1: number, $layer2: number) : boolean
            /** Set the collision layer mask that indicates which layer(s) the specified layer can collide with.
            * @param layer The layer to set the collision layer mask for.
            * @param layerMask A mask where each bit indicates a layer and whether it can collide with layer or not.
            */
            public static SetLayerCollisionMask ($layer: number, $layerMask: number) : void
            /** Get the collision layer mask that indicates which layer(s) the specified layer can collide with.
            * @param layer The layer to retrieve the collision layer mask for.
            * @returns A mask where each bit indicates a layer and whether it can collide with layer or not. 
            */
            public static GetLayerCollisionMask ($layer: number) : number
            /** Checks whether the passed Colliders are in contact or not.
            * @param collider1 The Collider to check if it is touching collider2.
            * @param collider2 The Collider to check if it is touching collider1.
            * @returns Whether collider1 is touching collider2 or not. 
            */
            public static IsTouching ($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D) : boolean
            /** Checks whether the passed Colliders are in contact or not.
            * @param collider1 The Collider to check if it is touching collider2.
            * @param collider2 The Collider to check if it is touching collider1.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Whether collider1 is touching collider2 or not. 
            */
            public static IsTouching ($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D) : boolean
            /** Checks whether the passed Colliders are in contact or not.
            * @param Collider The Collider to check if it is touching any other Collider filtered by the contactFilter.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Whether the Collider is touching any other Collider filtered by the contactFilter or not. 
            */
            public static IsTouching ($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D) : boolean
            public static IsTouchingLayers ($collider: UnityEngine.Collider2D) : boolean
            /** Checks whether the Collider is touching any Colliders on the specified layerMask or not.
            * @param Collider The Collider to check if it is touching Colliders on the layerMask.
            * @param layerMask Any Colliders on any of these layers count as touching.
            * @returns Whether the Collider is touching any Colliders on the specified layerMask or not. 
            */
            public static IsTouchingLayers ($collider: UnityEngine.Collider2D, $layerMask: number) : boolean
            /** Calculates the minimum distance between two Colliders.
            * @param colliderA A Collider used to calculate the minimum distance against colliderB.
            * @param colliderB A Collider used to calculate the minimum distance against colliderA.
            * @returns The minimum distance between colliderA and colliderB. 
            */
            public static Distance ($colliderA: UnityEngine.Collider2D, $colliderB: UnityEngine.Collider2D) : UnityEngine.ColliderDistance2D
            /** Returns a point on the perimeter of the Collider that is closest to the specified position.
            * @param position The position from which to find the closest point on the specified Collider.
            * @param Collider The Collider on which to find the closest specified position.
            * @returns A point on the perimeter of the Collider that is closest to the specified position. 
            */
            public static ClosestPoint ($position: UnityEngine.Vector2, $collider: UnityEngine.Collider2D) : UnityEngine.Vector2
            /** Returns a point on the perimeter of all enabled Colliders attached to the rigidbody that is closest to the specified position.
            * @param position The position from which to find the closest point on the specified rigidbody.
            * @param rigidbody The Rigidbody on which to find the closest specified position.
            * @returns A point on the perimeter of a Collider attached to the rigidbody that is closest to the specified position. 
            */
            public static ClosestPoint ($position: UnityEngine.Vector2, $rigidbody: UnityEngine.Rigidbody2D) : UnityEngine.Vector2
            public static Linecast ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2) : UnityEngine.RaycastHit2D
            public static Linecast ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask: number) : UnityEngine.RaycastHit2D
            public static Linecast ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask: number, $minDepth: number) : UnityEngine.RaycastHit2D
            /** Casts a line segment against Colliders in the Scene.
            * @param start The start point of the line in world space.
            * @param end The end point of the line in world space.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The cast results returned. 
            */
            public static Linecast ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask: number, $minDepth: number, $maxDepth: number) : UnityEngine.RaycastHit2D
            /** Casts a line segment against Colliders in the Scene with results filtered by ContactFilter2D.
            * @param start The start point of the line in world space.
            * @param end The end point of the line in world space.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @returns Returns the number of results placed in the results array. 
            */
            public static Linecast ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public static Linecast ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>) : number
            public static LinecastAll ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2) : System.Array$1<UnityEngine.RaycastHit2D>
            public static LinecastAll ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static LinecastAll ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask: number, $minDepth: number) : System.Array$1<UnityEngine.RaycastHit2D>
            /** Casts a line against Colliders in the Scene.
            * @param start The start point of the line in world space.
            * @param end The end point of the line in world space.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The cast results returned. 
            */
            public static LinecastAll ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $layerMask: number, $minDepth: number, $maxDepth: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static LinecastNonAlloc ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public static LinecastNonAlloc ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask: number) : number
            public static LinecastNonAlloc ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask: number, $minDepth: number) : number
            /** Casts a line against Colliders in the Scene. Note: This method will be deprecated in a future build and it is recommended to use Linecast instead.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @param start The start point of the line in world space.
            * @param end The end point of the line in world space.
            * @param results Returned array of objects that intersect the line.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @returns Returns the number of results placed in the results array. 
            */
            public static LinecastNonAlloc ($start: UnityEngine.Vector2, $end: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $layerMask: number, $minDepth: number, $maxDepth: number) : number
            public static Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2) : UnityEngine.RaycastHit2D
            public static Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number) : UnityEngine.RaycastHit2D
            public static Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number) : UnityEngine.RaycastHit2D
            public static Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number) : UnityEngine.RaycastHit2D
            /** Casts a ray against Colliders in the Scene.
            * @param origin The point in 2D space where the ray originates.
            * @param direction A vector representing the direction of the ray.
            * @param distance The maximum distance over which to cast the ray.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The cast results returned. 
            */
            public static Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : UnityEngine.RaycastHit2D
            public static Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            /** Casts a ray against Colliders in the Scene.
            * @param origin The point in 2D space where the ray originates.
            * @param direction A vector representing the direction of the ray.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param distance The maximum distance over which to cast the ray.
            * @returns Returns the number of results placed in the results array. 
            */
            public static Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            public static Raycast ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number) : number
            public static RaycastNonAlloc ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public static RaycastNonAlloc ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            public static RaycastNonAlloc ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number) : number
            public static RaycastNonAlloc ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number) : number
            /** Casts a ray into the Scene. Note: This method will be deprecated in a future build and it is recommended to use Raycast instead.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @param origin The point in 2D space where the ray originates.
            * @param direction A vector representing the direction of the ray.
            * @param results Array to receive results.
            * @param distance The maximum distance over which to cast the ray.
            * @param layerMask Filter to check objects only on specific layers.
            * @returns Returns the number of results placed in the results array. 
            */
            public static RaycastNonAlloc ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : number
            public static RaycastAll ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2) : System.Array$1<UnityEngine.RaycastHit2D>
            public static RaycastAll ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static RaycastAll ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static RaycastAll ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number) : System.Array$1<UnityEngine.RaycastHit2D>
            /** Casts a ray against Colliders in the Scene, returning all Colliders that contact with it.
            * @param origin The point in 2D space where the ray originates.
            * @param direction A vector representing the direction of the ray.
            * @param distance The maximum distance over which to cast the ray.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The cast results returned. 
            */
            public static RaycastAll ($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2) : UnityEngine.RaycastHit2D
            public static CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number) : UnityEngine.RaycastHit2D
            public static CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number) : UnityEngine.RaycastHit2D
            public static CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number) : UnityEngine.RaycastHit2D
            /** Casts a circle against Colliders in the Scene, returning the first Collider to contact with it.
            * @param origin The point in 2D space where the circle originates.
            * @param radius The radius of the circle.
            * @param direction A vector representing the direction of the circle.
            * @param distance The maximum distance over which to cast the circle.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The cast results returned. 
            */
            public static CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : UnityEngine.RaycastHit2D
            public static CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            /** Casts a circle against Colliders in the Scene, returning all Colliders that contact with it.
            * @param origin The point in 2D space where the circle originates.
            * @param radius The radius of the circle.
            * @param direction A vector representing the direction of the circle.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param distance The maximum distance over which to cast the circle.
            * @returns Returns the number of results placed in the results array. 
            */
            public static CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            public static CircleCast ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number) : number
            public static CircleCastAll ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2) : System.Array$1<UnityEngine.RaycastHit2D>
            public static CircleCastAll ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static CircleCastAll ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static CircleCastAll ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number) : System.Array$1<UnityEngine.RaycastHit2D>
            /** Casts a circle against Colliders in the Scene, returning all Colliders that contact with it.
            * @param origin The point in 2D space where the circle originates.
            * @param radius The radius of the circle.
            * @param direction A vector representing the direction of the circle.
            * @param distance The maximum distance over which to cast the circle.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The cast results returned. 
            */
            public static CircleCastAll ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static CircleCastNonAlloc ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public static CircleCastNonAlloc ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            public static CircleCastNonAlloc ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number) : number
            public static CircleCastNonAlloc ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number) : number
            /** Casts a circle into the Scene, returning Colliders that contact with it into the provided results array. Note: This method will be deprecated in a future build and it is recommended to use CircleCast instead.
            * @param origin The point in 2D space where the circle originates.
            * @param radius The radius of the circle.
            * @param direction A vector representing the direction of the circle.
            * @param results Array to receive results.
            * @param distance The maximum distance over which to cast the circle.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns Returns the number of results placed in the results array. 
            */
            public static CircleCastNonAlloc ($origin: UnityEngine.Vector2, $radius: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : number
            public static BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2) : UnityEngine.RaycastHit2D
            public static BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number) : UnityEngine.RaycastHit2D
            public static BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number) : UnityEngine.RaycastHit2D
            public static BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number) : UnityEngine.RaycastHit2D
            /** Casts a box against Colliders in the Scene, returning the first Collider to contact with it.
            * @param origin The point in 2D space where the box originates.
            * @param size The size of the box.
            * @param angle The angle of the box (in degrees).
            * @param direction A vector representing the direction of the box.
            * @param distance The maximum distance over which to cast the box.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The cast results returned. 
            */
            public static BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : UnityEngine.RaycastHit2D
            public static BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            /** Casts a box against the Colliders in the Scene and returns all Colliders that are in contact with it.
            * @param origin The point in 2D space where the box originates.
            * @param size The size of the box.
            * @param angle The angle of the box (in degrees).
            * @param direction A vector representing the direction of the box.
            * @param distance The maximum distance over which to cast the box.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Returns the number of results placed in the results array. 
            */
            public static BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            public static BoxCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number) : number
            public static BoxCastAll ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2) : System.Array$1<UnityEngine.RaycastHit2D>
            public static BoxCastAll ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static BoxCastAll ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static BoxCastAll ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number) : System.Array$1<UnityEngine.RaycastHit2D>
            /** Casts a box against Colliders in the Scene, returning all Colliders that contact with it.
            * @param origin The point in 2D space where the box originates.
            * @param size The size of the box.
            * @param angle The angle of the box (in degrees).
            * @param direction A vector representing the direction of the box.
            * @param distance The maximum distance over which to cast the box.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The cast results returned. 
            */
            public static BoxCastAll ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static BoxCastNonAlloc ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public static BoxCastNonAlloc ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            public static BoxCastNonAlloc ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number) : number
            public static BoxCastNonAlloc ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number) : number
            /** Casts a box into the Scene, returning Colliders that contact with it into the provided results array. Note: This method will be deprecated in a future build and it is recommended to use BoxCast instead.
            * @param origin The point in 2D space where the box originates.
            * @param size The size of the box.
            * @param angle The angle of the box (in degrees).
            * @param direction A vector representing the direction of the box.
            * @param results Array to receive results.
            * @param distance The maximum distance over which to cast the box.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns Returns the number of results placed in the results array. 
            */
            public static BoxCastNonAlloc ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : number
            public static CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2) : UnityEngine.RaycastHit2D
            public static CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number) : UnityEngine.RaycastHit2D
            public static CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number) : UnityEngine.RaycastHit2D
            public static CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number) : UnityEngine.RaycastHit2D
            /** Casts a capsule against Colliders in the Scene, returning the first Collider to contact with it.
            * @param origin The point in 2D space where the capsule originates.
            * @param size The size of the capsule.
            * @param capsuleDirection The direction of the capsule.
            * @param angle The angle of the capsule (in degrees).
            * @param direction Vector representing the direction to cast the capsule.
            * @param distance The maximum distance over which to cast the capsule.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than this value.
            * @returns The cast results returned. 
            */
            public static CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : UnityEngine.RaycastHit2D
            public static CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            /** Casts a capsule against the Colliders in the Scene and returns all Colliders that are in contact with it.
            * @param origin The point in 2D space where the capsule originates.
            * @param size The size of the capsule.
            * @param capsuleDirection The direction of the capsule.
            * @param angle The angle of the capsule (in degrees).
            * @param direction Vector representing the direction to cast the capsule.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @param distance The maximum distance over which to cast the capsule.
            * @returns Returns the number of results placed in the results array. 
            */
            public static CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            public static CapsuleCast ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number) : number
            public static CapsuleCastAll ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2) : System.Array$1<UnityEngine.RaycastHit2D>
            public static CapsuleCastAll ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static CapsuleCastAll ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static CapsuleCastAll ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number) : System.Array$1<UnityEngine.RaycastHit2D>
            /** Casts a capsule against Colliders in the Scene, returning all Colliders that contact with it.
            * @param origin The point in 2D space where the capsule originates.
            * @param size The size of the capsule.
            * @param capsuleDirection The direction of the capsule.
            * @param angle The angle of the capsule (in degrees).
            * @param direction Vector representing the direction to cast the capsule.
            * @param distance The maximum distance over which to cast the capsule.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than this value.
            * @returns The cast results returned. 
            */
            public static CapsuleCastAll ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static CapsuleCastNonAlloc ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public static CapsuleCastNonAlloc ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            public static CapsuleCastNonAlloc ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number) : number
            public static CapsuleCastNonAlloc ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number) : number
            /** Casts a capsule into the Scene, returning Colliders that contact with it into the provided results array. Note: This method will be deprecated in a future build and it is recommended to use CapsuleCast instead.
            * @param origin The point in 2D space where the capsule originates.
            * @param size The size of the capsule.
            * @param capsuleDirection The direction of the capsule.
            * @param angle The angle of the capsule (in degrees).
            * @param direction Vector representing the direction to cast the capsule.
            * @param results Array to receive results.
            * @param distance The maximum distance over which to cast the capsule.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than this value.
            * @returns Returns the number of results placed in the results array. 
            */
            public static CapsuleCastNonAlloc ($origin: UnityEngine.Vector2, $size: UnityEngine.Vector2, $capsuleDirection: UnityEngine.CapsuleDirection2D, $angle: number, $direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number, $minDepth: number, $maxDepth: number) : number
            public static GetRayIntersection ($ray: UnityEngine.Ray) : UnityEngine.RaycastHit2D
            public static GetRayIntersection ($ray: UnityEngine.Ray, $distance: number) : UnityEngine.RaycastHit2D
            /** Cast a 3D ray against the Colliders in the Scene returning the first Collider along the ray.
            * @param ray The 3D ray defining origin and direction to test.
            * @param distance The maximum distance over which to cast the ray.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @returns The cast results returned. 
            */
            public static GetRayIntersection ($ray: UnityEngine.Ray, $distance: number, $layerMask: number) : UnityEngine.RaycastHit2D
            public static GetRayIntersectionAll ($ray: UnityEngine.Ray) : System.Array$1<UnityEngine.RaycastHit2D>
            public static GetRayIntersectionAll ($ray: UnityEngine.Ray, $distance: number) : System.Array$1<UnityEngine.RaycastHit2D>
            /** Cast a 3D ray against the Colliders in the Scene returning all the Colliders along the ray.
            * @param ray The 3D ray defining origin and direction to test.
            * @param distance The maximum distance over which to cast the ray.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @returns The cast results returned. 
            */
            public static GetRayIntersectionAll ($ray: UnityEngine.Ray, $distance: number, $layerMask: number) : System.Array$1<UnityEngine.RaycastHit2D>
            public static GetRayIntersectionNonAlloc ($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            public static GetRayIntersectionNonAlloc ($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            /** Cast a 3D ray against the Colliders in the Scene returning the Colliders along the ray. Note: This method will be deprecated in a future build and it is recommended to use GetRayIntersection instead.
            * @param ray The 3D ray defining origin and direction to test.
            * @param distance The maximum distance over which to cast the ray.
            * @param layerMask Filter to detect Colliders only on certain layers.
            * @param results Array to receive results.
            * @returns The number of results returned. 
            */
            public static GetRayIntersectionNonAlloc ($ray: UnityEngine.Ray, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number, $layerMask: number) : number
            public static OverlapPoint ($point: UnityEngine.Vector2) : UnityEngine.Collider2D
            public static OverlapPoint ($point: UnityEngine.Vector2, $layerMask: number) : UnityEngine.Collider2D
            public static OverlapPoint ($point: UnityEngine.Vector2, $layerMask: number, $minDepth: number) : UnityEngine.Collider2D
            /** Checks if a Collider overlaps a point in space.
            * @param point A point in world space.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The Collider overlapping the point. 
            */
            public static OverlapPoint ($point: UnityEngine.Vector2, $layerMask: number, $minDepth: number, $maxDepth: number) : UnityEngine.Collider2D
            /** Checks if a Collider overlaps a point in world space.
            * @param point A point in world space.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth.  Note that normal angle is not used for overlap testing.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapPoint ($point: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public static OverlapPoint ($point: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            public static OverlapPointAll ($point: UnityEngine.Vector2) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapPointAll ($point: UnityEngine.Vector2, $layerMask: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapPointAll ($point: UnityEngine.Vector2, $layerMask: number, $minDepth: number) : System.Array$1<UnityEngine.Collider2D>
            /** Get a list of all Colliders that overlap a point in space.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @param point A point in space.
            * @param layerMask Filter to check objects only on specific layers.
            * @returns The cast results returned. 
            */
            public static OverlapPointAll ($point: UnityEngine.Vector2, $layerMask: number, $minDepth: number, $maxDepth: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapPointNonAlloc ($point: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public static OverlapPointNonAlloc ($point: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number) : number
            public static OverlapPointNonAlloc ($point: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number) : number
            /** Get a list of all Colliders that overlap a point in space. Note: This method will be deprecated in a future build and it is recommended to use OverlapPoint instead.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @param point A point in space.
            * @param results Array to receive results.
            * @param layerMask Filter to check objects only on specific layers.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapPointNonAlloc ($point: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number, $maxDepth: number) : number
            public static OverlapCircle ($point: UnityEngine.Vector2, $radius: number) : UnityEngine.Collider2D
            public static OverlapCircle ($point: UnityEngine.Vector2, $radius: number, $layerMask: number) : UnityEngine.Collider2D
            public static OverlapCircle ($point: UnityEngine.Vector2, $radius: number, $layerMask: number, $minDepth: number) : UnityEngine.Collider2D
            /** Checks if a Collider falls within a circular area.
            * @param point Centre of the circle.
            * @param radius The radius of the circle.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The Collider overlapping the circle. 
            */
            public static OverlapCircle ($point: UnityEngine.Vector2, $radius: number, $layerMask: number, $minDepth: number, $maxDepth: number) : UnityEngine.Collider2D
            /** Checks if a Collider is within a circular area.
            * @param point Centre of the circle.
            * @param radius The radius of the circle.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth.  Note that normal angle is not used for overlap testing.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapCircle ($point: UnityEngine.Vector2, $radius: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public static OverlapCircle ($point: UnityEngine.Vector2, $radius: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            public static OverlapCircleAll ($point: UnityEngine.Vector2, $radius: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapCircleAll ($point: UnityEngine.Vector2, $radius: number, $layerMask: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapCircleAll ($point: UnityEngine.Vector2, $radius: number, $layerMask: number, $minDepth: number) : System.Array$1<UnityEngine.Collider2D>
            /** Get a list of all Colliders that fall within a circular area.
            * @param point The center of the circle.
            * @param radius The radius of the circle.
            * @param layerMask Filter to check objects only on specified layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The cast results. 
            */
            public static OverlapCircleAll ($point: UnityEngine.Vector2, $radius: number, $layerMask: number, $minDepth: number, $maxDepth: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapCircleNonAlloc ($point: UnityEngine.Vector2, $radius: number, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public static OverlapCircleNonAlloc ($point: UnityEngine.Vector2, $radius: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number) : number
            public static OverlapCircleNonAlloc ($point: UnityEngine.Vector2, $radius: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number) : number
            /** Get a list of all Colliders that fall within a circular area. Note: This method will be deprecated in a future build and it is recommended to use OverlapCircle instead.
            * @param point The center of the circle.
            * @param radius The radius of the circle.
            * @param results Array to receive results.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapCircleNonAlloc ($point: UnityEngine.Vector2, $radius: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number, $maxDepth: number) : number
            public static OverlapBox ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number) : UnityEngine.Collider2D
            public static OverlapBox ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask: number) : UnityEngine.Collider2D
            public static OverlapBox ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask: number, $minDepth: number) : UnityEngine.Collider2D
            /** Checks if a Collider falls within a box area.
            * @param point The center of the box.
            * @param size The size of the box.
            * @param angle The angle of the box.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than this value.
            * @returns The Collider overlapping the box. 
            */
            public static OverlapBox ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask: number, $minDepth: number, $maxDepth: number) : UnityEngine.Collider2D
            /** Checks if a Collider falls within a box area.
            * @param point The center of the box.
            * @param size The size of the box.
            * @param angle The angle of the box.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth.  Note that normal angle is not used for overlap testing.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapBox ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public static OverlapBox ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            public static OverlapBoxAll ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapBoxAll ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapBoxAll ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask: number, $minDepth: number) : System.Array$1<UnityEngine.Collider2D>
            /** Get a list of all Colliders that fall within a box area.
            * @param point The center of the box.
            * @param size The size of the box.
            * @param angle The angle of the box.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than this value.
            * @returns The cast results returned. 
            */
            public static OverlapBoxAll ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $layerMask: number, $minDepth: number, $maxDepth: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapBoxNonAlloc ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public static OverlapBoxNonAlloc ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number) : number
            public static OverlapBoxNonAlloc ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number) : number
            /** Get a list of all Colliders that fall within a box area. Note: This method will be deprecated in a future build and it is recommended to use OverlapBox instead.
            * @param point The center of the box.
            * @param size The size of the box.
            * @param angle The angle of the box.
            * @param results Array to receive results.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than this value.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapBoxNonAlloc ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number, $maxDepth: number) : number
            public static OverlapArea ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2) : UnityEngine.Collider2D
            public static OverlapArea ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask: number) : UnityEngine.Collider2D
            public static OverlapArea ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask: number, $minDepth: number) : UnityEngine.Collider2D
            /** Checks if a Collider falls within a rectangular area.
            * @param pointA One corner of the rectangle.
            * @param pointB Diagonally opposite the point A corner of the rectangle.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The Collider overlapping the area. 
            */
            public static OverlapArea ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask: number, $minDepth: number, $maxDepth: number) : UnityEngine.Collider2D
            /** Checks if a Collider falls within a rectangular area.
            * @param pointA One corner of the rectangle.
            * @param pointB Diagonally opposite the point A corner of the rectangle.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth.  Note that normal angle is not used for overlap testing.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapArea ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public static OverlapArea ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            public static OverlapAreaAll ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapAreaAll ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapAreaAll ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask: number, $minDepth: number) : System.Array$1<UnityEngine.Collider2D>
            /** Get a list of all Colliders that fall within a rectangular area.
            * @param pointA One corner of the rectangle.
            * @param pointB Diagonally opposite the point A corner of the rectangle.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns The cast results returned. 
            */
            public static OverlapAreaAll ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $layerMask: number, $minDepth: number, $maxDepth: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapAreaNonAlloc ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public static OverlapAreaNonAlloc ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number) : number
            public static OverlapAreaNonAlloc ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number) : number
            /** Get a list of all Colliders that fall within a specified area. Note: This method will be deprecated in a future build and it is recommended to use OverlapArea instead.
            * @param pointA One corner of the rectangle.
            * @param pointB Diagonally opposite the point A corner of the rectangle.
            * @param results Array to receive results.
            * @param layerMask Filter to check objects only on specified layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than or equal to this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than or equal to this value.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapAreaNonAlloc ($pointA: UnityEngine.Vector2, $pointB: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number, $maxDepth: number) : number
            public static OverlapCapsule ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number) : UnityEngine.Collider2D
            public static OverlapCapsule ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask: number) : UnityEngine.Collider2D
            public static OverlapCapsule ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask: number, $minDepth: number) : UnityEngine.Collider2D
            /** Checks if a Collider falls within a capsule area.
            * @param point The center of the capsule.
            * @param size The size of the capsule.
            * @param direction The direction of the capsule.
            * @param angle The angle of the capsule.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than this value.
            * @returns The Collider overlapping the capsule. 
            */
            public static OverlapCapsule ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask: number, $minDepth: number, $maxDepth: number) : UnityEngine.Collider2D
            /** Checks if a Collider falls within a capsule area.
            * @param point The center of the capsule.
            * @param size The size of the capsule.
            * @param direction The direction of the capsule.
            * @param angle The angle of the capsule.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth.  Note that normal angle is not used for overlap testing.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapCapsule ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public static OverlapCapsule ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            public static OverlapCapsuleAll ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapCapsuleAll ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapCapsuleAll ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask: number, $minDepth: number) : System.Array$1<UnityEngine.Collider2D>
            /** Get a list of all Colliders that fall within a capsule area.
            * @param point The center of the capsule.
            * @param size The size of the capsule.
            * @param direction The direction of the capsule.
            * @param angle The angle of the capsule.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than this value.
            * @returns The cast results returned. 
            */
            public static OverlapCapsuleAll ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $layerMask: number, $minDepth: number, $maxDepth: number) : System.Array$1<UnityEngine.Collider2D>
            public static OverlapCapsuleNonAlloc ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public static OverlapCapsuleNonAlloc ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number) : number
            public static OverlapCapsuleNonAlloc ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number) : number
            /** Get a list of all Colliders that fall within a capsule area. Note: This method will be deprecated in a future build and it is recommended to use OverlapCapsule instead.
            * @param point The center of the capsule.
            * @param size The size of the capsule.
            * @param direction The direction of the capsule.
            * @param angle The angle of the capsule.
            * @param results Array to receive results.
            * @param layerMask Filter to check objects only on specific layers.
            * @param minDepth Only include objects with a Z coordinate (depth) greater than this value.
            * @param maxDepth Only include objects with a Z coordinate (depth) less than this value.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapCapsuleNonAlloc ($point: UnityEngine.Vector2, $size: UnityEngine.Vector2, $direction: UnityEngine.CapsuleDirection2D, $angle: number, $results: System.Array$1<UnityEngine.Collider2D>, $layerMask: number, $minDepth: number, $maxDepth: number) : number
            /** Gets a list of all Colliders that overlap the given Collider.
            * @param Collider The Collider that defines the area used to query for other Collider overlaps.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth.  Note that normal angle is not used for overlap testing.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @returns Returns the number of results placed in the results array. 
            */
            public static OverlapCollider ($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public static OverlapCollider ($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            /** Retrieves all contact points in for contacts between with the collider1 and collider2, with the results filtered by the ContactFilter2D.
            * @param collider1 The Collider to check if it has contacts against collider2.
            * @param collider2 The Collider to check if it has contacts against collider1.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param contacts An array of ContactPoint2D used to receive the results.
            * @returns Returns the number of contacts placed in the contacts array. 
            */
            public static GetContacts ($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>) : number
            /** Retrieves all contact points in contact with the Collider.
            * @param Collider The Collider to retrieve contacts for.
            * @param contacts An array of ContactPoint2D used to receive the results.
            * @returns Returns the number of contacts placed in the contacts array. 
            */
            public static GetContacts ($collider: UnityEngine.Collider2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>) : number
            /** Retrieves all contact points in contact with the Collider, with the results filtered by the ContactFilter2D.
            * @param Collider The Collider to retrieve contacts for.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param contacts An array of ContactPoint2D used to receive the results.
            * @returns Returns the number of contacts placed in the contacts array. 
            */
            public static GetContacts ($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>) : number
            /** Retrieves all Colliders in contact with the Collider.
            * @param Collider The Collider to retrieve contacts for.
            * @param Colliders An array of Collider2D used to receive the results.
            * @returns Returns the number of Colliders placed in the Colliders array. 
            */
            public static GetContacts ($collider: UnityEngine.Collider2D, $colliders: System.Array$1<UnityEngine.Collider2D>) : number
            /** Retrieves all Colliders in contact with the Collider, with the results filtered by the ContactFilter2D.
            * @param Collider The Collider to retrieve contacts for.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param Colliders An array of Collider2D used to receive the results.
            * @returns Returns the number of Colliders placed in the Colliders array. 
            */
            public static GetContacts ($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Array$1<UnityEngine.Collider2D>) : number
            /** Retrieves all contact points in contact with any of the Collider(s) attached to this rigidbody.
            * @param rigidbody The rigidbody to retrieve contacts for.  All Colliders attached to this rigidbody will be checked.
            * @param contacts An array of ContactPoint2D used to receive the results.
            * @returns Returns the number of contacts placed in the contacts array. 
            */
            public static GetContacts ($rigidbody: UnityEngine.Rigidbody2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>) : number
            /** Retrieves all contact points in contact with any of the Collider(s) attached to this rigidbody, with the results filtered by the ContactFilter2D.
            * @param rigidbody The rigidbody to retrieve contacts for.  All Colliders attached to this rigidbody will be checked.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param contacts An array of ContactPoint2D used to receive the results.
            * @returns Returns the number of contacts placed in the contacts array. 
            */
            public static GetContacts ($rigidbody: UnityEngine.Rigidbody2D, $contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>) : number
            /** Retrieves all Colliders in contact with any of the Collider(s) attached to this rigidbody.
            * @param rigidbody The rigidbody to retrieve contacts for.  All Colliders attached to this rigidbody will be checked.
            * @param Colliders An array of Collider2D used to receive the results.
            * @returns Returns the number of Colliders placed in the Colliders array. 
            */
            public static GetContacts ($rigidbody: UnityEngine.Rigidbody2D, $colliders: System.Array$1<UnityEngine.Collider2D>) : number
            /** Retrieves all Colliders in contact with any of the Collider(s) attached to this rigidbody, with the results filtered by the ContactFilter2D.
            * @param rigidbody The rigidbody to retrieve contacts for.  All Colliders attached to this rigidbody will be checked.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param Colliders An array of Collider2D used to receive the results.
            * @returns Returns the number of Colliders placed in the Colliders array. 
            */
            public static GetContacts ($rigidbody: UnityEngine.Rigidbody2D, $contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Array$1<UnityEngine.Collider2D>) : number
            public static GetContacts ($collider1: UnityEngine.Collider2D, $collider2: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>) : number
            public static GetContacts ($collider: UnityEngine.Collider2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>) : number
            public static GetContacts ($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>) : number
            public static GetContacts ($collider: UnityEngine.Collider2D, $colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            public static GetContacts ($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            public static GetContacts ($rigidbody: UnityEngine.Rigidbody2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>) : number
            public static GetContacts ($rigidbody: UnityEngine.Rigidbody2D, $contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>) : number
            public static GetContacts ($rigidbody: UnityEngine.Rigidbody2D, $colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            public static GetContacts ($rigidbody: UnityEngine.Rigidbody2D, $contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            public constructor ()
        }
        /** A selection of modes that control when Unity executes the 2D physics simulation.
        */
        enum SimulationMode2D
        { FixedUpdate = 0, Update = 1, Script = 2 }
        /** A set of options that control how physics operates when using the job system to multithread the physics simulation.
        */
        class PhysicsJobOptions2D extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Should physics simulation use multithreading?
            */
            public get useMultithreading(): boolean;
            public set useMultithreading(value: boolean);
            /** Should physics simulation sort multi-threaded results to maintain processing order consistency?
            */
            public get useConsistencySorting(): boolean;
            public set useConsistencySorting(value: boolean);
            /** Controls the minimum number of Rigidbody2D being interpolated in each simulation job.
            */
            public get interpolationPosesPerJob(): number;
            public set interpolationPosesPerJob(value: number);
            /** Controls the minimum number of new contacts to find in each simulation job.
            */
            public get newContactsPerJob(): number;
            public set newContactsPerJob(value: number);
            /** Controls the minimum number of contacts to collide in each simulation job.
            */
            public get collideContactsPerJob(): number;
            public set collideContactsPerJob(value: number);
            /** Controls the minimum number of flags to be cleared in each simulation job.
            */
            public get clearFlagsPerJob(): number;
            public set clearFlagsPerJob(value: number);
            /** Controls the minimum number of bodies to be cleared in each simulation job.
            */
            public get clearBodyForcesPerJob(): number;
            public set clearBodyForcesPerJob(value: number);
            /** Controls the minimum number of fixtures to synchronize in the broadphase during discrete island solving in each simulation job.
            */
            public get syncDiscreteFixturesPerJob(): number;
            public set syncDiscreteFixturesPerJob(value: number);
            /** Controls the minimum number of fixtures to synchronize in the broadphase during continuous island solving in each simulation job.
            */
            public get syncContinuousFixturesPerJob(): number;
            public set syncContinuousFixturesPerJob(value: number);
            /** Controls the minimum number of nearest contacts to find in each simulation job.
            */
            public get findNearestContactsPerJob(): number;
            public set findNearestContactsPerJob(value: number);
            /** Controls the minimum number of trigger contacts to update in each simulation job.
            */
            public get updateTriggerContactsPerJob(): number;
            public set updateTriggerContactsPerJob(value: number);
            /** The minimum threshold cost of all bodies, contacts and joints in an island during discrete island solving.
            */
            public get islandSolverCostThreshold(): number;
            public set islandSolverCostThreshold(value: number);
            /** Scales the cost of each body during discrete island solving.
            */
            public get islandSolverBodyCostScale(): number;
            public set islandSolverBodyCostScale(value: number);
            /** Scales the cost of each contact during discrete island solving.
            */
            public get islandSolverContactCostScale(): number;
            public set islandSolverContactCostScale(value: number);
            /** Scales the cost of each joint during discrete island solving.
            */
            public get islandSolverJointCostScale(): number;
            public set islandSolverJointCostScale(value: number);
            /** Controls the minimum number of bodies to solve in each simulation job when performing island solving.
            */
            public get islandSolverBodiesPerJob(): number;
            public set islandSolverBodiesPerJob(value: number);
            /** Controls the minimum number of contacts to solve in each simulation job when performing island solving.
            */
            public get islandSolverContactsPerJob(): number;
            public set islandSolverContactsPerJob(value: number);
        }
        /** Represents the separation or overlap of two Collider2D.
        */
        class ColliderDistance2D extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** A point on a Collider2D that is a specific distance away from pointB.
            */
            public get pointA(): UnityEngine.Vector2;
            public set pointA(value: UnityEngine.Vector2);
            /** A point on a Collider2D that is a specific distance away from pointA.
            */
            public get pointB(): UnityEngine.Vector2;
            public set pointB(value: UnityEngine.Vector2);
            /** A normalized vector that points from pointB to pointA.
            */
            public get normal(): UnityEngine.Vector2;
            /** Gets the distance between two colliders.
            */
            public get distance(): number;
            public set distance(value: number);
            /** Gets whether the distance represents an overlap or not.
            */
            public get isOverlapped(): boolean;
            /** Gets whether the distance is valid or not.
            */
            public get isValid(): boolean;
            public set isValid(value: boolean);
        }
        /** Rigidbody physics component for 2D sprites.
        */
        class Rigidbody2D extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** The position of the rigidbody.
            */
            public get position(): UnityEngine.Vector2;
            public set position(value: UnityEngine.Vector2);
            /** The rotation of the rigidbody.
            */
            public get rotation(): number;
            public set rotation(value: number);
            /** Linear velocity of the Rigidbody in units per second.
            */
            public get velocity(): UnityEngine.Vector2;
            public set velocity(value: UnityEngine.Vector2);
            /** Angular velocity in degrees per second.
            */
            public get angularVelocity(): number;
            public set angularVelocity(value: number);
            /** Should the total rigid-body mass be automatically calculated from the Collider2D.density of attached colliders?
            */
            public get useAutoMass(): boolean;
            public set useAutoMass(value: boolean);
            /** Mass of the Rigidbody.
            */
            public get mass(): number;
            public set mass(value: number);
            /** The PhysicsMaterial2D that is applied to all Collider2D attached to this Rigidbody2D.
            */
            public get sharedMaterial(): UnityEngine.PhysicsMaterial2D;
            public set sharedMaterial(value: UnityEngine.PhysicsMaterial2D);
            /** The center of mass of the rigidBody in local space.
            */
            public get centerOfMass(): UnityEngine.Vector2;
            public set centerOfMass(value: UnityEngine.Vector2);
            /** Gets the center of mass of the rigidBody in global space.
            */
            public get worldCenterOfMass(): UnityEngine.Vector2;
            /** The Rigidbody's resistance to changes in angular velocity (rotation).
            */
            public get inertia(): number;
            public set inertia(value: number);
            /** Coefficient of drag.
            */
            public get drag(): number;
            public set drag(value: number);
            /** Coefficient of angular drag.
            */
            public get angularDrag(): number;
            public set angularDrag(value: number);
            /** The degree to which this object is affected by gravity.
            */
            public get gravityScale(): number;
            public set gravityScale(value: number);
            /** The physical behaviour type of the Rigidbody2D.
            */
            public get bodyType(): UnityEngine.RigidbodyType2D;
            public set bodyType(value: UnityEngine.RigidbodyType2D);
            /** Should kinematickinematic and kinematicstatic collisions be allowed?
            */
            public get useFullKinematicContacts(): boolean;
            public set useFullKinematicContacts(value: boolean);
            /** Should this rigidbody be taken out of physics control?
            */
            public get isKinematic(): boolean;
            public set isKinematic(value: boolean);
            /** Controls whether physics will change the rotation of the object.
            */
            public get freezeRotation(): boolean;
            public set freezeRotation(value: boolean);
            /** Controls which degrees of freedom are allowed for the simulation of this Rigidbody2D.
            */
            public get constraints(): UnityEngine.RigidbodyConstraints2D;
            public set constraints(value: UnityEngine.RigidbodyConstraints2D);
            /** Indicates whether the rigid body should be simulated or not by the physics system.
            */
            public get simulated(): boolean;
            public set simulated(value: boolean);
            /** Physics interpolation used between updates.
            */
            public get interpolation(): UnityEngine.RigidbodyInterpolation2D;
            public set interpolation(value: UnityEngine.RigidbodyInterpolation2D);
            /** The sleep state that the rigidbody will initially be in.
            */
            public get sleepMode(): UnityEngine.RigidbodySleepMode2D;
            public set sleepMode(value: UnityEngine.RigidbodySleepMode2D);
            /** The method used by the physics engine to check if two objects have collided.
            */
            public get collisionDetectionMode(): UnityEngine.CollisionDetectionMode2D;
            public set collisionDetectionMode(value: UnityEngine.CollisionDetectionMode2D);
            /** Returns the number of Collider2D attached to this Rigidbody2D.
            */
            public get attachedColliderCount(): number;
            /** Sets the rotation of the Rigidbody2D to angle (given in degrees).
            * @param angle The rotation of the Rigidbody (in degrees).
            */
            public SetRotation ($angle: number) : void
            /** Sets the rotation of the Rigidbody2D to the z-axis rotation extracted from the full 3D rotation.
            * @param rotation Full 3D rotation used to extract only the z-axis rotation.
            */
            public SetRotation ($rotation: UnityEngine.Quaternion) : void
            /** Moves the rigidbody to position.
            * @param position The new position for the Rigidbody object.
            */
            public MovePosition ($position: UnityEngine.Vector2) : void
            /** Rotates the Rigidbody to angle (given in degrees).
            * @param angle The new rotation angle for the Rigidbody object.
            */
            public MoveRotation ($angle: number) : void
            /** An overload of MoveRotation that allows a full 3D rotation as an argument.
            * @param rotation Full 3D rotation used to extract only the z-axis rotation.
            */
            public MoveRotation ($rotation: UnityEngine.Quaternion) : void
            public IsSleeping () : boolean
            public IsAwake () : boolean
            public Sleep () : void
            public WakeUp () : void
            /** Checks whether the collider  is touching any of the collider(s) attached to this rigidbody or not.
            * @param collider The collider to check if it is touching any of the collider(s) attached to this rigidbody.
            * @returns Whether the collider is touching any of the collider(s) attached to this rigidbody or not. 
            */
            public IsTouching ($collider: UnityEngine.Collider2D) : boolean
            /** Checks whether the collider  is touching any of the collider(s) attached to this rigidbody or not with the results filtered by the ContactFilter2D.
            * @param collider The collider to check if it is touching any of the collider(s) attached to this rigidbody.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Whether the collider is touching any of the collider(s) attached to this rigidbody or not. 
            */
            public IsTouching ($collider: UnityEngine.Collider2D, $contactFilter: UnityEngine.ContactFilter2D) : boolean
            /** Checks whether any collider is touching any of the collider(s) attached to this rigidbody or not with the results filtered by the ContactFilter2D.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @returns Whether any collider is touching any of the collider(s) attached to this rigidbody or not. 
            */
            public IsTouching ($contactFilter: UnityEngine.ContactFilter2D) : boolean
            public IsTouchingLayers () : boolean
            /** Checks whether any of the collider(s) attached to this rigidbody are touching any colliders on the specified layerMask or not.
            * @param layerMask Any colliders on any of these layers count as touching.
            * @returns Whether any of the collider(s) attached to this rigidbody are touching any colliders on the specified layerMask or not. 
            */
            public IsTouchingLayers ($layerMask: number) : boolean
            /** Check if any of the Rigidbody2D colliders overlap a point in space.
            * @param point A point in world space.
            * @returns Whether the point overlapped any of the Rigidbody2D colliders. 
            */
            public OverlapPoint ($point: UnityEngine.Vector2) : boolean
            /** Calculates the minimum distance of this collider against all Collider2D attached to this Rigidbody2D.
            * @param collider A collider used to calculate the minimum distance against all colliders attached to this Rigidbody2D.
            * @returns The minimum distance of collider against all colliders attached to this Rigidbody2D. 
            */
            public Distance ($collider: UnityEngine.Collider2D) : UnityEngine.ColliderDistance2D
            /** Returns a point on the perimeter of all enabled Colliders attached to this Rigidbody that is closest to the specified position.
            * @param position The position from which to find the closest point on this Rigidbody.
            * @returns A point on the perimeter of a Collider attached to this rigidbody that is closest to the specified position. 
            */
            public ClosestPoint ($position: UnityEngine.Vector2) : UnityEngine.Vector2
            public AddForce ($force: UnityEngine.Vector2) : void
            /** Apply a force to the rigidbody.
            * @param force Components of the force in the X and Y axes.
            * @param mode The method used to apply the specified force.
            */
            public AddForce ($force: UnityEngine.Vector2, $mode: UnityEngine.ForceMode2D) : void
            public AddRelativeForce ($relativeForce: UnityEngine.Vector2) : void
            /** Adds a force to the rigidbody2D relative to its coordinate system.
            * @param relativeForce Components of the force in the X and Y axes.
            * @param mode The method used to apply the specified force.
            */
            public AddRelativeForce ($relativeForce: UnityEngine.Vector2, $mode: UnityEngine.ForceMode2D) : void
            public AddForceAtPosition ($force: UnityEngine.Vector2, $position: UnityEngine.Vector2) : void
            /** Apply a force at a given position in space.
            * @param force Components of the force in the X and Y axes.
            * @param position Position in world space to apply the force.
            * @param mode The method used to apply the specified force.
            */
            public AddForceAtPosition ($force: UnityEngine.Vector2, $position: UnityEngine.Vector2, $mode: UnityEngine.ForceMode2D) : void
            public AddTorque ($torque: number) : void
            /** Apply a torque at the rigidbody's centre of mass.
            * @param torque Torque to apply.
            * @param mode The force mode to use.
            */
            public AddTorque ($torque: number, $mode: UnityEngine.ForceMode2D) : void
            /** Get a local space point given the point point in rigidBody global space.
            * @param point The global space point to transform into local space.
            */
            public GetPoint ($point: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Get a global space point given the point relativePoint in rigidBody local space.
            * @param relativePoint The local space point to transform into global space.
            */
            public GetRelativePoint ($relativePoint: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Get a local space vector given the vector vector in rigidBody global space.
            * @param vector The global space vector to transform into a local space vector.
            */
            public GetVector ($vector: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Get a global space vector given the vector relativeVector in rigidBody local space.
            * @param relativeVector The local space vector to transform into a global space vector.
            */
            public GetRelativeVector ($relativeVector: UnityEngine.Vector2) : UnityEngine.Vector2
            /** The velocity of the rigidbody at the point Point in global space.
            * @param point The global space point to calculate velocity for.
            */
            public GetPointVelocity ($point: UnityEngine.Vector2) : UnityEngine.Vector2
            /** The velocity of the rigidbody at the point Point in local space.
            * @param relativePoint The local space point to calculate velocity for.
            */
            public GetRelativePointVelocity ($relativePoint: UnityEngine.Vector2) : UnityEngine.Vector2
            /** Get a list of all Colliders that overlap all Colliders attached to this Rigidbody2D.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth.  Note that normal angle is not used for overlap testing.
            * @param results The array to receive results.  The size of the array determines the maximum number of results that can be returned.
            * @returns Returns the number of results placed in the results array. 
            */
            public OverlapCollider ($contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.Collider2D>) : number
            public OverlapCollider ($contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            /** Retrieves all contact points for all of the Collider(s) attached to this Rigidbody.
            * @param contacts An array of ContactPoint2D used to receive the results.
            * @returns Returns the number of contacts placed in the contacts array. 
            */
            public GetContacts ($contacts: System.Array$1<UnityEngine.ContactPoint2D>) : number
            public GetContacts ($contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>) : number
            /** Retrieves all contact points for all of the Collider(s) attached to this Rigidbody, with the results filtered by the ContactFilter2D.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param contacts An array of ContactPoint2D used to receive the results.
            * @returns Returns the number of contacts placed in the contacts array. 
            */
            public GetContacts ($contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Array$1<UnityEngine.ContactPoint2D>) : number
            public GetContacts ($contactFilter: UnityEngine.ContactFilter2D, $contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>) : number
            /** Retrieves all Colliders in contact with any of the Collider(s) attached to this Rigidbody.
            * @param colliders An array of Collider2D used to receive the results.
            * @returns Returns the number of colliders placed in the colliders array. 
            */
            public GetContacts ($colliders: System.Array$1<UnityEngine.Collider2D>) : number
            public GetContacts ($colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            /** Retrieves all Colliders in contact with any of the Collider(s) attached to this rigidbody, with the results filtered by the ContactFilter2D.
            * @param contactFilter The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.
            * @param colliders An array of Collider2D used to receive the results.
            * @returns Returns the number of colliders placed in the colliders array. 
            */
            public GetContacts ($contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Array$1<UnityEngine.Collider2D>) : number
            public GetContacts ($contactFilter: UnityEngine.ContactFilter2D, $colliders: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            /** Returns all Collider2D that are attached to this Rigidbody2D.
            * @param results An array of Collider2D used to receive the results.
            * @returns Returns the number of Collider2D placed in the results array. 
            */
            public GetAttachedColliders ($results: System.Array$1<UnityEngine.Collider2D>) : number
            public GetAttachedColliders ($results: System.Collections.Generic.List$1<UnityEngine.Collider2D>) : number
            public Cast ($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            /** All the Collider2D shapes attached to the Rigidbody2D are cast into the Scene starting at each Collider position ignoring the Colliders attached to the same Rigidbody2D.
            * @param direction Vector representing the direction to cast each Collider2D shape.
            * @param results Array to receive results.
            * @param distance Maximum distance over which to cast the Collider(s).
            * @returns Returns the number of results placed in the results array. 
            */
            public Cast ($direction: UnityEngine.Vector2, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            public Cast ($direction: UnityEngine.Vector2, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance?: number) : number
            public Cast ($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>) : number
            /** All the Collider2D shapes attached to the Rigidbody2D are cast into the Scene starting at each Collider position ignoring the Colliders attached to the same Rigidbody2D.
            * @param direction Vector representing the direction to cast each Collider2D shape.
            * @param contactFilter Filter results defined by the contact filter.
            * @param results Array to receive results.
            * @param distance Maximum distance over which to cast the Collider(s).
            * @returns Returns the number of results placed in the results array. 
            */
            public Cast ($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Array$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            public Cast ($direction: UnityEngine.Vector2, $contactFilter: UnityEngine.ContactFilter2D, $results: System.Collections.Generic.List$1<UnityEngine.RaycastHit2D>, $distance: number) : number
            /** Gets all the PhysicsShape2D used by all Collider2D attached to the Rigidbody2D.
            * @param physicsShapeGroup The PhysicsShapeGroup2D to store the retrieved PhysicsShape2D in.
            * @returns Returns the number of PhysicsShape2D retrieved from the Rigidbody2D. 
            */
            public GetShapes ($physicsShapeGroup: UnityEngine.PhysicsShapeGroup2D) : number
            public constructor ()
        }
        /** Details about a specific point of contact involved in a 2D physics collision.
        */
        class ContactPoint2D extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The point of contact between the two colliders in world space.
            */
            public get point(): UnityEngine.Vector2;
            /** Surface normal at the contact point.
            */
            public get normal(): UnityEngine.Vector2;
            /** Gets the distance between the colliders at the contact point.
            */
            public get separation(): number;
            /** Gets the impulse applied at the contact point along the ContactPoint2D.normal.
            */
            public get normalImpulse(): number;
            /** Gets the impulse applied at the contact point which is perpendicular to the ContactPoint2D.normal.
            */
            public get tangentImpulse(): number;
            /** Gets the relative velocity of the two colliders at the contact point (Read Only).
            */
            public get relativeVelocity(): UnityEngine.Vector2;
            /** The incoming Collider2D involved in the collision with the otherCollider.
            */
            public get collider(): UnityEngine.Collider2D;
            /** The other Collider2D involved in the collision with the collider.
            */
            public get otherCollider(): UnityEngine.Collider2D;
            /** The incoming Rigidbody2D involved in the collision with the otherRigidbody.
            */
            public get rigidbody(): UnityEngine.Rigidbody2D;
            /** The other Rigidbody2D involved in the collision with the rigidbody.
            */
            public get otherRigidbody(): UnityEngine.Rigidbody2D;
            /** Indicates whether the collision response or reaction is enabled or disabled.
            */
            public get enabled(): boolean;
        }
        /** Use these flags to constrain motion of the Rigidbody2D.
        */
        enum RigidbodyConstraints2D
        { None = 0, FreezePositionX = 1, FreezePositionY = 2, FreezeRotation = 4, FreezePosition = 3, FreezeAll = 7 }
        /** Interpolation mode for Rigidbody2D objects.
        */
        enum RigidbodyInterpolation2D
        { None = 0, Interpolate = 1, Extrapolate = 2 }
        /** Settings for a Rigidbody2D's initial sleep state.
        */
        enum RigidbodySleepMode2D
        { NeverSleep = 0, StartAwake = 1, StartAsleep = 2 }
        /** Controls how collisions are detected when a Rigidbody2D moves.
        */
        enum CollisionDetectionMode2D
        { None = 0, Discrete = 0, Continuous = 1 }
        /** The physical behaviour type of the Rigidbody2D.
        */
        enum RigidbodyType2D
        { Dynamic = 0, Kinematic = 1, Static = 2 }
        /** Option for how to apply a force using Rigidbody2D.AddForce.
        */
        enum ForceMode2D
        { Force = 0, Impulse = 1 }
        /** Indicates what (if any) error was encountered when creating a 2D Collider.
        */
        enum ColliderErrorState2D
        { None = 0, NoShapes = 1, RemovedShapes = 2 }
        /** Represents the state of a joint limit.
        */
        enum JointLimitState2D
        { Inactive = 0, LowerLimit = 1, UpperLimit = 2, EqualLimits = 3 }
        /** Selects the source and/or target to be used by an Effector2D.
        */
        enum EffectorSelection2D
        { Rigidbody = 0, Collider = 1 }
        /** The mode used to apply Effector2D forces.
        */
        enum EffectorForceMode2D
        { Constant = 0, InverseLinear = 1, InverseSquared = 2 }
        /** Options for indicate which primitive shape type is used to interpret geometry contained within a PhysicsShape2D object.
        */
        enum PhysicsShapeType2D
        { Circle = 0, Capsule = 1, Polygon = 2, Edges = 3 }
        /** Represents an efficient low-level physics shape used by the physics engine.
        */
        class PhysicsShape2D extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The shape type determines how the vertices and radius are used by this PhysicsShape2D.
            */
            public get shapeType(): UnityEngine.PhysicsShapeType2D;
            public set shapeType(value: UnityEngine.PhysicsShapeType2D);
            /** The radius of the shape.
            */
            public get radius(): number;
            public set radius(value: number);
            /** The start index for the geometry of this shape within the PhysicsShapeGroup2D.
            */
            public get vertexStartIndex(): number;
            public set vertexStartIndex(value: number);
            /** The total number of vertices used to represent the PhysicsShape2D.shapeType|shape type.
            */
            public get vertexCount(): number;
            public set vertexCount(value: number);
            /** When the value is true, then the shape will use the PhysicsShape2D.adjacentStart|adjacentStart feature. When the value is false, then the shape will not use the PhysicsShape2D.adjacentEnd|adjacentStart feature.
            */
            public get useAdjacentStart(): boolean;
            public set useAdjacentStart(value: boolean);
            /** When the value is true, then the shape will use the PhysicsShape2D.adjacentEnd|adjacentEnd feature. When the value is false, then the shape will not use the PhysicsShape2D.adjacentEnd|adjacentEnd feature.
            */
            public get useAdjacentEnd(): boolean;
            public set useAdjacentEnd(value: boolean);
            /** Defines the position of a virtual point adjacent to the start vertex of an edge shape.
            */
            public get adjacentStart(): UnityEngine.Vector2;
            public set adjacentStart(value: UnityEngine.Vector2);
            /** Defines the position of a virtual point adjacent to the end vertex of an edge shape.
            */
            public get adjacentEnd(): UnityEngine.Vector2;
            public set adjacentEnd(value: UnityEngine.Vector2);
        }
        /** Represents a group of PhysicsShape2D and their geometry.
        */
        class PhysicsShapeGroup2D extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The total number of  PhysicsShape2D in the shape group. (Read Only)
            */
            public get shapeCount(): number;
            /** The total number of vertices in the shape group used to represent all PhysicsShape2D within it. (Read Only)
            */
            public get vertexCount(): number;
            /** Gets or sets a matrix that transforms the PhysicsShapeGroup2D vertices from local space into world space.
            */
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            public set localToWorldMatrix(value: UnityEngine.Matrix4x4);
            public Clear () : void
            /** Adds a copy of all the PhysicsShape2D and their geometry from the specified physicsShapeGroup into this shape group. The specified physicsShapeGroup is not modified.
            * @param physicsShapeGroup The PhysicsShapeGroup2D to add to this shape group. (Read Only)
            */
            public Add ($physicsShapeGroup: UnityEngine.PhysicsShapeGroup2D) : void
            public GetShapeData ($shapes: System.Collections.Generic.List$1<UnityEngine.PhysicsShape2D>, $vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            public GetShapeData ($shapes: Unity.Collections.NativeArray$1<UnityEngine.PhysicsShape2D>, $vertices: Unity.Collections.NativeArray$1<UnityEngine.Vector2>) : void
            public GetShapeVertices ($shapeIndex: number, $vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            /** Gets a single vertex of a shape. The vertex index is zero-based with the shape having a quantity of vertex specified by PhysicsShape2D.vertexCount.
            * @param shapeIndex The index of the shape stored in the PhysicsShapeGroup2D. The shape index is zero-based with the shape group having a quantity of shapes specified by PhysicsShapeGroup2D.shapeCount|shapeCount.
            * @param vertexIndex The index of the shape vertex stored in the PhysicsShapeGroup2D. The vertex index is zero-based with the shape having a quantity of vertex specified by PhysicsShape2D.vertexCount.
            * @returns Returns the specified shape vertex. 
            */
            public GetShapeVertex ($shapeIndex: number, $vertexIndex: number) : UnityEngine.Vector2
            /** Sets a single vertex of a shape.
            * @param shapeIndex The index of the shape stored in the PhysicsShapeGroup2D. The shape index is zero-based with the shape group having a quantity of shapes specified by PhysicsShapeGroup2D.shapeCount|shapeCount.
            * @param vertexIndex The index of the shape vertex stored in the PhysicsShapeGroup2D. The vertex index is zero-based with the shape having a quantity of vertex specified by PhysicsShape2D.vertexCount.
            * @param vertex The value to set the shape vertex to.
            */
            public SetShapeVertex ($shapeIndex: number, $vertexIndex: number, $vertex: UnityEngine.Vector2) : void
            /** Sets the radius of a shape.
            * @param shapeIndex The index of the shape stored in the PhysicsShapeGroup2D. The shape index is zero-based with the shape group having a quantity of shapes specified by PhysicsShapeGroup2D.shapeCount|shapeCount.
            * @param radius The value to set the shape radius to.
            */
            public SetShapeRadius ($shapeIndex: number, $radius: number) : void
            /** Sets the adjacent vertices of a shape.
            * @param shapeIndex The index of the shape to be modified that is stored the PhysicsShapeGroup2D.
            * @param useAdjacentStart Sets the PhysicsShape2D.useAdjacentStart property of the selected shape.
            * @param useAdjacentEnd Sets the PhysicsShape2D.useAdjacentEnd property of the selected shape.
            * @param adjacentStart Sets the PhysicsShape2D.adjacentStart property of the selected shape.
            * @param adjacentEnd Sets the PhysicsShape2D.adjacentEnd property of the selected shape.
            */
            public SetShapeAdjacentVertices ($shapeIndex: number, $useAdjacentStart: boolean, $useAdjacentEnd: boolean, $adjacentStart: UnityEngine.Vector2, $adjacentEnd: UnityEngine.Vector2) : void
            /** When destroying a shape at the specified shapeIndex, all other shapes that exist above the specified shapeIndex will have their shape indices updated appropriately.
            * @param shapeIndex The index of the shape stored the PhysicsShapeGroup2D.
            */
            public DeleteShape ($shapeIndex: number) : void
            /** Gets the PhysicsShape2D stored at the specified shapeIndex.
            * @param shapeIndex The index of the shape stored the PhysicsShapeGroup2D. The shape index is zero-based with the shape group having a quantity of shapes specified by PhysicsShapeGroup2D.shapeCount|shapeCount.
            * @returns Returns the shape stored at the specified shapeIndex. 
            */
            public GetShape ($shapeIndex: number) : UnityEngine.PhysicsShape2D
            /** Adds a circle shape (PhysicsShapeType2D.Circle) to the shape group.
            * @param center The center point of the circle shape. This is analogous to Collider2D.offset.
            * @param radius The radius of the circle defining a radius around the center. This is identical to CircleCollider2D.radius.
            * @returns Returns the shape index the shape was added to in the PhysicsShapeGroup2D. This index is used as the main reference when retrieving a shape. 
            */
            public AddCircle ($center: UnityEngine.Vector2, $radius: number) : number
            /** Adds a capsule shape (PhysicsShapeType2D.Capsule) to the shape group.
            * @param vertex0 The position of one end of a capsule shape. This point represents the center point of a logical circle at the end of a capsule.
            * @param vertex1 The position of the opposite end of a capsule shape. This point represents the  center point of a logical circle at the opposite end of a capsule.
            * @param radius The radius of the capsule defining a radius around the vertex0 and vertex1 and the area between them.
            * @returns Returns the shape index the shape was added to in the PhysicsShapeGroup2D. This index is used as the main reference when retrieving a shape. 
            */
            public AddCapsule ($vertex0: UnityEngine.Vector2, $vertex1: UnityEngine.Vector2, $radius: number) : number
            /** Adds a box shape (PhysicsShapeType2D.Polygon) to the shape group.
            * @param center The center point of the box shape. This is analogous to Collider2D.offset.
            * @param size The size of the box. This is identical to BoxCollider2D.size.
            * @param angle The angle in degrees the box should be rotated around the center.
            * @param edgeRadius The radius extending around the edges of the box. This is identical to BoxCollider2D.edgeRadius.
            * @returns Returns the shape index the shape was added to in the PhysicsShapeGroup2D. This index is used as the main reference when retrieving a shape. 
            */
            public AddBox ($center: UnityEngine.Vector2, $size: UnityEngine.Vector2, $angle?: number, $edgeRadius?: number) : number
            public AddPolygon ($vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>) : number
            public AddEdges ($vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>, $edgeRadius?: number) : number
            public AddEdges ($vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>, $useAdjacentStart: boolean, $useAdjacentEnd: boolean, $adjacentStart: UnityEngine.Vector2, $adjacentEnd: UnityEngine.Vector2, $edgeRadius?: number) : number
            public constructor ($shapeCapacity?: number, $vertexCapacity?: number)
            public constructor ()
        }
        /** Collision details returned by 2D physics callback functions.
        */
        class Collision2D extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The incoming Collider2D involved in the collision with the otherCollider.
            */
            public get collider(): UnityEngine.Collider2D;
            /** The other Collider2D involved in the collision with the collider.
            */
            public get otherCollider(): UnityEngine.Collider2D;
            /** The incoming Rigidbody2D involved in the collision with the otherRigidbody.
            */
            public get rigidbody(): UnityEngine.Rigidbody2D;
            /** The other Rigidbody2D involved in the collision with the rigidbody.
            */
            public get otherRigidbody(): UnityEngine.Rigidbody2D;
            /** The Transform of the incoming object involved in the collision.
            */
            public get transform(): UnityEngine.Transform;
            /** The incoming GameObject involved in the collision.
            */
            public get gameObject(): UnityEngine.GameObject;
            /** The relative linear velocity of the two colliding objects (Read Only).
            */
            public get relativeVelocity(): UnityEngine.Vector2;
            /** Indicates whether the collision response or reaction is enabled or disabled.
            */
            public get enabled(): boolean;
            /** The specific points of contact with the incoming Collider2D. You should avoid using this as it produces memory garbage. Use GetContact or GetContacts instead.
            */
            public get contacts(): System.Array$1<UnityEngine.ContactPoint2D>;
            /** Gets the number of contacts for this collision.
            */
            public get contactCount(): number;
            /** Gets the contact point at the specified index.
            * @param index The index of the contact to retrieve.
            * @returns The contact at the specified index. 
            */
            public GetContact ($index: number) : UnityEngine.ContactPoint2D
            /** Retrieves all contact points for contacts between collider and otherCollider.
            * @param contacts An array of ContactPoint2D used to receive the results.
            * @returns Returns the number of contacts placed in the contacts array. 
            */
            public GetContacts ($contacts: System.Array$1<UnityEngine.ContactPoint2D>) : number
            public GetContacts ($contacts: System.Collections.Generic.List$1<UnityEngine.ContactPoint2D>) : number
            public constructor ()
        }
        /** Angular limits on the rotation of a Rigidbody2D object around a HingeJoint2D.
        */
        class JointAngleLimits2D extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Lower angular limit of rotation.
            */
            public get min(): number;
            public set min(value: number);
            /** Upper angular limit of rotation.
            */
            public get max(): number;
            public set max(value: number);
        }
        /** Motion limits of a Rigidbody2D object along a SliderJoint2D.
        */
        class JointTranslationLimits2D extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Minimum distance the Rigidbody2D object can move from the Slider Joint's anchor.
            */
            public get min(): number;
            public set min(value: number);
            /** Maximum distance the Rigidbody2D object can move from the Slider Joint's anchor.
            */
            public get max(): number;
            public set max(value: number);
        }
        /** Parameters for the optional motor force applied to a Joint2D.
        */
        class JointMotor2D extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The desired speed for the Rigidbody2D to reach as it moves with the joint.
            */
            public get motorSpeed(): number;
            public set motorSpeed(value: number);
            /** The maximum force that can be applied to the Rigidbody2D at the joint to attain the target speed.
            */
            public get maxMotorTorque(): number;
            public set maxMotorTorque(value: number);
        }
        /** Joint suspension is used to define how suspension works on a WheelJoint2D.
        */
        class JointSuspension2D extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The amount by which the suspension spring force is reduced in proportion to the movement speed.
            */
            public get dampingRatio(): number;
            public set dampingRatio(value: number);
            /** The frequency at which the suspension spring oscillates.
            */
            public get frequency(): number;
            public set frequency(value: number);
            /** The world angle (in degrees) along which the suspension will move.
            */
            public get angle(): number;
            public set angle(value: number);
        }
        /** Asset type that defines the surface properties of a Collider2D.
        */
        class PhysicsMaterial2D extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The degree of elasticity during collisions.
            */
            public get bounciness(): number;
            public set bounciness(value: number);
            /** Coefficient of friction.
            */
            public get friction(): number;
            public set friction(value: number);
            public constructor ()
            public constructor ($name: string)
        }
        /** A Collider that can merge other Colliders together.
        */
        class CompositeCollider2D extends UnityEngine.Collider2D
        {
            protected [__keep_incompatibility]: never;
            /** Specifies the type of geometry the Composite Collider should generate.
            */
            public get geometryType(): UnityEngine.CompositeCollider2D.GeometryType;
            public set geometryType(value: UnityEngine.CompositeCollider2D.GeometryType);
            /** Specifies when to generate the Composite Collider geometry.
            */
            public get generationType(): UnityEngine.CompositeCollider2D.GenerationType;
            public set generationType(value: UnityEngine.CompositeCollider2D.GenerationType);
            /** Controls the minimum distance allowed between generated vertices.
            */
            public get vertexDistance(): number;
            public set vertexDistance(value: number);
            /** Controls the radius of all edges created by the Collider.
            */
            public get edgeRadius(): number;
            public set edgeRadius(value: number);
            /** Vertices are offset by this distance when compositing multiple physic shapes. Any vertices between shapes within this distance are combined.
            */
            public get offsetDistance(): number;
            public set offsetDistance(value: number);
            /** The number of paths in the Collider.
            */
            public get pathCount(): number;
            /** Gets the total number of points in all the paths within the Collider.
            */
            public get pointCount(): number;
            public GenerateGeometry () : void
            /** Gets the number of points in the specified path from the Collider by its index.
            * @param index The index of the path from 0 to pathCount minus 1.
            * @returns Returns the number of points in the path specified by index. 
            */
            public GetPathPointCount ($index: number) : number
            /** Gets a path from the Collider by its index.
            * @param index The index of the path from 0 to pathCount minus 1.
            * @param points An ordered array of the vertices (points) in the selected path.
            * @returns Returns the number of points placed in the points array. 
            */
            public GetPath ($index: number, $points: System.Array$1<UnityEngine.Vector2>) : number
            public GetPath ($index: number, $points: System.Collections.Generic.List$1<UnityEngine.Vector2>) : number
            public constructor ()
        }
        /** Represents a Collider2D that is configured by assigning PhysicsShape2D geometry to it via a PhysicsShapeGroup2D.
        */
        class CustomCollider2D extends UnityEngine.Collider2D
        {
            protected [__keep_incompatibility]: never;
            /** The total number of custom PhysicsShape2D assigned to the Collider. (Read Only)
            */
            public get customShapeCount(): number;
            /** The total number of Vector2|vertices used by the Collider. (Read Only)
            */
            public get customVertexCount(): number;
            /** Gets all the physics shapes and vertices in the Collider and places them in the specified PhysicsShapeGroup2D.
            * @param physicsShapeGroup The physics shape group that will receive all the PhysicsShape2D|physics shapes and Vector2|vertices from the Collider.
            * @returns Returns the total number of PhysicsShape2D|physics shapes placed in the specified physicsShapeGroup. 
            */
            public GetCustomShapes ($physicsShapeGroup: UnityEngine.PhysicsShapeGroup2D) : number
            /** Gets a specified number of physics shapes defined byshapeCount starting at shapeIndex along with all associated vertices those shapes use and places them in the specified PhysicsShapeGroup2D.
            * @param physicsShapeGroup The physics shape group that will receive the PhysicsShape2D|physics shapes and Vector2|vertices from the Collider.
            * @param shapeIndex The shape index within the Collider to start retrieving shapes from.
            * @param shapeCount The total number of shapes starting at the shapeIndex to retrieve.
            * @returns The total number of PhysicsShape2D|physics shapes placed in the specified physicsShapeGroup. 
            */
            public GetCustomShapes ($physicsShapeGroup: UnityEngine.PhysicsShapeGroup2D, $shapeIndex: number, $shapeCount?: number) : number
            public GetCustomShapes ($shapes: Unity.Collections.NativeArray$1<UnityEngine.PhysicsShape2D>, $vertices: Unity.Collections.NativeArray$1<UnityEngine.Vector2>) : number
            /** Sets all the shapes and vertices in the Collider to those represented by the specified PhysicsShapeGroup2D.
            * @param physicsShapeGroup The PhysicsShapeGroup2D to use as the source of shapes and vertices.
            */
            public SetCustomShapes ($physicsShapeGroup: UnityEngine.PhysicsShapeGroup2D) : void
            public SetCustomShapes ($shapes: Unity.Collections.NativeArray$1<UnityEngine.PhysicsShape2D>, $vertices: Unity.Collections.NativeArray$1<UnityEngine.Vector2>) : void
            /** Sets a single shape and all associated shape vertices from the specified physicsShapeGroup into the Collider.
            * @param physicsShapeGroup The PhysicsShapeGroup2D to use as the source of shapes and vertices.
            * @param srcShapeIndex The source shape index within the physicsShapeGroup used to assign to the Collider.
            * @param dstShapeIndex The destination shape index within the Collider to copy the source shape to.
            */
            public SetCustomShape ($physicsShapeGroup: UnityEngine.PhysicsShapeGroup2D, $srcShapeIndex: number, $dstShapeIndex: number) : void
            public SetCustomShape ($shapes: Unity.Collections.NativeArray$1<UnityEngine.PhysicsShape2D>, $vertices: Unity.Collections.NativeArray$1<UnityEngine.Vector2>, $srcShapeIndex: number, $dstShapeIndex: number) : void
            /** Deletes a specific number of shapes defined by shapeCount starting at shapeIndex along with all associated vertices those shapes use.
            * @param shapeIndex The index of the shape stored in the Collider.
            * @param shapeCount The number of shapes to delete starting at the specified index.
            */
            public ClearCustomShapes ($shapeIndex: number, $shapeCount: number) : void
            public ClearCustomShapes () : void
            public constructor ()
        }
        /** Collider for 2D physics representing an circle.
        */
        class CircleCollider2D extends UnityEngine.Collider2D
        {
            protected [__keep_incompatibility]: never;
            /** Radius of the circle.
            */
            public get radius(): number;
            public set radius(value: number);
            public constructor ()
        }
        /** A capsule-shaped primitive collider.
        */
        class CapsuleCollider2D extends UnityEngine.Collider2D
        {
            protected [__keep_incompatibility]: never;
            /** The width and height of the capsule area.
            */
            public get size(): UnityEngine.Vector2;
            public set size(value: UnityEngine.Vector2);
            /** The direction that the capsule sides can extend.
            */
            public get direction(): UnityEngine.CapsuleDirection2D;
            public set direction(value: UnityEngine.CapsuleDirection2D);
            public constructor ()
        }
        /** Collider for 2D physics representing an arbitrary set of connected edges (lines) defined by its vertices.
        */
        class EdgeCollider2D extends UnityEngine.Collider2D
        {
            protected [__keep_incompatibility]: never;
            /** Controls the radius of all edges created by the collider.
            */
            public get edgeRadius(): number;
            public set edgeRadius(value: number);
            /** Gets the number of edges.
            */
            public get edgeCount(): number;
            /** Gets the number of points.
            */
            public get pointCount(): number;
            /** Get or set the points defining multiple continuous edges.
            */
            public get points(): System.Array$1<UnityEngine.Vector2>;
            public set points(value: System.Array$1<UnityEngine.Vector2>);
            /** Set this to true to use the adjacentStartPoint to form the collision normal that is used to calculate the collision response when a collision occurs at the Edge Collider's start point. Set this to false to not use the adjacentStartPoint, and the collision normal becomes the direction of motion of the collision.
            */
            public get useAdjacentStartPoint(): boolean;
            public set useAdjacentStartPoint(value: boolean);
            /** Set this to true to use the adjacentEndPoint to form the collision normal that is used to calculate the collision response when a collision occurs at the Edge Collider's end point. Set this to false to not use the adjacentEndPoint, and the collision normal becomes the direction of motion of the collision.
            */
            public get useAdjacentEndPoint(): boolean;
            public set useAdjacentEndPoint(value: boolean);
            /** Defines the position of a virtual point adjacent to the start point of the EdgeCollider2D.
            */
            public get adjacentStartPoint(): UnityEngine.Vector2;
            public set adjacentStartPoint(value: UnityEngine.Vector2);
            /** Defines the position of a virtual point adjacent to the end point of the EdgeCollider2D.
            */
            public get adjacentEndPoint(): UnityEngine.Vector2;
            public set adjacentEndPoint(value: UnityEngine.Vector2);
            public Reset () : void
            public GetPoints ($points: System.Collections.Generic.List$1<UnityEngine.Vector2>) : number
            public SetPoints ($points: System.Collections.Generic.List$1<UnityEngine.Vector2>) : boolean
            public constructor ()
        }
        /** Collider for 2D physics representing an axis-aligned rectangle.
        */
        class BoxCollider2D extends UnityEngine.Collider2D
        {
            protected [__keep_incompatibility]: never;
            /** The width and height of the rectangle.
            */
            public get size(): UnityEngine.Vector2;
            public set size(value: UnityEngine.Vector2);
            /** Controls the radius of all edges created by the collider.
            */
            public get edgeRadius(): number;
            public set edgeRadius(value: number);
            /** Determines whether the BoxCollider2D's shape is automatically updated based on a SpriteRenderer's tiling properties.
            */
            public get autoTiling(): boolean;
            public set autoTiling(value: boolean);
            public constructor ()
        }
        /** Collider for 2D physics representing an arbitrary polygon defined by its vertices.
        */
        class PolygonCollider2D extends UnityEngine.Collider2D
        {
            protected [__keep_incompatibility]: never;
            /** Determines whether the PolygonCollider2D's shape is automatically updated based on a SpriteRenderer's tiling properties.
            */
            public get autoTiling(): boolean;
            public set autoTiling(value: boolean);
            /** Corner points that define the collider's shape in local space.
            */
            public get points(): System.Array$1<UnityEngine.Vector2>;
            public set points(value: System.Array$1<UnityEngine.Vector2>);
            /** The number of paths in the polygon.
            */
            public get pathCount(): number;
            public set pathCount(value: number);
            public GetTotalPointCount () : number
            /** Gets a path from the Collider by its index.
            * @param index The index of the path to retrieve.
            * @returns An ordered array of the vertices (points) in the selected path. 
            */
            public GetPath ($index: number) : System.Array$1<UnityEngine.Vector2>
            /** Define a path by its constituent points.
            * @param index Index of the path to set.
            * @param points An ordered array of the vertices (points) that define the path.
            */
            public SetPath ($index: number, $points: System.Array$1<UnityEngine.Vector2>) : void
            public GetPath ($index: number, $points: System.Collections.Generic.List$1<UnityEngine.Vector2>) : number
            public SetPath ($index: number, $points: System.Collections.Generic.List$1<UnityEngine.Vector2>) : void
            public CreatePrimitive ($sides: number) : void
            public CreatePrimitive ($sides: number, $scale: UnityEngine.Vector2) : void
            /** Creates as regular primitive polygon with the specified number of sides.
            * @param sides The number of sides in the polygon.  This must be greater than two.
            * @param scale The X/Y scale of the polygon.  These must be greater than zero.
            * @param offset The X/Y offset of the polygon.
            */
            public CreatePrimitive ($sides: number, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2) : void
            public constructor ()
        }
        /** Parent class for joints to connect Rigidbody2D objects.
        */
        class Joint2D extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The Rigidbody2D attached to the Joint2D.
            */
            public get attachedRigidbody(): UnityEngine.Rigidbody2D;
            /** The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component).
            */
            public get connectedBody(): UnityEngine.Rigidbody2D;
            public set connectedBody(value: UnityEngine.Rigidbody2D);
            /** Should the two rigid bodies connected with this joint collide with each other?
            */
            public get enableCollision(): boolean;
            public set enableCollision(value: boolean);
            /** The force that needs to be applied for this joint to break.
            */
            public get breakForce(): number;
            public set breakForce(value: number);
            /** The torque that needs to be applied for this joint to break.
            */
            public get breakTorque(): number;
            public set breakTorque(value: number);
            /** Gets the reaction force of the joint.
            */
            public get reactionForce(): UnityEngine.Vector2;
            /** Gets the reaction torque of the joint.
            */
            public get reactionTorque(): number;
            /** Gets the reaction force of the joint given the specified timeStep.
            * @param timeStep The time to calculate the reaction force for.
            * @returns The reaction force of the joint in the specified timeStep. 
            */
            public GetReactionForce ($timeStep: number) : UnityEngine.Vector2
            /** Gets the reaction torque of the joint given the specified timeStep.
            * @param timeStep The time to calculate the reaction torque for.
            * @returns The reaction torque of the joint in the specified timeStep. 
            */
            public GetReactionTorque ($timeStep: number) : number
            public constructor ()
        }
        /** Parent class for all joints that have anchor points.
        */
        class AnchoredJoint2D extends UnityEngine.Joint2D
        {
            protected [__keep_incompatibility]: never;
            /** The joint's anchor point on the object that has the joint component.
            */
            public get anchor(): UnityEngine.Vector2;
            public set anchor(value: UnityEngine.Vector2);
            /** The joint's anchor point on the second object (ie, the one which doesn't have the joint component).
            */
            public get connectedAnchor(): UnityEngine.Vector2;
            public set connectedAnchor(value: UnityEngine.Vector2);
            /** Should the connectedAnchor be calculated automatically?
            */
            public get autoConfigureConnectedAnchor(): boolean;
            public set autoConfigureConnectedAnchor(value: boolean);
            public constructor ()
        }
        /** Joint that attempts to keep two Rigidbody2D objects a set distance apart by applying a force between them.
        */
        class SpringJoint2D extends UnityEngine.AnchoredJoint2D
        {
            protected [__keep_incompatibility]: never;
            /** Should the distance be calculated automatically?
            */
            public get autoConfigureDistance(): boolean;
            public set autoConfigureDistance(value: boolean);
            /** The distance the spring will try to keep between the two objects.
            */
            public get distance(): number;
            public set distance(value: number);
            /** The amount by which the spring force is reduced in proportion to the movement speed.
            */
            public get dampingRatio(): number;
            public set dampingRatio(value: number);
            /** The frequency at which the spring oscillates around the distance distance between the objects.
            */
            public get frequency(): number;
            public set frequency(value: number);
            public constructor ()
        }
        /** Joint that keeps two Rigidbody2D objects a fixed distance apart.
        */
        class DistanceJoint2D extends UnityEngine.AnchoredJoint2D
        {
            protected [__keep_incompatibility]: never;
            /** Should the distance be calculated automatically?
            */
            public get autoConfigureDistance(): boolean;
            public set autoConfigureDistance(value: boolean);
            /** The distance separating the two ends of the joint.
            */
            public get distance(): number;
            public set distance(value: number);
            /** Whether to maintain a maximum distance only or not.  If not then the absolute distance will be maintained instead.
            */
            public get maxDistanceOnly(): boolean;
            public set maxDistanceOnly(value: boolean);
            public constructor ()
        }
        /** Applies both force and torque to reduce both the linear and angular velocities to zero.
        */
        class FrictionJoint2D extends UnityEngine.AnchoredJoint2D
        {
            protected [__keep_incompatibility]: never;
            /** The maximum force that can be generated when trying to maintain the friction joint constraint.
            */
            public get maxForce(): number;
            public set maxForce(value: number);
            /** The maximum torque that can be generated when trying to maintain the friction joint constraint.
            */
            public get maxTorque(): number;
            public set maxTorque(value: number);
            public constructor ()
        }
        /** Joint that allows a Rigidbody2D object to rotate around a point in space or a point on another object.
        */
        class HingeJoint2D extends UnityEngine.AnchoredJoint2D
        {
            protected [__keep_incompatibility]: never;
            /** Should the joint be rotated automatically by a motor torque?
            */
            public get useMotor(): boolean;
            public set useMotor(value: boolean);
            /** Should limits be placed on the range of rotation?
            */
            public get useLimits(): boolean;
            public set useLimits(value: boolean);
            /** Parameters for the motor force applied to the joint.
            */
            public get motor(): UnityEngine.JointMotor2D;
            public set motor(value: UnityEngine.JointMotor2D);
            /** Limit of angular rotation (in degrees) on the joint.
            */
            public get limits(): UnityEngine.JointAngleLimits2D;
            public set limits(value: UnityEngine.JointAngleLimits2D);
            /** Gets the state of the joint limit.
            */
            public get limitState(): UnityEngine.JointLimitState2D;
            /** The angle (in degrees) referenced between the two bodies used as the constraint for the joint.
            */
            public get referenceAngle(): number;
            /** The current joint angle (in degrees) with respect to the reference angle.
            */
            public get jointAngle(): number;
            /** The current joint speed.
            */
            public get jointSpeed(): number;
            /** Gets the motor torque of the joint given the specified timestep.
            * @param timeStep The time to calculate the motor torque for.
            */
            public GetMotorTorque ($timeStep: number) : number
            public constructor ()
        }
        /** Keeps two Rigidbody2D at their relative orientations.
        */
        class RelativeJoint2D extends UnityEngine.Joint2D
        {
            protected [__keep_incompatibility]: never;
            /** The maximum force that can be generated when trying to maintain the relative joint constraint.
            */
            public get maxForce(): number;
            public set maxForce(value: number);
            /** The maximum torque that can be generated when trying to maintain the relative joint constraint.
            */
            public get maxTorque(): number;
            public set maxTorque(value: number);
            /** Scales both the linear and angular forces used to correct the required relative orientation.
            */
            public get correctionScale(): number;
            public set correctionScale(value: number);
            /** Should both the linearOffset and angularOffset be calculated automatically?
            */
            public get autoConfigureOffset(): boolean;
            public set autoConfigureOffset(value: boolean);
            /** The current linear offset between the Rigidbody2D that the joint connects.
            */
            public get linearOffset(): UnityEngine.Vector2;
            public set linearOffset(value: UnityEngine.Vector2);
            /** The current angular offset between the Rigidbody2D that the joint connects.
            */
            public get angularOffset(): number;
            public set angularOffset(value: number);
            /** The world-space position that is currently trying to be maintained.
            */
            public get target(): UnityEngine.Vector2;
            public constructor ()
        }
        /** Joint that restricts the motion of a Rigidbody2D object to a single line.
        */
        class SliderJoint2D extends UnityEngine.AnchoredJoint2D
        {
            protected [__keep_incompatibility]: never;
            /** Should the angle be calculated automatically?
            */
            public get autoConfigureAngle(): boolean;
            public set autoConfigureAngle(value: boolean);
            /** The angle of the line in space (in degrees).
            */
            public get angle(): number;
            public set angle(value: number);
            /** Should a motor force be applied automatically to the Rigidbody2D?
            */
            public get useMotor(): boolean;
            public set useMotor(value: boolean);
            /** Should motion limits be used?
            */
            public get useLimits(): boolean;
            public set useLimits(value: boolean);
            /** Parameters for a motor force that is applied automatically to the Rigibody2D along the line.
            */
            public get motor(): UnityEngine.JointMotor2D;
            public set motor(value: UnityEngine.JointMotor2D);
            /** Restrictions on how far the joint can slide in each direction along the line.
            */
            public get limits(): UnityEngine.JointTranslationLimits2D;
            public set limits(value: UnityEngine.JointTranslationLimits2D);
            /** Gets the state of the joint limit.
            */
            public get limitState(): UnityEngine.JointLimitState2D;
            /** The angle (in degrees) referenced between the two bodies used as the constraint for the joint.
            */
            public get referenceAngle(): number;
            /** The current joint translation.
            */
            public get jointTranslation(): number;
            /** The current joint speed.
            */
            public get jointSpeed(): number;
            /** Gets the motor force of the joint given the specified timestep.
            * @param timeStep The time to calculate the motor force for.
            */
            public GetMotorForce ($timeStep: number) : number
            public constructor ()
        }
        /** The joint attempts to move a Rigidbody2D to a specific target position.
        */
        class TargetJoint2D extends UnityEngine.Joint2D
        {
            protected [__keep_incompatibility]: never;
            /** The local-space anchor on the rigid-body the joint is attached to.
            */
            public get anchor(): UnityEngine.Vector2;
            public set anchor(value: UnityEngine.Vector2);
            /** The world-space position that the joint will attempt to move the body to.
            */
            public get target(): UnityEngine.Vector2;
            public set target(value: UnityEngine.Vector2);
            /** Should the target be calculated automatically?
            */
            public get autoConfigureTarget(): boolean;
            public set autoConfigureTarget(value: boolean);
            /** The maximum force that can be generated when trying to maintain the target joint constraint.
            */
            public get maxForce(): number;
            public set maxForce(value: number);
            /** The amount by which the target spring force is reduced in proportion to the movement speed.
            */
            public get dampingRatio(): number;
            public set dampingRatio(value: number);
            /** The frequency at which the target spring oscillates around the target position.
            */
            public get frequency(): number;
            public set frequency(value: number);
            public constructor ()
        }
        /** Connects two Rigidbody2D together at their anchor points using a configurable spring.
        */
        class FixedJoint2D extends UnityEngine.AnchoredJoint2D
        {
            protected [__keep_incompatibility]: never;
            /** The amount by which the spring force is reduced in proportion to the movement speed.
            */
            public get dampingRatio(): number;
            public set dampingRatio(value: number);
            /** The frequency at which the spring oscillates around the distance between the objects.
            */
            public get frequency(): number;
            public set frequency(value: number);
            /** The angle referenced between the two bodies used as the constraint for the joint.
            */
            public get referenceAngle(): number;
            public constructor ()
        }
        /** The wheel joint allows the simulation of wheels by providing a constraining suspension motion with an optional motor.
        */
        class WheelJoint2D extends UnityEngine.AnchoredJoint2D
        {
            protected [__keep_incompatibility]: never;
            /** Set the joint suspension configuration.
            */
            public get suspension(): UnityEngine.JointSuspension2D;
            public set suspension(value: UnityEngine.JointSuspension2D);
            /** Should a motor force be applied automatically to the Rigidbody2D?
            */
            public get useMotor(): boolean;
            public set useMotor(value: boolean);
            /** Parameters for a motor force that is applied automatically to the Rigibody2D along the line.
            */
            public get motor(): UnityEngine.JointMotor2D;
            public set motor(value: UnityEngine.JointMotor2D);
            /** The current joint translation.
            */
            public get jointTranslation(): number;
            /** The current joint linear speed in meters/sec.
            */
            public get jointLinearSpeed(): number;
            /** The current joint rotational speed in degrees/sec.
            */
            public get jointSpeed(): number;
            /** The current joint angle (in degrees) defined as the relative angle between the two Rigidbody2D that the joint connects to.
            */
            public get jointAngle(): number;
            /** Gets the motor torque of the joint given the specified timestep.
            * @param timeStep The time to calculate the motor torque for.
            */
            public GetMotorTorque ($timeStep: number) : number
            public constructor ()
        }
        /** A base class for all 2D effectors.
        */
        class Effector2D extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Should the collider-mask be used or the global collision matrix?
            */
            public get useColliderMask(): boolean;
            public set useColliderMask(value: boolean);
            /** The mask used to select specific layers allowed to interact with the effector.
            */
            public get colliderMask(): number;
            public set colliderMask(value: number);
            public constructor ()
        }
        /** Applies forces within an area.
        */
        class AreaEffector2D extends UnityEngine.Effector2D
        {
            protected [__keep_incompatibility]: never;
            /** The angle of the force to be applied.
            */
            public get forceAngle(): number;
            public set forceAngle(value: number);
            /** Should the forceAngle use global space?
            */
            public get useGlobalAngle(): boolean;
            public set useGlobalAngle(value: boolean);
            /** The magnitude of the force to be applied.
            */
            public get forceMagnitude(): number;
            public set forceMagnitude(value: number);
            /** The variation of the magnitude of the force to be applied.
            */
            public get forceVariation(): number;
            public set forceVariation(value: number);
            /** The linear drag to apply to rigid-bodies.
            */
            public get drag(): number;
            public set drag(value: number);
            /** The angular drag to apply to rigid-bodies.
            */
            public get angularDrag(): number;
            public set angularDrag(value: number);
            /** The target for where the effector applies any force.
            */
            public get forceTarget(): UnityEngine.EffectorSelection2D;
            public set forceTarget(value: UnityEngine.EffectorSelection2D);
            public constructor ()
        }
        /** Applies forces to simulate buoyancy, fluid-flow and fluid drag.
        */
        class BuoyancyEffector2D extends UnityEngine.Effector2D
        {
            protected [__keep_incompatibility]: never;
            /** Defines an arbitrary horizontal line that represents the fluid surface level.
            */
            public get surfaceLevel(): number;
            public set surfaceLevel(value: number);
            /** The density of the fluid used to calculate the buoyancy forces.
            */
            public get density(): number;
            public set density(value: number);
            /** A force applied to slow linear movement of any Collider2D in contact with the effector.
            */
            public get linearDrag(): number;
            public set linearDrag(value: number);
            /** A force applied to slow angular movement of any Collider2D in contact with the effector.
            */
            public get angularDrag(): number;
            public set angularDrag(value: number);
            /** The angle of the force used to similate fluid flow.
            */
            public get flowAngle(): number;
            public set flowAngle(value: number);
            /** The magnitude of the force used to similate fluid flow.
            */
            public get flowMagnitude(): number;
            public set flowMagnitude(value: number);
            /** The random variation of the force used to similate fluid flow.
            */
            public get flowVariation(): number;
            public set flowVariation(value: number);
            public constructor ()
        }
        /** Applies forces to attract/repulse against a point.
        */
        class PointEffector2D extends UnityEngine.Effector2D
        {
            protected [__keep_incompatibility]: never;
            /** The magnitude of the force to be applied.
            */
            public get forceMagnitude(): number;
            public set forceMagnitude(value: number);
            /** The variation of the magnitude of the force to be applied.
            */
            public get forceVariation(): number;
            public set forceVariation(value: number);
            /** The scale applied to the calculated distance between source and target.
            */
            public get distanceScale(): number;
            public set distanceScale(value: number);
            /** The linear drag to apply to rigid-bodies.
            */
            public get drag(): number;
            public set drag(value: number);
            /** The angular drag to apply to rigid-bodies.
            */
            public get angularDrag(): number;
            public set angularDrag(value: number);
            /** The source which is used to calculate the centroid point of the effector.  The distance from the target is defined from this point.
            */
            public get forceSource(): UnityEngine.EffectorSelection2D;
            public set forceSource(value: UnityEngine.EffectorSelection2D);
            /** The target for where the effector applies any force.
            */
            public get forceTarget(): UnityEngine.EffectorSelection2D;
            public set forceTarget(value: UnityEngine.EffectorSelection2D);
            /** The mode used to apply the effector force.
            */
            public get forceMode(): UnityEngine.EffectorForceMode2D;
            public set forceMode(value: UnityEngine.EffectorForceMode2D);
            public constructor ()
        }
        /** Applies "platform" behaviour such as one-way collisions etc.
        */
        class PlatformEffector2D extends UnityEngine.Effector2D
        {
            protected [__keep_incompatibility]: never;
            /** Should the one-way collision behaviour be used?
            */
            public get useOneWay(): boolean;
            public set useOneWay(value: boolean);
            /** Ensures that all contacts controlled by the one-way behaviour act the same.
            */
            public get useOneWayGrouping(): boolean;
            public set useOneWayGrouping(value: boolean);
            /** Should friction be used on the platform sides?
            */
            public get useSideFriction(): boolean;
            public set useSideFriction(value: boolean);
            /** Should bounce be used on the platform sides?
            */
            public get useSideBounce(): boolean;
            public set useSideBounce(value: boolean);
            /** The angle of an arc that defines the surface of the platform centered of the local 'up' of the effector.
            */
            public get surfaceArc(): number;
            public set surfaceArc(value: number);
            /** The angle of an arc that defines the sides of the platform centered on the local 'left' and 'right' of the effector. Any collision normals within this arc are considered for the 'side' behaviours.
            */
            public get sideArc(): number;
            public set sideArc(value: number);
            /** The rotational offset angle from the local 'up'.
            */
            public get rotationalOffset(): number;
            public set rotationalOffset(value: number);
            public constructor ()
        }
        /** Applies tangent forces along the surfaces of colliders.
        */
        class SurfaceEffector2D extends UnityEngine.Effector2D
        {
            protected [__keep_incompatibility]: never;
            /** The speed to be maintained along the surface.
            */
            public get speed(): number;
            public set speed(value: number);
            /** The speed variation (from zero to the variation) added to base speed to be applied.
            */
            public get speedVariation(): number;
            public set speedVariation(value: number);
            /** The scale of the impulse force applied while attempting to reach the surface speed.
            */
            public get forceScale(): number;
            public set forceScale(value: number);
            /** Should the impulse force but applied to the contact point?
            */
            public get useContactForce(): boolean;
            public set useContactForce(value: boolean);
            /** Should friction be used for any contact with the surface?
            */
            public get useFriction(): boolean;
            public set useFriction(value: boolean);
            /** Should bounce be used for any contact with the surface?
            */
            public get useBounce(): boolean;
            public set useBounce(value: boolean);
            public constructor ()
        }
        /** A base type for 2D physics components that required a callback during FixedUpdate.
        */
        class PhysicsUpdateBehaviour2D extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        /** Applies both linear and angular (torque) forces continuously to the rigidbody each physics update.
        */
        class ConstantForce2D extends UnityEngine.PhysicsUpdateBehaviour2D
        {
            protected [__keep_incompatibility]: never;
            /** The linear force applied to the rigidbody each physics update.
            */
            public get force(): UnityEngine.Vector2;
            public set force(value: UnityEngine.Vector2);
            /** The linear force, relative to the rigid-body coordinate system, applied each physics update.
            */
            public get relativeForce(): UnityEngine.Vector2;
            public set relativeForce(value: UnityEngine.Vector2);
            /** The torque applied to the rigidbody each physics update.
            */
            public get torque(): number;
            public set torque(value: number);
            public constructor ()
        }
        /** Provides methods to take screenshots.
        */
        class ScreenCapture extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CaptureScreenshot ($filename: string) : void
            /** Captures a screenshot and saves it as a .png file to a specified path.
            * @param filename The path to save the screenshot file to.
            * @param superSize The factor to increase resolution with.
            * @param stereoCaptureMode The eye texture to capture when stereo rendering is enabled.
            */
            public static CaptureScreenshot ($filename: string, $superSize: number) : void
            public static CaptureScreenshot ($filename: string, $stereoCaptureMode: UnityEngine.ScreenCapture.StereoScreenCaptureMode) : void
            public static CaptureScreenshotAsTexture () : UnityEngine.Texture2D
            /** Captures a screenshot of the game view into a Texture2D object.
            * @param superSize Factor by which to increase resolution.
            * @param stereoCaptureMode Specifies the eye texture to capture when stereo rendering is enabled.
            */
            public static CaptureScreenshotAsTexture ($superSize: number) : UnityEngine.Texture2D
            public static CaptureScreenshotAsTexture ($stereoCaptureMode: UnityEngine.ScreenCapture.StereoScreenCaptureMode) : UnityEngine.Texture2D
            /** Captures a screenshot of the game view into a RenderTexture object.
            * @param renderTexture RenderTexture that will get filled with the screen content.
            */
            public static CaptureScreenshotIntoRenderTexture ($renderTexture: UnityEngine.RenderTexture) : void
        }
        /** A component for masking Sprites and Particles.
        */
        class SpriteMask extends UnityEngine.Renderer
        {
            protected [__keep_incompatibility]: never;
            /** Unique ID of the sorting layer defining the start of the custom range.
            */
            public get frontSortingLayerID(): number;
            public set frontSortingLayerID(value: number);
            /** Order within the front sorting layer defining the start of the custom range.
            */
            public get frontSortingOrder(): number;
            public set frontSortingOrder(value: number);
            /** Unique ID of the sorting layer defining the end of the custom range.
            */
            public get backSortingLayerID(): number;
            public set backSortingLayerID(value: number);
            /** Order within the back sorting layer defining the end of the custom range.
            */
            public get backSortingOrder(): number;
            public set backSortingOrder(value: number);
            /** The minimum alpha value used by the mask to select the area of influence defined over the mask's sprite.
            */
            public get alphaCutoff(): number;
            public set alphaCutoff(value: number);
            /** The Sprite used to define the mask.
            */
            public get sprite(): UnityEngine.Sprite;
            public set sprite(value: UnityEngine.Sprite);
            /** Mask sprites from front to back sorting values only.
            */
            public get isCustomRangeActive(): boolean;
            public set isCustomRangeActive(value: boolean);
            /** Determines the position of the Sprite used for sorting the SpriteMask.
            */
            public get spriteSortPoint(): UnityEngine.SpriteSortPoint;
            public set spriteSortPoint(value: UnityEngine.SpriteSortPoint);
            public constructor ()
        }
        /** A StreamingController controls the streaming settings for an individual camera location.
        */
        class StreamingController extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** Offset applied to the mipmap level chosen by the texture streaming system for any textures visible from this camera. This Offset can take either a positive or negative value.
            */
            public get streamingMipmapBias(): number;
            public set streamingMipmapBias(value: number);
            /** Initiate preloading of streaming data for this camera.
            * @param timeoutSeconds Optional timeout before stopping preloading. Set to 0.0f when no timeout is required.
            * @param activateCameraOnTimeout Set to True to activate the connected Camera component when timeout expires.
            * @param disableCameraCuttingFrom Camera to deactivate on timeout (if Camera.activateCameraOnTime is True). This parameter can be null.
            */
            public SetPreloading ($timeoutSeconds?: number, $activateCameraOnTimeout?: boolean, $disableCameraCuttingFrom?: UnityEngine.Camera) : void
            public CancelPreloading () : void
            public IsPreloading () : boolean
            public constructor ()
        }
        /** Deprecated feature, no longer available
        */
        enum ProceduralProcessorUsage
        { Unsupported = 0, One = 1, Half = 2, All = 3 }
        /** Deprecated feature, no longer available
        */
        enum ProceduralCacheSize
        { Tiny = 0, Medium = 1, Heavy = 2, NoLimit = 3, None = 4 }
        /** Deprecated feature, no longer available
        */
        enum ProceduralLoadingBehavior
        { DoNothing = 0, Generate = 1, BakeAndKeep = 2, BakeAndDiscard = 3, Cache = 4, DoNothingAndCache = 5 }
        /** Deprecated feature, no longer available
        */
        enum ProceduralPropertyType
        { Boolean = 0, Float = 1, Vector2 = 2, Vector3 = 3, Vector4 = 4, Color3 = 5, Color4 = 6, Enum = 7, Texture = 8, String = 9 }
        /** Deprecated feature, no longer available
        */
        enum ProceduralOutputType
        { Unknown = 0, Diffuse = 1, Normal = 2, Height = 3, Emissive = 4, Specular = 5, Opacity = 6, Smoothness = 7, AmbientOcclusion = 8, DetailMask = 9, Metallic = 10, Roughness = 11 }
        /** An IntegratedSubsystem is initialized from an IntegratedSubsystemDescriptor for a given Subsystem (Example, Input, Environment, Display, etc.) and provides an interface to interact with that given IntegratedSubsystem until it is Destroyed. After an IntegratedSubsystem is created it can be Started or Stopped to turn on and off functionality (and preserve performance). The base type for IntegratedSubsystem only exposes this functionality; this class is designed to be a base class for derived classes that expose more functionality specific to a given IntegratedSubsystem.
        Note: initializing a second IntegratedSubsystem from the same IntegratedSubsystemDescriptor will return a reference to the existing IntegratedSubsystem as only one IntegratedSubsystem is currently allowed for a single IntegratedSubsystem provider.
        */
        class IntegratedSubsystem extends System.Object implements UnityEngine.ISubsystem
        {
            protected [__keep_incompatibility]: never;
            /** Whether or not the subsystem is running.
            */
            public get running(): boolean;
            public Start () : void
            public Stop () : void
            public Destroy () : void
            public constructor ()
        }
        interface ISubsystem
        {
            /** Will be true if asking the subsytem to start was successful. False in the case that the subsystem has stopped, was asked to stop or has not been started yet.
            */
            running : boolean
            Start () : void
            Stop () : void
            Destroy () : void
        }
        /** Information about a subsystem that can be queried before creating a subsystem instance.
        */
        class IntegratedSubsystemDescriptor extends System.Object implements UnityEngine.ISubsystemDescriptorImpl, UnityEngine.ISubsystemDescriptor
        {
            protected [__keep_incompatibility]: never;
            /** A unique string that identifies the subsystem that this Descriptor can create.
            */
            public get id(): string;
            public Create () : UnityEngine.ISubsystem
        }
        interface ISubsystemDescriptorImpl extends UnityEngine.ISubsystemDescriptor
        {
            /** A unique string that identifies the subsystem that this Descriptor can create.
            */
            id : string
            Create () : UnityEngine.ISubsystem
        }
        interface ISubsystemDescriptor
        {
            /** A unique string that identifies the subsystem that this Descriptor can create.
            */
            id : string
            Create () : UnityEngine.ISubsystem
        }
        /** A Subsystem is initialized from a SubsystemDescriptorWithProvider for a given Subsystem (Example, Input, Display, etc.) and provides an interface to interact with that given Subsystem until it is Destroyed. After a Subsystem is created it can be Started or Stopped to turn on and off functionality (and improve performance). The base type for subsystems only exposes this functionality; this class is designed to be a base class for derived classes that expose more functionality specific to a given Subsystem.
        Note: initializing a second Subsystem from the same SubsystemDescriptor will return a reference to the existing Subsystem as only one Subsystem is currently allowed for a single Subsystem provider.
        This subsystem base-class is deprecated. If you are creating a new subsystem type, derive from SubsystemWithProvider instead.
        */
        class Subsystem extends System.Object implements UnityEngine.ISubsystem
        {
            protected [__keep_incompatibility]: never;
            /** Whether or not the subsystem is running.
            */
            public get running(): boolean;
            public Start () : void
            public Stop () : void
            public Destroy () : void
        }
        /** Information about a subsystem that can be queried before creating a subsystem instance.
        This subsystem descriptor base-class is deprecated. If you are creating a new subsystem type, derive from SubsystemDecriptorWithProvider instead.
        */
        class SubsystemDescriptor extends System.Object implements UnityEngine.ISubsystemDescriptor
        {
            protected [__keep_incompatibility]: never;
            /** A unique string that identifies the subsystem that this Descriptor can create.
            */
            public get id(): string;
            public set id(value: string);
            /** The System.Type of the subsystem implementation associated with this descriptor.
            */
            public get subsystemImplementationType(): System.Type;
            public set subsystemImplementationType(value: System.Type);
            public Create () : UnityEngine.ISubsystem
        }
        /** Gives access to subsystems which provide additional functionality through plugins.
        */
        class SubsystemManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetAllSubsystemDescriptors ($descriptors: System.Collections.Generic.List$1<UnityEngine.ISubsystemDescriptor>) : void
            public static add_beforeReloadSubsystems ($value: System.Action) : void
            public static remove_beforeReloadSubsystems ($value: System.Action) : void
            public static add_afterReloadSubsystems ($value: System.Action) : void
            public static remove_afterReloadSubsystems ($value: System.Action) : void
            public static add_reloadSubsytemsStarted ($value: System.Action) : void
            public static remove_reloadSubsytemsStarted ($value: System.Action) : void
            public static add_reloadSubsytemsCompleted ($value: System.Action) : void
            public static remove_reloadSubsytemsCompleted ($value: System.Action) : void
        }
        /** Indicate the types of changes to the terrain in OnTerrainChanged callback.
        */
        enum TerrainChangedFlags
        { Heightmap = 1, TreeInstances = 2, DelayedHeightmapUpdate = 4, FlushEverythingImmediately = 8, RemoveDirtyDetailsImmediately = 16, HeightmapResolution = 32, Holes = 64, DelayedHolesUpdate = 128, WillBeDestroyed = 256 }
        /** Enum provding terrain rendering options.
        */
        enum TerrainRenderFlags
        { heightmap = 1, trees = 2, details = 4, all = 7, Heightmap = 1, Trees = 2, Details = 4, All = 7 }
        /** The Terrain component renders the terrain.
        */
        class Terrain extends UnityEngine.Behaviour
        {
            protected [__keep_incompatibility]: never;
            /** The Terrain Data that stores heightmaps, terrain textures, detail meshes and trees.
            */
            public get terrainData(): UnityEngine.TerrainData;
            public set terrainData(value: UnityEngine.TerrainData);
            /** The maximum distance at which trees are rendered.
            */
            public get treeDistance(): number;
            public set treeDistance(value: number);
            /** Distance from the camera where trees will be rendered as billboards only.
            */
            public get treeBillboardDistance(): number;
            public set treeBillboardDistance(value: number);
            /** Total distance delta that trees will use to transition from billboard orientation to mesh orientation.
            */
            public get treeCrossFadeLength(): number;
            public set treeCrossFadeLength(value: number);
            /** Maximum number of trees rendered at full LOD.
            */
            public get treeMaximumFullLODCount(): number;
            public set treeMaximumFullLODCount(value: number);
            /** Detail objects will be displayed up to this distance.
            */
            public get detailObjectDistance(): number;
            public set detailObjectDistance(value: number);
            /** Density of detail objects.
            */
            public get detailObjectDensity(): number;
            public set detailObjectDensity(value: number);
            /** An approximation of how many pixels the terrain will pop in the worst case when switching lod.
            */
            public get heightmapPixelError(): number;
            public set heightmapPixelError(value: number);
            /** Lets you essentially lower the heightmap resolution used for rendering.
            */
            public get heightmapMaximumLOD(): number;
            public set heightmapMaximumLOD(value: number);
            /** Heightmap patches beyond basemap distance will use a precomputed low res basemap.
            */
            public get basemapDistance(): number;
            public set basemapDistance(value: number);
            /** The index of the baked lightmap applied to this terrain.
            */
            public get lightmapIndex(): number;
            public set lightmapIndex(value: number);
            /** The index of the realtime lightmap applied to this terrain.
            */
            public get realtimeLightmapIndex(): number;
            public set realtimeLightmapIndex(value: number);
            /** The UV scale & offset used for a baked lightmap.
            */
            public get lightmapScaleOffset(): UnityEngine.Vector4;
            public set lightmapScaleOffset(value: UnityEngine.Vector4);
            /** The UV scale & offset used for a realtime lightmap.
            */
            public get realtimeLightmapScaleOffset(): UnityEngine.Vector4;
            public set realtimeLightmapScaleOffset(value: UnityEngine.Vector4);
            /** Defines whether Unity frees per-Camera rendering resources for the Terrain when those resources aren't in use after a certain number of frames.
            */
            public get keepUnusedRenderingResources(): boolean;
            public set keepUnusedRenderingResources(value: boolean);
            /** Allows you to set the shadow casting mode for the terrain.
            */
            public get shadowCastingMode(): UnityEngine.Rendering.ShadowCastingMode;
            public set shadowCastingMode(value: UnityEngine.Rendering.ShadowCastingMode);
            /** How reflection probes are used for terrain. See Rendering.ReflectionProbeUsage.
            */
            public get reflectionProbeUsage(): UnityEngine.Rendering.ReflectionProbeUsage;
            public set reflectionProbeUsage(value: UnityEngine.Rendering.ReflectionProbeUsage);
            /** The custom material Unity uses to render the Terrain.
            */
            public get materialTemplate(): UnityEngine.Material;
            public set materialTemplate(value: UnityEngine.Material);
            /** Indicates whether Unity draws the Terrain geometry itself.
            */
            public get drawHeightmap(): boolean;
            public set drawHeightmap(value: boolean);
            /** Specifies if the terrain tile will be automatically connected to adjacent tiles.
            */
            public get allowAutoConnect(): boolean;
            public set allowAutoConnect(value: boolean);
            /** Grouping ID for auto connect.
            */
            public get groupingID(): number;
            public set groupingID(value: number);
            /** Set to true to enable the terrain instance renderer. The default value is false.
            */
            public get drawInstanced(): boolean;
            public set drawInstanced(value: boolean);
            /** Returns the normal map texture computed from sampling the heightmap. It is only used when terrain is rendered using instancing.
            */
            public get normalmapTexture(): UnityEngine.RenderTexture;
            /** Specify if terrain trees and details should be drawn.
            */
            public get drawTreesAndFoliage(): boolean;
            public set drawTreesAndFoliage(value: boolean);
            /** Set the terrain bounding box scale.
            */
            public get patchBoundsMultiplier(): UnityEngine.Vector3;
            public set patchBoundsMultiplier(value: UnityEngine.Vector3);
            /** The multiplier to the current LOD bias used for rendering LOD trees (i.e. SpeedTree trees).
            */
            public get treeLODBiasMultiplier(): number;
            public set treeLODBiasMultiplier(value: number);
            /** Collect detail patches from memory.
            */
            public get collectDetailPatches(): boolean;
            public set collectDetailPatches(value: boolean);
            /** Controls what part of the terrain should be rendered.
            */
            public get editorRenderFlags(): UnityEngine.TerrainRenderFlags;
            public set editorRenderFlags(value: UnityEngine.TerrainRenderFlags);
            /** Allows you to specify how Unity chooses the for tree instances.
            */
            public get preserveTreePrototypeLayers(): boolean;
            public set preserveTreePrototypeLayers(value: boolean);
            /** Graphics format of the Terrain heightmap.
            */
            public static get heightmapFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public static get heightmapTextureFormat(): UnityEngine.TextureFormat;
            /** RenderTextureFormat of the terrain heightmap.
            */
            public static get heightmapRenderTextureFormat(): UnityEngine.RenderTextureFormat;
            /** Graphics format of the Terrain normal map texture.
            */
            public static get normalmapFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            /** Texture format of the Terrain normal map texture.
            */
            public static get normalmapTextureFormat(): UnityEngine.TextureFormat;
            /** Render texture format of the Terrain normal map texture.
            */
            public static get normalmapRenderTextureFormat(): UnityEngine.RenderTextureFormat;
            /** Graphics format of the Terrain holes Texture when it is not compressed.
            */
            public static get holesFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            /** Render texture format of the Terrain holes Texture.
            */
            public static get holesRenderTextureFormat(): UnityEngine.RenderTextureFormat;
            /** Graphics format of the Terrain holes Texture when it is compressed.
            */
            public static get compressedHolesFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            /** Texture format of the Terrain holes Texture when it is compressed.
            */
            public static get compressedHolesTextureFormat(): UnityEngine.TextureFormat;
            /** The active Terrain. This is a convenient function to get to the main Terrain in the Scene.
            */
            public static get activeTerrain(): UnityEngine.Terrain;
            /** The active terrains in the Scene.
            */
            public static get activeTerrains(): System.Array$1<UnityEngine.Terrain>;
            /** The Terrain tile to the left, which is in the negative X direction.
            */
            public get leftNeighbor(): UnityEngine.Terrain;
            /** The Terrain tile to the left, which is in the positive X direction.
            */
            public get rightNeighbor(): UnityEngine.Terrain;
            /** Terrain top neighbor.
            */
            public get topNeighbor(): UnityEngine.Terrain;
            /** Terrain bottom neighbor.
            */
            public get bottomNeighbor(): UnityEngine.Terrain;
            /** Determines which rendering layers the Terrain renderer lives on.
            */
            public get renderingLayerMask(): number;
            public set renderingLayerMask(value: number);
            /**
            * @param cameraInstanceID The InstanceID of the camera being queried. See Object.GetInstanceID.
            * @returns Returns true if all rendering resources for the given camera are saved regardless of usage. Returns false if garbage collection is allowed to free unused resources. 
            */
            public GetKeepUnusedCameraRenderingResources ($cameraInstanceID: number) : boolean
            /** Defines whether Unity cleans up rendering resources for a given Camera during garbage collection.
            * @param cameraInstanceID The InstanceID of the camera for which freeUnusedRenderingResources is being set. See Object.GetInstanceID.
            * @param freeUnusedRenderingResources The value to set to this camera's freeUnusedRenderingResources flag.
            */
            public SetKeepUnusedCameraRenderingResources ($cameraInstanceID: number, $keepUnused: boolean) : void
            public GetClosestReflectionProbes ($result: System.Collections.Generic.List$1<UnityEngine.Rendering.ReflectionProbeBlendInfo>) : void
            /** Samples the height at the given position defined in world space, relative to the Terrain space.
            */
            public SampleHeight ($worldPosition: UnityEngine.Vector3) : number
            /** Adds a tree instance to the terrain.
            */
            public AddTreeInstance ($instance: UnityEngine.TreeInstance) : void
            /** Lets you set up the connection between neighboring Terrain tiles. This ensures LOD matches up on neighboring Terrain tiles.
            * @param left The Terrain tile to the left is in the negative X direction.
            * @param top The Terrain tile to the top is in the positive Z direction.
            * @param right The Terrain tile to the right is in the positive X direction.
            * @param bottom The Terrain tile to the bottom is in the negative Z direction.
            */
            public SetNeighbors ($left: UnityEngine.Terrain, $top: UnityEngine.Terrain, $right: UnityEngine.Terrain, $bottom: UnityEngine.Terrain) : void
            public GetPosition () : UnityEngine.Vector3
            public Flush () : void
            /** Set the additional material properties when rendering the terrain heightmap using the splat material.
            */
            public SetSplatMaterialPropertyBlock ($properties: UnityEngine.MaterialPropertyBlock) : void
            /** Get the previously set splat material properties by copying to the dest MaterialPropertyBlock object.
            */
            public GetSplatMaterialPropertyBlock ($dest: UnityEngine.MaterialPropertyBlock) : void
            public static SetConnectivityDirty () : void
            public static GetActiveTerrains ($terrainList: System.Collections.Generic.List$1<UnityEngine.Terrain>) : void
            /** Creates a Terrain including collider from TerrainData.
            */
            public static CreateTerrainGameObject ($assignTerrain: UnityEngine.TerrainData) : UnityEngine.GameObject
            public constructor ()
        }
        /** The Terrain component renders the terrain.
        */
        interface Terrain {
            /** Schedules an update of the albedo and emissive Textures of a system that contains the Terrain.
            */
            UpdateGIMaterials () : void;
            /** Schedules an update of the albedo and emissive Textures of a system that contains the Terrain.
            */
            UpdateGIMaterials ($x: number, $y: number, $width: number, $height: number) : void;
        }
        /** The TerrainData class stores heightmaps, detail mesh positions, tree instances, and terrain texture alpha maps.
        */
        class TerrainData extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** Contains information about a tree placed in the Terrain game object.
        */
        class TreeInstance extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Position of the tree.
            */
            public position : UnityEngine.Vector3
            /** Width scale of this instance (compared to the prototype's size).
            */
            public widthScale : number
            /** Height scale of this instance (compared to the prototype's size).
            */
            public heightScale : number
            /** Read-only.
            Rotation of the tree on X-Z plane (in radians).
            */
            public rotation : number
            /** Color of this instance.
            */
            public color : UnityEngine.Color32
            /** Lightmap color calculated for this instance.
            */
            public lightmapColor : UnityEngine.Color32
            /** Index of this instance in the TerrainData.treePrototypes array.
            */
            public prototypeIndex : number
        }
        /** Extension methods to the Terrain class, used only for the UpdateGIMaterials method used by the Global Illumination System.
        */
        class TerrainExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Schedules an update of the albedo and emissive Textures of a system that contains the Terrain.
            */
            public static UpdateGIMaterials ($terrain: UnityEngine.Terrain) : void
            /** Schedules an update of the albedo and emissive Textures of a system that contains the Terrain.
            */
            public static UpdateGIMaterials ($terrain: UnityEngine.Terrain, $x: number, $y: number, $width: number, $height: number) : void
        }
        /** Tree Component for the tree creator.
        */
        class Tree extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Data asociated to the Tree.
            */
            public get data(): UnityEngine.ScriptableObject;
            public set data(value: UnityEngine.ScriptableObject);
            /** Tells if there is wind data exported from SpeedTree are saved on this component.
            */
            public get hasSpeedTreeWind(): boolean;
            public constructor ()
        }
        /** This static class provides events that Unity triggers when Terrain data changes.
        */
        class TerrainCallbacks extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static add_heightmapChanged ($value: UnityEngine.TerrainCallbacks.HeightmapChangedCallback) : void
            public static remove_heightmapChanged ($value: UnityEngine.TerrainCallbacks.HeightmapChangedCallback) : void
            public static add_textureChanged ($value: UnityEngine.TerrainCallbacks.TextureChangedCallback) : void
            public static remove_textureChanged ($value: UnityEngine.TerrainCallbacks.TextureChangedCallback) : void
        }
        /** Simple class that contains a pointer to a tree prototype.
        */
        class TreePrototype extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Retrieves the actual GameObject used by the tree.
            */
            public get prefab(): UnityEngine.GameObject;
            public set prefab(value: UnityEngine.GameObject);
            /** Bend factor of the tree prototype.
            */
            public get bendFactor(): number;
            public set bendFactor(value: number);
            /** The LOD index of a Tree LODGroup that Unity uses to generate a NavMesh. It uses this value only for Trees with a LODGroup, and ignores this value for regular Trees.
            */
            public get navMeshLod(): number;
            public set navMeshLod(value: number);
            public constructor ()
            public constructor ($other: UnityEngine.TreePrototype)
        }
        /** Render mode for detail prototypes.
        */
        enum DetailRenderMode
        { GrassBillboard = 0, VertexLit = 1, Grass = 2 }
        /** Detail prototype used by the Terrain GameObject.
        */
        class DetailPrototype extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** GameObject used by the DetailPrototype.
            */
            public get prototype(): UnityEngine.GameObject;
            public set prototype(value: UnityEngine.GameObject);
            /** Texture used by the DetailPrototype.
            */
            public get prototypeTexture(): UnityEngine.Texture2D;
            public set prototypeTexture(value: UnityEngine.Texture2D);
            /** Minimum width of the grass billboards (if render mode is GrassBillboard).
            */
            public get minWidth(): number;
            public set minWidth(value: number);
            /** Maximum width of the grass billboards (if render mode is GrassBillboard).
            */
            public get maxWidth(): number;
            public set maxWidth(value: number);
            /** Minimum height of the grass billboards (if render mode is GrassBillboard).
            */
            public get minHeight(): number;
            public set minHeight(value: number);
            /** Maximum height of the grass billboards (if render mode is GrassBillboard).
            */
            public get maxHeight(): number;
            public set maxHeight(value: number);
            /** Specifies the random seed value for detail object placement.
            */
            public get noiseSeed(): number;
            public set noiseSeed(value: number);
            /** Controls the spatial frequency of the noise pattern used to vary the scale and color of the detail objects.
            */
            public get noiseSpread(): number;
            public set noiseSpread(value: number);
            /** Controls how far away detail objects are from the edge of the hole area.
            */
            public get holeEdgePadding(): number;
            public set holeEdgePadding(value: number);
            /** Color when the DetailPrototypes are "healthy".
            */
            public get healthyColor(): UnityEngine.Color;
            public set healthyColor(value: UnityEngine.Color);
            /** Color when the DetailPrototypes are "dry".
            */
            public get dryColor(): UnityEngine.Color;
            public set dryColor(value: UnityEngine.Color);
            /** Render mode for the DetailPrototype.
            */
            public get renderMode(): UnityEngine.DetailRenderMode;
            public set renderMode(value: UnityEngine.DetailRenderMode);
            /** Indicates whether this detail prototype uses the Mesh object from the GameObject specified by prototype.
            */
            public get usePrototypeMesh(): boolean;
            public set usePrototypeMesh(value: boolean);
            /** Indicates whether this detail prototype uses for rendering.
            */
            public get useInstancing(): boolean;
            public set useInstancing(value: boolean);
            public Validate () : boolean
            /** Returns true if the detail prototype is valid and the Terrain can accept it.
            * @param errorMessage Returns a message that indicates the cause of failed validation.
            */
            public Validate ($errorMessage: $Ref<string>) : boolean
            public constructor ()
            public constructor ($other: UnityEngine.DetailPrototype)
        }
        /** A Splat prototype is just a texture that is used by the TerrainData.
        */
        class SplatPrototype extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Texture of the splat applied to the Terrain.
            */
            public get texture(): UnityEngine.Texture2D;
            public set texture(value: UnityEngine.Texture2D);
            /** Normal map of the splat applied to the Terrain.
            */
            public get normalMap(): UnityEngine.Texture2D;
            public set normalMap(value: UnityEngine.Texture2D);
            /** Size of the tile used in the texture of the SplatPrototype.
            */
            public get tileSize(): UnityEngine.Vector2;
            public set tileSize(value: UnityEngine.Vector2);
            /** Offset of the tile texture of the SplatPrototype.
            */
            public get tileOffset(): UnityEngine.Vector2;
            public set tileOffset(value: UnityEngine.Vector2);
            public get specular(): UnityEngine.Color;
            public set specular(value: UnityEngine.Color);
            /** The metallic value of the splat layer.
            */
            public get metallic(): number;
            public set metallic(value: number);
            /** The smoothness value of the splat layer when the main texture has no alpha channel.
            */
            public get smoothness(): number;
            public set smoothness(value: number);
            public constructor ()
        }
        /** Structure containing minimum and maximum terrain patch height values.
        */
        class PatchExtents extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Minimum height of a terrain patch.
            */
            public get min(): number;
            public set min(value: number);
            /** Maximum height of a terrain patch.
            */
            public get max(): number;
            public set max(value: number);
        }
        /** Controls what Terrain heightmap data to synchronize when there are changes to the heightmap texture.
        */
        enum TerrainHeightmapSyncControl
        { None = 0, HeightOnly = 1, HeightAndLod = 2 }
        /** Describes the transform of a Terrain detail object.
        */
        class DetailInstanceTransform extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The X coordinate of the detail object in the Terrain's local space. To get the X in world space, add this value to position X of the Terrain.
            */
            public posX : number
            /** The Y coordinate of the detail object in the Terrain's local space. To get the Y in world space, add this value to position Y of the Terrain.
            */
            public posY : number
            /** The Z coordinate of the detail object in the Terrain's local space. To get the Z in world space, add this value to position Z of the Terrain.
            */
            public posZ : number
            /** The X and Z scale values of the detail object. These two values are always the same.
            */
            public scaleXZ : number
            /** The Y scale value of the detail object.
            */
            public scaleY : number
            /** The angle, in radians, at which the detail object rotates around the Y-axis.
            */
            public rotationY : number
        }
        /** Description of a terrain layer.
        */
        class TerrainLayer extends UnityEngine.Object
        {
            protected [__keep_incompatibility]: never;
            /** The diffuse texture used by the terrain layer.
            */
            public get diffuseTexture(): UnityEngine.Texture2D;
            public set diffuseTexture(value: UnityEngine.Texture2D);
            /** Normal map texture used by the terrain layer.
            */
            public get normalMapTexture(): UnityEngine.Texture2D;
            public set normalMapTexture(value: UnityEngine.Texture2D);
            /** The mask map texture used by the terrain layer.
            */
            public get maskMapTexture(): UnityEngine.Texture2D;
            public set maskMapTexture(value: UnityEngine.Texture2D);
            /** UV Tiling size.
            */
            public get tileSize(): UnityEngine.Vector2;
            public set tileSize(value: UnityEngine.Vector2);
            /** UV tiling offset.
            */
            public get tileOffset(): UnityEngine.Vector2;
            public set tileOffset(value: UnityEngine.Vector2);
            /** Specular color.
            */
            public get specular(): UnityEngine.Color;
            public set specular(value: UnityEngine.Color);
            /** Metallic factor used by the terrain layer.
            */
            public get metallic(): number;
            public set metallic(value: number);
            /** Smoothness of the specular reflection.
            */
            public get smoothness(): number;
            public set smoothness(value: number);
            /** A float value that scales the normal vector. The minimum value is 0, the maximum value is 1.
            */
            public get normalScale(): number;
            public set normalScale(value: number);
            /** A Vector4 value specifying the minimum RGBA value that the diffuse texture maps to when the value of the channel is 0.
            */
            public get diffuseRemapMin(): UnityEngine.Vector4;
            public set diffuseRemapMin(value: UnityEngine.Vector4);
            /** A Vector4 value specifying the maximum RGBA value that the diffuse texture maps to when the value of the channel is 1.
            */
            public get diffuseRemapMax(): UnityEngine.Vector4;
            public set diffuseRemapMax(value: UnityEngine.Vector4);
            /** A Vector4 value specifying the minimum RGBA value that the mask map texture maps to when the value of the channel is 0.
            */
            public get maskMapRemapMin(): UnityEngine.Vector4;
            public set maskMapRemapMin(value: UnityEngine.Vector4);
            /** A Vector4 value specifying the maximum RGBA value that the mask map texture maps to when the value of the channel is 1.
            */
            public get maskMapRemapMax(): UnityEngine.Vector4;
            public set maskMapRemapMax(value: UnityEngine.Vector4);
            public constructor ()
        }
        /** A heightmap based collider.
        */
        class TerrainCollider extends UnityEngine.Collider
        {
            protected [__keep_incompatibility]: never;
            /** The terrain that stores the heightmap.
            */
            public get terrainData(): UnityEngine.TerrainData;
            public set terrainData(value: UnityEngine.TerrainData);
            public constructor ()
        }
        /** A struct that stores the settings for TextGeneration.
        */
        class TextGenerationSettings extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Font to use for generation.
            */
            public font : UnityEngine.Font
            /** The base color for the text generation.
            */
            public color : UnityEngine.Color
            /** Font size.
            */
            public fontSize : number
            /** The line spacing multiplier.
            */
            public lineSpacing : number
            /** Allow rich text markup in generation.
            */
            public richText : boolean
            /** A scale factor for the text. This is useful if the Text is on a Canvas and the canvas is scaled.
            */
            public scaleFactor : number
            /** Font style.
            */
            public fontStyle : UnityEngine.FontStyle
            /** How is the generated text anchored.
            */
            public textAnchor : UnityEngine.TextAnchor
            /** Use the extents of glyph geometry to perform horizontal alignment rather than glyph metrics.
            */
            public alignByGeometry : boolean
            /** Should the text be resized to fit the configured bounds?
            */
            public resizeTextForBestFit : boolean
            /** Minimum size for resized text.
            */
            public resizeTextMinSize : number
            /** Maximum size for resized text.
            */
            public resizeTextMaxSize : number
            /** Should the text generator update the bounds from the generated text.
            */
            public updateBounds : boolean
            /** What happens to text when it reaches the bottom generation bounds.
            */
            public verticalOverflow : UnityEngine.VerticalWrapMode
            /** What happens to text when it reaches the horizontal generation bounds.
            */
            public horizontalOverflow : UnityEngine.HorizontalWrapMode
            /** Extents that the generator will attempt to fit the text in.
            */
            public generationExtents : UnityEngine.Vector2
            /** Generated vertices are offset by the pivot.
            */
            public pivot : UnityEngine.Vector2
            /** Continue to generate characters even if the text runs out of bounds.
            */
            public generateOutOfBounds : boolean
            public Equals ($other: UnityEngine.TextGenerationSettings) : boolean
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        /** Wrapping modes for text that reaches the vertical boundary.
        */
        enum VerticalWrapMode
        { Truncate = 0, Overflow = 1 }
        /** Wrapping modes for text that reaches the horizontal boundary.
        */
        enum HorizontalWrapMode
        { Wrap = 0, Overflow = 1 }
        /** Class that can be used to generate text for rendering.
        */
        class TextGenerator extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            /** The number of characters that have been generated and are included in the visible lines.
            */
            public get characterCountVisible(): number;
            /** Array of generated vertices.
            */
            public get verts(): System.Collections.Generic.IList$1<UnityEngine.UIVertex>;
            /** Array of generated characters.
            */
            public get characters(): System.Collections.Generic.IList$1<UnityEngine.UICharInfo>;
            /** Information about each generated text line.
            */
            public get lines(): System.Collections.Generic.IList$1<UnityEngine.UILineInfo>;
            /** Extents of the generated text in rect format.
            */
            public get rectExtents(): UnityEngine.Rect;
            /** Number of vertices generated.
            */
            public get vertexCount(): number;
            /** The number of characters that have been generated.
            */
            public get characterCount(): number;
            /** Number of text lines generated.
            */
            public get lineCount(): number;
            /** The size of the font that was found if using best fit mode.
            */
            public get fontSizeUsedForBestFit(): number;
            public Invalidate () : void
            public GetCharacters ($characters: System.Collections.Generic.List$1<UnityEngine.UICharInfo>) : void
            public GetLines ($lines: System.Collections.Generic.List$1<UnityEngine.UILineInfo>) : void
            public GetVertices ($vertices: System.Collections.Generic.List$1<UnityEngine.UIVertex>) : void
            /** Given a string and settings, returns the preferred width for a container that would hold this text.
            * @param str Generation text.
            * @param settings Settings for generation.
            * @returns Preferred width. 
            */
            public GetPreferredWidth ($str: string, $settings: UnityEngine.TextGenerationSettings) : number
            /** Given a string and settings, returns the preferred height for a container that would hold this text.
            * @param str Generation text.
            * @param settings Settings for generation.
            * @returns Preferred height. 
            */
            public GetPreferredHeight ($str: string, $settings: UnityEngine.TextGenerationSettings) : number
            /** Will generate the vertices and other data for the given string with the given settings.
            * @param str String to generate.
            * @param settings Generation settings.
            * @param context The object used as context of the error log message, if necessary.
            * @returns True if the generation is a success, false otherwise. 
            */
            public PopulateWithErrors ($str: string, $settings: UnityEngine.TextGenerationSettings, $context: UnityEngine.GameObject) : boolean
            /** Will generate the vertices and other data for the given string with the given settings.
            * @param str String to generate.
            * @param settings Settings.
            */
            public Populate ($str: string, $settings: UnityEngine.TextGenerationSettings) : boolean
            public GetVerticesArray () : System.Array$1<UnityEngine.UIVertex>
            public GetCharactersArray () : System.Array$1<UnityEngine.UICharInfo>
            public GetLinesArray () : System.Array$1<UnityEngine.UILineInfo>
            public constructor ()
            public constructor ($initialCapacity: number)
        }
        /** Class that specifies some information about a renderable character.
        */
        class UICharInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Position of the character cursor in local (text generated) space.
            */
            public cursorPos : UnityEngine.Vector2
            /** Character width.
            */
            public charWidth : number
        }
        /** Information about a generated line of text.
        */
        class UILineInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Index of the first character in the line.
            */
            public startCharIdx : number
            /** Height of the line.
            */
            public height : number
            /** The upper Y position of the line in pixels. This is used for text annotation such as the caret and selection box in the InputField.
            */
            public topY : number
            /** Space in pixels between this line and the next line.
            */
            public leading : number
        }
        /** Vertex class used by a Canvas for managing vertices.
        */
        class UIVertex extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Vertex position.
            */
            public position : UnityEngine.Vector3
            /** Normal.
            */
            public normal : UnityEngine.Vector3
            /** Tangent.
            */
            public tangent : UnityEngine.Vector4
            /** Vertex color.
            */
            public color : UnityEngine.Color32
            /** The first texture coordinate set of the mesh. Used by UI elements by default.
            */
            public uv0 : UnityEngine.Vector4
            /** The second texture coordinate set of the mesh, if present.
            */
            public uv1 : UnityEngine.Vector4
            /** The Third texture coordinate set of the mesh, if present.
            */
            public uv2 : UnityEngine.Vector4
            /** The forth texture coordinate set of the mesh, if present.
            */
            public uv3 : UnityEngine.Vector4
            /** Simple UIVertex with sensible settings for use in the UI system.
            */
            public static simpleVert : UnityEngine.UIVertex
        }
        /** How multiline text should be aligned.
        */
        enum TextAlignment
        { Left = 0, Center = 1, Right = 2 }
        /** A script interface for the.
        */
        class TextMesh extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** The text that is displayed.
            */
            public get text(): string;
            public set text(value: string);
            /** The Font used.
            */
            public get font(): UnityEngine.Font;
            public set font(value: UnityEngine.Font);
            /** The font size to use (for dynamic fonts).
            */
            public get fontSize(): number;
            public set fontSize(value: number);
            /** The font style to use (for dynamic fonts).
            */
            public get fontStyle(): UnityEngine.FontStyle;
            public set fontStyle(value: UnityEngine.FontStyle);
            /** How far should the text be offset from the transform.position.z when drawing.
            */
            public get offsetZ(): number;
            public set offsetZ(value: number);
            /** How lines of text are aligned (Left, Right, Center).
            */
            public get alignment(): UnityEngine.TextAlignment;
            public set alignment(value: UnityEngine.TextAlignment);
            /** Which point of the text shares the position of the Transform.
            */
            public get anchor(): UnityEngine.TextAnchor;
            public set anchor(value: UnityEngine.TextAnchor);
            /** The size of each character (This scales the whole text).
            */
            public get characterSize(): number;
            public set characterSize(value: number);
            /** How much space will be in-between lines of text.
            */
            public get lineSpacing(): number;
            public set lineSpacing(value: number);
            /** How much space will be inserted for a tab '\t' character. This is a multiplum of the 'spacebar' character offset.
            */
            public get tabSize(): number;
            public set tabSize(value: number);
            /** Enable HTML-style tags for Text Formatting Markup.
            */
            public get richText(): boolean;
            public set richText(value: boolean);
            /** The color used to render the text.
            */
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public constructor ()
        }
        /** Specification for how to render a character from the font texture. See Font.characterInfo.
        */
        class CharacterInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** Unicode value of the character.
            */
            public index : number
            /** The size of the character or 0 if it is the default font size.
            */
            public size : number
            /** The style of the character.
            */
            public style : UnityEngine.FontStyle
            /** The horizontal distance, rounded to the nearest integer, from the origin of this character to the origin of the next character.
            */
            public get advance(): number;
            public set advance(value: number);
            /** The width of the glyph image.
            */
            public get glyphWidth(): number;
            public set glyphWidth(value: number);
            /** The height of the glyph image.
            */
            public get glyphHeight(): number;
            public set glyphHeight(value: number);
            /** The horizontal distance from the origin of this glyph to the begining of the glyph image.
            */
            public get bearing(): number;
            public set bearing(value: number);
            /** The minimum extend of the glyph image in the y-axis.
            */
            public get minY(): number;
            public set minY(value: number);
            /** The maximum extend of the glyph image in the y-axis.
            */
            public get maxY(): number;
            public set maxY(value: number);
            /** The minium extend of the glyph image in the x-axis.
            */
            public get minX(): number;
            public set minX(value: number);
            /** The maximum extend of the glyph image in the x-axis.
            */
            public get maxX(): number;
            public set maxX(value: number);
            /** The uv coordinate matching the bottom left of the glyph image in the font texture.
            */
            public get uvBottomLeft(): UnityEngine.Vector2;
            public set uvBottomLeft(value: UnityEngine.Vector2);
            /** The uv coordinate matching the bottom right of the glyph image in the font texture.
            */
            public get uvBottomRight(): UnityEngine.Vector2;
            public set uvBottomRight(value: UnityEngine.Vector2);
            /** The uv coordinate matching the top right of the glyph image in the font texture.
            */
            public get uvTopRight(): UnityEngine.Vector2;
            public set uvTopRight(value: UnityEngine.Vector2);
            /** The uv coordinate matching the top left of the glyph image in the font texture.
            */
            public get uvTopLeft(): UnityEngine.Vector2;
            public set uvTopLeft(value: UnityEngine.Vector2);
        }
        /** Attribute to define the class as a grid brush and to make it available in the palette window.
        */
        class CustomGridBrushAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            /** Hide all asset instances of this brush in the tile palette window.
            */
            public get hideAssetInstances(): boolean;
            /** Hide the default instance of brush in the tile palette window.
            */
            public get hideDefaultInstance(): boolean;
            /** If set to true, brush will replace Unity built-in brush as the default brush in palette window.
            Only one class at any one time should set defaultBrush to true.
            */
            public get defaultBrush(): boolean;
            /** Name of the default instance of this brush.
            */
            public get defaultName(): string;
            public constructor ()
            public constructor ($hideAssetInstances: boolean, $hideDefaultInstance: boolean, $defaultBrush: boolean, $defaultName: string)
        }
        /** Base class for authoring data on a grid with grid painting tools like paint, erase, pick, select and fill.
        */
        class GridBrushBase extends UnityEngine.ScriptableObject
        {
            protected [__keep_incompatibility]: never;
            /** Paints data into a grid within the given bounds.
            * @param grid Grid used for layout.
            * @param brushTarget Target of the paint operation. By default the currently selected GameObject.
            * @param position The coordinates of the cell to paint data to.
            */
            public Paint ($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.Vector3Int) : void
            /** Erases data on a grid within the given bounds.
            * @param grid Grid used for layout.
            * @param brushTarget Target of the erase operation. By default the currently selected GameObject.
            * @param position The coordinates of the cell to erase data from.
            */
            public Erase ($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.Vector3Int) : void
            /** Box fills tiles and GameObjects into given bounds within the selected layers.
            * @param gridLayout Grid used for layout.
            * @param brushTarget Target of box fill operation. By default the currently selected GameObject.
            * @param position The bounds to box fill data to.
            */
            public BoxFill ($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.BoundsInt) : void
            /** Erases data on a grid within the given bounds.
            * @param gridLayout Grid used for layout.
            * @param brushTarget Target of the erase operation. By default the currently selected GameObject.
            * @param position The bounds to erase data from.
            */
            public BoxErase ($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.BoundsInt) : void
            /** Select an area of a grid.
            * @param grid Grid used for layout.
            * @param brushTarget Targets of paint operation. By default the currently selected GameObject.
            * @param position Area to get selected.
            */
            public Select ($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.BoundsInt) : void
            /** Flood fills data onto a grid given the starting coordinates of the cell.
            * @param gridLayout Grid used for layout.
            * @param brushTarget Targets of flood fill operation. By default the currently selected GameObject.
            * @param position Starting position of the flood fill.
            */
            public FloodFill ($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.Vector3Int) : void
            public Rotate ($direction: UnityEngine.GridBrushBase.RotationDirection, $layout: UnityEngine.GridLayout.CellLayout) : void
            public Flip ($flip: UnityEngine.GridBrushBase.FlipAxis, $layout: UnityEngine.GridLayout.CellLayout) : void
            /** Picks data from a grid given the coordinates of the cells.
            * @param grid Grid used for layout.
            * @param brushTarget Target of the paint operation. By default the currently selected GameObject.
            * @param position The coordinates of the cells to paint data from.
            * @param pivot Pivot of the picking brush.
            */
            public Pick ($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.BoundsInt, $pivot: UnityEngine.Vector3Int) : void
            /** Move is called when user moves the area previously selected with the selection marquee.
            * @param grid Grid used for layout.
            * @param brushTarget Target of the move operation. By default the currently selected GameObject.
            * @param from Source bounds of the move.
            * @param to Target bounds of the move.
            */
            public Move ($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $from: UnityEngine.BoundsInt, $to: UnityEngine.BoundsInt) : void
            /** MoveEnd is called when user starts moving the area previously selected with the selection marquee.
            * @param grid Grid used for layout.
            * @param brushTarget Target of the move operation. By default the currently selected GameObject.
            * @param position Position where the move operation has started.
            */
            public MoveStart ($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.BoundsInt) : void
            /** MoveEnd is called when user has ended the move of the area previously selected with the selection marquee.
            * @param position Layers affected by the move operation.
            * @param brushTarget Target of the move operation. By default the currently selected GameObject.
            * @param grid Grid used for layout.
            */
            public MoveEnd ($gridLayout: UnityEngine.GridLayout, $brushTarget: UnityEngine.GameObject, $position: UnityEngine.BoundsInt) : void
            /** Changes the Z position of the GridBrushBase.
            * @param change Modify the Z position of GridBrushBase by this value.
            */
            public ChangeZPosition ($change: number) : void
            public ResetZPosition () : void
        }
        /** A Canvas placable element that can be used to modify children Alpha, Raycasting, Enabled state.
        */
        class CanvasGroup extends UnityEngine.Behaviour implements UnityEngine.ICanvasRaycastFilter
        {
            protected [__keep_incompatibility]: never;
            /** Set the alpha of the group.
            */
            public get alpha(): number;
            public set alpha(value: number);
            /** Is the group interactable (are the elements beneath the group enabled).
            */
            public get interactable(): boolean;
            public set interactable(value: boolean);
            /** Does this group block raycasting (allow collision).
            */
            public get blocksRaycasts(): boolean;
            public set blocksRaycasts(value: boolean);
            /** Should the group ignore parent groups?
            */
            public get ignoreParentGroups(): boolean;
            public set ignoreParentGroups(value: boolean);
            /** Returns true if the Group allows raycasts.
            */
            public IsRaycastLocationValid ($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera) : boolean
            public constructor ()
        }
        /** A component that will render to the screen after all normal rendering has completed when attached to a Canvas. Designed for GUI application.
        */
        class CanvasRenderer extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Enable 'render stack' pop draw call.
            */
            public get hasPopInstruction(): boolean;
            public set hasPopInstruction(value: boolean);
            /** The number of materials usable by this renderer.
            */
            public get materialCount(): number;
            public set materialCount(value: number);
            /** The number of materials usable by this renderer. Used internally for masking.
            */
            public get popMaterialCount(): number;
            public set popMaterialCount(value: number);
            /** Depth of the renderer relative to the root canvas.
            */
            public get absoluteDepth(): number;
            /** True if any change has occured that would invalidate the positions of generated geometry.
            */
            public get hasMoved(): boolean;
            /** Indicates whether geometry emitted by this renderer can be ignored when the vertex color alpha is close to zero for every vertex of the mesh.
            */
            public get cullTransparentMesh(): boolean;
            public set cullTransparentMesh(value: boolean);
            /** True if rect clipping has been enabled on this renderer.
            See Also: CanvasRenderer.EnableRectClipping, CanvasRenderer.DisableRectClipping.
            */
            public get hasRectClipping(): boolean;
            /** Depth of the renderer realative to the parent canvas.
            */
            public get relativeDepth(): number;
            /** Indicates whether geometry emitted by this renderer is ignored.
            */
            public get cull(): boolean;
            public set cull(value: boolean);
            /** The clipping softness to apply to the renderer.
            */
            public get clippingSoftness(): UnityEngine.Vector2;
            public set clippingSoftness(value: UnityEngine.Vector2);
            /** Set the color of the renderer. Will be multiplied with the UIVertex color and the Canvas color.
            * @param color Renderer multiply color.
            */
            public SetColor ($color: UnityEngine.Color) : void
            public GetColor () : UnityEngine.Color
            /** Enables rect clipping on the CanvasRendered. Geometry outside of the specified rect will be clipped (not rendered).
            */
            public EnableRectClipping ($rect: UnityEngine.Rect) : void
            public DisableRectClipping () : void
            /** Set the material for the canvas renderer. If a texture is specified then it will be used as the 'MainTex' instead of the material's 'MainTex'.
            See Also: CanvasRenderer.SetMaterialCount, CanvasRenderer.SetTexture.
            * @param material Material for rendering.
            * @param texture Material texture overide.
            * @param index Material index.
            */
            public SetMaterial ($material: UnityEngine.Material, $index: number) : void
            /** Gets the current Material assigned to the CanvasRenderer.
            * @param index The material index to retrieve (0 if this parameter is omitted).
            * @returns Result. 
            */
            public GetMaterial ($index: number) : UnityEngine.Material
            /** Set the material for the canvas renderer. Used internally for masking.
            */
            public SetPopMaterial ($material: UnityEngine.Material, $index: number) : void
            /** Gets the current Material assigned to the CanvasRenderer. Used internally for masking.
            */
            public GetPopMaterial ($index: number) : UnityEngine.Material
            /** Sets the texture used by this renderer's material.
            */
            public SetTexture ($texture: UnityEngine.Texture) : void
            /** The Alpha Texture that will be passed to the Shader under the _AlphaTex property.
            * @param texture The Texture to be passed.
            */
            public SetAlphaTexture ($texture: UnityEngine.Texture) : void
            /** Sets the Mesh used by this renderer. Note the Mesh must be read/write enabled.
            */
            public SetMesh ($mesh: UnityEngine.Mesh) : void
            public Clear () : void
            public GetAlpha () : number
            /** Set the alpha of the renderer. Will be multiplied with the UIVertex alpha and the Canvas alpha.
            * @param alpha Alpha.
            */
            public SetAlpha ($alpha: number) : void
            public GetInheritedAlpha () : number
            /** Set the material for the canvas renderer. If a texture is specified then it will be used as the 'MainTex' instead of the material's 'MainTex'.
            See Also: CanvasRenderer.SetMaterialCount, CanvasRenderer.SetTexture.
            * @param material Material for rendering.
            * @param texture Material texture overide.
            * @param index Material index.
            */
            public SetMaterial ($material: UnityEngine.Material, $texture: UnityEngine.Texture) : void
            public GetMaterial () : UnityEngine.Material
            public static SplitUIVertexStreams ($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $colors: System.Collections.Generic.List$1<UnityEngine.Color32>, $uv0S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv1S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $normals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $indices: System.Collections.Generic.List$1<number>) : void
            public static SplitUIVertexStreams ($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $colors: System.Collections.Generic.List$1<UnityEngine.Color32>, $uv0S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv1S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv2S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv3S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $normals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $indices: System.Collections.Generic.List$1<number>) : void
            public static CreateUIVertexStream ($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $colors: System.Collections.Generic.List$1<UnityEngine.Color32>, $uv0S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv1S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $normals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $indices: System.Collections.Generic.List$1<number>) : void
            public static CreateUIVertexStream ($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $colors: System.Collections.Generic.List$1<UnityEngine.Color32>, $uv0S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv1S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv2S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv3S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $normals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $indices: System.Collections.Generic.List$1<number>) : void
            public static AddUIVertexStream ($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $colors: System.Collections.Generic.List$1<UnityEngine.Color32>, $uv0S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv1S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $normals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public static AddUIVertexStream ($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $colors: System.Collections.Generic.List$1<UnityEngine.Color32>, $uv0S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv1S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv2S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $uv3S: System.Collections.Generic.List$1<UnityEngine.Vector4>, $normals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>) : void
            public static add_onRequestRebuild ($value: UnityEngine.CanvasRenderer.OnRequestRebuild) : void
            public static remove_onRequestRebuild ($value: UnityEngine.CanvasRenderer.OnRequestRebuild) : void
            public constructor ()
        }
        /** Utility class containing helper methods for working with  RectTransform.
        */
        class RectTransformUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** Convert a given point in screen space into a pixel correct point.
            * @returns Pixel adjusted point. 
            */
            public static PixelAdjustPoint ($point: UnityEngine.Vector2, $elementTransform: UnityEngine.Transform, $canvas: UnityEngine.Canvas) : UnityEngine.Vector2
            /** Given a rect transform, return the corner points in pixel accurate coordinates.
            * @returns Pixel adjusted rect. 
            */
            public static PixelAdjustRect ($rectTransform: UnityEngine.RectTransform, $canvas: UnityEngine.Canvas) : UnityEngine.Rect
            public static RectangleContainsScreenPoint ($rect: UnityEngine.RectTransform, $screenPoint: UnityEngine.Vector2) : boolean
            /** Does the RectTransform contain the screen point as seen from the given camera?
            * @param rect The RectTransform to test with.
            * @param screenPoint The screen point to test.
            * @param cam The camera from which the test is performed from. (Optional)
            * @returns True if the point is inside the rectangle. 
            */
            public static RectangleContainsScreenPoint ($rect: UnityEngine.RectTransform, $screenPoint: UnityEngine.Vector2, $cam: UnityEngine.Camera) : boolean
            public static RectangleContainsScreenPoint ($rect: UnityEngine.RectTransform, $screenPoint: UnityEngine.Vector2, $cam: UnityEngine.Camera, $offset: UnityEngine.Vector4) : boolean
            /** Transform a screen space point to a position in world space that is on the plane of the given RectTransform.
            * @param rect The RectTransform to find a point inside.
            * @param cam The camera associated with the screen space position.
            * @param screenPoint Screen space position.
            * @param worldPoint Point in world space.
            * @returns Returns true if the plane of the RectTransform is hit, regardless of whether the point is inside the rectangle. 
            */
            public static ScreenPointToWorldPointInRectangle ($rect: UnityEngine.RectTransform, $screenPoint: UnityEngine.Vector2, $cam: UnityEngine.Camera, $worldPoint: $Ref<UnityEngine.Vector3>) : boolean
            /** Transform a screen space point to a position in the local space of a RectTransform that is on the plane of its rectangle.
            * @param rect The RectTransform to find a point inside.
            * @param cam The camera associated with the screen space position.
            * @param screenPoint Screen space position.
            * @param localPoint Point in local space of the rect transform.
            * @returns Returns true if the plane of the RectTransform is hit, regardless of whether the point is inside the rectangle. 
            */
            public static ScreenPointToLocalPointInRectangle ($rect: UnityEngine.RectTransform, $screenPoint: UnityEngine.Vector2, $cam: UnityEngine.Camera, $localPoint: $Ref<UnityEngine.Vector2>) : boolean
            public static ScreenPointToRay ($cam: UnityEngine.Camera, $screenPos: UnityEngine.Vector2) : UnityEngine.Ray
            public static WorldToScreenPoint ($cam: UnityEngine.Camera, $worldPoint: UnityEngine.Vector3) : UnityEngine.Vector2
            public static CalculateRelativeRectTransformBounds ($root: UnityEngine.Transform, $child: UnityEngine.Transform) : UnityEngine.Bounds
            public static CalculateRelativeRectTransformBounds ($trans: UnityEngine.Transform) : UnityEngine.Bounds
            /** Flips the alignment of the RectTransform along the horizontal or vertical axis, and optionally its children as well.
            * @param rect The RectTransform to flip.
            * @param keepPositioning Flips around the pivot if true. Flips within the parent rect if false.
            * @param recursive Flip the children as well?
            * @param axis The axis to flip along. 0 is horizontal and 1 is vertical.
            */
            public static FlipLayoutOnAxis ($rect: UnityEngine.RectTransform, $axis: number, $keepPositioning: boolean, $recursive: boolean) : void
            /** Flips the horizontal and vertical axes of the RectTransform size and alignment, and optionally its children as well.
            * @param rect The RectTransform to flip.
            * @param keepPositioning Flips around the pivot if true. Flips within the parent rect if false.
            * @param recursive Flip the children as well?
            */
            public static FlipLayoutAxes ($rect: UnityEngine.RectTransform, $keepPositioning: boolean, $recursive: boolean) : void
        }
        class UISystemProfilerApi extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static BeginSample ($type: UnityEngine.UISystemProfilerApi.SampleType) : void
            public static EndSample ($type: UnityEngine.UISystemProfilerApi.SampleType) : void
            public static AddMarker ($name: string, $obj: UnityEngine.Object) : void
        }
        class UIWidgetsInternal extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CreateBindableRenderTexture ($desc: UnityEngine.RenderTextureDescriptor) : UnityEngine.RenderTexture
            public constructor ()
        }
        /** Provides access to your remote settings.
        */
        class RemoteSettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static add_Updated ($value: UnityEngine.RemoteSettings.UpdatedEventHandler) : void
            public static remove_Updated ($value: UnityEngine.RemoteSettings.UpdatedEventHandler) : void
            public static add_BeforeFetchFromServer ($value: System.Action) : void
            public static remove_BeforeFetchFromServer ($value: System.Action) : void
            public static add_Completed ($value: System.Action$3<boolean, boolean, number>) : void
            public static remove_Completed ($value: System.Action$3<boolean, boolean, number>) : void
            public static ForceUpdate () : void
            public static WasLastUpdatedFromServer () : boolean
            /** Gets the value corresponding to remote setting identified by key, if it exists.
            * @param key The key identifying the setting.
            * @param defaultValue The default value to use if the setting identified by the key parameter cannot be found or is unavailable.
            * @returns The current value of the setting identified by key, or the default value. 
            */
            public static GetInt ($key: string) : number
            /** Gets the value corresponding to remote setting identified by key, if it exists.
            * @param key The key identifying the setting.
            * @param defaultValue The default value to use if the setting identified by the key parameter cannot be found or is unavailable.
            * @returns The current value of the setting identified by key, or the default value. 
            */
            public static GetInt ($key: string, $defaultValue: number) : number
            public static GetLong ($key: string) : bigint
            /** Gets the value corresponding to remote setting identified by key, if it exists.
            * @param key The key identifying the setting.
            * @param defaultValue The default value to use if the setting identified by the key parameter cannot be found or is unavailable.
            * @returns The current value of the setting identified by key, or the default value. 
            */
            public static GetLong ($key: string, $defaultValue: bigint) : bigint
            /** Gets the value corresponding to remote setting identified by key, if it exists.
            * @param key The key identifying the setting.
            * @param defaultValue The default value to use if the setting identified by the key parameter cannot be found or is unavailable.
            * @returns The current value of the setting identified by key, or the default value. 
            */
            public static GetFloat ($key: string) : number
            /** Gets the value corresponding to remote setting identified by key, if it exists.
            * @param key The key identifying the setting.
            * @param defaultValue The default value to use if the setting identified by the key parameter cannot be found or is unavailable.
            * @returns The current value of the setting identified by key, or the default value. 
            */
            public static GetFloat ($key: string, $defaultValue: number) : number
            /** Gets the value corresponding to remote setting identified by key, if it exists.
            * @param key The key identifying the setting.
            * @param defaultValue The default value to use if the setting identified by the key parameter cannot be found or is unavailable.
            * @returns The current value of the setting identified by key, or the default value. 
            */
            public static GetString ($key: string) : string
            /** Gets the value corresponding to remote setting identified by key, if it exists.
            * @param key The key identifying the setting.
            * @param defaultValue The default value to use if the setting identified by the key parameter cannot be found or is unavailable.
            * @returns The current value of the setting identified by key, or the default value. 
            */
            public static GetString ($key: string, $defaultValue: string) : string
            /** Gets the value corresponding to remote setting identified by key, if it exists.
            * @param key The key identifying the setting.
            * @param defaultValue The default value to use if the setting identified by the key parameter cannot be found or is unavailable.
            * @returns The current value of the setting identified by key, or the default value. 
            */
            public static GetBool ($key: string) : boolean
            /** Gets the value corresponding to remote setting identified by key, if it exists.
            * @param key The key identifying the setting.
            * @param defaultValue The default value to use if the setting identified by the key parameter cannot be found or is unavailable.
            * @returns The current value of the setting identified by key, or the default value. 
            */
            public static GetBool ($key: string, $defaultValue: boolean) : boolean
            /** Reports whether the specified key exists in the remote settings configuration.
            * @param key The key identifying the setting.
            * @returns True, if the key exists. 
            */
            public static HasKey ($key: string) : boolean
            public static GetCount () : number
            public static GetKeys () : System.Array$1<string>
            /** Gets the object corresponding to the remote setting identified by key, if it exists.
            * @param key The key identifying the setting.
            * @param type The type of object represented in RemoteSettings.
            * @returns An instance of the object with fields assigned the corresponding remote values. 
            */
            public static GetObject ($type: System.Type, $key?: string) : any
            /** Gets the object corresponding to the remote setting identified by key, if it exists.
            * @param defaultValue The object that should be for default values.
            * @param key The key identifying the setting.
            * @returns An instance of the object with fields assigned the corresponding remote values. 
            */
            public static GetObject ($key: string, $defaultValue: any) : any
            /** Gets a dictionary corresponding to the remote setting identified by key, if it exists.
            * @param key The key identifying the setting.
            * @returns An instance of Dictionary<string, object> containing the corresponding remote value or values. 
            */
            public static GetDictionary ($key?: string) : System.Collections.Generic.IDictionary$2<string, any>
        }
        class RemoteConfigSettings extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public add_Updated ($value: System.Action$1<boolean>) : void
            public remove_Updated ($value: System.Action$1<boolean>) : void
            public Dispose () : void
            public static QueueConfig ($name: string, $param: any, $ver?: number, $prefix?: string) : boolean
            public static SendDeviceInfoInConfigRequest () : boolean
            public static AddSessionTag ($tag: string) : void
            public ForceUpdate () : void
            public WasLastUpdatedFromServer () : boolean
            public GetInt ($key: string) : number
            public GetInt ($key: string, $defaultValue: number) : number
            public GetLong ($key: string) : bigint
            public GetLong ($key: string, $defaultValue: bigint) : bigint
            public GetFloat ($key: string) : number
            public GetFloat ($key: string, $defaultValue: number) : number
            public GetString ($key: string) : string
            public GetString ($key: string, $defaultValue: string) : string
            public GetBool ($key: string) : boolean
            public GetBool ($key: string, $defaultValue: boolean) : boolean
            public HasKey ($key: string) : boolean
            public GetCount () : number
            public GetKeys () : System.Array$1<string>
            public GetObject ($type: System.Type, $key?: string) : any
            public GetObject ($key: string, $defaultValue: any) : any
            public GetDictionary ($key?: string) : System.Collections.Generic.IDictionary$2<string, any>
            public constructor ($configKey: string)
            public constructor ()
        }
        /** Helper class to generate form data to post to web servers using the UnityWebRequest or WWW classes.
        */
        class WWWForm extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** (Read Only) Returns the correct request headers for posting the form using the WWW class.
            */
            public get headers(): System.Collections.Generic.Dictionary$2<string, string>;
            /** (Read Only) The raw data to pass as the POST request body when sending the form.
            */
            public get data(): System.Array$1<number>;
            /** Add a simple field to the form.
            */
            public AddField ($fieldName: string, $value: string) : void
            /** Add a simple field to the form.
            */
            public AddField ($fieldName: string, $value: string, $e: System.Text.Encoding) : void
            /** Adds a simple field to the form.
            */
            public AddField ($fieldName: string, $i: number) : void
            /** Add binary data to the form.
            */
            public AddBinaryData ($fieldName: string, $contents: System.Array$1<number>) : void
            /** Add binary data to the form.
            */
            public AddBinaryData ($fieldName: string, $contents: System.Array$1<number>, $fileName: string) : void
            /** Add binary data to the form.
            */
            public AddBinaryData ($fieldName: string, $contents: System.Array$1<number>, $fileName: string, $mimeType: string) : void
            public constructor ()
        }
        class WWWAudioExtensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        /** Simple access to web pages.
        */
        class WWW extends UnityEngine.CustomYieldInstruction implements System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
        /** MovieTexture has been removed. Use VideoPlayer instead.
        */
        class MovieTexture extends UnityEngine.Texture
        {
            protected [__keep_incompatibility]: never;
        }
        /** Contact information for the wheel, reported by WheelCollider.
        */
        class WheelHit extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            /** The other Collider the wheel is hitting.
            */
            public get collider(): UnityEngine.Collider;
            public set collider(value: UnityEngine.Collider);
            /** The point of contact between the wheel and the ground.
            */
            public get point(): UnityEngine.Vector3;
            public set point(value: UnityEngine.Vector3);
            /** The normal at the point of contact.
            */
            public get normal(): UnityEngine.Vector3;
            public set normal(value: UnityEngine.Vector3);
            /** The direction the wheel is pointing in.
            */
            public get forwardDir(): UnityEngine.Vector3;
            public set forwardDir(value: UnityEngine.Vector3);
            /** The sideways direction of the wheel.
            */
            public get sidewaysDir(): UnityEngine.Vector3;
            public set sidewaysDir(value: UnityEngine.Vector3);
            /** The magnitude of the force being applied for the contact.
            */
            public get force(): number;
            public set force(value: number);
            /** Tire slip in the rolling direction. Acceleration slip is negative, braking slip is positive.
            */
            public get forwardSlip(): number;
            public set forwardSlip(value: number);
            /** Tire slip in the sideways direction.
            */
            public get sidewaysSlip(): number;
            public set sidewaysSlip(value: number);
        }
        /** A special collider for vehicle wheels.
        */
        class WheelCollider extends UnityEngine.Collider
        {
            protected [__keep_incompatibility]: never;
            /** The center of the wheel, measured in the object's local space.
            */
            public get center(): UnityEngine.Vector3;
            public set center(value: UnityEngine.Vector3);
            /** The radius of the wheel, measured in local space.
            */
            public get radius(): number;
            public set radius(value: number);
            /** Maximum extension distance of wheel suspension, measured in local space.
            */
            public get suspensionDistance(): number;
            public set suspensionDistance(value: number);
            /** The parameters of wheel's suspension. The suspension attempts to reach a target position by applying a linear force and a damping force.
            */
            public get suspensionSpring(): UnityEngine.JointSpring;
            public set suspensionSpring(value: UnityEngine.JointSpring);
            /** Limits the expansion velocity of the Wheel Collider's suspension. If you set this property on a Rigidbody that has several Wheel Colliders, such as a vehicle, then it affects all other Wheel Colliders on the Rigidbody.
            * @param active Turns on/off the property
            */
            public get suspensionExpansionLimited(): boolean;
            public set suspensionExpansionLimited(value: boolean);
            /** Application point of the suspension and tire forces measured from the base of the resting wheel.
            */
            public get forceAppPointDistance(): number;
            public set forceAppPointDistance(value: number);
            /** The mass of the wheel, expressed in kilograms. Must be larger than zero. Typical values would be in range (20,80).
            */
            public get mass(): number;
            public set mass(value: number);
            /** The damping rate of the wheel. Must be larger than zero.
            */
            public get wheelDampingRate(): number;
            public set wheelDampingRate(value: number);
            /** Properties of tire friction in the direction the wheel is pointing in.
            */
            public get forwardFriction(): UnityEngine.WheelFrictionCurve;
            public set forwardFriction(value: UnityEngine.WheelFrictionCurve);
            /** Properties of tire friction in the sideways direction.
            */
            public get sidewaysFriction(): UnityEngine.WheelFrictionCurve;
            public set sidewaysFriction(value: UnityEngine.WheelFrictionCurve);
            /** Motor torque on the wheel axle expressed in Newton metres. Positive or negative depending on direction.
            */
            public get motorTorque(): number;
            public set motorTorque(value: number);
            /** Brake torque expressed in Newton metres.
            */
            public get brakeTorque(): number;
            public set brakeTorque(value: number);
            /** Steering angle in degrees, always around the local y-axis.
            */
            public get steerAngle(): number;
            public set steerAngle(value: number);
            /** Indicates whether the wheel currently collides with something (Read Only).
            */
            public get isGrounded(): boolean;
            /** Current wheel axle rotation speed, in rotations per minute (Read Only).
            */
            public get rpm(): number;
            /** The mass supported by this WheelCollider.
            */
            public get sprungMass(): number;
            public set sprungMass(value: number);
            public ResetSprungMasses () : void
            /** Configure vehicle sub-stepping parameters.
            * @param speedThreshold The speed threshold of the sub-stepping algorithm.
            * @param stepsBelowThreshold Amount of simulation sub-steps when vehicle's speed is below speedThreshold.
            * @param stepsAboveThreshold Amount of simulation sub-steps when vehicle's speed is above speedThreshold.
            */
            public ConfigureVehicleSubsteps ($speedThreshold: number, $stepsBelowThreshold: number, $stepsAboveThreshold: number) : void
            /** Gets the world space pose of the wheel accounting for ground contact, suspension limits, steer angle, and rotation angle (angles in degrees).
            * @param pos Position of the wheel in world space.
            * @param quat Rotation of the wheel in world space.
            */
            public GetWorldPose ($pos: $Ref<UnityEngine.Vector3>, $quat: $Ref<UnityEngine.Quaternion>) : void
            /** Gets ground collision data for the wheel.
            */
            public GetGroundHit ($hit: $Ref<UnityEngine.WheelHit>) : boolean
            public constructor ()
        }
        /** Modes a Wind Zone can have, either Spherical or Directional.
        */
        enum WindZoneMode
        { Directional = 0, Spherical = 1 }
        /** Wind Zones add realism to the trees you create by making them wave their branches and leaves as if blown by the wind.
        */
        class WindZone extends UnityEngine.Component
        {
            protected [__keep_incompatibility]: never;
            /** Defines the type of wind zone to be used (Spherical or Directional).
            */
            public get mode(): UnityEngine.WindZoneMode;
            public set mode(value: UnityEngine.WindZoneMode);
            /** Radius of the Spherical Wind Zone (only active if the WindZoneMode is set to Spherical).
            */
            public get radius(): number;
            public set radius(value: number);
            /** The primary wind force.
            */
            public get windMain(): number;
            public set windMain(value: number);
            /** The turbulence wind force.
            */
            public get windTurbulence(): number;
            public set windTurbulence(value: number);
            /** Defines how much the wind changes over time.
            */
            public get windPulseMagnitude(): number;
            public set windPulseMagnitude(value: number);
            /** Defines the frequency of the wind changes.
            */
            public get windPulseFrequency(): number;
            public set windPulseFrequency(value: number);
            public constructor ()
        }
    }
    namespace System.Collections.Generic {
        interface IEnumerable$1<T> extends System.Collections.IEnumerable
        {
        }
        class List$1<T> extends System.Object implements System.Collections.Generic.IReadOnlyList$1<T>, System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IList$1<T>, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Collections.IList, System.Collections.Generic.ICollection$1<T>
        {
            protected [__keep_incompatibility]: never;
            public get Capacity(): number;
            public set Capacity(value: number);
            public get Count(): number;
            public get_Item ($index: number) : T
            public set_Item ($index: number, $value: T) : void
            public Add ($item: T) : void
            public AddRange ($collection: System.Collections.Generic.IEnumerable$1<T>) : void
            public AsReadOnly () : System.Collections.ObjectModel.ReadOnlyCollection$1<T>
            public BinarySearch ($index: number, $count: number, $item: T, $comparer: System.Collections.Generic.IComparer$1<T>) : number
            public BinarySearch ($item: T) : number
            public BinarySearch ($item: T, $comparer: System.Collections.Generic.IComparer$1<T>) : number
            public Clear () : void
            public Contains ($item: T) : boolean
            public CopyTo ($array: System.Array$1<T>) : void
            public CopyTo ($index: number, $array: System.Array$1<T>, $arrayIndex: number, $count: number) : void
            public CopyTo ($array: System.Array$1<T>, $arrayIndex: number) : void
            public Exists ($match: System.Predicate$1<T>) : boolean
            public Find ($match: System.Predicate$1<T>) : T
            public FindAll ($match: System.Predicate$1<T>) : System.Collections.Generic.List$1<T>
            public FindIndex ($match: System.Predicate$1<T>) : number
            public FindIndex ($startIndex: number, $match: System.Predicate$1<T>) : number
            public FindIndex ($startIndex: number, $count: number, $match: System.Predicate$1<T>) : number
            public FindLast ($match: System.Predicate$1<T>) : T
            public FindLastIndex ($match: System.Predicate$1<T>) : number
            public FindLastIndex ($startIndex: number, $match: System.Predicate$1<T>) : number
            public FindLastIndex ($startIndex: number, $count: number, $match: System.Predicate$1<T>) : number
            public ForEach ($action: System.Action$1<T>) : void
            public GetEnumerator () : System.Collections.Generic.List$1.Enumerator<T>
            public GetRange ($index: number, $count: number) : System.Collections.Generic.List$1<T>
            public IndexOf ($item: T) : number
            public IndexOf ($item: T, $index: number) : number
            public IndexOf ($item: T, $index: number, $count: number) : number
            public Insert ($index: number, $item: T) : void
            public InsertRange ($index: number, $collection: System.Collections.Generic.IEnumerable$1<T>) : void
            public LastIndexOf ($item: T) : number
            public LastIndexOf ($item: T, $index: number) : number
            public LastIndexOf ($item: T, $index: number, $count: number) : number
            public Remove ($item: T) : boolean
            public RemoveAll ($match: System.Predicate$1<T>) : number
            public RemoveAt ($index: number) : void
            public RemoveRange ($index: number, $count: number) : void
            public Reverse () : void
            public Reverse ($index: number, $count: number) : void
            public Sort () : void
            public Sort ($comparer: System.Collections.Generic.IComparer$1<T>) : void
            public Sort ($index: number, $count: number, $comparer: System.Collections.Generic.IComparer$1<T>) : void
            public Sort ($comparison: System.Comparison$1<T>) : void
            public ToArray () : System.Array$1<T>
            public TrimExcess () : void
            public TrueForAll ($match: System.Predicate$1<T>) : boolean
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($collection: System.Collections.Generic.IEnumerable$1<T>)
        }
        interface IReadOnlyList$1<T> extends System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<T>
        {
        }
        interface IReadOnlyCollection$1<T> extends System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable
        {
        }
        interface IList$1<T> extends System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.ICollection$1<T>
        {
        }
        interface ICollection$1<T> extends System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable
        {
        }
        interface IComparer$1<T>
        {
        }
        interface IEnumerator$1<T> extends System.Collections.IEnumerator, System.IDisposable
        {
        }
        class Dictionary$2<TKey, TValue> extends System.Object implements System.Runtime.Serialization.IDeserializationCallback, System.Collections.Generic.IReadOnlyDictionary$2<TKey, TValue>, System.Collections.Generic.IDictionary$2<TKey, TValue>, System.Runtime.Serialization.ISerializable, System.Collections.ICollection, System.Collections.IDictionary, System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.Generic.ICollection$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>
        {
            protected [__keep_incompatibility]: never;
            public get Comparer(): System.Collections.Generic.IEqualityComparer$1<TKey>;
            public get Count(): number;
            public get Keys(): System.Collections.Generic.Dictionary$2.KeyCollection<TKey, TValue>;
            public get Values(): System.Collections.Generic.Dictionary$2.ValueCollection<TKey, TValue>;
            public get_Item ($key: TKey) : TValue
            public set_Item ($key: TKey, $value: TValue) : void
            public Add ($key: TKey, $value: TValue) : void
            public Clear () : void
            public ContainsKey ($key: TKey) : boolean
            public ContainsValue ($value: TValue) : boolean
            public GetEnumerator () : System.Collections.Generic.Dictionary$2.Enumerator<TKey, TValue>
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public OnDeserialization ($sender: any) : void
            public Remove ($key: TKey) : boolean
            public TryGetValue ($key: TKey, $value: $Ref<TValue>) : boolean
            public EnsureCapacity ($capacity: number) : number
            public TrimExcess () : void
            public TrimExcess ($capacity: number) : void
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($comparer: System.Collections.Generic.IEqualityComparer$1<TKey>)
            public constructor ($capacity: number, $comparer: System.Collections.Generic.IEqualityComparer$1<TKey>)
            public constructor ($dictionary: System.Collections.Generic.IDictionary$2<TKey, TValue>)
            public constructor ($dictionary: System.Collections.Generic.IDictionary$2<TKey, TValue>, $comparer: System.Collections.Generic.IEqualityComparer$1<TKey>)
            public constructor ($collection: System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>)
            public constructor ($collection: System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, $comparer: System.Collections.Generic.IEqualityComparer$1<TKey>)
        }
        interface IReadOnlyDictionary$2<TKey, TValue> extends System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>
        {
        }
        class KeyValuePair$2<TKey, TValue> extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        interface IDictionary$2<TKey, TValue> extends System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.Generic.ICollection$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>
        {
        }
        interface IEqualityComparer$1<T>
        {
        }
        class HashSet$1<T> extends System.Object implements System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable, System.Collections.Generic.IEnumerable$1<T>, System.Collections.Generic.ISet$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Collections.Generic.ICollection$1<T>
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get Comparer(): System.Collections.Generic.IEqualityComparer$1<T>;
            public Clear () : void
            public Contains ($item: T) : boolean
            public CopyTo ($array: System.Array$1<T>, $arrayIndex: number) : void
            public Remove ($item: T) : boolean
            public GetEnumerator () : System.Collections.Generic.HashSet$1.Enumerator<T>
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public OnDeserialization ($sender: any) : void
            public Add ($item: T) : boolean
            public UnionWith ($other: System.Collections.Generic.IEnumerable$1<T>) : void
            public IntersectWith ($other: System.Collections.Generic.IEnumerable$1<T>) : void
            public ExceptWith ($other: System.Collections.Generic.IEnumerable$1<T>) : void
            public SymmetricExceptWith ($other: System.Collections.Generic.IEnumerable$1<T>) : void
            public IsSubsetOf ($other: System.Collections.Generic.IEnumerable$1<T>) : boolean
            public IsProperSubsetOf ($other: System.Collections.Generic.IEnumerable$1<T>) : boolean
            public IsSupersetOf ($other: System.Collections.Generic.IEnumerable$1<T>) : boolean
            public IsProperSupersetOf ($other: System.Collections.Generic.IEnumerable$1<T>) : boolean
            public Overlaps ($other: System.Collections.Generic.IEnumerable$1<T>) : boolean
            public SetEquals ($other: System.Collections.Generic.IEnumerable$1<T>) : boolean
            public CopyTo ($array: System.Array$1<T>) : void
            public CopyTo ($array: System.Array$1<T>, $arrayIndex: number, $count: number) : void
            public RemoveWhere ($match: System.Predicate$1<T>) : number
            public EnsureCapacity ($capacity: number) : number
            public TrimExcess () : void
            public static CreateSetComparer () : System.Collections.Generic.IEqualityComparer$1<System.Collections.Generic.HashSet$1<T>>
            public constructor ()
            public constructor ($comparer: System.Collections.Generic.IEqualityComparer$1<T>)
            public constructor ($capacity: number)
            public constructor ($collection: System.Collections.Generic.IEnumerable$1<T>)
            public constructor ($collection: System.Collections.Generic.IEnumerable$1<T>, $comparer: System.Collections.Generic.IEqualityComparer$1<T>)
            public constructor ($capacity: number, $comparer: System.Collections.Generic.IEqualityComparer$1<T>)
        }
        interface ISet$1<T> extends System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.ICollection$1<T>
        {
        }
        class Queue$1<T> extends System.Object implements System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<T>
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Collections {
        interface IEnumerable
        {
        }
        interface IStructuralComparable
        {
        }
        interface IStructuralEquatable
        {
        }
        interface ICollection extends System.Collections.IEnumerable
        {
        }
        interface IList extends System.Collections.ICollection, System.Collections.IEnumerable
        {
        }
        interface IEnumerator
        {
        }
        interface IDictionary extends System.Collections.ICollection, System.Collections.IEnumerable
        {
        }
        interface IDictionaryEnumerator extends System.Collections.IEnumerator
        {
        }
        class Hashtable extends System.Object implements System.Runtime.Serialization.IDeserializationCallback, System.ICloneable, System.Runtime.Serialization.ISerializable, System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable
        {
            protected [__keep_incompatibility]: never;
            public get IsReadOnly(): boolean;
            public get IsFixedSize(): boolean;
            public get IsSynchronized(): boolean;
            public get Keys(): System.Collections.ICollection;
            public get Values(): System.Collections.ICollection;
            public get SyncRoot(): any;
            public get Count(): number;
            public Add ($key: any, $value: any) : void
            public Clear () : void
            public Clone () : any
            public Contains ($key: any) : boolean
            public ContainsKey ($key: any) : boolean
            public ContainsValue ($value: any) : boolean
            public CopyTo ($array: System.Array, $arrayIndex: number) : void
            public get_Item ($key: any) : any
            public set_Item ($key: any, $value: any) : void
            public GetEnumerator () : System.Collections.IDictionaryEnumerator
            public Remove ($key: any) : void
            public static Synchronized ($table: System.Collections.Hashtable) : System.Collections.Hashtable
            public GetObjectData ($info: System.Runtime.Serialization.SerializationInfo, $context: System.Runtime.Serialization.StreamingContext) : void
            public OnDeserialization ($sender: any) : void
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($capacity: number, $loadFactor: number)
            public constructor ($capacity: number, $loadFactor: number, $equalityComparer: System.Collections.IEqualityComparer)
            public constructor ($equalityComparer: System.Collections.IEqualityComparer)
            public constructor ($capacity: number, $equalityComparer: System.Collections.IEqualityComparer)
            public constructor ($d: System.Collections.IDictionary)
            public constructor ($d: System.Collections.IDictionary, $loadFactor: number)
            public constructor ($d: System.Collections.IDictionary, $equalityComparer: System.Collections.IEqualityComparer)
            public constructor ($d: System.Collections.IDictionary, $loadFactor: number, $equalityComparer: System.Collections.IEqualityComparer)
        }
        interface IEqualityComparer
        {
        }
        interface IHashCodeProvider
        {
        }
        interface IComparer
        {
        }
    }
    namespace System.Runtime.Serialization {
        interface ISerializable
        {
        }
        interface IDeserializationCallback
        {
        }
        class SerializationInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class StreamingContext extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Runtime.InteropServices {
        interface _Exception
        {
        }
        interface _MemberInfo
        {
        }
        interface _Type
        {
        }
        interface _MethodBase
        {
        }
        interface _MethodInfo
        {
        }
        interface _Assembly
        {
        }
        interface _Module
        {
        }
        interface _Attribute
        {
        }
        class StructLayoutAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
        }
        interface _ConstructorInfo
        {
        }
        interface _EventInfo
        {
        }
        interface _FieldInfo
        {
        }
        interface _PropertyInfo
        {
        }
        interface _AssemblyName
        {
        }
    }
    namespace System.Collections.ObjectModel {
        class ReadOnlyCollection$1<T> extends System.Object implements System.Collections.Generic.IReadOnlyList$1<T>, System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IList$1<T>, System.Collections.Generic.IReadOnlyCollection$1<T>, System.Collections.IList, System.Collections.Generic.ICollection$1<T>
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Collections.Generic.List$1 {
        class Enumerator<T> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Collections.Generic.Dictionary$2 {
        class KeyCollection<TKey, TValue> extends System.Object implements System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<TKey>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<TKey>, System.Collections.Generic.ICollection$1<TKey>
        {
            protected [__keep_incompatibility]: never;
        }
        class ValueCollection<TKey, TValue> extends System.Object implements System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<TValue>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<TValue>, System.Collections.Generic.ICollection$1<TValue>
        {
            protected [__keep_incompatibility]: never;
        }
        class Enumerator<TKey, TValue> extends System.ValueType implements System.Collections.IDictionaryEnumerator, System.Collections.Generic.IEnumerator$1<System.Collections.Generic.KeyValuePair$2<TKey, TValue>>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Collections.Generic.HashSet$1 {
        class Enumerator<T> extends System.ValueType implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Reflection {
        class MemberInfo extends System.Object implements System.Runtime.InteropServices._MemberInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
        }
        interface ICustomAttributeProvider
        {
        }
        interface IReflect
        {
        }
        class MethodBase extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._MethodBase, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
        }
        class MethodInfo extends System.Reflection.MethodBase implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._MethodBase, System.Runtime.InteropServices._MethodInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
        }
        interface MemberFilter
        { 
        (m: System.Reflection.MemberInfo, filterCriteria: any) : boolean; 
        Invoke?: (m: System.Reflection.MemberInfo, filterCriteria: any) => boolean;
        }
        var MemberFilter: { new (func: (m: System.Reflection.MemberInfo, filterCriteria: any) => boolean): MemberFilter; }
        interface TypeFilter
        { 
        (m: System.Type, filterCriteria: any) : boolean; 
        Invoke?: (m: System.Type, filterCriteria: any) => boolean;
        }
        var TypeFilter: { new (func: (m: System.Type, filterCriteria: any) => boolean): TypeFilter; }
        enum MemberTypes
        { Constructor = 1, Event = 2, Field = 4, Method = 8, Property = 16, TypeInfo = 32, Custom = 64, NestedType = 128, All = 191 }
        enum BindingFlags
        { Default = 0, IgnoreCase = 1, DeclaredOnly = 2, Instance = 4, Static = 8, Public = 16, NonPublic = 32, FlattenHierarchy = 64, InvokeMethod = 256, CreateInstance = 512, GetField = 1024, SetField = 2048, GetProperty = 4096, SetProperty = 8192, PutDispProperty = 16384, PutRefDispProperty = 32768, ExactBinding = 65536, SuppressChangeType = 131072, OptionalParamBinding = 262144, IgnoreReturn = 16777216, DoNotWrapExceptions = 33554432 }
        class Assembly extends System.Object implements System.Runtime.Serialization.ISerializable, System.Reflection.ICustomAttributeProvider, System.Security.IEvidenceFactory, System.Runtime.InteropServices._Assembly
        {
            protected [__keep_incompatibility]: never;
        }
        class Module extends System.Object implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Module, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
        }
        enum GenericParameterAttributes
        { None = 0, VarianceMask = 3, Covariant = 1, Contravariant = 2, SpecialConstraintMask = 28, ReferenceTypeConstraint = 4, NotNullableValueTypeConstraint = 8, DefaultConstructorConstraint = 16 }
        enum TypeAttributes
        { VisibilityMask = 7, NotPublic = 0, Public = 1, NestedPublic = 2, NestedPrivate = 3, NestedFamily = 4, NestedAssembly = 5, NestedFamANDAssem = 6, NestedFamORAssem = 7, LayoutMask = 24, AutoLayout = 0, SequentialLayout = 8, ExplicitLayout = 16, ClassSemanticsMask = 32, Class = 0, Interface = 32, Abstract = 128, Sealed = 256, SpecialName = 1024, Import = 4096, Serializable = 8192, WindowsRuntime = 16384, StringFormatMask = 196608, AnsiClass = 0, UnicodeClass = 65536, AutoClass = 131072, CustomFormatClass = 196608, CustomFormatMask = 12582912, BeforeFieldInit = 1048576, RTSpecialName = 2048, HasSecurity = 262144, ReservedMask = 264192 }
        class ConstructorInfo extends System.Reflection.MethodBase implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._MethodBase, System.Runtime.InteropServices._ConstructorInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
        }
        class Binder extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class ParameterModifier extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        enum CallingConventions
        { Standard = 1, VarArgs = 2, Any = 3, HasThis = 32, ExplicitThis = 64 }
        class EventInfo extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._MemberInfo, System.Runtime.InteropServices._EventInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
        }
        class FieldInfo extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._MemberInfo, System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._FieldInfo
        {
            protected [__keep_incompatibility]: never;
        }
        class PropertyInfo extends System.Reflection.MemberInfo implements System.Runtime.InteropServices._PropertyInfo, System.Runtime.InteropServices._MemberInfo, System.Reflection.ICustomAttributeProvider
        {
            protected [__keep_incompatibility]: never;
        }
        class InterfaceMapping extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class AssemblyName extends System.Object implements System.Runtime.InteropServices._AssemblyName, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable, System.ICloneable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.SceneManagement {
        /** Run-time data structure for *.unity file.
        */
        class Scene extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get handle(): number;
            /** Returns the relative path of the Scene. Like: "AssetsMyScenesMyScene.unity".
            */
            public get path(): string;
            /** Returns the name of the Scene that is currently active in the game or app.
            */
            public get name(): string;
            public set name(value: string);
            /** Returns true if the Scene is loaded.
            */
            public get isLoaded(): boolean;
            /** Return the index of the Scene in the Build Settings.
            */
            public get buildIndex(): number;
            /** Returns true if the Scene is modifed.
            */
            public get isDirty(): boolean;
            /** The number of root transforms of this Scene.
            */
            public get rootCount(): number;
            public get isSubScene(): boolean;
            public set isSubScene(value: boolean);
            public IsValid () : boolean
            public GetRootGameObjects () : System.Array$1<UnityEngine.GameObject>
            public GetRootGameObjects ($rootGameObjects: System.Collections.Generic.List$1<UnityEngine.GameObject>) : void
            public static op_Equality ($lhs: UnityEngine.SceneManagement.Scene, $rhs: UnityEngine.SceneManagement.Scene) : boolean
            public static op_Inequality ($lhs: UnityEngine.SceneManagement.Scene, $rhs: UnityEngine.SceneManagement.Scene) : boolean
        }
        /** Run-time data structure for *.unity file.
        */
        interface Scene {
            /** An extension method that returns the 3D physics Scene from the Scene.
            * @param scene The Scene from which to return the 3D physics Scene.
            * @returns The 3D physics Scene used by the Scene. 
            */
            GetPhysicsScene () : UnityEngine.PhysicsScene;
            /** An extension method that returns the 2D physics Scene from the Scene.
            * @param scene The Scene from which to return the 2D physics Scene.
            * @returns The 2D physics Scene used by the Scene. 
            */
            GetPhysicsScene2D () : UnityEngine.PhysicsScene2D;
        }
        /** Scene management at run-time.
        */
        class SceneManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            /** The total number of currently loaded Scenes.
            */
            public static get sceneCount(): number;
            /** Number of Scenes in Build Settings.
            */
            public static get sceneCountInBuildSettings(): number;
            public static GetActiveScene () : UnityEngine.SceneManagement.Scene
            /** Set the Scene to be active.
            * @param scene The Scene to be set.
            * @returns Returns false if the Scene is not loaded yet. 
            */
            public static SetActiveScene ($scene: UnityEngine.SceneManagement.Scene) : boolean
            /** Searches all Scenes loaded for a Scene that has the given asset path.
            * @param scenePath Path of the Scene. Should be relative to the project folder. Like: "AssetsMyScenesMyScene.unity".
            * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned. 
            */
            public static GetSceneByPath ($scenePath: string) : UnityEngine.SceneManagement.Scene
            /** Searches through the Scenes loaded for a Scene with the given name.
            * @param name Name of Scene to find.
            * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned. 
            */
            public static GetSceneByName ($name: string) : UnityEngine.SceneManagement.Scene
            /** Get a Scene struct from a build index.
            * @param buildIndex Build index as shown in the Build Settings window.
            * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned. 
            */
            public static GetSceneByBuildIndex ($buildIndex: number) : UnityEngine.SceneManagement.Scene
            /** Get the Scene at index in the SceneManager's list of loaded Scenes.
            * @param index Index of the Scene to get. Index must be greater than or equal to 0 and less than SceneManager.sceneCount.
            * @returns A reference to the Scene at the index specified. 
            */
            public static GetSceneAt ($index: number) : UnityEngine.SceneManagement.Scene
            /** Create an empty new Scene at runtime with the given name.
            * @param sceneName The name of the new Scene. It cannot be empty or null, or same as the name of the existing Scenes.
            * @param parameters Various parameters used to create the Scene.
            * @returns A reference to the new Scene that was created, or an invalid Scene if creation failed. 
            */
            public static CreateScene ($sceneName: string, $parameters: UnityEngine.SceneManagement.CreateSceneParameters) : UnityEngine.SceneManagement.Scene
            /** This will merge the source Scene into the destinationScene.
            * @param sourceScene The Scene that will be merged into the destination Scene.
            * @param destinationScene Existing Scene to merge the source Scene into.
            */
            public static MergeScenes ($sourceScene: UnityEngine.SceneManagement.Scene, $destinationScene: UnityEngine.SceneManagement.Scene) : void
            /** Move a GameObject from its current Scene to a new Scene.
            * @param go GameObject to move.
            * @param scene Scene to move into.
            */
            public static MoveGameObjectToScene ($go: UnityEngine.GameObject, $scene: UnityEngine.SceneManagement.Scene) : void
            public static add_sceneLoaded ($value: UnityEngine.Events.UnityAction$2<UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.LoadSceneMode>) : void
            public static remove_sceneLoaded ($value: UnityEngine.Events.UnityAction$2<UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.LoadSceneMode>) : void
            public static add_sceneUnloaded ($value: UnityEngine.Events.UnityAction$1<UnityEngine.SceneManagement.Scene>) : void
            public static remove_sceneUnloaded ($value: UnityEngine.Events.UnityAction$1<UnityEngine.SceneManagement.Scene>) : void
            public static add_activeSceneChanged ($value: UnityEngine.Events.UnityAction$2<UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.Scene>) : void
            public static remove_activeSceneChanged ($value: UnityEngine.Events.UnityAction$2<UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.Scene>) : void
            /** Create an empty new Scene at runtime with the given name.
            * @param sceneName The name of the new Scene. It cannot be empty or null, or same as the name of the existing Scenes.
            * @param parameters Various parameters used to create the Scene.
            * @returns A reference to the new Scene that was created, or an invalid Scene if creation failed. 
            */
            public static CreateScene ($sceneName: string) : UnityEngine.SceneManagement.Scene
            /** Loads the Scene by its name or index in Build Settings.
            * @param sceneName Name or path of the Scene to load.
            * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param mode Allows you to specify whether or not to load the Scene additively. See SceneManagement.LoadSceneMode for more information about the options.
            */
            public static LoadScene ($sceneName: string, $mode: UnityEngine.SceneManagement.LoadSceneMode) : void
            public static LoadScene ($sceneName: string) : void
            /** Loads the Scene by its name or index in Build Settings.
            * @param sceneName Name or path of the Scene to load.
            * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param parameters Various parameters used to load the Scene.
            * @returns A handle to the Scene being loaded. 
            */
            public static LoadScene ($sceneName: string, $parameters: UnityEngine.SceneManagement.LoadSceneParameters) : UnityEngine.SceneManagement.Scene
            /** Loads the Scene by its name or index in Build Settings.
            * @param sceneName Name or path of the Scene to load.
            * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param mode Allows you to specify whether or not to load the Scene additively. See SceneManagement.LoadSceneMode for more information about the options.
            */
            public static LoadScene ($sceneBuildIndex: number, $mode: UnityEngine.SceneManagement.LoadSceneMode) : void
            public static LoadScene ($sceneBuildIndex: number) : void
            /** Loads the Scene by its name or index in Build Settings.
            * @param sceneName Name or path of the Scene to load.
            * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param parameters Various parameters used to load the Scene.
            * @returns A handle to the Scene being loaded. 
            */
            public static LoadScene ($sceneBuildIndex: number, $parameters: UnityEngine.SceneManagement.LoadSceneParameters) : UnityEngine.SceneManagement.Scene
            /** Loads the Scene asynchronously in the background.
            * @param sceneName Name or path of the Scene to load.
            * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
            * @param parameters Struct that collects the various parameters into a single place except for the name and index.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static LoadSceneAsync ($sceneBuildIndex: number, $mode: UnityEngine.SceneManagement.LoadSceneMode) : UnityEngine.AsyncOperation
            public static LoadSceneAsync ($sceneBuildIndex: number) : UnityEngine.AsyncOperation
            /** Loads the Scene asynchronously in the background.
            * @param sceneName Name or path of the Scene to load.
            * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
            * @param parameters Struct that collects the various parameters into a single place except for the name and index.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static LoadSceneAsync ($sceneBuildIndex: number, $parameters: UnityEngine.SceneManagement.LoadSceneParameters) : UnityEngine.AsyncOperation
            /** Loads the Scene asynchronously in the background.
            * @param sceneName Name or path of the Scene to load.
            * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
            * @param parameters Struct that collects the various parameters into a single place except for the name and index.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static LoadSceneAsync ($sceneName: string, $mode: UnityEngine.SceneManagement.LoadSceneMode) : UnityEngine.AsyncOperation
            public static LoadSceneAsync ($sceneName: string) : UnityEngine.AsyncOperation
            /** Loads the Scene asynchronously in the background.
            * @param sceneName Name or path of the Scene to load.
            * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
            * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
            * @param parameters Struct that collects the various parameters into a single place except for the name and index.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static LoadSceneAsync ($sceneName: string, $parameters: UnityEngine.SceneManagement.LoadSceneParameters) : UnityEngine.AsyncOperation
            /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
            * @param sceneBuildIndex Index of the Scene in BuildSettings.
            * @param sceneName Name or path of the Scene to unload.
            * @param scene Scene to unload.
            * @param options Scene unloading options.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static UnloadSceneAsync ($sceneBuildIndex: number) : UnityEngine.AsyncOperation
            /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
            * @param sceneBuildIndex Index of the Scene in BuildSettings.
            * @param sceneName Name or path of the Scene to unload.
            * @param scene Scene to unload.
            * @param options Scene unloading options.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static UnloadSceneAsync ($sceneName: string) : UnityEngine.AsyncOperation
            /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
            * @param sceneBuildIndex Index of the Scene in BuildSettings.
            * @param sceneName Name or path of the Scene to unload.
            * @param scene Scene to unload.
            * @param options Scene unloading options.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static UnloadSceneAsync ($scene: UnityEngine.SceneManagement.Scene) : UnityEngine.AsyncOperation
            /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
            * @param sceneBuildIndex Index of the Scene in BuildSettings.
            * @param sceneName Name or path of the Scene to unload.
            * @param scene Scene to unload.
            * @param options Scene unloading options.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static UnloadSceneAsync ($sceneBuildIndex: number, $options: UnityEngine.SceneManagement.UnloadSceneOptions) : UnityEngine.AsyncOperation
            /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
            * @param sceneBuildIndex Index of the Scene in BuildSettings.
            * @param sceneName Name or path of the Scene to unload.
            * @param scene Scene to unload.
            * @param options Scene unloading options.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static UnloadSceneAsync ($sceneName: string, $options: UnityEngine.SceneManagement.UnloadSceneOptions) : UnityEngine.AsyncOperation
            /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
            * @param sceneBuildIndex Index of the Scene in BuildSettings.
            * @param sceneName Name or path of the Scene to unload.
            * @param scene Scene to unload.
            * @param options Scene unloading options.
            * @returns Use the AsyncOperation to determine if the operation has completed. 
            */
            public static UnloadSceneAsync ($scene: UnityEngine.SceneManagement.Scene, $options: UnityEngine.SceneManagement.UnloadSceneOptions) : UnityEngine.AsyncOperation
            public constructor ()
        }
        /** This struct collects all the CreateScene parameters in to a single place.
        */
        class CreateSceneParameters extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** Used when loading a Scene in a player.
        */
        enum LoadSceneMode
        { Single = 0, Additive = 1 }
        /** This struct collects all the LoadScene parameters in to a single place.
        */
        class LoadSceneParameters extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** Scene unloading options passed to SceneManager.UnloadScene.
        */
        enum UnloadSceneOptions
        { None = 0, UnloadAllEmbeddedSceneObjects = 1 }
    }
    namespace System.Security {
        interface IEvidenceFactory
        {
        }
    }
    namespace System.Globalization {
        class CultureInfo extends System.Object implements System.ICloneable, System.IFormatProvider
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.ParticleSystem {
        class Particle extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            public get velocity(): UnityEngine.Vector3;
            public set velocity(value: UnityEngine.Vector3);
            public get animatedVelocity(): UnityEngine.Vector3;
            public get totalVelocity(): UnityEngine.Vector3;
            public get remainingLifetime(): number;
            public set remainingLifetime(value: number);
            public get startLifetime(): number;
            public set startLifetime(value: number);
            public get startColor(): UnityEngine.Color32;
            public set startColor(value: UnityEngine.Color32);
            public get randomSeed(): number;
            public set randomSeed(value: number);
            public get axisOfRotation(): UnityEngine.Vector3;
            public set axisOfRotation(value: UnityEngine.Vector3);
            public get startSize(): number;
            public set startSize(value: number);
            public get startSize3D(): UnityEngine.Vector3;
            public set startSize3D(value: UnityEngine.Vector3);
            public get rotation(): number;
            public set rotation(value: number);
            public get rotation3D(): UnityEngine.Vector3;
            public set rotation3D(value: UnityEngine.Vector3);
            public get angularVelocity(): number;
            public set angularVelocity(value: number);
            public get angularVelocity3D(): UnityEngine.Vector3;
            public set angularVelocity3D(value: UnityEngine.Vector3);
            public GetCurrentSize ($system: UnityEngine.ParticleSystem) : number
            public GetCurrentSize3D ($system: UnityEngine.ParticleSystem) : UnityEngine.Vector3
            public GetCurrentColor ($system: UnityEngine.ParticleSystem) : UnityEngine.Color32
            public SetMeshIndex ($index: number) : void
            public GetMeshIndex ($system: UnityEngine.ParticleSystem) : number
        }
        class PlaybackState extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class Trails extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get capacity(): number;
            public set capacity(value: number);
        }
        class EmitParams extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get particle(): UnityEngine.ParticleSystem.Particle;
            public set particle(value: UnityEngine.ParticleSystem.Particle);
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            public get applyShapeToPosition(): boolean;
            public set applyShapeToPosition(value: boolean);
            public get velocity(): UnityEngine.Vector3;
            public set velocity(value: UnityEngine.Vector3);
            public get startLifetime(): number;
            public set startLifetime(value: number);
            public get startSize(): number;
            public set startSize(value: number);
            public get startSize3D(): UnityEngine.Vector3;
            public set startSize3D(value: UnityEngine.Vector3);
            public get axisOfRotation(): UnityEngine.Vector3;
            public set axisOfRotation(value: UnityEngine.Vector3);
            public get rotation(): number;
            public set rotation(value: number);
            public get rotation3D(): UnityEngine.Vector3;
            public set rotation3D(value: UnityEngine.Vector3);
            public get angularVelocity(): number;
            public set angularVelocity(value: number);
            public get angularVelocity3D(): UnityEngine.Vector3;
            public set angularVelocity3D(value: UnityEngine.Vector3);
            public get startColor(): UnityEngine.Color32;
            public set startColor(value: UnityEngine.Color32);
            public get randomSeed(): number;
            public set randomSeed(value: number);
            public set meshIndex(value: number);
            public ResetPosition () : void
            public ResetVelocity () : void
            public ResetAxisOfRotation () : void
            public ResetRotation () : void
            public ResetAngularVelocity () : void
            public ResetStartSize () : void
            public ResetStartColor () : void
            public ResetRandomSeed () : void
            public ResetStartLifetime () : void
            public ResetMeshIndex () : void
        }
        class MainModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get emitterVelocity(): UnityEngine.Vector3;
            public set emitterVelocity(value: UnityEngine.Vector3);
            public get duration(): number;
            public set duration(value: number);
            public get loop(): boolean;
            public set loop(value: boolean);
            public get prewarm(): boolean;
            public set prewarm(value: boolean);
            public get startDelay(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startDelay(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startDelayMultiplier(): number;
            public set startDelayMultiplier(value: number);
            public get startLifetime(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startLifetime(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startLifetimeMultiplier(): number;
            public set startLifetimeMultiplier(value: number);
            public get startSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startSpeedMultiplier(): number;
            public set startSpeedMultiplier(value: number);
            public get startSize3D(): boolean;
            public set startSize3D(value: boolean);
            public get startSize(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startSize(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startSizeMultiplier(): number;
            public set startSizeMultiplier(value: number);
            public get startSizeX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startSizeX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startSizeXMultiplier(): number;
            public set startSizeXMultiplier(value: number);
            public get startSizeY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startSizeY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startSizeYMultiplier(): number;
            public set startSizeYMultiplier(value: number);
            public get startSizeZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startSizeZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startSizeZMultiplier(): number;
            public set startSizeZMultiplier(value: number);
            public get startRotation3D(): boolean;
            public set startRotation3D(value: boolean);
            public get startRotation(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startRotation(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startRotationMultiplier(): number;
            public set startRotationMultiplier(value: number);
            public get startRotationX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startRotationX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startRotationXMultiplier(): number;
            public set startRotationXMultiplier(value: number);
            public get startRotationY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startRotationY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startRotationYMultiplier(): number;
            public set startRotationYMultiplier(value: number);
            public get startRotationZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startRotationZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startRotationZMultiplier(): number;
            public set startRotationZMultiplier(value: number);
            public get flipRotation(): number;
            public set flipRotation(value: number);
            public get startColor(): UnityEngine.ParticleSystem.MinMaxGradient;
            public set startColor(value: UnityEngine.ParticleSystem.MinMaxGradient);
            public get gravityModifier(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set gravityModifier(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get gravityModifierMultiplier(): number;
            public set gravityModifierMultiplier(value: number);
            public get simulationSpace(): UnityEngine.ParticleSystemSimulationSpace;
            public set simulationSpace(value: UnityEngine.ParticleSystemSimulationSpace);
            public get customSimulationSpace(): UnityEngine.Transform;
            public set customSimulationSpace(value: UnityEngine.Transform);
            public get simulationSpeed(): number;
            public set simulationSpeed(value: number);
            public get useUnscaledTime(): boolean;
            public set useUnscaledTime(value: boolean);
            public get scalingMode(): UnityEngine.ParticleSystemScalingMode;
            public set scalingMode(value: UnityEngine.ParticleSystemScalingMode);
            public get playOnAwake(): boolean;
            public set playOnAwake(value: boolean);
            public get maxParticles(): number;
            public set maxParticles(value: number);
            public get emitterVelocityMode(): UnityEngine.ParticleSystemEmitterVelocityMode;
            public set emitterVelocityMode(value: UnityEngine.ParticleSystemEmitterVelocityMode);
            public get stopAction(): UnityEngine.ParticleSystemStopAction;
            public set stopAction(value: UnityEngine.ParticleSystemStopAction);
            public get ringBufferMode(): UnityEngine.ParticleSystemRingBufferMode;
            public set ringBufferMode(value: UnityEngine.ParticleSystemRingBufferMode);
            public get ringBufferLoopRange(): UnityEngine.Vector2;
            public set ringBufferLoopRange(value: UnityEngine.Vector2);
            public get cullingMode(): UnityEngine.ParticleSystemCullingMode;
            public set cullingMode(value: UnityEngine.ParticleSystemCullingMode);
        }
        class EmissionModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get rateOverTime(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set rateOverTime(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get rateOverTimeMultiplier(): number;
            public set rateOverTimeMultiplier(value: number);
            public get rateOverDistance(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set rateOverDistance(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get rateOverDistanceMultiplier(): number;
            public set rateOverDistanceMultiplier(value: number);
            public get burstCount(): number;
            public set burstCount(value: number);
            public SetBursts ($bursts: System.Array$1<UnityEngine.ParticleSystem.Burst>) : void
            public SetBursts ($bursts: System.Array$1<UnityEngine.ParticleSystem.Burst>, $size: number) : void
            public GetBursts ($bursts: System.Array$1<UnityEngine.ParticleSystem.Burst>) : number
            public SetBurst ($index: number, $burst: UnityEngine.ParticleSystem.Burst) : void
            public GetBurst ($index: number) : UnityEngine.ParticleSystem.Burst
        }
        class ShapeModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get shapeType(): UnityEngine.ParticleSystemShapeType;
            public set shapeType(value: UnityEngine.ParticleSystemShapeType);
            public get randomDirectionAmount(): number;
            public set randomDirectionAmount(value: number);
            public get sphericalDirectionAmount(): number;
            public set sphericalDirectionAmount(value: number);
            public get randomPositionAmount(): number;
            public set randomPositionAmount(value: number);
            public get alignToDirection(): boolean;
            public set alignToDirection(value: boolean);
            public get radius(): number;
            public set radius(value: number);
            public get radiusMode(): UnityEngine.ParticleSystemShapeMultiModeValue;
            public set radiusMode(value: UnityEngine.ParticleSystemShapeMultiModeValue);
            public get radiusSpread(): number;
            public set radiusSpread(value: number);
            public get radiusSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set radiusSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get radiusSpeedMultiplier(): number;
            public set radiusSpeedMultiplier(value: number);
            public get radiusThickness(): number;
            public set radiusThickness(value: number);
            public get angle(): number;
            public set angle(value: number);
            public get length(): number;
            public set length(value: number);
            public get boxThickness(): UnityEngine.Vector3;
            public set boxThickness(value: UnityEngine.Vector3);
            public get meshShapeType(): UnityEngine.ParticleSystemMeshShapeType;
            public set meshShapeType(value: UnityEngine.ParticleSystemMeshShapeType);
            public get mesh(): UnityEngine.Mesh;
            public set mesh(value: UnityEngine.Mesh);
            public get meshRenderer(): UnityEngine.MeshRenderer;
            public set meshRenderer(value: UnityEngine.MeshRenderer);
            public get skinnedMeshRenderer(): UnityEngine.SkinnedMeshRenderer;
            public set skinnedMeshRenderer(value: UnityEngine.SkinnedMeshRenderer);
            public get sprite(): UnityEngine.Sprite;
            public set sprite(value: UnityEngine.Sprite);
            public get spriteRenderer(): UnityEngine.SpriteRenderer;
            public set spriteRenderer(value: UnityEngine.SpriteRenderer);
            public get useMeshMaterialIndex(): boolean;
            public set useMeshMaterialIndex(value: boolean);
            public get meshMaterialIndex(): number;
            public set meshMaterialIndex(value: number);
            public get useMeshColors(): boolean;
            public set useMeshColors(value: boolean);
            public get normalOffset(): number;
            public set normalOffset(value: number);
            public get meshSpawnMode(): UnityEngine.ParticleSystemShapeMultiModeValue;
            public set meshSpawnMode(value: UnityEngine.ParticleSystemShapeMultiModeValue);
            public get meshSpawnSpread(): number;
            public set meshSpawnSpread(value: number);
            public get meshSpawnSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set meshSpawnSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get meshSpawnSpeedMultiplier(): number;
            public set meshSpawnSpeedMultiplier(value: number);
            public get arc(): number;
            public set arc(value: number);
            public get arcMode(): UnityEngine.ParticleSystemShapeMultiModeValue;
            public set arcMode(value: UnityEngine.ParticleSystemShapeMultiModeValue);
            public get arcSpread(): number;
            public set arcSpread(value: number);
            public get arcSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set arcSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get arcSpeedMultiplier(): number;
            public set arcSpeedMultiplier(value: number);
            public get donutRadius(): number;
            public set donutRadius(value: number);
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            public get rotation(): UnityEngine.Vector3;
            public set rotation(value: UnityEngine.Vector3);
            public get scale(): UnityEngine.Vector3;
            public set scale(value: UnityEngine.Vector3);
            public get texture(): UnityEngine.Texture2D;
            public set texture(value: UnityEngine.Texture2D);
            public get textureClipChannel(): UnityEngine.ParticleSystemShapeTextureChannel;
            public set textureClipChannel(value: UnityEngine.ParticleSystemShapeTextureChannel);
            public get textureClipThreshold(): number;
            public set textureClipThreshold(value: number);
            public get textureColorAffectsParticles(): boolean;
            public set textureColorAffectsParticles(value: boolean);
            public get textureAlphaAffectsParticles(): boolean;
            public set textureAlphaAffectsParticles(value: boolean);
            public get textureBilinearFiltering(): boolean;
            public set textureBilinearFiltering(value: boolean);
            public get textureUVChannel(): number;
            public set textureUVChannel(value: number);
        }
        class VelocityOverLifetimeModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get x(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set x(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get y(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set y(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get z(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set z(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get xMultiplier(): number;
            public set xMultiplier(value: number);
            public get yMultiplier(): number;
            public set yMultiplier(value: number);
            public get zMultiplier(): number;
            public set zMultiplier(value: number);
            public get orbitalX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set orbitalX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get orbitalY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set orbitalY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get orbitalZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set orbitalZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get orbitalXMultiplier(): number;
            public set orbitalXMultiplier(value: number);
            public get orbitalYMultiplier(): number;
            public set orbitalYMultiplier(value: number);
            public get orbitalZMultiplier(): number;
            public set orbitalZMultiplier(value: number);
            public get orbitalOffsetX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set orbitalOffsetX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get orbitalOffsetY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set orbitalOffsetY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get orbitalOffsetZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set orbitalOffsetZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get orbitalOffsetXMultiplier(): number;
            public set orbitalOffsetXMultiplier(value: number);
            public get orbitalOffsetYMultiplier(): number;
            public set orbitalOffsetYMultiplier(value: number);
            public get orbitalOffsetZMultiplier(): number;
            public set orbitalOffsetZMultiplier(value: number);
            public get radial(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set radial(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get radialMultiplier(): number;
            public set radialMultiplier(value: number);
            public get speedModifier(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set speedModifier(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get speedModifierMultiplier(): number;
            public set speedModifierMultiplier(value: number);
            public get space(): UnityEngine.ParticleSystemSimulationSpace;
            public set space(value: UnityEngine.ParticleSystemSimulationSpace);
        }
        class LimitVelocityOverLifetimeModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get limitX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set limitX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get limitXMultiplier(): number;
            public set limitXMultiplier(value: number);
            public get limitY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set limitY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get limitYMultiplier(): number;
            public set limitYMultiplier(value: number);
            public get limitZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set limitZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get limitZMultiplier(): number;
            public set limitZMultiplier(value: number);
            public get limit(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set limit(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get limitMultiplier(): number;
            public set limitMultiplier(value: number);
            public get dampen(): number;
            public set dampen(value: number);
            public get separateAxes(): boolean;
            public set separateAxes(value: boolean);
            public get space(): UnityEngine.ParticleSystemSimulationSpace;
            public set space(value: UnityEngine.ParticleSystemSimulationSpace);
            public get drag(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set drag(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get dragMultiplier(): number;
            public set dragMultiplier(value: number);
            public get multiplyDragByParticleSize(): boolean;
            public set multiplyDragByParticleSize(value: boolean);
            public get multiplyDragByParticleVelocity(): boolean;
            public set multiplyDragByParticleVelocity(value: boolean);
        }
        class InheritVelocityModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get mode(): UnityEngine.ParticleSystemInheritVelocityMode;
            public set mode(value: UnityEngine.ParticleSystemInheritVelocityMode);
            public get curve(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set curve(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get curveMultiplier(): number;
            public set curveMultiplier(value: number);
        }
        class LifetimeByEmitterSpeedModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get curve(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set curve(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get curveMultiplier(): number;
            public set curveMultiplier(value: number);
            public get range(): UnityEngine.Vector2;
            public set range(value: UnityEngine.Vector2);
        }
        class ForceOverLifetimeModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get x(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set x(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get y(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set y(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get z(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set z(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get xMultiplier(): number;
            public set xMultiplier(value: number);
            public get yMultiplier(): number;
            public set yMultiplier(value: number);
            public get zMultiplier(): number;
            public set zMultiplier(value: number);
            public get space(): UnityEngine.ParticleSystemSimulationSpace;
            public set space(value: UnityEngine.ParticleSystemSimulationSpace);
            public get randomized(): boolean;
            public set randomized(value: boolean);
        }
        class ColorOverLifetimeModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get color(): UnityEngine.ParticleSystem.MinMaxGradient;
            public set color(value: UnityEngine.ParticleSystem.MinMaxGradient);
        }
        class ColorBySpeedModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get color(): UnityEngine.ParticleSystem.MinMaxGradient;
            public set color(value: UnityEngine.ParticleSystem.MinMaxGradient);
            public get range(): UnityEngine.Vector2;
            public set range(value: UnityEngine.Vector2);
        }
        class SizeOverLifetimeModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get size(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set size(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get sizeMultiplier(): number;
            public set sizeMultiplier(value: number);
            public get x(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set x(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get xMultiplier(): number;
            public set xMultiplier(value: number);
            public get y(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set y(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get yMultiplier(): number;
            public set yMultiplier(value: number);
            public get z(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set z(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get zMultiplier(): number;
            public set zMultiplier(value: number);
            public get separateAxes(): boolean;
            public set separateAxes(value: boolean);
        }
        class SizeBySpeedModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get size(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set size(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get sizeMultiplier(): number;
            public set sizeMultiplier(value: number);
            public get x(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set x(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get xMultiplier(): number;
            public set xMultiplier(value: number);
            public get y(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set y(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get yMultiplier(): number;
            public set yMultiplier(value: number);
            public get z(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set z(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get zMultiplier(): number;
            public set zMultiplier(value: number);
            public get separateAxes(): boolean;
            public set separateAxes(value: boolean);
            public get range(): UnityEngine.Vector2;
            public set range(value: UnityEngine.Vector2);
        }
        class RotationOverLifetimeModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get x(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set x(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get xMultiplier(): number;
            public set xMultiplier(value: number);
            public get y(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set y(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get yMultiplier(): number;
            public set yMultiplier(value: number);
            public get z(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set z(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get zMultiplier(): number;
            public set zMultiplier(value: number);
            public get separateAxes(): boolean;
            public set separateAxes(value: boolean);
        }
        class RotationBySpeedModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get x(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set x(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get xMultiplier(): number;
            public set xMultiplier(value: number);
            public get y(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set y(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get yMultiplier(): number;
            public set yMultiplier(value: number);
            public get z(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set z(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get zMultiplier(): number;
            public set zMultiplier(value: number);
            public get separateAxes(): boolean;
            public set separateAxes(value: boolean);
            public get range(): UnityEngine.Vector2;
            public set range(value: UnityEngine.Vector2);
        }
        class ExternalForcesModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get multiplier(): number;
            public set multiplier(value: number);
            public get multiplierCurve(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set multiplierCurve(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get influenceFilter(): UnityEngine.ParticleSystemGameObjectFilter;
            public set influenceFilter(value: UnityEngine.ParticleSystemGameObjectFilter);
            public get influenceMask(): UnityEngine.LayerMask;
            public set influenceMask(value: UnityEngine.LayerMask);
            public get influenceCount(): number;
            public IsAffectedBy ($field: UnityEngine.ParticleSystemForceField) : boolean
            public AddInfluence ($field: UnityEngine.ParticleSystemForceField) : void
            public RemoveInfluence ($index: number) : void
            public RemoveInfluence ($field: UnityEngine.ParticleSystemForceField) : void
            public RemoveAllInfluences () : void
            public SetInfluence ($index: number, $field: UnityEngine.ParticleSystemForceField) : void
            public GetInfluence ($index: number) : UnityEngine.ParticleSystemForceField
        }
        class NoiseModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get separateAxes(): boolean;
            public set separateAxes(value: boolean);
            public get strength(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set strength(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get strengthMultiplier(): number;
            public set strengthMultiplier(value: number);
            public get strengthX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set strengthX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get strengthXMultiplier(): number;
            public set strengthXMultiplier(value: number);
            public get strengthY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set strengthY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get strengthYMultiplier(): number;
            public set strengthYMultiplier(value: number);
            public get strengthZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set strengthZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get strengthZMultiplier(): number;
            public set strengthZMultiplier(value: number);
            public get frequency(): number;
            public set frequency(value: number);
            public get damping(): boolean;
            public set damping(value: boolean);
            public get octaveCount(): number;
            public set octaveCount(value: number);
            public get octaveMultiplier(): number;
            public set octaveMultiplier(value: number);
            public get octaveScale(): number;
            public set octaveScale(value: number);
            public get quality(): UnityEngine.ParticleSystemNoiseQuality;
            public set quality(value: UnityEngine.ParticleSystemNoiseQuality);
            public get scrollSpeed(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set scrollSpeed(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get scrollSpeedMultiplier(): number;
            public set scrollSpeedMultiplier(value: number);
            public get remapEnabled(): boolean;
            public set remapEnabled(value: boolean);
            public get remap(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set remap(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get remapMultiplier(): number;
            public set remapMultiplier(value: number);
            public get remapX(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set remapX(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get remapXMultiplier(): number;
            public set remapXMultiplier(value: number);
            public get remapY(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set remapY(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get remapYMultiplier(): number;
            public set remapYMultiplier(value: number);
            public get remapZ(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set remapZ(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get remapZMultiplier(): number;
            public set remapZMultiplier(value: number);
            public get positionAmount(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set positionAmount(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get rotationAmount(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set rotationAmount(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get sizeAmount(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set sizeAmount(value: UnityEngine.ParticleSystem.MinMaxCurve);
        }
        class CollisionModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get type(): UnityEngine.ParticleSystemCollisionType;
            public set type(value: UnityEngine.ParticleSystemCollisionType);
            public get mode(): UnityEngine.ParticleSystemCollisionMode;
            public set mode(value: UnityEngine.ParticleSystemCollisionMode);
            public get dampen(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set dampen(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get dampenMultiplier(): number;
            public set dampenMultiplier(value: number);
            public get bounce(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set bounce(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get bounceMultiplier(): number;
            public set bounceMultiplier(value: number);
            public get lifetimeLoss(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set lifetimeLoss(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get lifetimeLossMultiplier(): number;
            public set lifetimeLossMultiplier(value: number);
            public get minKillSpeed(): number;
            public set minKillSpeed(value: number);
            public get maxKillSpeed(): number;
            public set maxKillSpeed(value: number);
            public get collidesWith(): UnityEngine.LayerMask;
            public set collidesWith(value: UnityEngine.LayerMask);
            public get enableDynamicColliders(): boolean;
            public set enableDynamicColliders(value: boolean);
            public get maxCollisionShapes(): number;
            public set maxCollisionShapes(value: number);
            public get quality(): UnityEngine.ParticleSystemCollisionQuality;
            public set quality(value: UnityEngine.ParticleSystemCollisionQuality);
            public get voxelSize(): number;
            public set voxelSize(value: number);
            public get radiusScale(): number;
            public set radiusScale(value: number);
            public get sendCollisionMessages(): boolean;
            public set sendCollisionMessages(value: boolean);
            public get colliderForce(): number;
            public set colliderForce(value: number);
            public get multiplyColliderForceByCollisionAngle(): boolean;
            public set multiplyColliderForceByCollisionAngle(value: boolean);
            public get multiplyColliderForceByParticleSpeed(): boolean;
            public set multiplyColliderForceByParticleSpeed(value: boolean);
            public get multiplyColliderForceByParticleSize(): boolean;
            public set multiplyColliderForceByParticleSize(value: boolean);
            public get planeCount(): number;
            public AddPlane ($transform: UnityEngine.Transform) : void
            public RemovePlane ($index: number) : void
            public RemovePlane ($transform: UnityEngine.Transform) : void
            public SetPlane ($index: number, $transform: UnityEngine.Transform) : void
            public GetPlane ($index: number) : UnityEngine.Transform
        }
        class TriggerModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get inside(): UnityEngine.ParticleSystemOverlapAction;
            public set inside(value: UnityEngine.ParticleSystemOverlapAction);
            public get outside(): UnityEngine.ParticleSystemOverlapAction;
            public set outside(value: UnityEngine.ParticleSystemOverlapAction);
            public get enter(): UnityEngine.ParticleSystemOverlapAction;
            public set enter(value: UnityEngine.ParticleSystemOverlapAction);
            public get exit(): UnityEngine.ParticleSystemOverlapAction;
            public set exit(value: UnityEngine.ParticleSystemOverlapAction);
            public get colliderQueryMode(): UnityEngine.ParticleSystemColliderQueryMode;
            public set colliderQueryMode(value: UnityEngine.ParticleSystemColliderQueryMode);
            public get radiusScale(): number;
            public set radiusScale(value: number);
            public get colliderCount(): number;
            public AddCollider ($collider: UnityEngine.Component) : void
            public RemoveCollider ($index: number) : void
            public RemoveCollider ($collider: UnityEngine.Component) : void
            public SetCollider ($index: number, $collider: UnityEngine.Component) : void
            public GetCollider ($index: number) : UnityEngine.Component
        }
        class SubEmittersModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get subEmittersCount(): number;
            public AddSubEmitter ($subEmitter: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemSubEmitterType, $properties: UnityEngine.ParticleSystemSubEmitterProperties, $emitProbability: number) : void
            public AddSubEmitter ($subEmitter: UnityEngine.ParticleSystem, $type: UnityEngine.ParticleSystemSubEmitterType, $properties: UnityEngine.ParticleSystemSubEmitterProperties) : void
            public RemoveSubEmitter ($index: number) : void
            public RemoveSubEmitter ($subEmitter: UnityEngine.ParticleSystem) : void
            public SetSubEmitterSystem ($index: number, $subEmitter: UnityEngine.ParticleSystem) : void
            public SetSubEmitterType ($index: number, $type: UnityEngine.ParticleSystemSubEmitterType) : void
            public SetSubEmitterProperties ($index: number, $properties: UnityEngine.ParticleSystemSubEmitterProperties) : void
            public SetSubEmitterEmitProbability ($index: number, $emitProbability: number) : void
            public GetSubEmitterSystem ($index: number) : UnityEngine.ParticleSystem
            public GetSubEmitterType ($index: number) : UnityEngine.ParticleSystemSubEmitterType
            public GetSubEmitterProperties ($index: number) : UnityEngine.ParticleSystemSubEmitterProperties
            public GetSubEmitterEmitProbability ($index: number) : number
        }
        class TextureSheetAnimationModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get mode(): UnityEngine.ParticleSystemAnimationMode;
            public set mode(value: UnityEngine.ParticleSystemAnimationMode);
            public get timeMode(): UnityEngine.ParticleSystemAnimationTimeMode;
            public set timeMode(value: UnityEngine.ParticleSystemAnimationTimeMode);
            public get fps(): number;
            public set fps(value: number);
            public get numTilesX(): number;
            public set numTilesX(value: number);
            public get numTilesY(): number;
            public set numTilesY(value: number);
            public get animation(): UnityEngine.ParticleSystemAnimationType;
            public set animation(value: UnityEngine.ParticleSystemAnimationType);
            public get rowMode(): UnityEngine.ParticleSystemAnimationRowMode;
            public set rowMode(value: UnityEngine.ParticleSystemAnimationRowMode);
            public get frameOverTime(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set frameOverTime(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get frameOverTimeMultiplier(): number;
            public set frameOverTimeMultiplier(value: number);
            public get startFrame(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set startFrame(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get startFrameMultiplier(): number;
            public set startFrameMultiplier(value: number);
            public get cycleCount(): number;
            public set cycleCount(value: number);
            public get rowIndex(): number;
            public set rowIndex(value: number);
            public get uvChannelMask(): UnityEngine.Rendering.UVChannelFlags;
            public set uvChannelMask(value: UnityEngine.Rendering.UVChannelFlags);
            public get spriteCount(): number;
            public get speedRange(): UnityEngine.Vector2;
            public set speedRange(value: UnityEngine.Vector2);
            public AddSprite ($sprite: UnityEngine.Sprite) : void
            public RemoveSprite ($index: number) : void
            public SetSprite ($index: number, $sprite: UnityEngine.Sprite) : void
            public GetSprite ($index: number) : UnityEngine.Sprite
        }
        class LightsModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get ratio(): number;
            public set ratio(value: number);
            public get useRandomDistribution(): boolean;
            public set useRandomDistribution(value: boolean);
            public get light(): UnityEngine.Light;
            public set light(value: UnityEngine.Light);
            public get useParticleColor(): boolean;
            public set useParticleColor(value: boolean);
            public get sizeAffectsRange(): boolean;
            public set sizeAffectsRange(value: boolean);
            public get alphaAffectsIntensity(): boolean;
            public set alphaAffectsIntensity(value: boolean);
            public get range(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set range(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get rangeMultiplier(): number;
            public set rangeMultiplier(value: number);
            public get intensity(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set intensity(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get intensityMultiplier(): number;
            public set intensityMultiplier(value: number);
            public get maxLights(): number;
            public set maxLights(value: number);
        }
        class TrailModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get mode(): UnityEngine.ParticleSystemTrailMode;
            public set mode(value: UnityEngine.ParticleSystemTrailMode);
            public get ratio(): number;
            public set ratio(value: number);
            public get lifetime(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set lifetime(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get lifetimeMultiplier(): number;
            public set lifetimeMultiplier(value: number);
            public get minVertexDistance(): number;
            public set minVertexDistance(value: number);
            public get textureMode(): UnityEngine.ParticleSystemTrailTextureMode;
            public set textureMode(value: UnityEngine.ParticleSystemTrailTextureMode);
            public get worldSpace(): boolean;
            public set worldSpace(value: boolean);
            public get dieWithParticles(): boolean;
            public set dieWithParticles(value: boolean);
            public get sizeAffectsWidth(): boolean;
            public set sizeAffectsWidth(value: boolean);
            public get sizeAffectsLifetime(): boolean;
            public set sizeAffectsLifetime(value: boolean);
            public get inheritParticleColor(): boolean;
            public set inheritParticleColor(value: boolean);
            public get colorOverLifetime(): UnityEngine.ParticleSystem.MinMaxGradient;
            public set colorOverLifetime(value: UnityEngine.ParticleSystem.MinMaxGradient);
            public get widthOverTrail(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set widthOverTrail(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get widthOverTrailMultiplier(): number;
            public set widthOverTrailMultiplier(value: number);
            public get colorOverTrail(): UnityEngine.ParticleSystem.MinMaxGradient;
            public set colorOverTrail(value: UnityEngine.ParticleSystem.MinMaxGradient);
            public get generateLightingData(): boolean;
            public set generateLightingData(value: boolean);
            public get ribbonCount(): number;
            public set ribbonCount(value: number);
            public get shadowBias(): number;
            public set shadowBias(value: number);
            public get splitSubEmitterRibbons(): boolean;
            public set splitSubEmitterRibbons(value: boolean);
            public get attachRibbonsToTransform(): boolean;
            public set attachRibbonsToTransform(value: boolean);
        }
        class CustomDataModule extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public SetMode ($stream: UnityEngine.ParticleSystemCustomData, $mode: UnityEngine.ParticleSystemCustomDataMode) : void
            public GetMode ($stream: UnityEngine.ParticleSystemCustomData) : UnityEngine.ParticleSystemCustomDataMode
            public SetVectorComponentCount ($stream: UnityEngine.ParticleSystemCustomData, $count: number) : void
            public GetVectorComponentCount ($stream: UnityEngine.ParticleSystemCustomData) : number
            public SetVector ($stream: UnityEngine.ParticleSystemCustomData, $component: number, $curve: UnityEngine.ParticleSystem.MinMaxCurve) : void
            public GetVector ($stream: UnityEngine.ParticleSystemCustomData, $component: number) : UnityEngine.ParticleSystem.MinMaxCurve
            public SetColor ($stream: UnityEngine.ParticleSystemCustomData, $gradient: UnityEngine.ParticleSystem.MinMaxGradient) : void
            public GetColor ($stream: UnityEngine.ParticleSystemCustomData) : UnityEngine.ParticleSystem.MinMaxGradient
        }
        class MinMaxCurve extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get mode(): UnityEngine.ParticleSystemCurveMode;
            public set mode(value: UnityEngine.ParticleSystemCurveMode);
            public get curveMultiplier(): number;
            public set curveMultiplier(value: number);
            public get curveMax(): UnityEngine.AnimationCurve;
            public set curveMax(value: UnityEngine.AnimationCurve);
            public get curveMin(): UnityEngine.AnimationCurve;
            public set curveMin(value: UnityEngine.AnimationCurve);
            public get constantMax(): number;
            public set constantMax(value: number);
            public get constantMin(): number;
            public set constantMin(value: number);
            public get constant(): number;
            public set constant(value: number);
            public get curve(): UnityEngine.AnimationCurve;
            public set curve(value: UnityEngine.AnimationCurve);
            public Evaluate ($time: number) : number
            public Evaluate ($time: number, $lerpFactor: number) : number
            public static op_Implicit ($constant: number) : UnityEngine.ParticleSystem.MinMaxCurve
            public constructor ($constant: number)
            public constructor ($multiplier: number, $curve: UnityEngine.AnimationCurve)
            public constructor ($multiplier: number, $min: UnityEngine.AnimationCurve, $max: UnityEngine.AnimationCurve)
            public constructor ($min: number, $max: number)
            public constructor ()
        }
        class MinMaxGradient extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get mode(): UnityEngine.ParticleSystemGradientMode;
            public set mode(value: UnityEngine.ParticleSystemGradientMode);
            public get gradientMax(): UnityEngine.Gradient;
            public set gradientMax(value: UnityEngine.Gradient);
            public get gradientMin(): UnityEngine.Gradient;
            public set gradientMin(value: UnityEngine.Gradient);
            public get colorMax(): UnityEngine.Color;
            public set colorMax(value: UnityEngine.Color);
            public get colorMin(): UnityEngine.Color;
            public set colorMin(value: UnityEngine.Color);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get gradient(): UnityEngine.Gradient;
            public set gradient(value: UnityEngine.Gradient);
            public Evaluate ($time: number) : UnityEngine.Color
            public Evaluate ($time: number, $lerpFactor: number) : UnityEngine.Color
            public static op_Implicit ($color: UnityEngine.Color) : UnityEngine.ParticleSystem.MinMaxGradient
            public static op_Implicit ($gradient: UnityEngine.Gradient) : UnityEngine.ParticleSystem.MinMaxGradient
            public constructor ($color: UnityEngine.Color)
            public constructor ($gradient: UnityEngine.Gradient)
            public constructor ($min: UnityEngine.Color, $max: UnityEngine.Color)
            public constructor ($min: UnityEngine.Gradient, $max: UnityEngine.Gradient)
            public constructor ()
        }
        class Burst extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get time(): number;
            public set time(value: number);
            public get count(): UnityEngine.ParticleSystem.MinMaxCurve;
            public set count(value: UnityEngine.ParticleSystem.MinMaxCurve);
            public get minCount(): number;
            public set minCount(value: number);
            public get maxCount(): number;
            public set maxCount(value: number);
            public get cycleCount(): number;
            public set cycleCount(value: number);
            public get repeatInterval(): number;
            public set repeatInterval(value: number);
            public get probability(): number;
            public set probability(value: number);
            public constructor ($_time: number, $_count: number)
            public constructor ($_time: number, $_minCount: number, $_maxCount: number)
            public constructor ($_time: number, $_minCount: number, $_maxCount: number, $_cycleCount: number, $_repeatInterval: number)
            public constructor ($_time: number, $_count: UnityEngine.ParticleSystem.MinMaxCurve)
            public constructor ($_time: number, $_count: UnityEngine.ParticleSystem.MinMaxCurve, $_cycleCount: number, $_repeatInterval: number)
            public constructor ()
        }
        class ColliderData extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public GetColliderCount ($particleIndex: number) : number
            public GetCollider ($particleIndex: number, $colliderIndex: number) : UnityEngine.Component
        }
    }
    namespace Unity.Collections {
        class NativeArray$1<T> extends System.ValueType implements System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.IDisposable, System.IEquatable$1<Unity.Collections.NativeArray$1<T>>
        {
            protected [__keep_incompatibility]: never;
        }
        class NativeSlice$1<T> extends System.ValueType implements System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.IEquatable$1<Unity.Collections.NativeSlice$1<T>>
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.Canvas {
        interface WillRenderCanvases
        { 
        () : void; 
        Invoke?: () => void;
        }
        var WillRenderCanvases: { new (func: () => void): WillRenderCanvases; }
    }
    namespace UnityEngine.Events {
        interface UnityAction$2<T0, T1>
        { 
        (arg0: T0, arg1: T1) : void; 
        Invoke?: (arg0: T0, arg1: T1) => void;
        }
        interface UnityAction$1<T0>
        { 
        (arg0: T0) : void; 
        Invoke?: (arg0: T0) => void;
        }
        /** Abstract base class for UnityEvents.
        */
        class UnityEventBase extends System.Object implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
        /** A zero argument persistent callback that can be saved with the Scene.
        */
        class UnityEvent extends UnityEngine.Events.UnityEventBase implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            /** Add a non persistent listener to the UnityEvent.
            * @param call Callback function.
            */
            public AddListener ($call: UnityEngine.Events.UnityAction) : void
            /** Remove a non persistent listener from the UnityEvent. If you have added the same listener multiple times, this method will remove all occurrences of it.
            * @param call Callback function.
            */
            public RemoveListener ($call: UnityEngine.Events.UnityAction) : void
            public Invoke () : void
            public constructor ()
        }
        /** Zero argument delegate used by UnityEvents.
        */
        interface UnityAction
        { 
        () : void; 
        Invoke?: () => void;
        }
        var UnityAction: { new (func: () => void): UnityAction; }
        class UnityEvent$1<T0> extends UnityEngine.Events.UnityEventBase implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public AddListener ($call: UnityEngine.Events.UnityAction$1<T0>) : void
            public RemoveListener ($call: UnityEngine.Events.UnityAction$1<T0>) : void
            public Invoke ($arg0: T0) : void
            public constructor ()
        }
    }
    namespace UnityEngine.EventSystems {
        class UIBehaviour extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public IsActive () : boolean
            public IsDestroyed () : boolean
        }
        interface IEventSystemHandler
        {
        }
        interface IPointerEnterHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface ISelectHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface IPointerExitHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface IDeselectHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface IPointerDownHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface IPointerUpHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface IMoveHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        class AbstractEventData extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class BaseEventData extends UnityEngine.EventSystems.AbstractEventData
        {
            protected [__keep_incompatibility]: never;
        }
        class AxisEventData extends UnityEngine.EventSystems.BaseEventData
        {
            protected [__keep_incompatibility]: never;
        }
        class PointerEventData extends UnityEngine.EventSystems.BaseEventData
        {
            protected [__keep_incompatibility]: never;
        }
        interface ISubmitHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface IPointerClickHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface IBeginDragHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface IDragHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface IEndDragHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface IUpdateSelectedHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface ICancelHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        class BaseRaycaster extends UnityEngine.EventSystems.UIBehaviour
        {
            protected [__keep_incompatibility]: never;
        }
        class RaycastResult extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        interface IInitializePotentialDragHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
        interface IScrollHandler extends UnityEngine.EventSystems.IEventSystemHandler
        {
        }
    }
    namespace UnityEngine.UI {
        class Selectable extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler
        {
            protected [__keep_incompatibility]: never;
            public static get allSelectablesArray(): System.Array$1<UnityEngine.UI.Selectable>;
            public static get allSelectableCount(): number;
            public get navigation(): UnityEngine.UI.Navigation;
            public set navigation(value: UnityEngine.UI.Navigation);
            public get transition(): UnityEngine.UI.Selectable.Transition;
            public set transition(value: UnityEngine.UI.Selectable.Transition);
            public get colors(): UnityEngine.UI.ColorBlock;
            public set colors(value: UnityEngine.UI.ColorBlock);
            public get spriteState(): UnityEngine.UI.SpriteState;
            public set spriteState(value: UnityEngine.UI.SpriteState);
            public get animationTriggers(): UnityEngine.UI.AnimationTriggers;
            public set animationTriggers(value: UnityEngine.UI.AnimationTriggers);
            public get targetGraphic(): UnityEngine.UI.Graphic;
            public set targetGraphic(value: UnityEngine.UI.Graphic);
            public get interactable(): boolean;
            public set interactable(value: boolean);
            public get image(): UnityEngine.UI.Image;
            public set image(value: UnityEngine.UI.Image);
            public get animator(): UnityEngine.Animator;
            public static AllSelectablesNoAlloc ($selectables: System.Array$1<UnityEngine.UI.Selectable>) : number
            public IsInteractable () : boolean
            public FindSelectable ($dir: UnityEngine.Vector3) : UnityEngine.UI.Selectable
            public FindSelectableOnLeft () : UnityEngine.UI.Selectable
            public FindSelectableOnRight () : UnityEngine.UI.Selectable
            public FindSelectableOnUp () : UnityEngine.UI.Selectable
            public FindSelectableOnDown () : UnityEngine.UI.Selectable
            public OnMove ($eventData: UnityEngine.EventSystems.AxisEventData) : void
            public OnPointerDown ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnPointerUp ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnPointerEnter ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnPointerExit ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnSelect ($eventData: UnityEngine.EventSystems.BaseEventData) : void
            public OnDeselect ($eventData: UnityEngine.EventSystems.BaseEventData) : void
            public Select () : void
        }
        class Navigation extends System.ValueType implements System.IEquatable$1<UnityEngine.UI.Navigation>
        {
            protected [__keep_incompatibility]: never;
            public get mode(): UnityEngine.UI.Navigation.Mode;
            public set mode(value: UnityEngine.UI.Navigation.Mode);
            public get wrapAround(): boolean;
            public set wrapAround(value: boolean);
            public get selectOnUp(): UnityEngine.UI.Selectable;
            public set selectOnUp(value: UnityEngine.UI.Selectable);
            public get selectOnDown(): UnityEngine.UI.Selectable;
            public set selectOnDown(value: UnityEngine.UI.Selectable);
            public get selectOnLeft(): UnityEngine.UI.Selectable;
            public set selectOnLeft(value: UnityEngine.UI.Selectable);
            public get selectOnRight(): UnityEngine.UI.Selectable;
            public set selectOnRight(value: UnityEngine.UI.Selectable);
            public static get defaultNavigation(): UnityEngine.UI.Navigation;
            public Equals ($other: UnityEngine.UI.Navigation) : boolean
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class ColorBlock extends System.ValueType implements System.IEquatable$1<UnityEngine.UI.ColorBlock>
        {
            protected [__keep_incompatibility]: never;
            public static defaultColorBlock : UnityEngine.UI.ColorBlock
            public get normalColor(): UnityEngine.Color;
            public set normalColor(value: UnityEngine.Color);
            public get highlightedColor(): UnityEngine.Color;
            public set highlightedColor(value: UnityEngine.Color);
            public get pressedColor(): UnityEngine.Color;
            public set pressedColor(value: UnityEngine.Color);
            public get selectedColor(): UnityEngine.Color;
            public set selectedColor(value: UnityEngine.Color);
            public get disabledColor(): UnityEngine.Color;
            public set disabledColor(value: UnityEngine.Color);
            public get colorMultiplier(): number;
            public set colorMultiplier(value: number);
            public get fadeDuration(): number;
            public set fadeDuration(value: number);
            public Equals ($obj: any) : boolean
            public Equals ($other: UnityEngine.UI.ColorBlock) : boolean
            public static op_Equality ($point1: UnityEngine.UI.ColorBlock, $point2: UnityEngine.UI.ColorBlock) : boolean
            public static op_Inequality ($point1: UnityEngine.UI.ColorBlock, $point2: UnityEngine.UI.ColorBlock) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class SpriteState extends System.ValueType implements System.IEquatable$1<UnityEngine.UI.SpriteState>
        {
            protected [__keep_incompatibility]: never;
            public get highlightedSprite(): UnityEngine.Sprite;
            public set highlightedSprite(value: UnityEngine.Sprite);
            public get pressedSprite(): UnityEngine.Sprite;
            public set pressedSprite(value: UnityEngine.Sprite);
            public get selectedSprite(): UnityEngine.Sprite;
            public set selectedSprite(value: UnityEngine.Sprite);
            public get disabledSprite(): UnityEngine.Sprite;
            public set disabledSprite(value: UnityEngine.Sprite);
            public Equals ($other: UnityEngine.UI.SpriteState) : boolean
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class AnimationTriggers extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get normalTrigger(): string;
            public set normalTrigger(value: string);
            public get highlightedTrigger(): string;
            public set highlightedTrigger(value: string);
            public get pressedTrigger(): string;
            public set pressedTrigger(value: string);
            public get selectedTrigger(): string;
            public set selectedTrigger(value: string);
            public get disabledTrigger(): string;
            public set disabledTrigger(value: string);
            public constructor ()
        }
        class Graphic extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ICanvasElement
        {
            protected [__keep_incompatibility]: never;
            public static get defaultGraphicMaterial(): UnityEngine.Material;
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get raycastTarget(): boolean;
            public set raycastTarget(value: boolean);
            public get raycastPadding(): UnityEngine.Vector4;
            public set raycastPadding(value: UnityEngine.Vector4);
            public get depth(): number;
            public get rectTransform(): UnityEngine.RectTransform;
            public get canvas(): UnityEngine.Canvas;
            public get canvasRenderer(): UnityEngine.CanvasRenderer;
            public get defaultMaterial(): UnityEngine.Material;
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get materialForRendering(): UnityEngine.Material;
            public get mainTexture(): UnityEngine.Texture;
            public SetAllDirty () : void
            public SetLayoutDirty () : void
            public SetVerticesDirty () : void
            public SetMaterialDirty () : void
            public SetRaycastDirty () : void
            public OnCullingChanged () : void
            public Rebuild ($update: UnityEngine.UI.CanvasUpdate) : void
            public LayoutComplete () : void
            public GraphicUpdateComplete () : void
            public SetNativeSize () : void
            public Raycast ($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera) : boolean
            public PixelAdjustPoint ($point: UnityEngine.Vector2) : UnityEngine.Vector2
            public GetPixelAdjustedRect () : UnityEngine.Rect
            public CrossFadeColor ($targetColor: UnityEngine.Color, $duration: number, $ignoreTimeScale: boolean, $useAlpha: boolean) : void
            public CrossFadeColor ($targetColor: UnityEngine.Color, $duration: number, $ignoreTimeScale: boolean, $useAlpha: boolean, $useRGB: boolean) : void
            public CrossFadeAlpha ($alpha: number, $duration: number, $ignoreTimeScale: boolean) : void
            public RegisterDirtyLayoutCallback ($action: UnityEngine.Events.UnityAction) : void
            public UnregisterDirtyLayoutCallback ($action: UnityEngine.Events.UnityAction) : void
            public RegisterDirtyVerticesCallback ($action: UnityEngine.Events.UnityAction) : void
            public UnregisterDirtyVerticesCallback ($action: UnityEngine.Events.UnityAction) : void
            public RegisterDirtyMaterialCallback ($action: UnityEngine.Events.UnityAction) : void
            public UnregisterDirtyMaterialCallback ($action: UnityEngine.Events.UnityAction) : void
            public Rebuild ($executing: UnityEngine.UI.CanvasUpdate) : void
        }
        interface ICanvasElement
        {
            transform : UnityEngine.Transform
            Rebuild ($executing: UnityEngine.UI.CanvasUpdate) : void
            LayoutComplete () : void
            GraphicUpdateComplete () : void
            IsDestroyed () : boolean
        }
        class MaskableGraphic extends UnityEngine.UI.Graphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.UI.ICanvasElement, UnityEngine.UI.IClippable
        {
            protected [__keep_incompatibility]: never;
            public get onCullStateChanged(): UnityEngine.UI.MaskableGraphic.CullStateChangedEvent;
            public set onCullStateChanged(value: UnityEngine.UI.MaskableGraphic.CullStateChangedEvent);
            public get maskable(): boolean;
            public set maskable(value: boolean);
            public get isMaskingGraphic(): boolean;
            public set isMaskingGraphic(value: boolean);
            public GetModifiedMaterial ($baseMaterial: UnityEngine.Material) : UnityEngine.Material
            public Cull ($clipRect: UnityEngine.Rect, $validRect: boolean) : void
            public SetClipRect ($clipRect: UnityEngine.Rect, $validRect: boolean) : void
            public SetClipSoftness ($clipSoftness: UnityEngine.Vector2) : void
            public RecalculateClipping () : void
            public RecalculateMasking () : void
            public SetClipRect ($value: UnityEngine.Rect, $validRect: boolean) : void
        }
        interface IMaterialModifier
        {
            GetModifiedMaterial ($baseMaterial: UnityEngine.Material) : UnityEngine.Material
        }
        interface IMaskable
        {
            RecalculateMasking () : void
        }
        interface IClippable
        {
            gameObject : UnityEngine.GameObject
            rectTransform : UnityEngine.RectTransform
            RecalculateClipping () : void
            Cull ($clipRect: UnityEngine.Rect, $validRect: boolean) : void
            SetClipRect ($value: UnityEngine.Rect, $validRect: boolean) : void
            SetClipSoftness ($clipSoftness: UnityEngine.Vector2) : void
        }
        class Image extends UnityEngine.UI.MaskableGraphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.ICanvasElement, UnityEngine.ISerializationCallbackReceiver, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable
        {
            protected [__keep_incompatibility]: never;
            public get sprite(): UnityEngine.Sprite;
            public set sprite(value: UnityEngine.Sprite);
            public get overrideSprite(): UnityEngine.Sprite;
            public set overrideSprite(value: UnityEngine.Sprite);
            public get type(): UnityEngine.UI.Image.Type;
            public set type(value: UnityEngine.UI.Image.Type);
            public get preserveAspect(): boolean;
            public set preserveAspect(value: boolean);
            public get fillCenter(): boolean;
            public set fillCenter(value: boolean);
            public get fillMethod(): UnityEngine.UI.Image.FillMethod;
            public set fillMethod(value: UnityEngine.UI.Image.FillMethod);
            public get fillAmount(): number;
            public set fillAmount(value: number);
            public get fillClockwise(): boolean;
            public set fillClockwise(value: boolean);
            public get fillOrigin(): number;
            public set fillOrigin(value: number);
            public get alphaHitTestMinimumThreshold(): number;
            public set alphaHitTestMinimumThreshold(value: number);
            public get useSpriteMesh(): boolean;
            public set useSpriteMesh(value: boolean);
            public static get defaultETC1GraphicMaterial(): UnityEngine.Material;
            public get mainTexture(): UnityEngine.Texture;
            public get hasBorder(): boolean;
            public get pixelsPerUnitMultiplier(): number;
            public set pixelsPerUnitMultiplier(value: number);
            public get pixelsPerUnit(): number;
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get minWidth(): number;
            public get preferredWidth(): number;
            public get flexibleWidth(): number;
            public get minHeight(): number;
            public get preferredHeight(): number;
            public get flexibleHeight(): number;
            public get layoutPriority(): number;
            public DisableSpriteOptimizations () : void
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
            public CalculateLayoutInputHorizontal () : void
            public CalculateLayoutInputVertical () : void
            public IsRaycastLocationValid ($screenPoint: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera) : boolean
            /** Given a point and a camera is the raycast valid.
            * @param sp Screen position.
            * @param eventCamera Raycast camera.
            * @returns Valid. 
            */
            public IsRaycastLocationValid ($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera) : boolean
        }
        interface ILayoutElement
        {
            minWidth : number
            preferredWidth : number
            flexibleWidth : number
            minHeight : number
            preferredHeight : number
            flexibleHeight : number
            layoutPriority : number
            CalculateLayoutInputHorizontal () : void
            CalculateLayoutInputVertical () : void
        }
        class Button extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler
        {
            protected [__keep_incompatibility]: never;
            public get onClick(): UnityEngine.UI.Button.ButtonClickedEvent;
            public set onClick(value: UnityEngine.UI.Button.ButtonClickedEvent);
            public OnPointerClick ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnSubmit ($eventData: UnityEngine.EventSystems.BaseEventData) : void
        }
        class InputField extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.IUpdateSelectedHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler, UnityEngine.UI.ILayoutElement, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler
        {
            protected [__keep_incompatibility]: never;
            public get shouldHideMobileInput(): boolean;
            public set shouldHideMobileInput(value: boolean);
            public get shouldActivateOnSelect(): boolean;
            public set shouldActivateOnSelect(value: boolean);
            public get text(): string;
            public set text(value: string);
            public get isFocused(): boolean;
            public get caretBlinkRate(): number;
            public set caretBlinkRate(value: number);
            public get caretWidth(): number;
            public set caretWidth(value: number);
            public get textComponent(): UnityEngine.UI.Text;
            public set textComponent(value: UnityEngine.UI.Text);
            public get placeholder(): UnityEngine.UI.Graphic;
            public set placeholder(value: UnityEngine.UI.Graphic);
            public get caretColor(): UnityEngine.Color;
            public set caretColor(value: UnityEngine.Color);
            public get customCaretColor(): boolean;
            public set customCaretColor(value: boolean);
            public get selectionColor(): UnityEngine.Color;
            public set selectionColor(value: UnityEngine.Color);
            public get onEndEdit(): UnityEngine.UI.InputField.EndEditEvent;
            public set onEndEdit(value: UnityEngine.UI.InputField.EndEditEvent);
            public get onSubmit(): UnityEngine.UI.InputField.SubmitEvent;
            public set onSubmit(value: UnityEngine.UI.InputField.SubmitEvent);
            public get onValueChanged(): UnityEngine.UI.InputField.OnChangeEvent;
            public set onValueChanged(value: UnityEngine.UI.InputField.OnChangeEvent);
            public get onValidateInput(): UnityEngine.UI.InputField.OnValidateInput;
            public set onValidateInput(value: UnityEngine.UI.InputField.OnValidateInput);
            public get characterLimit(): number;
            public set characterLimit(value: number);
            public get contentType(): UnityEngine.UI.InputField.ContentType;
            public set contentType(value: UnityEngine.UI.InputField.ContentType);
            public get lineType(): UnityEngine.UI.InputField.LineType;
            public set lineType(value: UnityEngine.UI.InputField.LineType);
            public get inputType(): UnityEngine.UI.InputField.InputType;
            public set inputType(value: UnityEngine.UI.InputField.InputType);
            public get touchScreenKeyboard(): UnityEngine.TouchScreenKeyboard;
            public get keyboardType(): UnityEngine.TouchScreenKeyboardType;
            public set keyboardType(value: UnityEngine.TouchScreenKeyboardType);
            public get characterValidation(): UnityEngine.UI.InputField.CharacterValidation;
            public set characterValidation(value: UnityEngine.UI.InputField.CharacterValidation);
            public get readOnly(): boolean;
            public set readOnly(value: boolean);
            public get multiLine(): boolean;
            public get asteriskChar(): number;
            public set asteriskChar(value: number);
            public get wasCanceled(): boolean;
            public get caretPosition(): number;
            public set caretPosition(value: number);
            public get selectionAnchorPosition(): number;
            public set selectionAnchorPosition(value: number);
            public get selectionFocusPosition(): number;
            public set selectionFocusPosition(value: number);
            public get minWidth(): number;
            public get preferredWidth(): number;
            public get flexibleWidth(): number;
            public get minHeight(): number;
            public get preferredHeight(): number;
            public get flexibleHeight(): number;
            public get layoutPriority(): number;
            public SetTextWithoutNotify ($input: string) : void
            public MoveTextEnd ($shift: boolean) : void
            public MoveTextStart ($shift: boolean) : void
            public OnBeginDrag ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnDrag ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnEndDrag ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public ProcessEvent ($e: UnityEngine.Event) : void
            public OnUpdateSelected ($eventData: UnityEngine.EventSystems.BaseEventData) : void
            public ForceLabelUpdate () : void
            public Rebuild ($update: UnityEngine.UI.CanvasUpdate) : void
            public LayoutComplete () : void
            public GraphicUpdateComplete () : void
            public ActivateInputField () : void
            public OnPointerClick ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public DeactivateInputField () : void
            public OnSubmit ($eventData: UnityEngine.EventSystems.BaseEventData) : void
            public CalculateLayoutInputHorizontal () : void
            public CalculateLayoutInputVertical () : void
            public Rebuild ($executing: UnityEngine.UI.CanvasUpdate) : void
        }
        class Text extends UnityEngine.UI.MaskableGraphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.UI.ICanvasElement, UnityEngine.UI.ILayoutElement, UnityEngine.UI.IClippable
        {
            protected [__keep_incompatibility]: never;
            public get cachedTextGenerator(): UnityEngine.TextGenerator;
            public get cachedTextGeneratorForLayout(): UnityEngine.TextGenerator;
            public get mainTexture(): UnityEngine.Texture;
            public get font(): UnityEngine.Font;
            public set font(value: UnityEngine.Font);
            public get text(): string;
            public set text(value: string);
            public get supportRichText(): boolean;
            public set supportRichText(value: boolean);
            public get resizeTextForBestFit(): boolean;
            public set resizeTextForBestFit(value: boolean);
            public get resizeTextMinSize(): number;
            public set resizeTextMinSize(value: number);
            public get resizeTextMaxSize(): number;
            public set resizeTextMaxSize(value: number);
            public get alignment(): UnityEngine.TextAnchor;
            public set alignment(value: UnityEngine.TextAnchor);
            public get alignByGeometry(): boolean;
            public set alignByGeometry(value: boolean);
            public get fontSize(): number;
            public set fontSize(value: number);
            public get horizontalOverflow(): UnityEngine.HorizontalWrapMode;
            public set horizontalOverflow(value: UnityEngine.HorizontalWrapMode);
            public get verticalOverflow(): UnityEngine.VerticalWrapMode;
            public set verticalOverflow(value: UnityEngine.VerticalWrapMode);
            public get lineSpacing(): number;
            public set lineSpacing(value: number);
            public get fontStyle(): UnityEngine.FontStyle;
            public set fontStyle(value: UnityEngine.FontStyle);
            public get pixelsPerUnit(): number;
            public get minWidth(): number;
            public get preferredWidth(): number;
            public get flexibleWidth(): number;
            public get minHeight(): number;
            public get preferredHeight(): number;
            public get flexibleHeight(): number;
            public get layoutPriority(): number;
            public FontTextureChanged () : void
            public GetGenerationSettings ($extents: UnityEngine.Vector2) : UnityEngine.TextGenerationSettings
            public static GetTextAnchorPivot ($anchor: UnityEngine.TextAnchor) : UnityEngine.Vector2
            public CalculateLayoutInputHorizontal () : void
            public CalculateLayoutInputVertical () : void
        }
        enum CanvasUpdate
        { Prelayout = 0, Layout = 1, PostLayout = 2, PreRender = 3, LatePreRender = 4, MaxUpdateValue = 5 }
        class Toggle extends UnityEngine.UI.Selectable implements UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler
        {
            protected [__keep_incompatibility]: never;
            public toggleTransition : UnityEngine.UI.Toggle.ToggleTransition
            public graphic : UnityEngine.UI.Graphic
            public onValueChanged : UnityEngine.UI.Toggle.ToggleEvent
            public get group(): UnityEngine.UI.ToggleGroup;
            public set group(value: UnityEngine.UI.ToggleGroup);
            public get isOn(): boolean;
            public set isOn(value: boolean);
            public Rebuild ($executing: UnityEngine.UI.CanvasUpdate) : void
            public LayoutComplete () : void
            public GraphicUpdateComplete () : void
            public SetIsOnWithoutNotify ($value: boolean) : void
            public OnPointerClick ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnSubmit ($eventData: UnityEngine.EventSystems.BaseEventData) : void
        }
        class ToggleGroup extends UnityEngine.EventSystems.UIBehaviour
        {
            protected [__keep_incompatibility]: never;
            public get allowSwitchOff(): boolean;
            public set allowSwitchOff(value: boolean);
            public NotifyToggleOn ($toggle: UnityEngine.UI.Toggle, $sendCallback?: boolean) : void
            public UnregisterToggle ($toggle: UnityEngine.UI.Toggle) : void
            public RegisterToggle ($toggle: UnityEngine.UI.Toggle) : void
            public EnsureValidState () : void
            public AnyTogglesOn () : boolean
            public ActiveToggles () : System.Collections.Generic.IEnumerable$1<UnityEngine.UI.Toggle>
            public GetFirstActiveToggle () : UnityEngine.UI.Toggle
            public SetAllTogglesOff ($sendCallback?: boolean) : void
        }
        class CanvasUpdateRegistry extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get instance(): UnityEngine.UI.CanvasUpdateRegistry;
            public static RegisterCanvasElementForLayoutRebuild ($element: UnityEngine.UI.ICanvasElement) : void
            public static TryRegisterCanvasElementForLayoutRebuild ($element: UnityEngine.UI.ICanvasElement) : boolean
            public static RegisterCanvasElementForGraphicRebuild ($element: UnityEngine.UI.ICanvasElement) : void
            public static TryRegisterCanvasElementForGraphicRebuild ($element: UnityEngine.UI.ICanvasElement) : boolean
            public static UnRegisterCanvasElementForRebuild ($element: UnityEngine.UI.ICanvasElement) : void
            public static DisableCanvasElementForRebuild ($element: UnityEngine.UI.ICanvasElement) : void
            public static IsRebuildingLayout () : boolean
            public static IsRebuildingGraphics () : boolean
        }
        class ClipperRegistry extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get instance(): UnityEngine.UI.ClipperRegistry;
            public Cull () : void
            public static Register ($c: UnityEngine.UI.IClipper) : void
            public static Unregister ($c: UnityEngine.UI.IClipper) : void
            public static Disable ($c: UnityEngine.UI.IClipper) : void
        }
        interface IClipper
        {
            PerformClipping () : void
        }
        class Clipping extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static FindCullAndClipWorldRect ($rectMaskParents: System.Collections.Generic.List$1<UnityEngine.UI.RectMask2D>, $validRect: $Ref<boolean>) : UnityEngine.Rect
        }
        class RectMask2D extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.ICanvasRaycastFilter, UnityEngine.UI.IClipper
        {
            protected [__keep_incompatibility]: never;
            public get padding(): UnityEngine.Vector4;
            public set padding(value: UnityEngine.Vector4);
            public get softness(): UnityEngine.Vector2Int;
            public set softness(value: UnityEngine.Vector2Int);
            public get canvasRect(): UnityEngine.Rect;
            public get rectTransform(): UnityEngine.RectTransform;
            public IsRaycastLocationValid ($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera) : boolean
            public PerformClipping () : void
            public UpdateClipSoftness () : void
            public AddClippable ($clippable: UnityEngine.UI.IClippable) : void
            public RemoveClippable ($clippable: UnityEngine.UI.IClippable) : void
        }
        class Dropdown extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.ICancelHandler, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler, UnityEngine.EventSystems.ISubmitHandler, UnityEngine.EventSystems.IPointerClickHandler
        {
            protected [__keep_incompatibility]: never;
            public get template(): UnityEngine.RectTransform;
            public set template(value: UnityEngine.RectTransform);
            public get captionText(): UnityEngine.UI.Text;
            public set captionText(value: UnityEngine.UI.Text);
            public get captionImage(): UnityEngine.UI.Image;
            public set captionImage(value: UnityEngine.UI.Image);
            public get itemText(): UnityEngine.UI.Text;
            public set itemText(value: UnityEngine.UI.Text);
            public get itemImage(): UnityEngine.UI.Image;
            public set itemImage(value: UnityEngine.UI.Image);
            public get options(): System.Collections.Generic.List$1<UnityEngine.UI.Dropdown.OptionData>;
            public set options(value: System.Collections.Generic.List$1<UnityEngine.UI.Dropdown.OptionData>);
            public get onValueChanged(): UnityEngine.UI.Dropdown.DropdownEvent;
            public set onValueChanged(value: UnityEngine.UI.Dropdown.DropdownEvent);
            public get alphaFadeSpeed(): number;
            public set alphaFadeSpeed(value: number);
            public get value(): number;
            public set value(value: number);
            public SetValueWithoutNotify ($input: number) : void
            public RefreshShownValue () : void
            public AddOptions ($options: System.Collections.Generic.List$1<UnityEngine.UI.Dropdown.OptionData>) : void
            public AddOptions ($options: System.Collections.Generic.List$1<string>) : void
            public AddOptions ($options: System.Collections.Generic.List$1<UnityEngine.Sprite>) : void
            public ClearOptions () : void
            public OnPointerClick ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnSubmit ($eventData: UnityEngine.EventSystems.BaseEventData) : void
            public OnCancel ($eventData: UnityEngine.EventSystems.BaseEventData) : void
            public Show () : void
            public Hide () : void
        }
        class FontData extends System.Object implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public static get defaultFontData(): UnityEngine.UI.FontData;
            public get font(): UnityEngine.Font;
            public set font(value: UnityEngine.Font);
            public get fontSize(): number;
            public set fontSize(value: number);
            public get fontStyle(): UnityEngine.FontStyle;
            public set fontStyle(value: UnityEngine.FontStyle);
            public get bestFit(): boolean;
            public set bestFit(value: boolean);
            public get minSize(): number;
            public set minSize(value: number);
            public get maxSize(): number;
            public set maxSize(value: number);
            public get alignment(): UnityEngine.TextAnchor;
            public set alignment(value: UnityEngine.TextAnchor);
            public get alignByGeometry(): boolean;
            public set alignByGeometry(value: boolean);
            public get richText(): boolean;
            public set richText(value: boolean);
            public get horizontalOverflow(): UnityEngine.HorizontalWrapMode;
            public set horizontalOverflow(value: UnityEngine.HorizontalWrapMode);
            public get verticalOverflow(): UnityEngine.VerticalWrapMode;
            public set verticalOverflow(value: UnityEngine.VerticalWrapMode);
            public get lineSpacing(): number;
            public set lineSpacing(value: number);
            public constructor ()
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
        class FontUpdateTracker extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static TrackText ($t: UnityEngine.UI.Text) : void
            public static UntrackText ($t: UnityEngine.UI.Text) : void
        }
        class GraphicRaycaster extends UnityEngine.EventSystems.BaseRaycaster
        {
            protected [__keep_incompatibility]: never;
            public get sortOrderPriority(): number;
            public get renderOrderPriority(): number;
            public get ignoreReversedGraphics(): boolean;
            public set ignoreReversedGraphics(value: boolean);
            public get blockingObjects(): UnityEngine.UI.GraphicRaycaster.BlockingObjects;
            public set blockingObjects(value: UnityEngine.UI.GraphicRaycaster.BlockingObjects);
            public get blockingMask(): UnityEngine.LayerMask;
            public set blockingMask(value: UnityEngine.LayerMask);
            public get eventCamera(): UnityEngine.Camera;
        }
        class GraphicRegistry extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get instance(): UnityEngine.UI.GraphicRegistry;
            public static RegisterGraphicForCanvas ($c: UnityEngine.Canvas, $graphic: UnityEngine.UI.Graphic) : void
            public static RegisterRaycastGraphicForCanvas ($c: UnityEngine.Canvas, $graphic: UnityEngine.UI.Graphic) : void
            public static UnregisterGraphicForCanvas ($c: UnityEngine.Canvas, $graphic: UnityEngine.UI.Graphic) : void
            public static UnregisterRaycastGraphicForCanvas ($c: UnityEngine.Canvas, $graphic: UnityEngine.UI.Graphic) : void
            public static DisableGraphicForCanvas ($c: UnityEngine.Canvas, $graphic: UnityEngine.UI.Graphic) : void
            public static DisableRaycastGraphicForCanvas ($c: UnityEngine.Canvas, $graphic: UnityEngine.UI.Graphic) : void
            public static GetGraphicsForCanvas ($canvas: UnityEngine.Canvas) : System.Collections.Generic.IList$1<UnityEngine.UI.Graphic>
            public static GetRaycastableGraphicsForCanvas ($canvas: UnityEngine.Canvas) : System.Collections.Generic.IList$1<UnityEngine.UI.Graphic>
        }
        class AspectRatioFitter extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ILayoutSelfController, UnityEngine.UI.ILayoutController
        {
            protected [__keep_incompatibility]: never;
            public get aspectMode(): UnityEngine.UI.AspectRatioFitter.AspectMode;
            public set aspectMode(value: UnityEngine.UI.AspectRatioFitter.AspectMode);
            public get aspectRatio(): number;
            public set aspectRatio(value: number);
            public SetLayoutHorizontal () : void
            public SetLayoutVertical () : void
            public IsComponentValidOnObject () : boolean
            public IsAspectModeValid () : boolean
        }
        interface ILayoutSelfController extends UnityEngine.UI.ILayoutController
        {
            SetLayoutHorizontal () : void
            SetLayoutVertical () : void
        }
        interface ILayoutController
        {
            SetLayoutHorizontal () : void
            SetLayoutVertical () : void
        }
        class CanvasScaler extends UnityEngine.EventSystems.UIBehaviour
        {
            protected [__keep_incompatibility]: never;
            public get uiScaleMode(): UnityEngine.UI.CanvasScaler.ScaleMode;
            public set uiScaleMode(value: UnityEngine.UI.CanvasScaler.ScaleMode);
            public get referencePixelsPerUnit(): number;
            public set referencePixelsPerUnit(value: number);
            public get scaleFactor(): number;
            public set scaleFactor(value: number);
            public get referenceResolution(): UnityEngine.Vector2;
            public set referenceResolution(value: UnityEngine.Vector2);
            public get screenMatchMode(): UnityEngine.UI.CanvasScaler.ScreenMatchMode;
            public set screenMatchMode(value: UnityEngine.UI.CanvasScaler.ScreenMatchMode);
            public get matchWidthOrHeight(): number;
            public set matchWidthOrHeight(value: number);
            public get physicalUnit(): UnityEngine.UI.CanvasScaler.Unit;
            public set physicalUnit(value: UnityEngine.UI.CanvasScaler.Unit);
            public get fallbackScreenDPI(): number;
            public set fallbackScreenDPI(value: number);
            public get defaultSpriteDPI(): number;
            public set defaultSpriteDPI(value: number);
            public get dynamicPixelsPerUnit(): number;
            public set dynamicPixelsPerUnit(value: number);
        }
        class ContentSizeFitter extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ILayoutSelfController, UnityEngine.UI.ILayoutController
        {
            protected [__keep_incompatibility]: never;
            public get horizontalFit(): UnityEngine.UI.ContentSizeFitter.FitMode;
            public set horizontalFit(value: UnityEngine.UI.ContentSizeFitter.FitMode);
            public get verticalFit(): UnityEngine.UI.ContentSizeFitter.FitMode;
            public set verticalFit(value: UnityEngine.UI.ContentSizeFitter.FitMode);
            public SetLayoutHorizontal () : void
            public SetLayoutVertical () : void
        }
        class LayoutGroup extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController
        {
            protected [__keep_incompatibility]: never;
            public get padding(): UnityEngine.RectOffset;
            public set padding(value: UnityEngine.RectOffset);
            public get childAlignment(): UnityEngine.TextAnchor;
            public set childAlignment(value: UnityEngine.TextAnchor);
            public get minWidth(): number;
            public get preferredWidth(): number;
            public get flexibleWidth(): number;
            public get minHeight(): number;
            public get preferredHeight(): number;
            public get flexibleHeight(): number;
            public get layoutPriority(): number;
            public CalculateLayoutInputHorizontal () : void
            public CalculateLayoutInputVertical () : void
            public SetLayoutHorizontal () : void
            public SetLayoutVertical () : void
        }
        interface ILayoutGroup extends UnityEngine.UI.ILayoutController
        {
            SetLayoutHorizontal () : void
            SetLayoutVertical () : void
        }
        class GridLayoutGroup extends UnityEngine.UI.LayoutGroup implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController
        {
            protected [__keep_incompatibility]: never;
            public get startCorner(): UnityEngine.UI.GridLayoutGroup.Corner;
            public set startCorner(value: UnityEngine.UI.GridLayoutGroup.Corner);
            public get startAxis(): UnityEngine.UI.GridLayoutGroup.Axis;
            public set startAxis(value: UnityEngine.UI.GridLayoutGroup.Axis);
            public get cellSize(): UnityEngine.Vector2;
            public set cellSize(value: UnityEngine.Vector2);
            public get spacing(): UnityEngine.Vector2;
            public set spacing(value: UnityEngine.Vector2);
            public get constraint(): UnityEngine.UI.GridLayoutGroup.Constraint;
            public set constraint(value: UnityEngine.UI.GridLayoutGroup.Constraint);
            public get constraintCount(): number;
            public set constraintCount(value: number);
        }
        class HorizontalOrVerticalLayoutGroup extends UnityEngine.UI.LayoutGroup implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController
        {
            protected [__keep_incompatibility]: never;
            public get spacing(): number;
            public set spacing(value: number);
            public get childForceExpandWidth(): boolean;
            public set childForceExpandWidth(value: boolean);
            public get childForceExpandHeight(): boolean;
            public set childForceExpandHeight(value: boolean);
            public get childControlWidth(): boolean;
            public set childControlWidth(value: boolean);
            public get childControlHeight(): boolean;
            public set childControlHeight(value: boolean);
            public get childScaleWidth(): boolean;
            public set childScaleWidth(value: boolean);
            public get childScaleHeight(): boolean;
            public set childScaleHeight(value: boolean);
            public get reverseArrangement(): boolean;
            public set reverseArrangement(value: boolean);
        }
        class HorizontalLayoutGroup extends UnityEngine.UI.HorizontalOrVerticalLayoutGroup implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController
        {
            protected [__keep_incompatibility]: never;
        }
        interface ILayoutIgnorer
        {
            ignoreLayout : boolean
        }
        class LayoutElement extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ILayoutIgnorer, UnityEngine.UI.ILayoutElement
        {
            protected [__keep_incompatibility]: never;
            public get ignoreLayout(): boolean;
            public set ignoreLayout(value: boolean);
            public get minWidth(): number;
            public set minWidth(value: number);
            public get minHeight(): number;
            public set minHeight(value: number);
            public get preferredWidth(): number;
            public set preferredWidth(value: number);
            public get preferredHeight(): number;
            public set preferredHeight(value: number);
            public get flexibleWidth(): number;
            public set flexibleWidth(value: number);
            public get flexibleHeight(): number;
            public set flexibleHeight(value: number);
            public get layoutPriority(): number;
            public set layoutPriority(value: number);
            public CalculateLayoutInputHorizontal () : void
            public CalculateLayoutInputVertical () : void
        }
        class LayoutRebuilder extends System.Object implements UnityEngine.UI.ICanvasElement
        {
            protected [__keep_incompatibility]: never;
            public get transform(): UnityEngine.Transform;
            public IsDestroyed () : boolean
            public static ForceRebuildLayoutImmediate ($layoutRoot: UnityEngine.RectTransform) : void
            public Rebuild ($executing: UnityEngine.UI.CanvasUpdate) : void
            public static MarkLayoutForRebuild ($rect: UnityEngine.RectTransform) : void
            public LayoutComplete () : void
            public GraphicUpdateComplete () : void
            public constructor ()
        }
        class LayoutUtility extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetMinSize ($rect: UnityEngine.RectTransform, $axis: number) : number
            public static GetPreferredSize ($rect: UnityEngine.RectTransform, $axis: number) : number
            public static GetFlexibleSize ($rect: UnityEngine.RectTransform, $axis: number) : number
            public static GetMinWidth ($rect: UnityEngine.RectTransform) : number
            public static GetPreferredWidth ($rect: UnityEngine.RectTransform) : number
            public static GetFlexibleWidth ($rect: UnityEngine.RectTransform) : number
            public static GetMinHeight ($rect: UnityEngine.RectTransform) : number
            public static GetPreferredHeight ($rect: UnityEngine.RectTransform) : number
            public static GetFlexibleHeight ($rect: UnityEngine.RectTransform) : number
            public static GetLayoutProperty ($rect: UnityEngine.RectTransform, $property: System.Func$2<UnityEngine.UI.ILayoutElement, number>, $defaultValue: number) : number
            public static GetLayoutProperty ($rect: UnityEngine.RectTransform, $property: System.Func$2<UnityEngine.UI.ILayoutElement, number>, $defaultValue: number, $source: $Ref<UnityEngine.UI.ILayoutElement>) : number
        }
        class VerticalLayoutGroup extends UnityEngine.UI.HorizontalOrVerticalLayoutGroup implements UnityEngine.UI.ILayoutGroup, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController
        {
            protected [__keep_incompatibility]: never;
        }
        class Mask extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.IMaterialModifier, UnityEngine.ICanvasRaycastFilter
        {
            protected [__keep_incompatibility]: never;
            public get rectTransform(): UnityEngine.RectTransform;
            public get showMaskGraphic(): boolean;
            public set showMaskGraphic(value: boolean);
            public get graphic(): UnityEngine.UI.Graphic;
            public MaskEnabled () : boolean
            public IsRaycastLocationValid ($sp: UnityEngine.Vector2, $eventCamera: UnityEngine.Camera) : boolean
            public GetModifiedMaterial ($baseMaterial: UnityEngine.Material) : UnityEngine.Material
        }
        class MaskUtilities extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Notify2DMaskStateChanged ($mask: UnityEngine.Component) : void
            public static NotifyStencilStateChanged ($mask: UnityEngine.Component) : void
            public static FindRootSortOverrideCanvas ($start: UnityEngine.Transform) : UnityEngine.Transform
            public static GetStencilDepth ($transform: UnityEngine.Transform, $stopAfter: UnityEngine.Transform) : number
            public static IsDescendantOrSelf ($father: UnityEngine.Transform, $child: UnityEngine.Transform) : boolean
            public static GetRectMaskForClippable ($clippable: UnityEngine.UI.IClippable) : UnityEngine.UI.RectMask2D
            public static GetRectMasksForClip ($clipper: UnityEngine.UI.RectMask2D, $masks: System.Collections.Generic.List$1<UnityEngine.UI.RectMask2D>) : void
            public constructor ()
        }
        class RawImage extends UnityEngine.UI.MaskableGraphic implements UnityEngine.UI.IMaterialModifier, UnityEngine.UI.IMaskable, UnityEngine.UI.ICanvasElement, UnityEngine.UI.IClippable
        {
            protected [__keep_incompatibility]: never;
            public get mainTexture(): UnityEngine.Texture;
            public get texture(): UnityEngine.Texture;
            public set texture(value: UnityEngine.Texture);
            public get uvRect(): UnityEngine.Rect;
            public set uvRect(value: UnityEngine.Rect);
        }
        class Scrollbar extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IInitializePotentialDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler
        {
            protected [__keep_incompatibility]: never;
            public get handleRect(): UnityEngine.RectTransform;
            public set handleRect(value: UnityEngine.RectTransform);
            public get direction(): UnityEngine.UI.Scrollbar.Direction;
            public set direction(value: UnityEngine.UI.Scrollbar.Direction);
            public get value(): number;
            public set value(value: number);
            public get size(): number;
            public set size(value: number);
            public get numberOfSteps(): number;
            public set numberOfSteps(value: number);
            public get onValueChanged(): UnityEngine.UI.Scrollbar.ScrollEvent;
            public set onValueChanged(value: UnityEngine.UI.Scrollbar.ScrollEvent);
            public SetValueWithoutNotify ($input: number) : void
            public Rebuild ($executing: UnityEngine.UI.CanvasUpdate) : void
            public LayoutComplete () : void
            public GraphicUpdateComplete () : void
            public OnBeginDrag ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnDrag ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnInitializePotentialDrag ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public SetDirection ($direction: UnityEngine.UI.Scrollbar.Direction, $includeRectLayouts: boolean) : void
        }
        class ScrollRect extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.ILayoutGroup, UnityEngine.EventSystems.IBeginDragHandler, UnityEngine.EventSystems.IInitializePotentialDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.EventSystems.IEndDragHandler, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IScrollHandler, UnityEngine.UI.ILayoutElement, UnityEngine.UI.ILayoutController
        {
            protected [__keep_incompatibility]: never;
            public get content(): UnityEngine.RectTransform;
            public set content(value: UnityEngine.RectTransform);
            public get horizontal(): boolean;
            public set horizontal(value: boolean);
            public get vertical(): boolean;
            public set vertical(value: boolean);
            public get movementType(): UnityEngine.UI.ScrollRect.MovementType;
            public set movementType(value: UnityEngine.UI.ScrollRect.MovementType);
            public get elasticity(): number;
            public set elasticity(value: number);
            public get inertia(): boolean;
            public set inertia(value: boolean);
            public get decelerationRate(): number;
            public set decelerationRate(value: number);
            public get scrollSensitivity(): number;
            public set scrollSensitivity(value: number);
            public get viewport(): UnityEngine.RectTransform;
            public set viewport(value: UnityEngine.RectTransform);
            public get horizontalScrollbar(): UnityEngine.UI.Scrollbar;
            public set horizontalScrollbar(value: UnityEngine.UI.Scrollbar);
            public get verticalScrollbar(): UnityEngine.UI.Scrollbar;
            public set verticalScrollbar(value: UnityEngine.UI.Scrollbar);
            public get horizontalScrollbarVisibility(): UnityEngine.UI.ScrollRect.ScrollbarVisibility;
            public set horizontalScrollbarVisibility(value: UnityEngine.UI.ScrollRect.ScrollbarVisibility);
            public get verticalScrollbarVisibility(): UnityEngine.UI.ScrollRect.ScrollbarVisibility;
            public set verticalScrollbarVisibility(value: UnityEngine.UI.ScrollRect.ScrollbarVisibility);
            public get horizontalScrollbarSpacing(): number;
            public set horizontalScrollbarSpacing(value: number);
            public get verticalScrollbarSpacing(): number;
            public set verticalScrollbarSpacing(value: number);
            public get onValueChanged(): UnityEngine.UI.ScrollRect.ScrollRectEvent;
            public set onValueChanged(value: UnityEngine.UI.ScrollRect.ScrollRectEvent);
            public get velocity(): UnityEngine.Vector2;
            public set velocity(value: UnityEngine.Vector2);
            public get normalizedPosition(): UnityEngine.Vector2;
            public set normalizedPosition(value: UnityEngine.Vector2);
            public get horizontalNormalizedPosition(): number;
            public set horizontalNormalizedPosition(value: number);
            public get verticalNormalizedPosition(): number;
            public set verticalNormalizedPosition(value: number);
            public get minWidth(): number;
            public get preferredWidth(): number;
            public get flexibleWidth(): number;
            public get minHeight(): number;
            public get preferredHeight(): number;
            public get flexibleHeight(): number;
            public get layoutPriority(): number;
            public Rebuild ($executing: UnityEngine.UI.CanvasUpdate) : void
            public LayoutComplete () : void
            public GraphicUpdateComplete () : void
            public StopMovement () : void
            public OnScroll ($data: UnityEngine.EventSystems.PointerEventData) : void
            public OnInitializePotentialDrag ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnBeginDrag ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnEndDrag ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnDrag ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public CalculateLayoutInputHorizontal () : void
            public CalculateLayoutInputVertical () : void
            public SetLayoutHorizontal () : void
            public SetLayoutVertical () : void
        }
        class Slider extends UnityEngine.UI.Selectable implements UnityEngine.EventSystems.IInitializePotentialDragHandler, UnityEngine.EventSystems.IDragHandler, UnityEngine.UI.ICanvasElement, UnityEngine.EventSystems.IEventSystemHandler, UnityEngine.EventSystems.IPointerEnterHandler, UnityEngine.EventSystems.ISelectHandler, UnityEngine.EventSystems.IPointerExitHandler, UnityEngine.EventSystems.IDeselectHandler, UnityEngine.EventSystems.IPointerDownHandler, UnityEngine.EventSystems.IPointerUpHandler, UnityEngine.EventSystems.IMoveHandler
        {
            protected [__keep_incompatibility]: never;
            public get fillRect(): UnityEngine.RectTransform;
            public set fillRect(value: UnityEngine.RectTransform);
            public get handleRect(): UnityEngine.RectTransform;
            public set handleRect(value: UnityEngine.RectTransform);
            public get direction(): UnityEngine.UI.Slider.Direction;
            public set direction(value: UnityEngine.UI.Slider.Direction);
            public get minValue(): number;
            public set minValue(value: number);
            public get maxValue(): number;
            public set maxValue(value: number);
            public get wholeNumbers(): boolean;
            public set wholeNumbers(value: boolean);
            public get value(): number;
            public set value(value: number);
            public get normalizedValue(): number;
            public set normalizedValue(value: number);
            public get onValueChanged(): UnityEngine.UI.Slider.SliderEvent;
            public set onValueChanged(value: UnityEngine.UI.Slider.SliderEvent);
            public SetValueWithoutNotify ($input: number) : void
            public Rebuild ($executing: UnityEngine.UI.CanvasUpdate) : void
            public LayoutComplete () : void
            public GraphicUpdateComplete () : void
            public OnDrag ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public OnInitializePotentialDrag ($eventData: UnityEngine.EventSystems.PointerEventData) : void
            public SetDirection ($direction: UnityEngine.UI.Slider.Direction, $includeRectLayouts: boolean) : void
        }
        class StencilMaterial extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Add ($baseMat: UnityEngine.Material, $stencilID: number, $operation: UnityEngine.Rendering.StencilOp, $compareFunction: UnityEngine.Rendering.CompareFunction, $colorWriteMask: UnityEngine.Rendering.ColorWriteMask) : UnityEngine.Material
            public static Add ($baseMat: UnityEngine.Material, $stencilID: number, $operation: UnityEngine.Rendering.StencilOp, $compareFunction: UnityEngine.Rendering.CompareFunction, $colorWriteMask: UnityEngine.Rendering.ColorWriteMask, $readMask: number, $writeMask: number) : UnityEngine.Material
            public static Remove ($customMat: UnityEngine.Material) : void
            public static ClearAll () : void
        }
        class VertexHelper extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get currentVertCount(): number;
            public get currentIndexCount(): number;
            public Dispose () : void
            public Clear () : void
            public PopulateUIVertex ($vertex: $Ref<UnityEngine.UIVertex>, $i: number) : void
            public SetUIVertex ($vertex: UnityEngine.UIVertex, $i: number) : void
            public FillMesh ($mesh: UnityEngine.Mesh) : void
            public AddVert ($position: UnityEngine.Vector3, $color: UnityEngine.Color32, $uv0: UnityEngine.Vector4, $uv1: UnityEngine.Vector4, $uv2: UnityEngine.Vector4, $uv3: UnityEngine.Vector4, $normal: UnityEngine.Vector3, $tangent: UnityEngine.Vector4) : void
            public AddVert ($position: UnityEngine.Vector3, $color: UnityEngine.Color32, $uv0: UnityEngine.Vector4, $uv1: UnityEngine.Vector4, $normal: UnityEngine.Vector3, $tangent: UnityEngine.Vector4) : void
            public AddVert ($position: UnityEngine.Vector3, $color: UnityEngine.Color32, $uv0: UnityEngine.Vector4) : void
            public AddVert ($v: UnityEngine.UIVertex) : void
            public AddTriangle ($idx0: number, $idx1: number, $idx2: number) : void
            public AddUIVertexQuad ($verts: System.Array$1<UnityEngine.UIVertex>) : void
            public AddUIVertexStream ($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>, $indices: System.Collections.Generic.List$1<number>) : void
            public AddUIVertexTriangleStream ($verts: System.Collections.Generic.List$1<UnityEngine.UIVertex>) : void
            public GetUIVertexStream ($stream: System.Collections.Generic.List$1<UnityEngine.UIVertex>) : void
            public constructor ()
            public constructor ($m: UnityEngine.Mesh)
        }
        class BaseMeshEffect extends UnityEngine.EventSystems.UIBehaviour implements UnityEngine.UI.IMeshModifier
        {
            protected [__keep_incompatibility]: never;
            public ModifyMesh ($mesh: UnityEngine.Mesh) : void
            public ModifyMesh ($vh: UnityEngine.UI.VertexHelper) : void
            public ModifyMesh ($verts: UnityEngine.UI.VertexHelper) : void
        }
        interface IMeshModifier
        {
            ModifyMesh ($verts: UnityEngine.UI.VertexHelper) : void
        }
        class Shadow extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier
        {
            protected [__keep_incompatibility]: never;
            public get effectColor(): UnityEngine.Color;
            public set effectColor(value: UnityEngine.Color);
            public get effectDistance(): UnityEngine.Vector2;
            public set effectDistance(value: UnityEngine.Vector2);
            public get useGraphicAlpha(): boolean;
            public set useGraphicAlpha(value: boolean);
        }
        class Outline extends UnityEngine.UI.Shadow implements UnityEngine.UI.IMeshModifier
        {
            protected [__keep_incompatibility]: never;
        }
        class PositionAsUV1 extends UnityEngine.UI.BaseMeshEffect implements UnityEngine.UI.IMeshModifier
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.UI.Selectable {
        enum Transition
        { None = 0, ColorTint = 1, SpriteSwap = 2, Animation = 3 }
    }
    namespace UnityEngine.UI.Button {
        class ButtonClickedEvent extends UnityEngine.Events.UnityEvent implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
    }
    namespace UnityEngine.UI.InputField {
        class EndEditEvent extends UnityEngine.Events.UnityEvent$1<string> implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
        class SubmitEvent extends UnityEngine.Events.UnityEvent$1<string> implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
        class OnChangeEvent extends UnityEngine.Events.UnityEvent$1<string> implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
        interface OnValidateInput
        { 
        (text: string, charIndex: number, addedChar: number) : number; 
        Invoke?: (text: string, charIndex: number, addedChar: number) => number;
        }
        var OnValidateInput: { new (func: (text: string, charIndex: number, addedChar: number) => number): OnValidateInput; }
        enum ContentType
        { Standard = 0, Autocorrected = 1, IntegerNumber = 2, DecimalNumber = 3, Alphanumeric = 4, Name = 5, EmailAddress = 6, Password = 7, Pin = 8, Custom = 9 }
        enum LineType
        { SingleLine = 0, MultiLineSubmit = 1, MultiLineNewline = 2 }
        enum InputType
        { Standard = 0, AutoCorrect = 1, Password = 2 }
        enum CharacterValidation
        { None = 0, Integer = 1, Decimal = 2, Alphanumeric = 3, Name = 4, EmailAddress = 5 }
    }
    namespace UnityEngine.UI.Toggle {
        enum ToggleTransition
        { None = 0, Fade = 1 }
        class ToggleEvent extends UnityEngine.Events.UnityEvent$1<boolean> implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
    }
    namespace ET {
        class Object extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class DisposeObject extends ET.Object implements System.ComponentModel.ISupportInitialize, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Dispose () : void
            public BeginInit () : void
            public EndInit () : void
        }
        class Entity extends ET.DisposeObject implements System.ComponentModel.ISupportInitialize, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get InstanceId(): bigint;
            public get IsDisposed(): boolean;
            public get Parent(): ET.Entity;
            public get Id(): bigint;
            public set Id(value: bigint);
            public get Domain(): ET.Entity;
            public get Children(): System.Collections.Generic.Dictionary$2<bigint, ET.Entity>;
            public get Components(): System.Collections.Generic.Dictionary$2<System.Type, ET.Entity>;
            public RemoveChild ($id: bigint) : void
            public RemoveComponent ($component: ET.Entity) : void
            public RemoveComponent ($type: System.Type) : void
            public GetComponent ($type: System.Type) : ET.Entity
            public AddComponent ($component: ET.Entity) : ET.Entity
            public AddComponent ($type: System.Type, $isFromPool?: boolean) : ET.Entity
            public AddChild ($entity: ET.Entity) : ET.Entity
            public AddChildWithId ($type: System.Type, $id: bigint, $instanceId: bigint, $isFromPool?: boolean) : ET.Entity
        }
        interface Entity {
            AddDisposeAction ($action: ET.DisposeActionComponent.DisposeCallback) : void;
            MapUnit () : AO.IMapUnit;
            GetOrAdd ($type: System.Type) : ET.Entity;
            GetNotifyComponents () : System.Array$1<ET.Entity>;
            GetNotifySelfComponents () : System.Array$1<ET.Entity>;
            GetNotifyAOIComponents () : System.Array$1<ET.Entity>;
            DomainZone () : number;
            CheckIsCombatUnit () : boolean;
            IsPlayerActor () : boolean;
        }
        class TimerCallback extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Args : any
        }
        class AInvokeHandler$1<A> extends System.Object implements ET.IInvoke
        {
            protected [__keep_incompatibility]: never;
            public get Type(): System.Type;
        }
        interface IInvoke
        {
            Type : System.Type
        }
        interface IAwake
        {
        }
        class ATimer$1<T> extends ET.AInvokeHandler$1<ET.TimerCallback> implements ET.IInvoke
        {
            protected [__keep_incompatibility]: never;
            public get Type(): System.Type;
        }
        class ETTask$1<T> extends System.Object implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion
        {
            protected [__keep_incompatibility]: never;
        }
        class AssemblyReference extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Run () : void
        }
        class Singleton$1<T> extends System.Object implements ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        interface ISingleton extends System.IDisposable
        {
            Register () : void
            Destroy () : void
            IsDisposed () : boolean
        }
        class CodeLoader extends ET.Singleton$1<ET.CodeLoader> implements ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public types : System.Collections.Generic.Dictionary$2<string, System.Type>
            public model : System.Reflection.Assembly
            public hotfix : System.Reflection.Assembly
            public Start () : void
            public LoadHotfix () : void
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        class Define extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static BuildOutputDir : string
            public static IsAsync : boolean
            public static IsEditor : boolean
            public static EnableDllLoad : boolean
            public static EnableView : boolean
            public static EnableIL2CPP : boolean
            public static LoadAssetAtPath ($s: string) : UnityEngine.Object
            public static GetAssetPathsFromAssetBundle ($assetBundleName: string) : System.Array$1<string>
            public static GetAssetBundleDependencies ($assetBundleName: string, $v: boolean) : System.Array$1<string>
        }
        class AcceptAllCertificate extends UnityEngine.Networking.CertificateHandler implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class AssetsBundleHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static LoadBundle ($assetBundleName: string) : System.Collections.Generic.Dictionary$2<string, UnityEngine.Object>
        }
        class CoroutineHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetAwaiter ($asyncOperation: UnityEngine.AsyncOperation) : ET.ETTask
            public static HttpGet ($link: string) : ET.ETTask$1<string>
        }
        class ETTask extends System.Object implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion
        {
            protected [__keep_incompatibility]: never;
            public static ExceptionHandler : System.Action$1<System.Exception>
            public static get CompletedTask(): ET.ETTaskCompleted;
            public get IsCompleted(): boolean;
            public static Create ($fromPool?: boolean) : ET.ETTask
            public Coroutine () : void
            public GetAwaiter () : ET.ETTask
            public UnsafeOnCompleted ($action: System.Action) : void
            public OnCompleted ($action: System.Action) : void
            public GetResult () : void
            public SetResult () : void
            public SetException ($e: System.Exception) : void
        }
        class PathHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get AppHotfixResPath(): string;
            public static get AppResPath(): string;
            public static get AppResPath4Web(): string;
        }
        class JsModuleFileLoader extends System.Object implements Puerts.ILoader, Puerts.IModuleChecker
        {
            protected [__keep_incompatibility]: never;
            public bootstrapScript : string
            public FileExists ($filepath: string) : boolean
            public ReadFile ($filepath: string, $debugpath: $Ref<string>) : string
            public IsESM ($filepath: string) : boolean
            public constructor ()
            public constructor ($root: string)
        }
        class CanvasConfig extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public CanvasName : string
            public constructor ()
        }
        class GizmosDebug extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public Path : System.Collections.Generic.List$1<UnityEngine.Vector3>
            public static get Instance(): ET.GizmosDebug;
            public constructor ()
        }
        enum CodeMode
        { Client = 1, Server = 2, ClientServer = 3 }
        class GlobalConfig extends UnityEngine.ScriptableObject
        {
            protected [__keep_incompatibility]: never;
            public CodeMode : ET.CodeMode
            public AssemblyDefinitions : System.Array$1<UnityEditorInternal.AssemblyDefinitionAsset>
            public constructor ()
        }
        class Init extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum UILayer
        { Hidden = 0, Low = 10, Mid = 20, High = 30 }
        class UILayerScript extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public UILayer : ET.UILayer
            public constructor ()
        }
        class UnityLogger extends System.Object implements ET.ILog
        {
            protected [__keep_incompatibility]: never;
            public Trace ($msg: string) : void
            public Debug ($msg: string) : void
            public Info ($msg: string) : void
            public Warning ($msg: string) : void
            public Error ($msg: string) : void
            public Error ($e: System.Exception) : void
            public Trace ($message: string, ...args: any[]) : void
            public Warning ($message: string, ...args: any[]) : void
            public Info ($message: string, ...args: any[]) : void
            public Debug ($message: string, ...args: any[]) : void
            public Error ($message: string, ...args: any[]) : void
            public constructor ()
            public Trace ($message: string) : void
            public Warning ($message: string) : void
            public Info ($message: string) : void
            public Debug ($message: string) : void
            public Error ($message: string) : void
        }
        interface ILog
        {
            Trace ($message: string) : void
            Warning ($message: string) : void
            Info ($message: string) : void
            Debug ($message: string) : void
            Error ($message: string) : void
            Trace ($message: string, ...args: any[]) : void
            Warning ($message: string, ...args: any[]) : void
            Info ($message: string, ...args: any[]) : void
            Debug ($message: string, ...args: any[]) : void
            Error ($message: string, ...args: any[]) : void
        }
        class Scene extends ET.Entity implements ET.IAwake$1<string>, AO.IMapUnit, System.ComponentModel.ISupportInitialize, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Type(): string;
            public set Type(value: string);
            public get Name(): string;
            public set Name(value: string);
            public get ConfigId(): number;
            public set ConfigId(value: number);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get Forward(): Unity.Mathematics.float3;
            public set Forward(value: Unity.Mathematics.float3);
            public get Rotation(): Unity.Mathematics.quaternion;
            public set Rotation(value: Unity.Mathematics.quaternion);
            public static get CurrentScene(): ET.Scene;
            public static set CurrentScene(value: ET.Scene);
            public constructor ()
            public Entity () : ET.Entity
            public SetMapUnitComponents () : void
            public AddAOI () : void
            public CreateUnitInfo () : ET.UnitInfo
            public MoveToAsync ($pathPoint: Unity.Mathematics.float3) : ET.ETTask
            public MovePathAsync ($pathPoints: System.Array$1<Unity.Mathematics.float3>) : ET.ETTask
            public Translate ($point: Unity.Mathematics.float3) : void
            public TranslateAsync ($point: Unity.Mathematics.float3) : ET.ETTask
        }
        interface IAwake$1<A>
        {
        }
        class AEvent$1<A> extends System.Object implements ET.IEvent
        {
            protected [__keep_incompatibility]: never;
            public get Type(): System.Type;
        }
        interface IEvent
        {
            Type : System.Type
        }
        interface IUpdate
        {
        }
        interface IDestroy
        {
        }
        class AwakeSystem$1<T> extends System.Object implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        interface ISystemType
        {
            Type () : System.Type
            SystemType () : System.Type
            GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
        interface IAwakeSystem extends ET.ISystemType
        {
            Run ($o: ET.Entity) : void
            Type () : System.Type
            SystemType () : System.Type
            GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
        class UpdateSystem$1<T> extends System.Object implements ET.ISystemType, ET.IUpdateSystem
        {
            protected [__keep_incompatibility]: never;
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        interface IUpdateSystem extends ET.ISystemType
        {
            Run ($o: ET.Entity) : void
            Type () : System.Type
            SystemType () : System.Type
            GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
        class DestroySystem$1<T> extends System.Object implements ET.ISystemType, ET.IDestroySystem
        {
            protected [__keep_incompatibility]: never;
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        interface IDestroySystem extends ET.ISystemType
        {
            Run ($o: ET.Entity) : void
            Type () : System.Type
            SystemType () : System.Type
            GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
        class Entry extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Init () : void
            public static Start () : void
        }
        interface IActorMessage extends ET.IMessage
        {
        }
        interface IMessage
        {
        }
        interface IActorRequest extends ET.IMessage, ET.IRequest
        {
            RpcId : number
        }
        interface IRequest extends ET.IMessage
        {
            RpcId : number
        }
        interface IActorResponse extends ET.IMessage, ET.IResponse
        {
            Error : number
            Message : string
            RpcId : number
        }
        interface IResponse extends ET.IMessage
        {
            Error : number
            Message : string
            RpcId : number
        }
        class ProtoObject extends ET.Object implements System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public Clone () : any
            public BeginInit () : void
            public EndInit () : void
            public AfterEndInit () : void
        }
        class ActorResponse extends ET.ProtoObject implements ET.IMessage, ET.IResponse, ET.IActorResponse, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Error(): number;
            public set Error(value: number);
            public get Message(): string;
            public set Message(value: string);
            public constructor ()
        }
        interface IActorLocationMessage extends ET.IMessage, ET.IRequest, ET.IActorRequest
        {
            RpcId : number
        }
        interface IActorLocationRequest extends ET.IMessage, ET.IRequest, ET.IActorRequest
        {
            RpcId : number
        }
        interface IActorLocationResponse extends ET.IMessage, ET.IResponse, ET.IActorResponse
        {
            Error : number
            Message : string
            RpcId : number
        }
        class BaseAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ResponseTypeAttribute extends ET.BaseAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Type(): string;
            public constructor ($type: string)
            public constructor ()
        }
        class ErrorCode extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ERR_Success : number
        }
        interface IMHandler
        {
            Handle ($message: any) : void
            GetMessageType () : System.Type
            GetResponseType () : System.Type
        }
        class MessageHandlerAttribute extends ET.BaseAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get SceneType(): ET.SceneType;
            public constructor ($sceneType: ET.SceneType)
            public constructor ()
        }
        enum SceneType
        { None = -1, Process = 0, Manager = 1, Realm = 2, Gate = 3, Http = 4, Location = 5, Map = 6, Router = 7, RouterManager = 8, Robot = 9, BenchmarkClient = 10, BenchmarkServer = 11, Benchmark = 12, Client = 31, Current = 34 }
        class NotifySelfAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class NotifyAOIAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ClientApp extends ET.Entity implements AO.IApp, ET.IAwake, ET.IDomain, System.ComponentModel.ISupportInitialize, ET.IDestroy, ET.IUpdate, System.IDisposable, ET.IAddComponent
        {
            protected [__keep_incompatibility]: never;
            public jsEnv : Puerts.JsEnv
            public JsCallback : ET.ClientApp.ModuleCallback
            public get DomainIndex(): number;
            public get Zone(): number;
            public set Zone(value: number);
            public constructor ()
        }
        interface IDomain
        {
            DomainIndex : number
        }
        interface IAddComponent
        {
        }
        interface IGateMessage
        {
        }
        interface IMapMessage
        {
        }
        class DisposeActionComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, ET.IDestroy, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public DisposeAction : ET.DisposeActionComponent.DisposeCallback
            public constructor ()
        }
        class DisposeActionComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static AddDisposeAction ($self: ET.Entity, $action: ET.DisposeActionComponent.DisposeCallback) : void
        }
        class EntitySystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Entity ($entity: AO.IMapUnit) : ET.Entity
            public static MapUnit ($entity: ET.Entity) : AO.IMapUnit
            public static GetOrAdd ($entity: ET.Entity, $type: System.Type) : ET.Entity
            public static GetNotifyComponents ($entity: ET.Entity) : System.Array$1<ET.Entity>
            public static GetNotifySelfComponents ($entity: ET.Entity) : System.Array$1<ET.Entity>
            public static GetNotifyAOIComponents ($entity: ET.Entity) : System.Array$1<ET.Entity>
            public static DeserializeComponents ($unitInfo: ET.UnitInfo) : System.Array$1<ET.Entity>
        }
        class UnitInfo extends ET.ProtoObject implements System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get UnitId(): bigint;
            public set UnitId(value: bigint);
            public get ConfigId(): number;
            public set ConfigId(value: number);
            public get Name(): string;
            public set Name(value: string);
            public get UnitType(): number;
            public set UnitType(value: number);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get Forward(): Unity.Mathematics.float3;
            public set Forward(value: Unity.Mathematics.float3);
            public get KV(): System.Collections.Generic.Dictionary$2<number, bigint>;
            public set KV(value: System.Collections.Generic.Dictionary$2<number, bigint>);
            public get MoveInfo(): ET.MoveInfo;
            public set MoveInfo(value: ET.MoveInfo);
            public get ComponentInfos(): System.Collections.Generic.List$1<ET.ComponentInfo>;
            public set ComponentInfos(value: System.Collections.Generic.List$1<ET.ComponentInfo>);
            public get ActorType(): number;
            public set ActorType(value: number);
            public get ItemType(): number;
            public set ItemType(value: number);
            public constructor ()
        }
        class TimeUtils extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static WaitAsync ($time: bigint) : ET.ETTask
        }
        class HttpGetRouterResponse extends ET.ProtoObject implements System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get Realms(): System.Collections.Generic.List$1<string>;
            public set Realms(value: System.Collections.Generic.List$1<string>);
            public get Routers(): System.Collections.Generic.List$1<string>;
            public set Routers(value: System.Collections.Generic.List$1<string>);
            public constructor ()
        }
        class RouterSync extends ET.ProtoObject implements System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get ConnectId(): number;
            public set ConnectId(value: number);
            public get Address(): string;
            public set Address(value: string);
            public constructor ()
        }
        class MoveInfo extends ET.ProtoObject implements System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get Points(): System.Collections.Generic.List$1<Unity.Mathematics.float3>;
            public set Points(value: System.Collections.Generic.List$1<Unity.Mathematics.float3>);
            public get Rotation(): Unity.Mathematics.quaternion;
            public set Rotation(value: Unity.Mathematics.quaternion);
            public get TurnSpeed(): number;
            public set TurnSpeed(value: number);
            public get MoveSpeed(): number;
            public set MoveSpeed(value: number);
            public constructor ()
        }
        class ComponentInfo extends ET.ProtoObject implements System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get ComponentName(): string;
            public set ComponentName(value: string);
            public get ComponentBytes(): System.Array$1<number>;
            public set ComponentBytes(value: System.Array$1<number>);
            public constructor ()
        }
        class C2G_Ping extends ET.ProtoObject implements ET.IMessage, ET.IRequest, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public constructor ()
        }
        class G2C_Ping extends ET.ProtoObject implements ET.IMessage, ET.IResponse, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Error(): number;
            public set Error(value: number);
            public get Message(): string;
            public set Message(value: string);
            public get Time(): bigint;
            public set Time(value: bigint);
            public constructor ()
        }
        class G2C_Test extends ET.ProtoObject implements ET.IMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class C2M_Reload extends ET.ProtoObject implements ET.IMessage, ET.IRequest, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Account(): string;
            public set Account(value: string);
            public get Password(): string;
            public set Password(value: string);
            public constructor ()
        }
        class M2C_Reload extends ET.ProtoObject implements ET.IMessage, ET.IResponse, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Error(): number;
            public set Error(value: number);
            public get Message(): string;
            public set Message(value: string);
            public constructor ()
        }
        class C2R_Login extends ET.ProtoObject implements ET.IMessage, ET.IRequest, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Account(): string;
            public set Account(value: string);
            public get Password(): string;
            public set Password(value: string);
            public constructor ()
        }
        class R2C_Login extends ET.ProtoObject implements ET.IMessage, ET.IResponse, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Error(): number;
            public set Error(value: number);
            public get Message(): string;
            public set Message(value: string);
            public get Address(): string;
            public set Address(value: string);
            public get Key(): bigint;
            public set Key(value: bigint);
            public get GateId(): bigint;
            public set GateId(value: bigint);
            public constructor ()
        }
        class C2G_LoginGate extends ET.ProtoObject implements ET.IMessage, ET.IRequest, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Key(): bigint;
            public set Key(value: bigint);
            public get GateId(): bigint;
            public set GateId(value: bigint);
            public get Account(): string;
            public set Account(value: string);
            public get Password(): string;
            public set Password(value: string);
            public constructor ()
        }
        class G2C_LoginGate extends ET.ProtoObject implements ET.IMessage, ET.IResponse, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Error(): number;
            public set Error(value: number);
            public get Message(): string;
            public set Message(value: string);
            public get PlayerId(): bigint;
            public set PlayerId(value: bigint);
            public constructor ()
        }
        class G2C_TestHotfixMessage extends ET.ProtoObject implements ET.IMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get Info(): string;
            public set Info(value: string);
            public constructor ()
        }
        class C2G_Benchmark extends ET.ProtoObject implements ET.IMessage, ET.IRequest, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public constructor ()
        }
        class G2C_Benchmark extends ET.ProtoObject implements ET.IMessage, ET.IResponse, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Error(): number;
            public set Error(value: number);
            public get Message(): string;
            public set Message(value: string);
            public constructor ()
        }
        class M2C_OnEnterMap extends ET.ProtoObject implements ET.IMessage, ET.IActorMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get MapName(): string;
            public set MapName(value: string);
            public get Scene(): ET.UnitInfo;
            public set Scene(value: ET.UnitInfo);
            public constructor ()
        }
        class M2C_OnLeaveMap extends ET.ProtoObject implements ET.IMessage, ET.IActorMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get MapName(): string;
            public set MapName(value: string);
            public constructor ()
        }
        class M2C_CreateUnits extends ET.ProtoObject implements ET.IMessage, ET.IActorMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get Units(): System.Collections.Generic.List$1<ET.UnitInfo>;
            public set Units(value: System.Collections.Generic.List$1<ET.UnitInfo>);
            public constructor ()
        }
        class M2C_CreateMyUnit extends ET.ProtoObject implements ET.IMessage, ET.IActorMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get Unit(): ET.UnitInfo;
            public set Unit(value: ET.UnitInfo);
            public constructor ()
        }
        class M2C_RemoveUnits extends ET.ProtoObject implements ET.IMessage, ET.IActorMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get Units(): System.Collections.Generic.List$1<bigint>;
            public set Units(value: System.Collections.Generic.List$1<bigint>);
            public constructor ()
        }
        class M2C_ComponentPropertyNotify extends ET.ProtoObject implements ET.IMessage, ET.IActorMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get UnitId(): bigint;
            public set UnitId(value: bigint);
            public get ComponentName(): string;
            public set ComponentName(value: string);
            public get PropertyName(): string;
            public set PropertyName(value: string);
            public get PropertyBytes(): System.Array$1<number>;
            public set PropertyBytes(value: System.Array$1<number>);
            public constructor ()
        }
        class M2C_StartSceneChange extends ET.ProtoObject implements ET.IMessage, ET.IActorMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get SceneInstanceId(): bigint;
            public set SceneInstanceId(value: bigint);
            public get SceneName(): string;
            public set SceneName(value: string);
            public constructor ()
        }
        class C2M_PathfindingResult extends ET.ProtoObject implements ET.IMessage, ET.IRequest, ET.IMapMessage, ET.IActorRequest, System.ComponentModel.ISupportInitialize, ET.IActorLocationMessage
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public constructor ()
        }
        class M2C_PathfindingResult extends ET.ProtoObject implements ET.IMessage, ET.IActorMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get Id(): bigint;
            public set Id(value: bigint);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get Points(): System.Collections.Generic.List$1<Unity.Mathematics.float3>;
            public set Points(value: System.Collections.Generic.List$1<Unity.Mathematics.float3>);
            public get ArriveTime(): bigint;
            public set ArriveTime(value: bigint);
            public constructor ()
        }
        class C2M_Stop extends ET.ProtoObject implements ET.IMessage, ET.IRequest, ET.IActorRequest, System.ComponentModel.ISupportInitialize, ET.IActorLocationMessage
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public constructor ()
        }
        class M2C_Stop extends ET.ProtoObject implements ET.IMessage, ET.IActorMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get Error(): number;
            public set Error(value: number);
            public get Id(): bigint;
            public set Id(value: bigint);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get Rotation(): Unity.Mathematics.quaternion;
            public set Rotation(value: Unity.Mathematics.quaternion);
            public constructor ()
        }
        class C2M_TestRobotCase extends ET.ProtoObject implements ET.IMessage, ET.IRequest, ET.IActorRequest, System.ComponentModel.ISupportInitialize, ET.IActorLocationRequest
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get N(): number;
            public set N(value: number);
            public constructor ()
        }
        class M2C_TestRobotCase extends ET.ProtoObject implements ET.IMessage, ET.IResponse, ET.IActorResponse, System.ComponentModel.ISupportInitialize, ET.IActorLocationResponse
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Error(): number;
            public set Error(value: number);
            public get Message(): string;
            public set Message(value: string);
            public get N(): number;
            public set N(value: number);
            public constructor ()
        }
        class C2M_TestRequest extends ET.ProtoObject implements ET.IMessage, ET.IRequest, ET.IActorRequest, System.ComponentModel.ISupportInitialize, ET.IActorLocationRequest
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get request(): string;
            public set request(value: string);
            public constructor ()
        }
        class M2C_TestResponse extends ET.ProtoObject implements ET.IMessage, ET.IResponse, ET.IActorResponse, System.ComponentModel.ISupportInitialize, ET.IActorLocationResponse
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Error(): number;
            public set Error(value: number);
            public get Message(): string;
            public set Message(value: string);
            public get response(): string;
            public set response(value: string);
            public constructor ()
        }
        class Actor_TransferRequest extends ET.ProtoObject implements ET.IMessage, ET.IRequest, ET.IActorRequest, System.ComponentModel.ISupportInitialize, ET.IActorLocationRequest
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get MapIndex(): number;
            public set MapIndex(value: number);
            public constructor ()
        }
        class Actor_TransferResponse extends ET.ProtoObject implements ET.IMessage, ET.IResponse, ET.IActorResponse, System.ComponentModel.ISupportInitialize, ET.IActorLocationResponse
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Error(): number;
            public set Error(value: number);
            public get Message(): string;
            public set Message(value: string);
            public constructor ()
        }
        class C2M_TransferMap extends ET.ProtoObject implements ET.IMessage, ET.IRequest, ET.IActorRequest, System.ComponentModel.ISupportInitialize, ET.IActorLocationRequest
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public constructor ()
        }
        class M2C_TransferMap extends ET.ProtoObject implements ET.IMessage, ET.IResponse, ET.IActorResponse, System.ComponentModel.ISupportInitialize, ET.IActorLocationResponse
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Error(): number;
            public set Error(value: number);
            public get Message(): string;
            public set Message(value: string);
            public constructor ()
        }
        class C2M_SpellRequest extends ET.ProtoObject implements ET.IMessage, ET.IRequest, ET.IMapMessage, ET.IActorRequest, System.ComponentModel.ISupportInitialize, ET.IActorLocationRequest
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get SkillId(): number;
            public set SkillId(value: number);
            public get CastPoint(): Unity.Mathematics.float3;
            public set CastPoint(value: Unity.Mathematics.float3);
            public get CastTargetId(): bigint;
            public set CastTargetId(value: bigint);
            public constructor ()
        }
        class M2C_SpellResponse extends ET.ProtoObject implements ET.IMessage, ET.IResponse, ET.IActorResponse, System.ComponentModel.ISupportInitialize, ET.IActorLocationResponse
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Error(): number;
            public set Error(value: number);
            public get Message(): string;
            public set Message(value: string);
            public constructor ()
        }
        class M2C_SpellStart extends ET.ProtoObject implements ET.IMessage, ET.IActorMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get Error(): number;
            public set Error(value: number);
            public get SkillId(): bigint;
            public set SkillId(value: bigint);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get Rotation(): Unity.Mathematics.quaternion;
            public set Rotation(value: Unity.Mathematics.quaternion);
            public get UnitId(): bigint;
            public set UnitId(value: bigint);
            public constructor ()
        }
        class M2C_SpellStep extends ET.ProtoObject implements ET.IMessage, ET.IActorMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get Error(): number;
            public set Error(value: number);
            public get SkillId(): bigint;
            public set SkillId(value: bigint);
            public get UnitId(): bigint;
            public set UnitId(value: bigint);
            public constructor ()
        }
        class M2C_SpellEnd extends ET.ProtoObject implements ET.IMessage, ET.IActorMessage, System.ComponentModel.ISupportInitialize
        {
            protected [__keep_incompatibility]: never;
            public get Error(): number;
            public set Error(value: number);
            public get SkillId(): bigint;
            public set SkillId(value: bigint);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get Rotation(): Unity.Mathematics.quaternion;
            public set Rotation(value: Unity.Mathematics.quaternion);
            public get UnitId(): bigint;
            public set UnitId(value: bigint);
            public constructor ()
        }
        class C2G_EnterMap extends ET.ProtoObject implements ET.IMessage, ET.IRequest, ET.IGateMessage, ET.IActorRequest, System.ComponentModel.ISupportInitialize, ET.IActorLocationRequest
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public constructor ()
        }
        class G2C_EnterMap extends ET.ProtoObject implements ET.IMessage, ET.IResponse, ET.IActorResponse, System.ComponentModel.ISupportInitialize, ET.IActorLocationResponse
        {
            protected [__keep_incompatibility]: never;
            public get RpcId(): number;
            public set RpcId(value: number);
            public get Error(): number;
            public set Error(value: number);
            public get Message(): string;
            public set Message(value: string);
            public get MyId(): bigint;
            public set MyId(value: bigint);
            public constructor ()
        }
        class OuterMessage extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static HttpGetRouterResponse : number
            public static RouterSync : number
            public static MoveInfo : number
            public static UnitInfo : number
            public static ComponentInfo : number
            public static C2G_Ping : number
            public static G2C_Ping : number
            public static G2C_Test : number
            public static C2M_Reload : number
            public static M2C_Reload : number
            public static C2R_Login : number
            public static R2C_Login : number
            public static C2G_LoginGate : number
            public static G2C_LoginGate : number
            public static G2C_TestHotfixMessage : number
            public static C2G_Benchmark : number
            public static G2C_Benchmark : number
            public static M2C_OnEnterMap : number
            public static M2C_OnLeaveMap : number
            public static M2C_CreateUnits : number
            public static M2C_CreateMyUnit : number
            public static M2C_RemoveUnits : number
            public static M2C_ComponentPropertyNotify : number
            public static M2C_StartSceneChange : number
            public static C2M_PathfindingResult : number
            public static M2C_PathfindingResult : number
            public static C2M_Stop : number
            public static M2C_Stop : number
            public static C2M_TestRobotCase : number
            public static M2C_TestRobotCase : number
            public static C2M_TestRequest : number
            public static M2C_TestResponse : number
            public static Actor_TransferRequest : number
            public static Actor_TransferResponse : number
            public static C2M_TransferMap : number
            public static M2C_TransferMap : number
            public static C2M_SpellRequest : number
            public static M2C_SpellResponse : number
            public static M2C_SpellStart : number
            public static M2C_SpellStep : number
            public static M2C_SpellEnd : number
            public static C2G_EnterMap : number
            public static G2C_EnterMap : number
        }
        class Root extends ET.Entity implements ET.IDomain, System.ComponentModel.ISupportInitialize, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get DomainIndex(): number;
            public get Domain(): ET.Entity;
            public get Parent(): ET.Entity;
            public constructor ()
        }
        class UnOrderMultiMap$2<T, K> extends System.Collections.Generic.Dictionary$2<T, System.Collections.Generic.List$1<K>> implements System.Runtime.Serialization.IDeserializationCallback, System.Collections.Generic.IReadOnlyDictionary$2<T, System.Collections.Generic.List$1<K>>, System.Collections.Generic.IDictionary$2<T, System.Collections.Generic.List$1<K>>, System.Runtime.Serialization.ISerializable, System.Collections.ICollection, System.Collections.IDictionary, System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<T, System.Collections.Generic.List$1<K>>>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<System.Collections.Generic.KeyValuePair$2<T, System.Collections.Generic.List$1<K>>>, System.Collections.Generic.ICollection$1<System.Collections.Generic.KeyValuePair$2<T, System.Collections.Generic.List$1<K>>>
        {
            protected [__keep_incompatibility]: never;
        }
        class ChildOfAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public type : System.Type
            public constructor ($type?: System.Type)
            public constructor ()
        }
        class ComponentOfAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public Type : System.Type
            public constructor ($type?: System.Type)
            public constructor ()
        }
        class EnableAccessEntiyChildAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class EnableClassAttribute extends ET.BaseAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class EnableMethodAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class FriendOfAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public Type : System.Type
            public constructor ($type: System.Type)
            public constructor ()
        }
        class StaticFieldAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public valueToAssign : any
            public assignNewTypeInstance : boolean
            public constructor ()
            public constructor ($valueToAssign: any)
            public constructor ($assignNewTypeInstance: boolean)
        }
        class UniqueIdAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public Min : number
            public Max : number
            public constructor ($min?: number, $max?: number)
            public constructor ()
        }
        class AssemblyHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetAssemblyTypes (...args: System.Reflection.Assembly[]) : System.Collections.Generic.Dictionary$2<string, System.Type>
        }
        class ByteHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ToHex ($b: number) : string
            public static ToHex ($bytes: System.Array$1<number>) : string
            public static ToHex ($bytes: System.Array$1<number>, $format: string) : string
            public static ToHex ($bytes: System.Array$1<number>, $offset: number, $count: number) : string
            public static ToStr ($bytes: System.Array$1<number>) : string
            public static ToStr ($bytes: System.Array$1<number>, $index: number, $count: number) : string
            public static Utf8ToStr ($bytes: System.Array$1<number>) : string
            public static Utf8ToStr ($bytes: System.Array$1<number>, $index: number, $count: number) : string
            public static WriteTo ($bytes: System.Array$1<number>, $offset: number, $num: number) : void
            public static WriteTo ($bytes: System.Array$1<number>, $offset: number, $num: bigint) : void
        }
        class EnumHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class ETCancelationTokenHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CancelAfter ($self: ET.ETCancellationToken, $afterTimeCancel: bigint) : ET.ETTask
        }
        class ETCancellationToken extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Add ($callback: System.Action) : void
            public Remove ($callback: System.Action) : void
            public IsDispose () : boolean
            public Cancel () : void
            public constructor ()
        }
        interface ETCancellationToken {
            CancelAfter ($afterTimeCancel: bigint) : ET.ETTask;
            IsCancel () : boolean;
        }
        class FileHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetAllFiles ($dir: string, $searchPattern?: string) : System.Collections.Generic.List$1<string>
            public static GetAllFiles ($files: System.Collections.Generic.List$1<string>, $dir: string, $searchPattern?: string) : void
            public static CleanDirectory ($dir: string) : void
            public static CopyDirectory ($srcDir: string, $tgtDir: string) : void
            public static ReplaceExtensionName ($srcDir: string, $extensionName: string, $newExtensionName: string) : void
        }
        class MD5Helper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static FileMD5 ($filePath: string) : string
        }
        class NetworkHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetAddressIPs () : System.Array$1<string>
            public static GetHostAddress ($hostName: string) : System.Net.IPAddress
            public static ToIPEndPoint ($host: string, $port: number) : System.Net.IPEndPoint
            public static ToIPEndPoint ($address: string) : System.Net.IPEndPoint
        }
        class ObjectHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class ProcessHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Run ($exe: string, $arguments: string, $workingDirectory?: string, $waitExit?: boolean) : System.Diagnostics.Process
        }
        class RandomGenerator extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static RandUInt64 () : bigint
            public static RandInt32 () : number
            public static RandUInt32 () : number
            public static RandInt64 () : bigint
            public static RandomNumber ($lower: number, $upper: number) : number
            public static RandomBool () : boolean
            public static RandFloat01 () : number
        }
        class StringHashHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetLongHashCode ($str: string) : bigint
            public static Mode ($strText: string, $mode: number) : number
        }
        class StringHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ToBytes ($str: string) : System.Collections.Generic.IEnumerable$1<number>
            public static ToByteArray ($str: string) : System.Array$1<number>
            public static ToUtf8 ($str: string) : System.Array$1<number>
            public static HexToBytes ($hexString: string) : System.Array$1<number>
            public static Fmt ($text: string, ...args: any[]) : string
        }
        class WinPeriod extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Init () : void
        }
        class ZipHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Compress ($content: System.Array$1<number>) : System.Array$1<number>
            public static Decompress ($content: System.Array$1<number>) : System.Array$1<number>
            public static Decompress ($content: System.Array$1<number>, $offset: number, $count: number) : System.Array$1<number>
        }
        class IStaticMethod extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Run () : void
            public Run ($a: any) : void
            public Run ($a: any, $b: any) : void
            public Run ($a: any, $b: any, $c: any) : void
        }
        class StaticMethod extends ET.IStaticMethod
        {
            protected [__keep_incompatibility]: never;
            public constructor ($assembly: System.Reflection.Assembly, $typeName: string, $methodName: string)
            public constructor ()
        }
        class ConfigAttribute extends ET.BaseAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ConfigComponent extends ET.Singleton$1<ET.ConfigComponent> implements ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public LoadOneConfig ($configType: System.Type) : any
            public Load () : void
            public LoadAsync () : ET.ETTask
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        interface IConfig
        {
            Id : number
        }
        interface IMerge
        {
            Merge ($o: any) : void
        }
        class CoroutineLock extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Create ($type: number, $k: bigint, $count: number) : ET.CoroutineLock
            public Dispose () : void
            public constructor ()
        }
        class CoroutineLockComponent extends ET.Singleton$1<ET.CoroutineLockComponent> implements ET.ISingletonUpdate, ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Update () : void
            public RunNextCoroutine ($coroutineLockType: number, $key: bigint, $level: number) : void
            public Wait ($coroutineLockType: number, $key: bigint, $time?: number) : ET.ETTask$1<ET.CoroutineLock>
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        interface ISingletonUpdate
        {
            Update () : void
        }
        class CoroutineLockQueue extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public static Create ($type: number, $key: bigint) : ET.CoroutineLockQueue
            public Wait ($time: number) : ET.ETTask$1<ET.CoroutineLock>
            public Notify ($level: number) : void
            public Recycle () : void
            public constructor ()
        }
        class CoroutineLockQueueType extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Wait ($key: bigint, $time: number) : ET.ETTask$1<ET.CoroutineLock>
            public Notify ($key: bigint, $level: number) : void
            public constructor ($type: number)
            public constructor ()
        }
        class CoroutineLockType extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static None : number
            public static Location : number
            public static ActorLocationSender : number
            public static Mailbox : number
            public static UnitId : number
            public static DB : number
            public static Resources : number
            public static ResourcesLoader : number
            public static Max : number
        }
        class WaitCoroutineLock extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Create () : ET.WaitCoroutineLock
            public SetResult ($coroutineLock: ET.CoroutineLock) : void
            public SetException ($exception: System.Exception) : void
            public IsDisposed () : boolean
            public Wait () : ET.ETTask$1<ET.CoroutineLock>
            public constructor ()
        }
        class WaitCoroutineLockTimer extends ET.ATimer$1<ET.WaitCoroutineLock> implements ET.IInvoke
        {
            protected [__keep_incompatibility]: never;
            public get Type(): System.Type;
            public constructor ()
        }
        enum EntityStatus
        { None = 0, IsFromPool = 1, IsRegister = 2, IsComponent = 4, IsCreated = 8, IsNew = 16 }
        class ETRoot extends ET.Singleton$1<ET.ETRoot> implements ET.ISingletonAwake, ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static get Root(): ET.Root;
            public Awake () : void
            public Add ($entity: ET.Entity) : void
            public Remove ($instanceId: bigint) : void
            public Get ($instanceId: bigint) : ET.Entity
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        interface ISingletonAwake
        {
            Awake () : void
        }
        class SceneHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static DomainZone ($entity: ET.Entity) : number
        }
        class EventAttribute extends ET.BaseAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get SceneType(): ET.SceneType;
            public constructor ($sceneType: ET.SceneType)
            public constructor ()
        }
        class EventSystem extends ET.Singleton$1<ET.EventSystem> implements ET.ISingletonLateUpdate, ET.ISingletonUpdate, ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public allEvents : System.Collections.Generic.Dictionary$2<System.Type, System.Collections.Generic.List$1<ET.EventSystem.EventInfo>>
            public Add ($addTypes: System.Collections.Generic.Dictionary$2<string, System.Type>) : void
            public GetTypes ($systemAttributeType: System.Type) : System.Collections.Generic.HashSet$1<System.Type>
            public GetTypes () : System.Collections.Generic.Dictionary$2<string, System.Type>
            public GetType ($typeName: string) : System.Type
            public RegisterSystem ($component: ET.Entity) : void
            public Deserialize ($component: ET.Entity) : void
            public GetComponent ($entity: ET.Entity, $component: ET.Entity) : void
            public AddComponent ($entity: ET.Entity, $component: ET.Entity) : void
            public Awake ($component: ET.Entity) : void
            public Load () : void
            public Destroy ($component: ET.Entity) : void
            public Update () : void
            public LateUpdate () : void
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        interface ISingletonLateUpdate
        {
            LateUpdate () : void
        }
        interface IAddComponentSystem extends ET.ISystemType
        {
            Run ($o: ET.Entity, $component: ET.Entity) : void
            Type () : System.Type
            SystemType () : System.Type
            GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
        interface IDeserialize
        {
        }
        interface IDeserializeSystem extends ET.ISystemType
        {
            Run ($o: ET.Entity) : void
            Type () : System.Type
            SystemType () : System.Type
            GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
        interface IGetComponent
        {
        }
        interface IGetComponentSystem extends ET.ISystemType
        {
            Run ($o: ET.Entity, $component: ET.Entity) : void
            Type () : System.Type
            SystemType () : System.Type
            GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
        interface ILateUpdate
        {
        }
        interface ILateUpdateSystem extends ET.ISystemType
        {
            Run ($o: ET.Entity) : void
            Type () : System.Type
            SystemType () : System.Type
            GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
        interface ILoad
        {
        }
        interface ILoadSystem extends ET.ISystemType
        {
            Run ($o: ET.Entity) : void
            Type () : System.Type
            SystemType () : System.Type
            GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
        enum InstanceQueueIndex
        { None = -1, Update = 0, LateUpdate = 1, Load = 2, Max = 3 }
        class InvokeAttribute extends ET.BaseAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Type(): number;
            public constructor ($type?: number)
            public constructor ()
        }
        interface ISerializeToEntity
        {
        }
        interface ITransfer
        {
        }
        class ObjectSystemAttribute extends ET.BaseAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ProcessActorId extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Process : number
            public ActorId : bigint
            public constructor ($actorId: bigint)
            public constructor ()
        }
        class IdStruct extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Time : number
            public Process : number
            public Value : number
            public ToLong () : bigint
            public constructor ($time: number, $process: number, $value: number)
            public constructor ($id: bigint)
            public constructor ()
        }
        class InstanceIdStruct extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Time : number
            public Process : number
            public Value : number
            public ToLong () : bigint
            public constructor ($id: bigint)
            public constructor ($time: number, $process: number, $value: number)
            public constructor ($process: number, $value: number)
            public constructor ()
        }
        class UnitIdStruct extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Time : number
            public Zone : number
            public ProcessMode : number
            public Value : number
            public ToLong () : bigint
            public static GetUnitZone ($unitId: bigint) : number
            public constructor ($zone: number, $process: number, $time: number, $value: number)
            public constructor ($id: bigint)
            public constructor ()
        }
        class IdGenerater extends ET.Singleton$1<ET.IdGenerater> implements ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static Mask18bit : number
            public static MaxZone : number
            public GenerateInstanceId () : bigint
            public GenerateId () : bigint
            public GenerateUnitId ($zone: number) : bigint
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        class Log extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Trace ($msg: string) : void
            public static Debug ($msg: string) : void
            public static Info ($msg: string) : void
            public static TraceInfo ($msg: string) : void
            public static Warning ($msg: string) : void
            public static Error ($msg: string) : void
            public static Error ($e: System.Exception) : void
            public static Trace ($message: string, ...args: any[]) : void
            public static Warning ($message: string, ...args: any[]) : void
            public static Info ($message: string, ...args: any[]) : void
            public static Debug ($message: string, ...args: any[]) : void
            public static Error ($message: string, ...args: any[]) : void
            public static Console ($message: string) : void
            public static Console ($message: string, ...args: any[]) : void
        }
        class Logger extends ET.Singleton$1<ET.Logger> implements ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public set ILog(value: ET.ILog);
            public Trace ($msg: string) : void
            public Debug ($msg: string) : void
            public Info ($msg: string) : void
            public TraceInfo ($msg: string) : void
            public Warning ($msg: string) : void
            public Error ($msg: string) : void
            public Error ($e: System.Exception) : void
            public Trace ($message: string, ...args: any[]) : void
            public Warning ($message: string, ...args: any[]) : void
            public Info ($message: string, ...args: any[]) : void
            public Debug ($message: string, ...args: any[]) : void
            public Error ($message: string, ...args: any[]) : void
            public Console ($message: string) : void
            public Console ($message: string, ...args: any[]) : void
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        class NLogger extends System.Object implements ET.ILog
        {
            protected [__keep_incompatibility]: never;
            public Trace ($message: string) : void
            public Warning ($message: string) : void
            public Info ($message: string) : void
            public Debug ($message: string) : void
            public Error ($message: string) : void
            public Fatal ($message: string) : void
            public Trace ($message: string, ...args: any[]) : void
            public Warning ($message: string, ...args: any[]) : void
            public Info ($message: string, ...args: any[]) : void
            public Debug ($message: string, ...args: any[]) : void
            public Error ($message: string, ...args: any[]) : void
            public Fatal ($message: string, ...args: any[]) : void
            public constructor ($name: string, $process: number, $configPath: string)
            public constructor ()
        }
        enum ChannelType
        { Connect = 0, Accept = 1 }
        class Packet extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static MinPacketSize : number
            public static OpcodeIndex : number
            public static KcpOpcodeIndex : number
            public static OpcodeLength : number
            public static ActorIdIndex : number
            public static ActorIdLength : number
            public static MessageIndex : number
            public Opcode : number
            public ActorId : bigint
            public MemoryStream : System.IO.MemoryStream
        }
        class AChannel extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Id : bigint
            public get ChannelType(): ET.ChannelType;
            public get Error(): number;
            public set Error(value: number);
            public get RemoteAddress(): System.Net.IPEndPoint;
            public set RemoteAddress(value: System.Net.IPEndPoint);
            public get IsDisposed(): boolean;
            public Dispose () : void
        }
        class AService extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Id(): number;
            public set Id(value: number);
            public get ServiceType(): ET.ServiceType;
            public Dispose () : void
            public Update () : void
            public Remove ($id: bigint, $error?: number) : void
            public IsDispose () : boolean
            public Create ($id: bigint, $address: System.Net.IPEndPoint) : void
            public Send ($channelId: bigint, $actorId: bigint, $message: any) : void
            public GetChannelConn ($channelId: bigint) : System.ValueTuple$2<number, number>
            public ChangeAddress ($channelId: bigint, $ipEndPoint: System.Net.IPEndPoint) : void
        }
        enum ServiceType
        { Outer = 0, Inner = 1 }
        class ErrorCore extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ERR_MyErrorCode : number
            public static ERR_KcpConnectTimeout : number
            public static ERR_KcpAcceptTimeout : number
            public static ERR_PeerDisconnect : number
            public static ERR_SocketCantSend : number
            public static ERR_SocketError : number
            public static ERR_KcpWaitSendSizeTooLarge : number
            public static ERR_KcpCreateError : number
            public static ERR_SendMessageNotFoundTChannel : number
            public static ERR_TChannelRecvError : number
            public static ERR_MessageSocketParserError : number
            public static ERR_KcpNotFoundChannel : number
            public static ERR_WebsocketSendError : number
            public static ERR_WebsocketPeerReset : number
            public static ERR_WebsocketMessageTooBig : number
            public static ERR_WebsocketRecvError : number
            public static ERR_KcpReadNotSame : number
            public static ERR_KcpSplitError : number
            public static ERR_KcpSplitCountError : number
            public static ERR_ActorLocationSenderTimeout : number
            public static ERR_PacketParserError : number
            public static ERR_KcpChannelAcceptTimeout : number
            public static ERR_KcpRemoteDisconnect : number
            public static ERR_WebsocketError : number
            public static ERR_WebsocketConnectError : number
            public static ERR_RpcFail : number
            public static ERR_ReloadFail : number
            public static ERR_ConnectGateKeyError : number
            public static ERR_SessionSendOrRecvTimeout : number
            public static ERR_OuterSessionRecvInnerMessage : number
            public static ERR_NotFoundActor : number
            public static ERR_ActorTimeout : number
            public static ERR_UnverifiedSessionSendMessage : number
            public static ERR_ActorLocationSenderTimeout2 : number
            public static ERR_ActorLocationSenderTimeout3 : number
            public static ERR_ActorLocationSenderTimeout4 : number
            public static ERR_ActorLocationSenderTimeout5 : number
            public static ERR_KcpRouterTimeout : number
            public static ERR_KcpRouterTooManyPackets : number
            public static ERR_KcpRouterSame : number
            public static ERR_KcpRouterConnectFail : number
            public static ERR_KcpRouterRouterSyncCountTooMuchTimes : number
            public static ERR_KcpRouterSyncCountTooMuchTimes : number
            public static ERR_Exception : number
            public static ERR_Cancel : number
            public static IsRpcNeedThrowException ($error: number) : boolean
        }
        class KcpWaitPacket extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public ActorId : bigint
            public MemoryStream : System.IO.MemoryStream
        }
        class KChannel extends ET.AChannel implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Service : ET.KService
            public CreateTime : number
            public get kcp(): System.IntPtr;
            public get LocalConn(): number;
            public get RemoteConn(): number;
            public set RemoteConn(value: number);
            public get IsConnected(): boolean;
            public set IsConnected(value: boolean);
            public get RealAddress(): string;
            public set RealAddress(value: string);
            public HandleConnnect () : void
            public Update ($timeNow: number) : void
            public HandleRecv ($date: System.Array$1<number>, $offset: number, $length: number) : void
            public Output ($bytes: System.IntPtr, $count: number) : void
            public Send ($actorId: bigint, $stream: System.IO.MemoryStream) : void
            public OnError ($error: number) : void
            public constructor ($localConn: number, $socket: System.Net.Sockets.Socket, $remoteEndPoint: System.Net.IPEndPoint, $kService: ET.KService)
            public constructor ($localConn: number, $remoteConn: number, $socket: System.Net.Sockets.Socket, $remoteEndPoint: System.Net.IPEndPoint, $kService: ET.KService)
            public constructor ()
        }
        class KService extends ET.AService implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static ConnectTimeoutTime : number
            public KcpPtrChannels : System.Collections.Generic.Dictionary$2<System.IntPtr, ET.KChannel>
            public get TimeNow(): number;
            public Get ($id: bigint) : ET.KChannel
            public Disconnect ($localConn: number, $remoteConn: number, $error: number, $address: System.Net.IPEndPoint, $times: number) : void
            public AddToUpdate ($time: bigint, $id: bigint) : void
            public constructor ($ipEndPoint: System.Net.IPEndPoint, $serviceType: ET.ServiceType)
            public constructor ($addressFamily: System.Net.Sockets.AddressFamily, $serviceType: ET.ServiceType)
            public constructor ()
        }
        class KcpProtocalType extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static SYN : number
            public static ACK : number
            public static FIN : number
            public static MSG : number
            public static RouterReconnectSYN : number
            public static RouterReconnectACK : number
            public static RouterSYN : number
            public static RouterACK : number
        }
        class MessageAttribute extends ET.BaseAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Opcode(): number;
            public constructor ($opcode: number)
            public constructor ()
        }
        class MessageSerializeHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static MessageToStream ($message: any) : System.ValueTuple$2<number, System.IO.MemoryStream>
        }
        enum NetworkProtocol
        { TCP = 0, KCP = 1, Websocket = 2 }
        enum NetOp
        { AddService = 1, RemoveService = 2, OnAccept = 3, OnRead = 4, OnError = 5, CreateChannel = 6, RemoveChannel = 7, SendMessage = 9, GetChannelConn = 10, ChangeAddress = 11 }
        class NetOperator extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Op : ET.NetOp
            public ServiceId : number
            public ChannelId : bigint
            public ActorId : bigint
            public Object : any
        }
        class NetServices extends ET.Singleton$1<ET.NetServices> implements ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public GetOpcode ($type: System.Type) : number
            public GetType ($opcode: number) : System.Type
            public GetChannelConn ($serviceId: number, $channelId: bigint) : System.Threading.Tasks.Task$1<System.ValueTuple$2<number, number>>
            public ChangeAddress ($serviceId: number, $channelId: bigint, $ipEndPoint: System.Net.IPEndPoint) : void
            public SendMessage ($serviceId: number, $channelId: bigint, $actorId: bigint, $message: any) : void
            public AddService ($aService: ET.AService) : number
            public RemoveService ($serviceId: number) : void
            public RemoveChannel ($serviceId: number, $channelId: bigint, $error: number) : void
            public CreateChannel ($serviceId: number, $channelId: bigint, $address: System.Net.IPEndPoint) : void
            public RegisterAcceptCallback ($serviceId: number, $action: System.Action$2<bigint, System.Net.IPEndPoint>) : void
            public RegisterReadCallback ($serviceId: number, $action: System.Action$3<bigint, bigint, any>) : void
            public RegisterErrorCallback ($serviceId: number, $action: System.Action$2<bigint, number>) : void
            public UpdateInMainThread () : void
            public Get ($id: number) : ET.AService
            public UpdateInNetThread () : void
            public OnAccept ($serviceId: number, $channelId: bigint, $ipEndPoint: System.Net.IPEndPoint) : void
            public OnRead ($serviceId: number, $channelId: bigint, $actorId: bigint, $message: any) : void
            public OnError ($serviceId: number, $channelId: bigint, $error: number) : void
            public CreateConnectChannelId () : number
            public CreateAcceptChannelId () : number
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        class OpcodeRangeDefine extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static OuterMinOpcode : number
            public static OuterMaxOpcode : number
            public static InnerMinOpcode : number
            public static InnerMaxOpcode : number
            public static MaxOpcode : number
        }
        enum ParserState
        { PacketSize = 0, PacketBody = 1 }
        class PacketParser extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public service : ET.AService
            public static InnerPacketSizeLength : number
            public static OuterPacketSizeLength : number
            public MemoryStream : System.IO.MemoryStream
            public Parse () : boolean
            public constructor ($buffer: ET.CircularBuffer, $service: ET.AService)
            public constructor ()
        }
        class CircularBuffer extends System.IO.Stream implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
        class RpcException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public get Error(): number;
            public constructor ($error: number, $message: string)
            public constructor ($error: number, $message: string, $e: System.Exception)
            public constructor ()
        }
        class TChannel extends ET.AChannel implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Send ($actorId: bigint, $stream: System.IO.MemoryStream) : void
            public ConnectAsync () : void
            public OnConnectComplete ($e: System.Net.Sockets.SocketAsyncEventArgs) : void
            public OnDisconnectComplete ($e: System.Net.Sockets.SocketAsyncEventArgs) : void
            public StartRecv () : void
            public OnRecvComplete ($o: System.Net.Sockets.SocketAsyncEventArgs) : void
            public StartSend () : void
            public OnSendComplete ($o: System.Net.Sockets.SocketAsyncEventArgs) : void
            public constructor ($id: bigint, $ipEndPoint: System.Net.IPEndPoint, $service: ET.TService)
            public constructor ($id: bigint, $socket: System.Net.Sockets.Socket, $service: ET.TService)
            public constructor ()
        }
        class TService extends ET.AService implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Queue : System.Collections.Concurrent.ConcurrentQueue$1<ET.TArgs>
            public constructor ($addressFamily: System.Net.Sockets.AddressFamily, $serviceType: ET.ServiceType)
            public constructor ($ipEndPoint: System.Net.IPEndPoint, $serviceType: ET.ServiceType)
            public constructor ()
        }
        enum TcpOp
        { StartSend = 0, StartRecv = 1, Connect = 2 }
        class TArgs extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Op : ET.TcpOp
            public ChannelId : bigint
            public SocketAsyncEventArgs : System.Net.Sockets.SocketAsyncEventArgs
        }
        class WChannel extends ET.AChannel implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get WebSocketContext(): System.Net.WebSockets.HttpListenerWebSocketContext;
            public ConnectAsync ($url: string) : ET.ETTask
            public Send ($stream: System.IO.MemoryStream) : void
            public StartSend () : ET.ETTask
            public StartRecv () : ET.ETTask
            public constructor ($id: bigint, $webSocketContext: System.Net.WebSockets.HttpListenerWebSocketContext, $service: ET.WService)
            public constructor ($id: bigint, $webSocket: System.Net.WebSockets.WebSocket, $connectUrl: string, $service: ET.WService)
            public constructor ()
        }
        class WService extends ET.AService implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public ThreadSynchronizationContext : ET.ThreadSynchronizationContext
            public Create ($address: string, $id: bigint) : ET.WChannel
            public Create ($id: bigint, $address: System.Net.IPEndPoint) : void
            public constructor ($prefixs: System.Collections.Generic.IEnumerable$1<string>)
            public constructor ()
        }
        class ThreadSynchronizationContext extends System.Threading.SynchronizationContext
        {
            protected [__keep_incompatibility]: never;
            public Update () : void
            public Post ($callback: System.Threading.SendOrPostCallback, $state: any) : void
            public Post ($action: System.Action) : void
            public constructor ()
        }
        class ObjectPool extends ET.Singleton$1<ET.ObjectPool> implements ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Fetch ($type: System.Type) : any
            public Recycle ($obj: any) : void
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        enum AppType
        { Server = 0, Watcher = 1, GameTool = 2, ExcelExporter = 3, Proto2CS = 4, BenchmarkClient = 5, BenchmarkServer = 6 }
        class Options extends ET.Singleton$1<ET.Options> implements ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get AppType(): string;
            public set AppType(value: string);
            public get LauncherType(): string;
            public set LauncherType(value: string);
            public get StartConfig(): string;
            public set StartConfig(value: string);
            public get Process(): number;
            public set Process(value: number);
            public get Develop(): number;
            public set Develop(value: number);
            public get LogLevel(): number;
            public set LogLevel(value: number);
            public get Console(): number;
            public set Console(value: number);
            public get CreateScenes(): number;
            public set CreateScenes(value: number);
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        class MainThreadSynchronizationContext extends ET.Singleton$1<ET.MainThreadSynchronizationContext> implements ET.ISingletonUpdate, ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Update () : void
            public Post ($callback: System.Threading.SendOrPostCallback, $state: any) : void
            public Post ($action: System.Action) : void
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        class TimeHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static OneDay : bigint
            public static Hour : bigint
            public static Minute : bigint
            public static ClientNow () : bigint
            public static ClientNowSeconds () : bigint
            public static DateTimeNow () : Date
            public static ServerNow () : bigint
            public static ClientFrameTime () : bigint
            public static ServerFrameTime () : bigint
            public static WaitAsync ($time: bigint) : ET.ETTask
        }
        class TimeInfo extends ET.Singleton$1<ET.TimeInfo> implements ET.ISingletonUpdate, ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public FrameTime : bigint
            public get TimeZone(): number;
            public set TimeZone(value: number);
            public set ServerMinusClientTime(value: bigint);
            public Update () : void
            public ToDateTime ($timeStamp: bigint) : Date
            public ClientNow () : bigint
            public ServerNow () : bigint
            public ClientFrameTime () : bigint
            public ServerFrameTime () : bigint
            public Transition ($d: Date) : bigint
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        enum TimerClass
        { None = 0, OnceTimer = 1, OnceWaitTimer = 2, RepeatedTimer = 3 }
        class TimerAction extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Id : bigint
            public TimerClass : ET.TimerClass
            public Object : any
            public StartTime : bigint
            public Time : bigint
            public Type : number
            public static Create ($id: bigint, $timerClass: ET.TimerClass, $startTime: bigint, $time: bigint, $type: number, $obj: any) : ET.TimerAction
            public Recycle () : void
            public constructor ()
        }
        class TimerComponent extends ET.Singleton$1<ET.TimerComponent> implements ET.ISingletonUpdate, ET.ISingleton, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Update () : void
            public Remove ($id: $Ref<bigint>) : boolean
            public WaitTillAsync ($tillTime: bigint, $cancellationToken?: ET.ETCancellationToken) : ET.ETTask
            public WaitFrameAsync ($cancellationToken?: ET.ETCancellationToken) : ET.ETTask
            public WaitAsync ($time: bigint, $cancellationToken?: ET.ETCancellationToken) : ET.ETTask
            public NewOnceTimer ($tillTime: bigint, $type: number, $args: any) : bigint
            public NewFrameTimer ($type: number, $args: any) : bigint
            public NewRepeatedTimer ($time: bigint, $type: number, $args: any) : bigint
            public constructor ()
            public Register () : void
            public Destroy () : void
            public IsDisposed () : boolean
        }
        class JsonHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ToJson ($o: any) : string
            public static FromJson ($type: System.Type, $json: string) : any
        }
        class MongoHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Init () : void
            public static ToJson ($obj: any) : string
            public static ToJson ($obj: any, $settings: MongoDB.Bson.IO.JsonWriterSettings) : string
            public static FromJson ($type: System.Type, $str: string) : any
            public static Serialize ($obj: any) : System.Array$1<number>
            public static Serialize ($message: any, $stream: System.IO.MemoryStream) : void
            public static Deserialize ($type: System.Type, $bytes: System.Array$1<number>) : any
            public static Deserialize ($type: System.Type, $bytes: System.Array$1<number>, $index: number, $count: number) : any
            public static Deserialize ($type: System.Type, $stream: System.IO.Stream) : any
        }
        class ProtobufHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Init () : void
            public static Deserialize ($type: System.Type, $bytes: System.Array$1<number>, $index: number, $count: number) : any
            public static Serialize ($message: any) : System.Array$1<number>
            public static Serialize ($message: any, $stream: System.IO.Stream) : void
            public static Deserialize ($type: System.Type, $stream: System.IO.Stream) : any
        }
        class SerializeHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Deserialize ($type: System.Type, $bytes: System.Array$1<number>, $index: number, $count: number) : any
            public static Serialize ($message: any) : System.Array$1<number>
            public static Serialize ($message: any, $stream: System.IO.Stream) : void
            public static Deserialize ($type: System.Type, $stream: System.IO.Stream) : any
        }
        class Game extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static AddSingleton ($singleton: ET.ISingleton) : void
            public static WaitFrameFinish () : ET.ETTask
            public static Update () : void
            public static LateUpdate () : void
            public static FrameFinishUpdate () : void
            public static Close () : void
        }
        class TimerCoreInvokeType extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CoroutineTimeout : number
        }
        class AMHandler$1<Message> extends System.Object implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
        class AddComponentSystem$1<T> extends System.Object implements ET.ISystemType, ET.IAddComponentSystem
        {
            protected [__keep_incompatibility]: never;
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity, $component: ET.Entity) : void
        }
        class AwakeSystem$2<T, A> extends System.Object implements ET.ISystemType, ET.IAwakeSystem$1<A>
        {
            protected [__keep_incompatibility]: never;
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
        interface IAwakeSystem$1<A> extends ET.ISystemType
        {
            Type () : System.Type
            SystemType () : System.Type
            GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
        class AsyncETTaskCompletedMethodBuilder extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Task(): ET.ETTaskCompleted;
            public static Create () : ET.AsyncETTaskCompletedMethodBuilder
            public SetException ($e: System.Exception) : void
            public SetResult () : void
            public SetStateMachine ($stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine) : void
        }
        class ETTaskCompleted extends System.ValueType implements System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ICriticalNotifyCompletion
        {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public GetAwaiter () : ET.ETTaskCompleted
            public GetResult () : void
            public OnCompleted ($continuation: System.Action) : void
            public UnsafeOnCompleted ($continuation: System.Action) : void
        }
        class ETAsyncTaskMethodBuilder extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Task(): ET.ETTask;
            public static Create () : ET.ETAsyncTaskMethodBuilder
            public SetException ($exception: System.Exception) : void
            public SetResult () : void
            public SetStateMachine ($stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine) : void
        }
        class ETTaskHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static IsCancel ($self: ET.ETCancellationToken) : boolean
            public static WaitAny ($tasks: System.Array$1<ET.ETTask>, $cancellationToken?: ET.ETCancellationToken) : ET.ETTask$1<boolean>
            public static WaitAll ($tasks: System.Array$1<ET.ETTask>, $cancellationToken?: ET.ETCancellationToken) : ET.ETTask$1<boolean>
            public static WaitAll ($tasks: System.Collections.Generic.List$1<ET.ETTask>, $cancellationToken?: ET.ETCancellationToken) : ET.ETTask$1<boolean>
        }
        enum AwaiterStatus
        { Pending = 0, Succeeded = 1, Faulted = 2 }
        interface KcpOutput
        { 
        (buf: System.IntPtr, len: number, kcp: System.IntPtr, user: System.IntPtr) : number; 
        Invoke?: (buf: System.IntPtr, len: number, kcp: System.IntPtr, user: System.IntPtr) => number;
        }
        var KcpOutput: { new (func: (buf: System.IntPtr, len: number, kcp: System.IntPtr, user: System.IntPtr) => number): KcpOutput; }
        interface KcpLog
        { 
        (buf: System.IntPtr, len: number, kcp: System.IntPtr, user: System.IntPtr) : void; 
        Invoke?: (buf: System.IntPtr, len: number, kcp: System.IntPtr, user: System.IntPtr) => void;
        }
        var KcpLog: { new (func: (buf: System.IntPtr, len: number, kcp: System.IntPtr, user: System.IntPtr) => void): KcpLog; }
        class Kcp extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static OneM : number
            public static InnerMaxWaitSize : number
            public static OuterMaxWaitSize : number
            public static KcpCheck ($kcp: System.IntPtr, $current: number) : number
            public static KcpCreate ($conv: number, $user: System.IntPtr) : System.IntPtr
            public static KcpFlush ($kcp: System.IntPtr) : void
            public static KcpGetconv ($ptr: System.IntPtr) : number
            public static KcpInput ($kcp: System.IntPtr, $buffer: System.Array$1<number>, $offset: number, $len: number) : number
            public static KcpNodelay ($kcp: System.IntPtr, $nodelay: number, $interval: number, $resend: number, $nc: number) : number
            public static KcpPeeksize ($kcp: System.IntPtr) : number
            public static KcpRecv ($kcp: System.IntPtr, $buffer: System.Array$1<number>, $index: number, $len: number) : number
            public static KcpRelease ($kcp: System.IntPtr) : void
            public static KcpSend ($kcp: System.IntPtr, $buffer: System.Array$1<number>, $offset: number, $len: number) : number
            public static KcpSetminrto ($kcp: System.IntPtr, $minrto: number) : void
            public static KcpSetmtu ($kcp: System.IntPtr, $mtu: number) : number
            public static KcpSetoutput ($output: ET.KcpOutput) : void
            public static KcpSetLog ($kcpLog: ET.KcpLog) : void
            public static KcpUpdate ($kcp: System.IntPtr, $current: number) : void
            public static KcpWaitsnd ($kcp: System.IntPtr) : number
            public static KcpWndsize ($kcp: System.IntPtr, $sndwnd: number, $rcvwnd: number) : number
        }
        class Recast extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static MAX_POLYS : number
            public static RecastLoadLong ($id: number, $buffer: System.Array$1<number>, $n: number) : bigint
            public static RecastGetLong ($id: number) : bigint
            public static RecastFind ($navPtr: bigint, $extents: System.Array$1<number>, $startPos: System.Array$1<number>, $endPos: System.Array$1<number>, $straightPath: System.Array$1<number>) : number
            public static RecastFindNearestPoint ($navPtr: bigint, $extents: System.Array$1<number>, $pos: System.Array$1<number>, $nearestPos: System.Array$1<number>) : number
            public static RecastFindRandomPointAroundCircle ($navPtr: bigint, $extents: System.Array$1<number>, $centerPos: System.Array$1<number>, $radius: number, $randomPos: System.Array$1<number>) : number
            public static RecastFindRandomPoint ($navPtr: bigint, $randomPos: System.Array$1<number>) : number
        }
    }
    namespace System.ComponentModel {
        interface ISupportInitialize
        {
        }
        class Component extends System.MarshalByRefObject implements System.IDisposable, System.ComponentModel.IComponent
        {
            protected [__keep_incompatibility]: never;
        }
        interface IComponent extends System.IDisposable
        {
        }
    }
    namespace UnityEngine.Playables {
        /** Use the PlayableGraph to manage Playable creations and destructions.
        */
        class PlayableGraph extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        interface IPlayable
        {
        }
    }
    namespace UnityEngine.Animations {
        /** An implementation of IPlayable that controls an animation RuntimeAnimatorController.
        */
        class AnimatorControllerPlayable extends System.ValueType implements UnityEngine.Playables.IPlayable, System.IEquatable$1<UnityEngine.Animations.AnimatorControllerPlayable>
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.IO {
        class Stream extends System.MarshalByRefObject implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
        class MemoryStream extends System.IO.Stream implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
        class BinaryWriter extends System.Object implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
        class BinaryReader extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
        class TextReader extends System.MarshalByRefObject implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
        class TextWriter extends System.MarshalByRefObject implements System.IAsyncDisposable, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.AudioSettings {
        interface AudioConfigurationChangeHandler
        { 
        (deviceWasChanged: boolean) : void; 
        Invoke?: (deviceWasChanged: boolean) => void;
        }
        var AudioConfigurationChangeHandler: { new (func: (deviceWasChanged: boolean) => void): AudioConfigurationChangeHandler; }
        class Mobile extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get muteState(): boolean;
            public static get stopAudioOutputOnMute(): boolean;
            public static set stopAudioOutputOnMute(value: boolean);
            public static get audioOutputStarted(): boolean;
            public static add_OnMuteStateChanged ($value: System.Action$1<boolean>) : void
            public static remove_OnMuteStateChanged ($value: System.Action$1<boolean>) : void
            public static StartAudioOutput () : void
            public static StopAudioOutput () : void
        }
    }
    namespace UnityEngine.AudioClip {
        interface PCMReaderCallback
        { 
        (data: System.Array$1<number>) : void; 
        Invoke?: (data: System.Array$1<number>) => void;
        }
        var PCMReaderCallback: { new (func: (data: System.Array$1<number>) => void): PCMReaderCallback; }
        interface PCMSetPositionCallback
        { 
        (position: number) : void; 
        Invoke?: (position: number) => void;
        }
        var PCMSetPositionCallback: { new (func: (position: number) => void): PCMSetPositionCallback; }
    }
    namespace UnityEngine.Application {
        interface AdvertisingIdentifierCallback
        { 
        (advertisingId: string, trackingEnabled: boolean, errorMsg: string) : void; 
        Invoke?: (advertisingId: string, trackingEnabled: boolean, errorMsg: string) => void;
        }
        var AdvertisingIdentifierCallback: { new (func: (advertisingId: string, trackingEnabled: boolean, errorMsg: string) => void): AdvertisingIdentifierCallback; }
        interface LowMemoryCallback
        { 
        () : void; 
        Invoke?: () => void;
        }
        var LowMemoryCallback: { new (func: () => void): LowMemoryCallback; }
        interface LogCallback
        { 
        (condition: string, stackTrace: string, type: UnityEngine.LogType) : void; 
        Invoke?: (condition: string, stackTrace: string, type: UnityEngine.LogType) => void;
        }
        var LogCallback: { new (func: (condition: string, stackTrace: string, type: UnityEngine.LogType) => void): LogCallback; }
    }
    namespace UnityEngine.Camera {
        interface CameraCallback
        { 
        (cam: UnityEngine.Camera) : void; 
        Invoke?: (cam: UnityEngine.Camera) => void;
        }
        var CameraCallback: { new (func: (cam: UnityEngine.Camera) => void): CameraCallback; }
        enum GateFitMode
        { Vertical = 1, Horizontal = 2, Fill = 3, Overscan = 4, None = 0 }
        enum MonoOrStereoscopicEye
        { Left = 0, Right = 1, Mono = 2 }
        class GateFitParameters extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get mode(): UnityEngine.Camera.GateFitMode;
            public set mode(value: UnityEngine.Camera.GateFitMode);
            public get aspect(): number;
            public set aspect(value: number);
            public constructor ($mode: UnityEngine.Camera.GateFitMode, $aspect: number)
            public constructor ()
        }
        enum StereoscopicEye
        { Left = 0, Right = 1 }
        enum SceneViewFilterMode
        { Off = 0, ShowFiltered = 1 }
        class RenderRequest extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get isValid(): boolean;
            public get mode(): UnityEngine.Camera.RenderRequestMode;
            public get result(): UnityEngine.RenderTexture;
            public get outputSpace(): UnityEngine.Camera.RenderRequestOutputSpace;
            public constructor ($mode: UnityEngine.Camera.RenderRequestMode, $rt: UnityEngine.RenderTexture)
            public constructor ($mode: UnityEngine.Camera.RenderRequestMode, $space: UnityEngine.Camera.RenderRequestOutputSpace, $rt: UnityEngine.RenderTexture)
            public constructor ()
        }
        enum FieldOfViewAxis
        { Vertical = 0, Horizontal = 1 }
        enum RenderRequestMode
        { None = 0, ObjectId = 1, Depth = 2, VertexNormal = 3, WorldPosition = 4, EntityId = 5, BaseColor = 6, SpecularColor = 7, Metallic = 8, Emission = 9, Normal = 10, Smoothness = 11, Occlusion = 12, DiffuseColor = 13 }
        enum RenderRequestOutputSpace
        { ScreenSpace = -1, UV0 = 0, UV1 = 1, UV2 = 2, UV3 = 3, UV4 = 4, UV5 = 5, UV6 = 6, UV7 = 7, UV8 = 8 }
    }
    namespace UnityEngine.Rendering {
        /** Opaque object sorting mode of a Camera.
        */
        enum OpaqueSortMode
        { Default = 0, FrontToBack = 1, NoDistanceSort = 2 }
        /** Defines a place in camera's rendering to attach Rendering.CommandBuffer objects to.
        */
        enum CameraEvent
        { BeforeDepthTexture = 0, AfterDepthTexture = 1, BeforeDepthNormalsTexture = 2, AfterDepthNormalsTexture = 3, BeforeGBuffer = 4, AfterGBuffer = 5, BeforeLighting = 6, AfterLighting = 7, BeforeFinalPass = 8, AfterFinalPass = 9, BeforeForwardOpaque = 10, AfterForwardOpaque = 11, BeforeImageEffectsOpaque = 12, AfterImageEffectsOpaque = 13, BeforeSkybox = 14, AfterSkybox = 15, BeforeForwardAlpha = 16, AfterForwardAlpha = 17, BeforeImageEffects = 18, AfterImageEffects = 19, AfterEverything = 20, BeforeReflections = 21, AfterReflections = 22, BeforeHaloAndLensFlares = 23, AfterHaloAndLensFlares = 24 }
        /** List of graphics commands to execute.
        */
        class CommandBuffer extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
        /** Describes the desired characteristics with respect to prioritisation and load balancing of the queue that a command buffer being submitted via Graphics.ExecuteCommandBufferAsync or [[ScriptableRenderContext.ExecuteCommandBufferAsync] should be sent to.
        */
        enum ComputeQueueType
        { Default = 0, Background = 1, Urgent = 2 }
        /** Parameters that configure a culling operation in the Scriptable Render Pipeline.
        */
        class ScriptableCullingParameters extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.ScriptableCullingParameters>
        {
            protected [__keep_incompatibility]: never;
        }
        enum ReflectionProbeType
        { Cube = 0, Card = 1 }
        /** Values for ReflectionProbe.clearFlags, determining what to clear when rendering a ReflectionProbe.
        */
        enum ReflectionProbeClearFlags
        { Skybox = 1, SolidColor = 2 }
        /** Reflection probe's update mode.
        */
        enum ReflectionProbeMode
        { Baked = 0, Realtime = 1, Custom = 2 }
        /** An enum describing the way a real-time reflection probe refreshes in the Player.
        */
        enum ReflectionProbeRefreshMode
        { OnAwake = 0, EveryFrame = 1, ViaScripting = 2 }
        /** When a probe's ReflectionProbe.refreshMode is set to ReflectionProbeRefreshMode.EveryFrame, this enum specify whether or not Unity should update the probe's cubemap over several frames or update the whole cubemap in one frame.
        Updating a probe's cubemap is a costly operation. Unity needs to render the entire Scene for each face of the cubemap, as well as perform special blurring in order to get glossy reflections. The impact on frame rate can be significant. Time-slicing helps maintaning a more constant frame rate during these updates by performing the rendering over several frames.
        */
        enum ReflectionProbeTimeSlicingMode
        { AllFacesAtOnce = 0, IndividualFaces = 1, NoTimeSlicing = 2 }
        /** An enum that represents.
        */
        enum GraphicsTier
        { Tier1 = 0, Tier2 = 1, Tier3 = 2 }
        /** Specifies the OpenGL ES version.
        */
        enum OpenGLESVersion
        { None = 0, OpenGLES20 = 1, OpenGLES30 = 2, OpenGLES31 = 3, OpenGLES31AEP = 4, OpenGLES32 = 5 }
        /** Used to manage synchronisation between tasks on async compute queues and the graphics queue.
        */
        class GraphicsFence extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** The stages of the draw call processing on the GPU.
        */
        enum SynchronisationStage
        { VertexProcessing = 0, PixelProcessing = 1 }
        /** The type of GraphicFence.
        */
        enum GraphicsFenceType
        { AsyncQueueSynchronisation = 0, CPUSynchronisation = 1 }
        /** Describes the various stages of GPU processing against which the GraphicsFence can be set and waited against.
        */
        enum SynchronisationStageFlags
        { VertexProcessing = 1, PixelProcessing = 2, ComputeProcessing = 4, AllGPUOperations = 7 }
        /** How shadows are cast from this object.
        */
        enum ShadowCastingMode
        { Off = 0, On = 1, TwoSided = 2, ShadowsOnly = 3 }
        /** Light probe interpolation type.
        */
        enum LightProbeUsage
        { Off = 0, BlendProbes = 1, UseProxyVolume = 2, CustomProvided = 4 }
        /** This functionality is deprecated, and should no longer be used. Please use GraphicsFence.
        */
        class GPUFence extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** Spherical harmonics up to the second order (3 bands, 9 coefficients).
        */
        class SphericalHarmonicsL2 extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.SphericalHarmonicsL2>
        {
            protected [__keep_incompatibility]: never;
        }
        /** This enum describes what should be done on the render target when it is activated (loaded).
        */
        enum RenderBufferLoadAction
        { Load = 0, Clear = 1, DontCare = 2 }
        /** This enum describes what should be done on the render target when the GPU is done rendering into it.
        */
        enum RenderBufferStoreAction
        { Store = 0, Resolve = 1, StoreAndResolve = 2, DontCare = 3 }
        /** Reflection Probe usage.
        */
        enum ReflectionProbeUsage
        { Off = 0, BlendProbes = 1, BlendProbesAndSkybox = 2, Simple = 3 }
        /** An asset that produces a specific IRenderPipeline.
        */
        class RenderPipelineAsset extends UnityEngine.ScriptableObject
        {
            protected [__keep_incompatibility]: never;
        }
        /** Format of the mesh index buffer data.
        */
        enum IndexFormat
        { UInt16 = 0, UInt32 = 1 }
        /** Information about a single VertexAttribute of a Mesh vertex.
        */
        class VertexAttributeDescriptor extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.VertexAttributeDescriptor>
        {
            protected [__keep_incompatibility]: never;
        }
        /** Possible attribute types that describe a vertex in a Mesh.
        */
        enum VertexAttribute
        { Position = 0, Normal = 1, Tangent = 2, Color = 3, TexCoord0 = 4, TexCoord1 = 5, TexCoord2 = 6, TexCoord3 = 7, TexCoord4 = 8, TexCoord5 = 9, TexCoord6 = 10, TexCoord7 = 11, BlendWeight = 12, BlendIndices = 13 }
        /** Data type of a VertexAttribute.
        */
        enum VertexAttributeFormat
        { Float32 = 0, Float16 = 1, UNorm8 = 2, SNorm8 = 3, UNorm16 = 4, SNorm16 = 5, UInt8 = 6, SInt8 = 7, UInt16 = 8, SInt16 = 9, UInt32 = 10, SInt32 = 11 }
        /** Contains information about a single sub-mesh of a Mesh.
        */
        class SubMeshDescriptor extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** Mesh data update flags.
        */
        enum MeshUpdateFlags
        { Default = 0, DontValidateIndices = 1, DontResetBoneBounds = 2, DontNotifyMeshUsers = 4, DontRecalculateBounds = 8 }
        /** ReflectionProbeBlendInfo contains information required for blending probes.
        */
        class ReflectionProbeBlendInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        enum ShaderHardwareTier
        { Tier1 = 0, Tier2 = 1, Tier3 = 2 }
        /** Represents a global shader keyword.
        */
        class GlobalKeyword extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        /** Represents the local keyword space of a Shader or ComputeShader.
        */
        class LocalKeywordSpace extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.LocalKeywordSpace>
        {
            protected [__keep_incompatibility]: never;
        }
        /** Shader tag ids are used to refer to various names in shaders.
        */
        class ShaderTagId extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.ShaderTagId>
        {
            protected [__keep_incompatibility]: never;
        }
        /** Types of data that you can encapsulate within a render texture.
        */
        enum RenderTextureSubElement
        { Color = 0, Depth = 1, Stencil = 2, Default = 3 }
        /** Type of a given shader property.
        */
        enum ShaderPropertyType
        { Color = 0, Vector = 1, Float = 2, Range = 3, Texture = 4, Int = 5 }
        /** Flags that control how a shader property behaves.
        */
        enum ShaderPropertyFlags
        { None = 0, HideInInspector = 1, PerRendererData = 2, NoScaleOffset = 4, Normal = 8, HDR = 16, Gamma = 32, NonModifiableTextureData = 64, MainTexture = 128, MainColor = 256 }
        /** Texture "dimension" (type).
        */
        enum TextureDimension
        { Unknown = -1, None = 0, Any = 1, Tex2D = 2, Tex3D = 3, Cube = 4, Tex2DArray = 5, CubeArray = 6 }
        /** Ambient lighting mode.
        */
        enum AmbientMode
        { Skybox = 0, Trilight = 1, Flat = 3, Custom = 4 }
        /** Default reflection mode.
        */
        enum DefaultReflectionMode
        { Skybox = 0, Custom = 1 }
        /** Represents a shader keyword declared in a shader source file.
        */
        class LocalKeyword extends System.ValueType implements System.IEquatable$1<UnityEngine.Rendering.LocalKeyword>
        {
            protected [__keep_incompatibility]: never;
        }
        /** Shadow resolution options for a Light.
        */
        enum LightShadowResolution
        { FromQualitySettings = -1, Low = 0, Medium = 1, High = 2, VeryHigh = 3 }
        /** Defines a place in light's rendering to attach Rendering.CommandBuffer objects to.
        */
        enum LightEvent
        { BeforeShadowMap = 0, AfterShadowMap = 1, BeforeScreenspaceMask = 2, AfterScreenspaceMask = 3, BeforeShadowMapPass = 4, AfterShadowMapPass = 5 }
        /** Allows precise control over which shadow map passes to execute Rendering.CommandBuffer objects attached using Light.AddCommandBuffer.
        */
        enum ShadowMapPass
        { PointlightPositiveX = 1, PointlightNegativeX = 2, PointlightPositiveY = 4, PointlightNegativeY = 8, PointlightPositiveZ = 16, PointlightNegativeZ = 32, DirectionalCascade0 = 64, DirectionalCascade1 = 128, DirectionalCascade2 = 256, DirectionalCascade3 = 512, Spotlight = 1024, Pointlight = 63, Directional = 960, All = 2047 }
        /** Used by CommandBuffer.SetShadowSamplingMode.
        */
        enum ShadowSamplingMode
        { CompareDepths = 0, RawDepth = 1, None = 2 }
        /** Shader pass type for Unity's lighting pipeline.
        */
        enum PassType
        { Normal = 0, Vertex = 1, VertexLM = 2, VertexLMRGBM = 3, ForwardBase = 4, ForwardAdd = 5, LightPrePassBase = 6, LightPrePassFinal = 7, ShadowCaster = 8, Deferred = 10, Meta = 11, MotionVectors = 12, ScriptableRenderPipeline = 13, ScriptableRenderPipelineDefaultUnlit = 14, GrabPass = 15 }
        /** Graphics device API type.
        */
        enum GraphicsDeviceType
        { OpenGL2 = 0, Direct3D9 = 1, Direct3D11 = 2, PlayStation3 = 3, Null = 4, Xbox360 = 6, OpenGLES2 = 8, OpenGLES3 = 11, PlayStationVita = 12, PlayStation4 = 13, XboxOne = 14, PlayStationMobile = 15, Metal = 16, OpenGLCore = 17, Direct3D12 = 18, N3DS = 19, Vulkan = 21, Switch = 22, XboxOneD3D12 = 23, GameCoreXboxOne = 24, GameCoreScarlett = -1, GameCoreXboxSeries = 25, PlayStation5 = 26, PlayStation5NGGC = 27 }
        /** Options for the application's actual rendering threading mode.
        */
        enum RenderingThreadingMode
        { Direct = 0, SingleThreaded = 1, MultiThreaded = 2, LegacyJobified = 3, NativeGraphicsJobs = 4, NativeGraphicsJobsWithoutRenderThread = 5 }
        /** Support for various Graphics.CopyTexture cases.
        */
        enum CopyTextureSupport
        { None = 0, Basic = 1, Copy3D = 2, DifferentTypes = 4, TextureToRT = 8, RTToTexture = 16 }
        /** A flag representing each UV channel.
        */
        enum UVChannelFlags
        { UV0 = 1, UV1 = 2, UV2 = 4, UV3 = 8 }
        /** Specifies the operation that's performed on the stencil buffer when rendering.
        */
        enum StencilOp
        { Keep = 0, Zero = 1, Replace = 2, IncrementSaturate = 3, DecrementSaturate = 4, Invert = 5, IncrementWrap = 6, DecrementWrap = 7 }
        /** Depth or stencil comparison function.
        */
        enum CompareFunction
        { Disabled = 0, Never = 1, Less = 2, Equal = 3, LessEqual = 4, Greater = 5, NotEqual = 6, GreaterEqual = 7, Always = 8 }
        /** Specifies which color components will get written into the target framebuffer.
        */
        enum ColorWriteMask
        { Alpha = 1, Blue = 2, Green = 4, Red = 8, All = 15 }
        /** Blend mode for controlling the blending.
        */
        enum BlendMode
        { Zero = 0, One = 1, DstColor = 2, SrcColor = 3, OneMinusDstColor = 4, SrcAlpha = 5, OneMinusSrcColor = 6, DstAlpha = 7, OneMinusDstAlpha = 8, SrcAlphaSaturate = 9, OneMinusSrcAlpha = 10 }
    }
    namespace UnityEngine.CullingGroup {
        interface StateChanged
        { 
        (sphere: UnityEngine.CullingGroupEvent) : void; 
        Invoke?: (sphere: UnityEngine.CullingGroupEvent) => void;
        }
        var StateChanged: { new (func: (sphere: UnityEngine.CullingGroupEvent) => void): StateChanged; }
    }
    namespace UnityEngine.ReflectionProbe {
        enum ReflectionProbeEvent
        { ReflectionProbeAdded = 0, ReflectionProbeRemoved = 1 }
    }
    namespace UnityEngine.BoundsInt {
        class PositionEnumerator extends System.ValueType implements System.Collections.Generic.IEnumerator$1<UnityEngine.Vector3Int>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): UnityEngine.Vector3Int;
            public GetEnumerator () : UnityEngine.BoundsInt.PositionEnumerator
            public MoveNext () : boolean
            public Reset () : void
            public constructor ($min: UnityEngine.Vector3Int, $max: UnityEngine.Vector3Int)
            public constructor ()
        }
    }
    namespace UnityEngine.RectInt {
        class PositionEnumerator extends System.ValueType implements System.Collections.Generic.IEnumerator$1<UnityEngine.Vector2Int>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): UnityEngine.Vector2Int;
            public GetEnumerator () : UnityEngine.RectInt.PositionEnumerator
            public MoveNext () : boolean
            public Reset () : void
            public constructor ($min: UnityEngine.Vector2Int, $max: UnityEngine.Vector2Int)
            public constructor ()
        }
    }
    namespace UnityEngine.LightingSettings {
        enum Lightmapper
        { Enlighten = 0, ProgressiveCPU = 1, ProgressiveGPU = 2 }
        enum Sampling
        { Auto = 0, Fixed = 1 }
        enum FilterMode
        { None = 0, Auto = 1, Advanced = 2 }
        enum DenoiserType
        { None = 0, Optix = 1, OpenImage = 2, RadeonPro = 3 }
        enum FilterType
        { Gaussian = 0, ATrous = 1, None = 2 }
    }
    namespace UnityEngine.Display {
        interface DisplaysUpdatedDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var DisplaysUpdatedDelegate: { new (func: () => void): DisplaysUpdatedDelegate; }
    }
    namespace UnityEngine.Experimental.Rendering {
        /** Use this format to create either Textures or RenderTextures from scripts.
        */
        enum GraphicsFormat
        { None = 0, R8_SRGB = 1, R8G8_SRGB = 2, R8G8B8_SRGB = 3, R8G8B8A8_SRGB = 4, R8_UNorm = 5, R8G8_UNorm = 6, R8G8B8_UNorm = 7, R8G8B8A8_UNorm = 8, R8_SNorm = 9, R8G8_SNorm = 10, R8G8B8_SNorm = 11, R8G8B8A8_SNorm = 12, R8_UInt = 13, R8G8_UInt = 14, R8G8B8_UInt = 15, R8G8B8A8_UInt = 16, R8_SInt = 17, R8G8_SInt = 18, R8G8B8_SInt = 19, R8G8B8A8_SInt = 20, R16_UNorm = 21, R16G16_UNorm = 22, R16G16B16_UNorm = 23, R16G16B16A16_UNorm = 24, R16_SNorm = 25, R16G16_SNorm = 26, R16G16B16_SNorm = 27, R16G16B16A16_SNorm = 28, R16_UInt = 29, R16G16_UInt = 30, R16G16B16_UInt = 31, R16G16B16A16_UInt = 32, R16_SInt = 33, R16G16_SInt = 34, R16G16B16_SInt = 35, R16G16B16A16_SInt = 36, R32_UInt = 37, R32G32_UInt = 38, R32G32B32_UInt = 39, R32G32B32A32_UInt = 40, R32_SInt = 41, R32G32_SInt = 42, R32G32B32_SInt = 43, R32G32B32A32_SInt = 44, R16_SFloat = 45, R16G16_SFloat = 46, R16G16B16_SFloat = 47, R16G16B16A16_SFloat = 48, R32_SFloat = 49, R32G32_SFloat = 50, R32G32B32_SFloat = 51, R32G32B32A32_SFloat = 52, B8G8R8_SRGB = 56, B8G8R8A8_SRGB = 57, B8G8R8_UNorm = 58, B8G8R8A8_UNorm = 59, B8G8R8_SNorm = 60, B8G8R8A8_SNorm = 61, B8G8R8_UInt = 62, B8G8R8A8_UInt = 63, B8G8R8_SInt = 64, B8G8R8A8_SInt = 65, R4G4B4A4_UNormPack16 = 66, B4G4R4A4_UNormPack16 = 67, R5G6B5_UNormPack16 = 68, B5G6R5_UNormPack16 = 69, R5G5B5A1_UNormPack16 = 70, B5G5R5A1_UNormPack16 = 71, A1R5G5B5_UNormPack16 = 72, E5B9G9R9_UFloatPack32 = 73, B10G11R11_UFloatPack32 = 74, A2B10G10R10_UNormPack32 = 75, A2B10G10R10_UIntPack32 = 76, A2B10G10R10_SIntPack32 = 77, A2R10G10B10_UNormPack32 = 78, A2R10G10B10_UIntPack32 = 79, A2R10G10B10_SIntPack32 = 80, A2R10G10B10_XRSRGBPack32 = 81, A2R10G10B10_XRUNormPack32 = 82, R10G10B10_XRSRGBPack32 = 83, R10G10B10_XRUNormPack32 = 84, A10R10G10B10_XRSRGBPack32 = 85, A10R10G10B10_XRUNormPack32 = 86, D16_UNorm = 90, D24_UNorm = 91, D24_UNorm_S8_UInt = 92, D32_SFloat = 93, D32_SFloat_S8_UInt = 94, S8_UInt = 95, RGB_DXT1_SRGB = 96, RGBA_DXT1_SRGB = 96, RGB_DXT1_UNorm = 97, RGBA_DXT1_UNorm = 97, RGBA_DXT3_SRGB = 98, RGBA_DXT3_UNorm = 99, RGBA_DXT5_SRGB = 100, RGBA_DXT5_UNorm = 101, R_BC4_UNorm = 102, R_BC4_SNorm = 103, RG_BC5_UNorm = 104, RG_BC5_SNorm = 105, RGB_BC6H_UFloat = 106, RGB_BC6H_SFloat = 107, RGBA_BC7_SRGB = 108, RGBA_BC7_UNorm = 109, RGB_PVRTC_2Bpp_SRGB = 110, RGB_PVRTC_2Bpp_UNorm = 111, RGB_PVRTC_4Bpp_SRGB = 112, RGB_PVRTC_4Bpp_UNorm = 113, RGBA_PVRTC_2Bpp_SRGB = 114, RGBA_PVRTC_2Bpp_UNorm = 115, RGBA_PVRTC_4Bpp_SRGB = 116, RGBA_PVRTC_4Bpp_UNorm = 117, RGB_ETC_UNorm = 118, RGB_ETC2_SRGB = 119, RGB_ETC2_UNorm = 120, RGB_A1_ETC2_SRGB = 121, RGB_A1_ETC2_UNorm = 122, RGBA_ETC2_SRGB = 123, RGBA_ETC2_UNorm = 124, R_EAC_UNorm = 125, R_EAC_SNorm = 126, RG_EAC_UNorm = 127, RG_EAC_SNorm = 128, RGBA_ASTC4X4_SRGB = 129, RGBA_ASTC4X4_UNorm = 130, RGBA_ASTC5X5_SRGB = 131, RGBA_ASTC5X5_UNorm = 132, RGBA_ASTC6X6_SRGB = 133, RGBA_ASTC6X6_UNorm = 134, RGBA_ASTC8X8_SRGB = 135, RGBA_ASTC8X8_UNorm = 136, RGBA_ASTC10X10_SRGB = 137, RGBA_ASTC10X10_UNorm = 138, RGBA_ASTC12X12_SRGB = 139, RGBA_ASTC12X12_UNorm = 140, YUV2 = 141, DepthAuto = 142, ShadowAuto = 143, VideoAuto = 144, RGBA_ASTC4X4_UFloat = 145, RGBA_ASTC5X5_UFloat = 146, RGBA_ASTC6X6_UFloat = 147, RGBA_ASTC8X8_UFloat = 148, RGBA_ASTC10X10_UFloat = 149, RGBA_ASTC12X12_UFloat = 150 }
        /** Indicates how a Renderer is updated.
        */
        enum RayTracingMode
        { Off = 0, Static = 1, DynamicTransform = 2, DynamicGeometry = 3 }
        /** 
        Use a default format to create either Textures or RenderTextures from scripts based on platform specific capability.
        */
        enum DefaultFormat
        { LDR = 0, HDR = 1, DepthStencil = 2, Shadow = 3, Video = 4 }
        enum TextureCreationFlags
        { None = 0, MipChain = 1, Crunch = 64 }
        /** Use this format usages to figure out the capabilities of specific GraphicsFormat
        */
        enum FormatUsage
        { Sample = 0, Linear = 1, Sparse = 2, Render = 4, Blend = 5, GetPixels = 6, SetPixels = 7, SetPixels32 = 8, ReadPixels = 9, LoadStore = 10, MSAA2x = 11, MSAA4x = 12, MSAA8x = 13, StencilSampling = 16 }
    }
    namespace UnityEngine.GraphicsBuffer {
        enum Target
        { Vertex = 1, Index = 2, CopySource = 4, CopyDestination = 8, Structured = 16, Raw = 32, Append = 64, Counter = 128, IndirectArguments = 256, Constant = 512 }
        class IndirectDrawArgs extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static size : number
            public get vertexCountPerInstance(): number;
            public set vertexCountPerInstance(value: number);
            public get instanceCount(): number;
            public set instanceCount(value: number);
            public get startVertex(): number;
            public set startVertex(value: number);
            public get startInstance(): number;
            public set startInstance(value: number);
        }
        class IndirectDrawIndexedArgs extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public static size : number
            public get indexCountPerInstance(): number;
            public set indexCountPerInstance(value: number);
            public get instanceCount(): number;
            public set instanceCount(value: number);
            public get startIndex(): number;
            public set startIndex(value: number);
            public get baseVertexIndex(): number;
            public set baseVertexIndex(value: number);
            public get startInstance(): number;
            public set startInstance(value: number);
        }
    }
    namespace UnityEngine.Mesh {
        class MeshDataArray extends System.ValueType implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Length(): number;
            public get_Item ($index: number) : UnityEngine.Mesh.MeshData
            public Dispose () : void
        }
        class MeshData extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get vertexCount(): number;
            public get vertexBufferCount(): number;
            public get indexFormat(): UnityEngine.Rendering.IndexFormat;
            public get subMeshCount(): number;
            public set subMeshCount(value: number);
            public GetVertexBufferStride ($stream: number) : number
            public HasVertexAttribute ($attr: UnityEngine.Rendering.VertexAttribute) : boolean
            public GetVertexAttributeDimension ($attr: UnityEngine.Rendering.VertexAttribute) : number
            public GetVertexAttributeFormat ($attr: UnityEngine.Rendering.VertexAttribute) : UnityEngine.Rendering.VertexAttributeFormat
            public GetVertexAttributeStream ($attr: UnityEngine.Rendering.VertexAttribute) : number
            public GetVertexAttributeOffset ($attr: UnityEngine.Rendering.VertexAttribute) : number
            public GetVertices ($outVertices: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : void
            public GetNormals ($outNormals: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : void
            public GetTangents ($outTangents: Unity.Collections.NativeArray$1<UnityEngine.Vector4>) : void
            public GetColors ($outColors: Unity.Collections.NativeArray$1<UnityEngine.Color>) : void
            public GetColors ($outColors: Unity.Collections.NativeArray$1<UnityEngine.Color32>) : void
            public GetUVs ($channel: number, $outUVs: Unity.Collections.NativeArray$1<UnityEngine.Vector2>) : void
            public GetUVs ($channel: number, $outUVs: Unity.Collections.NativeArray$1<UnityEngine.Vector3>) : void
            public GetUVs ($channel: number, $outUVs: Unity.Collections.NativeArray$1<UnityEngine.Vector4>) : void
            public SetVertexBufferParams ($vertexCount: number, ...attributes: UnityEngine.Rendering.VertexAttributeDescriptor[]) : void
            public SetVertexBufferParams ($vertexCount: number, $attributes: Unity.Collections.NativeArray$1<UnityEngine.Rendering.VertexAttributeDescriptor>) : void
            public SetIndexBufferParams ($indexCount: number, $format: UnityEngine.Rendering.IndexFormat) : void
            public GetIndices ($outIndices: Unity.Collections.NativeArray$1<number>, $submesh: number, $applyBaseVertex?: boolean) : void
            public GetSubMesh ($index: number) : UnityEngine.Rendering.SubMeshDescriptor
            public SetSubMesh ($index: number, $desc: UnityEngine.Rendering.SubMeshDescriptor, $flags?: UnityEngine.Rendering.MeshUpdateFlags) : void
        }
    }
    namespace UnityEngine.LightProbeProxyVolume {
        enum BoundingBoxMode
        { AutomaticLocal = 0, AutomaticWorld = 1, Custom = 2 }
        enum ResolutionMode
        { Automatic = 0, Custom = 1 }
        enum ProbePositionMode
        { CellCorner = 0, CellCenter = 1 }
        enum RefreshMode
        { Automatic = 0, EveryFrame = 1, ViaScripting = 2 }
        enum QualityMode
        { Low = 0, Normal = 1 }
        enum DataFormat
        { HalfFloat = 0, Float = 1 }
    }
    namespace UnityEngine.Texture2D {
        enum EXRFlags
        { None = 0, OutputAsFloat = 1, CompressZIP = 2, CompressRLE = 4, CompressPIZ = 8 }
    }
    namespace UnityEngine.ADBannerView {
        enum Layout
        { Top = 0, Bottom = 1, TopLeft = 0, TopRight = 4, TopCenter = 8, BottomLeft = 1, BottomRight = 5, BottomCenter = 9, CenterLeft = 2, CenterRight = 6, Center = 10, Manual = -1 }
        enum Type
        { Banner = 0, MediumRect = 1 }
        interface BannerWasClickedDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var BannerWasClickedDelegate: { new (func: () => void): BannerWasClickedDelegate; }
        interface BannerWasLoadedDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var BannerWasLoadedDelegate: { new (func: () => void): BannerWasLoadedDelegate; }
    }
    namespace UnityEngine.ADInterstitialAd {
        interface InterstitialWasLoadedDelegate
        { 
        () : void; 
        Invoke?: () => void;
        }
        var InterstitialWasLoadedDelegate: { new (func: () => void): InterstitialWasLoadedDelegate; }
    }
    namespace UnityEngine.Random {
        class State extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.Scripting {
        /** PreserveAttribute prevents byte code stripping from removing a class, method, field, or property.
        */
        class PreserveAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.ShaderVariantCollection {
        class ShaderVariant extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public shader : UnityEngine.Shader
            public passType : UnityEngine.Rendering.PassType
            public keywords : System.Array$1<string>
            public constructor ($shader: UnityEngine.Shader, $passType: UnityEngine.Rendering.PassType, ...keywords: string[])
            public constructor ()
        }
    }
    namespace UnityEngine.TouchScreenKeyboard {
        enum Status
        { Visible = 0, Done = 1, Canceled = 2, LostFocus = 3 }
        class Android extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get consumesOutsideTouches(): boolean;
            public static set consumesOutsideTouches(value: boolean);
            public constructor ()
        }
    }
    namespace UnityEngine.RectTransform {
        interface ReapplyDrivenProperties
        { 
        (driven: UnityEngine.RectTransform) : void; 
        Invoke?: (driven: UnityEngine.RectTransform) => void;
        }
        var ReapplyDrivenProperties: { new (func: (driven: UnityEngine.RectTransform) => void): ReapplyDrivenProperties; }
        enum Edge
        { Left = 0, Right = 1, Top = 2, Bottom = 3 }
        enum Axis
        { Horizontal = 0, Vertical = 1 }
    }
    namespace UnityEngine.SocialPlatforms {
        interface ISocialPlatform
        {
        }
        interface ILocalUser extends UnityEngine.SocialPlatforms.IUserProfile
        {
        }
        interface IUserProfile
        {
        }
        interface IAchievementDescription
        {
        }
        interface IAchievement
        {
        }
        interface IScore
        {
        }
        interface ILeaderboard
        {
        }
    }
    namespace UnityEngine.GridLayout {
        enum CellLayout
        { Rectangle = 0, Hexagon = 1, Isometric = 2, IsometricZAsY = 3 }
        enum CellSwizzle
        { XYZ = 0, XZY = 1, YXZ = 2, YZX = 3, ZXY = 4, ZYX = 5 }
    }
    namespace UnityEngine.GUI {
        enum ToolbarButtonSize
        { Fixed = 0, FitToContents = 1 }
        interface WindowFunction
        { 
        (id: number) : void; 
        Invoke?: (id: number) => void;
        }
        var WindowFunction: { new (func: (id: number) => void): WindowFunction; }
        class Scope extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public Dispose () : void
        }
    }
    namespace UnityEngine.TextEditor {
        enum DblClickSnapping
        { WORDS = 0, PARAGRAPHS = 1 }
    }
    namespace Unity.Jobs {
        /** A handle to a job, which uniquely identifies a job scheduled in the job system.
        */
        class JobHandle extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.CompositeCollider2D {
        enum GeometryType
        { Outlines = 0, Polygons = 1 }
        enum GenerationType
        { Synchronous = 0, Manual = 1 }
    }
    namespace UnityEngine.ScreenCapture {
        enum StereoScreenCaptureMode
        { LeftEye = 1, RightEye = 2, BothEyes = 3 }
    }
    namespace UnityEngine.Terrain {
        enum MaterialType
        { BuiltInStandard = 0, BuiltInLegacyDiffuse = 1, BuiltInLegacySpecular = 2, Custom = 3 }
    }
    namespace UnityEngine.TerrainCallbacks {
        interface HeightmapChangedCallback
        { 
        (terrain: UnityEngine.Terrain, heightRegion: UnityEngine.RectInt, synched: boolean) : void; 
        Invoke?: (terrain: UnityEngine.Terrain, heightRegion: UnityEngine.RectInt, synched: boolean) => void;
        }
        var HeightmapChangedCallback: { new (func: (terrain: UnityEngine.Terrain, heightRegion: UnityEngine.RectInt, synched: boolean) => void): HeightmapChangedCallback; }
        interface TextureChangedCallback
        { 
        (terrain: UnityEngine.Terrain, textureName: string, texelRegion: UnityEngine.RectInt, synched: boolean) : void; 
        Invoke?: (terrain: UnityEngine.Terrain, textureName: string, texelRegion: UnityEngine.RectInt, synched: boolean) => void;
        }
        var TextureChangedCallback: { new (func: (terrain: UnityEngine.Terrain, textureName: string, texelRegion: UnityEngine.RectInt, synched: boolean) => void): TextureChangedCallback; }
    }
    namespace UnityEngine.Font {
        interface FontTextureRebuildCallback
        { 
        () : void; 
        Invoke?: () => void;
        }
        var FontTextureRebuildCallback: { new (func: () => void): FontTextureRebuildCallback; }
    }
    namespace UnityEngine.GridBrushBase {
        enum RotationDirection
        { Clockwise = 0, CounterClockwise = 1 }
        enum FlipAxis
        { X = 0, Y = 1 }
        enum Tool
        { Select = 0, Move = 1, Paint = 2, Box = 3, Pick = 4, Erase = 5, FloodFill = 6 }
    }
    namespace UnityEngine.CanvasRenderer {
        interface OnRequestRebuild
        { 
        () : void; 
        Invoke?: () => void;
        }
        var OnRequestRebuild: { new (func: () => void): OnRequestRebuild; }
    }
    namespace UnityEngine.UISystemProfilerApi {
        enum SampleType
        { Layout = 0, Render = 1 }
    }
    namespace UnityEngine.RemoteSettings {
        interface UpdatedEventHandler
        { 
        () : void; 
        Invoke?: () => void;
        }
        var UpdatedEventHandler: { new (func: () => void): UpdatedEventHandler; }
    }
    namespace System.Text {
        class Encoding extends System.Object implements System.ICloneable
        {
            protected [__keep_incompatibility]: never;
        }
        class StringBuilder extends System.Object implements System.Runtime.Serialization.ISerializable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace UnityEngine.InputManagerEntry {
        enum Kind
        { KeyOrButton = 0, Mouse = 1, Axis = 2 }
        enum Axis
        { X = 0, Y = 1, Third = 2, Fourth = 3, Fifth = 4, Sixth = 5, Seventh = 6, Eigth = 7 }
        enum Joy
        { All = 0, First = 1, Second = 2 }
    }
    namespace UnityEngine.LightAnchor {
        enum UpDirection
        { World = 0, Local = 1 }
    }
    namespace UnityEngine.UI.Dropdown {
        class OptionData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get text(): string;
            public set text(value: string);
            public get image(): UnityEngine.Sprite;
            public set image(value: UnityEngine.Sprite);
            public constructor ()
            public constructor ($text: string)
            public constructor ($image: UnityEngine.Sprite)
            public constructor ($text: string, $image: UnityEngine.Sprite)
        }
        class DropdownEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
        class OptionDataList extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get options(): System.Collections.Generic.List$1<UnityEngine.UI.Dropdown.OptionData>;
            public set options(value: System.Collections.Generic.List$1<UnityEngine.UI.Dropdown.OptionData>);
            public constructor ()
        }
    }
    namespace UnityEngine.UI.GraphicRaycaster {
        enum BlockingObjects
        { None = 0, TwoD = 1, ThreeD = 2, All = 3 }
    }
    namespace UnityEngine.UI.Image {
        enum Type
        { Simple = 0, Sliced = 1, Tiled = 2, Filled = 3 }
        enum FillMethod
        { Horizontal = 0, Vertical = 1, Radial90 = 2, Radial180 = 3, Radial360 = 4 }
        enum OriginHorizontal
        { Left = 0, Right = 1 }
        enum OriginVertical
        { Bottom = 0, Top = 1 }
        enum Origin90
        { BottomLeft = 0, TopLeft = 1, TopRight = 2, BottomRight = 3 }
        enum Origin180
        { Bottom = 0, Left = 1, Top = 2, Right = 3 }
        enum Origin360
        { Bottom = 0, Right = 1, Top = 2, Left = 3 }
    }
    namespace UnityEngine.UI.AspectRatioFitter {
        enum AspectMode
        { None = 0, WidthControlsHeight = 1, HeightControlsWidth = 2, FitInParent = 3, EnvelopeParent = 4 }
    }
    namespace UnityEngine.UI.CanvasScaler {
        enum ScaleMode
        { ConstantPixelSize = 0, ScaleWithScreenSize = 1, ConstantPhysicalSize = 2 }
        enum ScreenMatchMode
        { MatchWidthOrHeight = 0, Expand = 1, Shrink = 2 }
        enum Unit
        { Centimeters = 0, Millimeters = 1, Inches = 2, Points = 3, Picas = 4 }
    }
    namespace UnityEngine.UI.ContentSizeFitter {
        enum FitMode
        { Unconstrained = 0, MinSize = 1, PreferredSize = 2 }
    }
    namespace UnityEngine.UI.GridLayoutGroup {
        enum Corner
        { UpperLeft = 0, UpperRight = 1, LowerLeft = 2, LowerRight = 3 }
        enum Axis
        { Horizontal = 0, Vertical = 1 }
        enum Constraint
        { Flexible = 0, FixedColumnCount = 1, FixedRowCount = 2 }
    }
    namespace UnityEngine.UI.MaskableGraphic {
        class CullStateChangedEvent extends UnityEngine.Events.UnityEvent$1<boolean> implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
    }
    namespace UnityEngine.UI.Navigation {
        enum Mode
        { None = 0, Horizontal = 1, Vertical = 2, Automatic = 3, Explicit = 4 }
    }
    namespace UnityEngine.UI.Scrollbar {
        enum Direction
        { LeftToRight = 0, RightToLeft = 1, BottomToTop = 2, TopToBottom = 3 }
        class ScrollEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
    }
    namespace UnityEngine.UI.ScrollRect {
        enum MovementType
        { Unrestricted = 0, Elastic = 1, Clamped = 2 }
        enum ScrollbarVisibility
        { Permanent = 0, AutoHide = 1, AutoHideAndExpandViewport = 2 }
        class ScrollRectEvent extends UnityEngine.Events.UnityEvent$1<UnityEngine.Vector2> implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
    }
    namespace UnityEngine.UI.Slider {
        enum Direction
        { LeftToRight = 0, RightToLeft = 1, BottomToTop = 2, TopToBottom = 3 }
        class SliderEvent extends UnityEngine.Events.UnityEvent$1<number> implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
    }
    namespace UnityEngine.UI.DefaultControls {
        interface IFactoryControls
        {
            CreateGameObject ($name: string, ...components: System.Type[]) : UnityEngine.GameObject
        }
        class Resources extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public standard : UnityEngine.Sprite
            public background : UnityEngine.Sprite
            public inputField : UnityEngine.Sprite
            public knob : UnityEngine.Sprite
            public checkmark : UnityEngine.Sprite
            public dropdown : UnityEngine.Sprite
            public mask : UnityEngine.Sprite
        }
    }
    namespace AO {
        class DestroyTimer extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class AOView extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static UITest () : void
        }
        class ActorControlComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class ActorSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetScene ($avatar: AO.Actor) : ET.Scene
        }
        interface IMapUnit
        {
            Name : string
            ConfigId : number
            Position : Unity.Mathematics.float3
            Forward : Unity.Mathematics.float3
            Rotation : Unity.Mathematics.quaternion
        }
        interface IMapUnit {
            Entity () : ET.Entity;
            SetMapUnitComponents () : void;
            AddAOI () : void;
            CreateUnitInfo () : ET.UnitInfo;
            CheckIsCombatUnit () : boolean;
            IsPlayerActor () : boolean;
            MoveToAsync ($pathPoint: Unity.Mathematics.float3) : ET.ETTask;
            MovePathAsync ($pathPoints: System.Array$1<Unity.Mathematics.float3>) : ET.ETTask;
            Translate ($point: Unity.Mathematics.float3) : void;
            TranslateAsync ($point: Unity.Mathematics.float3) : ET.ETTask;
        }
        class Actor extends ET.Entity implements ET.IAwake, AO.IMapUnit, System.ComponentModel.ISupportInitialize, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get ActorType(): AO.ActorType;
            public set ActorType(value: AO.ActorType);
            public get Name(): string;
            public set Name(value: string);
            public get ConfigId(): number;
            public set ConfigId(value: number);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get Forward(): Unity.Mathematics.float3;
            public set Forward(value: Unity.Mathematics.float3);
            public get Rotation(): Unity.Mathematics.quaternion;
            public set Rotation(value: Unity.Mathematics.quaternion);
            public static get Main(): AO.Actor;
            public static set Main(value: AO.Actor);
            public constructor ()
            public Entity () : ET.Entity
            public SetMapUnitComponents () : void
            public AddAOI () : void
            public CreateUnitInfo () : ET.UnitInfo
            public MoveToAsync ($pathPoint: Unity.Mathematics.float3) : ET.ETTask
            public MovePathAsync ($pathPoints: System.Array$1<Unity.Mathematics.float3>) : ET.ETTask
            public Translate ($point: Unity.Mathematics.float3) : void
            public TranslateAsync ($point: Unity.Mathematics.float3) : ET.ETTask
        }
        interface Actor {
            GetScene () : ET.Scene;
            IsPlayer () : boolean;
        }
        class ChangePosition_SetTransform extends ET.AEvent$1<ET.EventType.ChangePosition> implements ET.IEvent
        {
            protected [__keep_incompatibility]: never;
            public get Type(): System.Type;
            public constructor ()
        }
        class CreateUnit_CreateUnitView extends ET.AEvent$1<ET.EventType.CreateUnit> implements ET.IEvent
        {
            protected [__keep_incompatibility]: never;
            public get Type(): System.Type;
            public constructor ()
        }
        class PropertyChanged_UpdateInfo extends ET.AEvent$1<ET.EventType.PropertyChangedEvent> implements ET.IEvent
        {
            protected [__keep_incompatibility]: never;
            public get Type(): System.Type;
            public constructor ()
        }
        class SpellStart_ChangeView extends ET.AEvent$1<ET.EventType.SpellStart> implements ET.IEvent
        {
            protected [__keep_incompatibility]: never;
            public get Type(): System.Type;
            public constructor ()
        }
        class UnitMove_SetTransform extends ET.AEvent$1<ET.EventType.UnitMove> implements ET.IEvent
        {
            protected [__keep_incompatibility]: never;
            public get Type(): System.Type;
            public constructor ()
        }
        class AttributeHPComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static AvailableValue_Changed ($self: AO.AttributeHPComponent) : void
        }
        class AttributeHPComponent extends ET.Entity implements ET.IAwake, AO.IUnitDBComponent, System.ComponentModel.ISupportInitialize, System.IDisposable, AO.IUnitAttribute
        {
            protected [__keep_incompatibility]: never;
            public get AttributeValue(): number;
            public set AttributeValue(value: number);
            public get AvailableValue(): number;
            public set AvailableValue(value: number);
            public constructor ()
        }
        interface AttributeHPComponent {
            AvailableValue_Changed () : void;
        }
        interface IUnitDBComponent
        {
        }
        interface IUnitAttribute
        {
            AttributeValue : number
            AvailableValue : number
        }
        class UnitAnimationComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Play ($self: AO.UnitAnimationComponent, $animationType: AO.AnimationType) : void
        }
        class UnitAnimationComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Animation(): UnityEngine.Animation;
            public set Animation(value: UnityEngine.Animation);
            public get AnimationType(): AO.AnimationType;
            public set AnimationType(value: AO.AnimationType);
            public constructor ()
        }
        interface UnitAnimationComponent {
            Play ($animationType: AO.AnimationType) : void;
        }
        enum AnimationType
        { None = 0, Idle = 1, Walk = 2, Run = 3, Die = 4, Attack = 5, Gethit = 6 }
        class UnitPanelComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CreatePanelObj ($self: AO.UnitPanelComponent, $asset: AssetFile.Asset) : void
            public static SetHPMax ($self: AO.UnitPanelComponent, $hp: number) : void
            public static SetHP ($self: AO.UnitPanelComponent, $hp: number) : void
        }
        class UnitPanelComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, ET.IUpdate, ET.IDestroy, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get UnitPanel(): FairyGUI.UIPanel;
            public set UnitPanel(value: FairyGUI.UIPanel);
            public constructor ()
        }
        interface UnitPanelComponent {
            CreatePanelObj ($asset: AssetFile.Asset) : void;
            SetHPMax ($hp: number) : void;
            SetHP ($hp: number) : void;
        }
        class UnitViewComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CreateViewObj ($self: AO.UnitViewComponent, $asset: AssetFile.Asset) : void
        }
        class UnitViewComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, ET.IDestroy, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get UnitObj(): UnityEngine.GameObject;
            public set UnitObj(value: UnityEngine.GameObject);
            public get DestroyWithComponent(): boolean;
            public set DestroyWithComponent(value: boolean);
            public constructor ()
        }
        interface UnitViewComponent {
            CreateViewObj ($asset: AssetFile.Asset) : void;
        }
        class OpenWindowCmd extends System.ValueType implements AO.ICommand, AO.IExecuteCommand
        {
            protected [__keep_incompatibility]: never;
            public Window : IUIWindow
            public get ExecuteAction(): System.Action$1<any>;
            public set ExecuteAction(value: System.Action$1<any>);
        }
        interface ICommand
        {
        }
        interface IExecuteCommand extends AO.ICommand
        {
            ExecuteAction : System.Action$1<any>
        }
        class UIFunctions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static OpenIn () : void
            public static Close () : void
            public static Destroy () : void
            public static OpenFrontWindow () : void
            public static OpenMiddWindow () : void
            public static OpenBackWindow () : void
        }
        class ActorControlComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, ET.IUpdate, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        interface IApp extends ET.IDomain
        {
            Zone : number
            DomainIndex : number
        }
        class AOGame extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Root : ET.Root
            public static RootScene : ET.Root
            public static ClientApp : ET.ClientApp
            public static Start ($root: ET.Root) : void
            public static Run ($app: ET.Entity) : void
            public constructor ()
        }
        class PropertyChangedAttribute extends System.Attribute implements ITnnovative.AOP.Attributes.Property.IPropertyAspect, System.Runtime.InteropServices._Attribute, ITnnovative.AOP.Attributes.Property.IPropertySetAspect, ITnnovative.AOP.Attributes.Property.IPropertySetExitAspect
        {
            protected [__keep_incompatibility]: never;
            public OnPropertySetExit ($args: ITnnovative.AOP.Processing.Execution.Arguments.PropertyExecutionArguments) : void
            public constructor ()
        }
        class ExecutionEditorModeComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, AO.IClientMode, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get BossUnit(): AO.Actor;
            public set BossUnit(value: AO.Actor);
            public constructor ()
        }
        interface IClientMode
        {
        }
        class LoadingModeComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, AO.IClientMode, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get LoadingProgress(): number;
            public set LoadingProgress(value: number);
            public constructor ()
        }
        interface LoadingModeComponent {
            SetProgressValue ($progress: number) : void;
        }
        class LobbyModeComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, AO.IClientMode, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        interface LobbyModeComponent {
            EnterMap () : $Task<any>;
        }
        class LoginModeComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, AO.IClientMode, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        interface LoginModeComponent {
            Login ($account: string, $password: string) : $Task<any>;
        }
        class MapModeComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, AO.IClientMode, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        interface MapModeComponent {
            ChangeMapScene ($map: string) : $Task<any>;
            RemoveCurrentScene () : void;
            CreateMapScene ($map: string) : ET.Scene;
        }
        class Player extends ET.Entity implements ET.IAwake$1<string>, System.ComponentModel.ISupportInitialize, ET.IDestroy, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Account(): string;
            public set Account(value: string);
            public get UnitId(): bigint;
            public set UnitId(value: bigint);
            public constructor ()
        }
        class PlayerComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, ET.IDestroy, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public idPlayers : System.Collections.Generic.Dictionary$2<bigint, AO.Player>
            public constructor ()
        }
        interface PlayerComponent {
            Add ($player: AO.Player) : void;
            Get ($id: bigint) : AO.Player;
            Remove ($id: bigint) : void;
            GetAll () : System.Array$1<AO.Player>;
        }
        enum ActorType
        { Player = 0, NonPlayer = 1 }
        enum ItemType
        { DroppedItem = 0, CollectableItem = 1 }
        class ItemUnit extends ET.Entity implements ET.IAwake, AO.IMapUnit, System.ComponentModel.ISupportInitialize, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public ItemType : AO.ItemType
            public get Name(): string;
            public set Name(value: string);
            public get ConfigId(): number;
            public set ConfigId(value: number);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get Forward(): Unity.Mathematics.float3;
            public set Forward(value: Unity.Mathematics.float3);
            public get Rotation(): Unity.Mathematics.quaternion;
            public set Rotation(value: Unity.Mathematics.quaternion);
            public get OwnerUnit(): ET.Entity;
            public set OwnerUnit(value: ET.Entity);
            public get AbilityItem(): EGamePlay.Combat.AbilityItem;
            public set AbilityItem(value: EGamePlay.Combat.AbilityItem);
            public constructor ()
            public Entity () : ET.Entity
            public SetMapUnitComponents () : void
            public AddAOI () : void
            public CreateUnitInfo () : ET.UnitInfo
            public MoveToAsync ($pathPoint: Unity.Mathematics.float3) : ET.ETTask
            public MovePathAsync ($pathPoints: System.Array$1<Unity.Mathematics.float3>) : ET.ETTask
            public Translate ($point: Unity.Mathematics.float3) : void
            public TranslateAsync ($point: Unity.Mathematics.float3) : ET.ETTask
        }
        class MapSceneComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, ET.IDestroy, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public idScenes : System.Collections.Generic.Dictionary$2<bigint, ET.Scene>
            public typeScenes : ET.UnOrderMultiMap$2<string, ET.Scene>
            public constructor ()
        }
        interface MapSceneComponent {
            Add ($scene: ET.Scene) : void;
            Get ($id: bigint) : ET.Scene;
            GetScene ($type: string) : ET.Scene;
            Remove ($id: bigint) : void;
            GetAll () : System.Array$1<ET.Scene>;
        }
        class SceneUnitComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, ET.IUpdate, ET.IDestroy, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public idUnits : System.Collections.Generic.Dictionary$2<bigint, ET.Entity>
            public idAvatars : System.Collections.Generic.Dictionary$2<bigint, AO.Actor>
            public CollisionUnitAdd : System.Collections.Generic.Queue$1<ET.Entity>
            public CollisionUnitCache : System.Collections.Generic.List$1<ET.Entity>
            public CollisionUnitRemove : System.Collections.Generic.Queue$1<ET.Entity>
            public constructor ()
        }
        interface SceneUnitComponent {
            Add ($unit: ET.Entity) : void;
            Get ($id: bigint) : ET.Entity;
            Remove ($id: bigint) : void;
            GetAll () : System.Array$1<ET.Entity>;
            GetAllAvatars () : System.Array$1<ET.Entity>;
        }
        class AIStateMachine extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get ActiveStates(): System.Collections.Generic.List$1<AO.IAIState>;
            public set ActiveStates(value: System.Collections.Generic.List$1<AO.IAIState>);
            public constructor ()
        }
        interface IAIState
        {
        }
        class PatrolAI extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, ET.IUpdate, ET.IDestroy, System.IDisposable, AO.IAIState
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class PursueAI extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, System.IDisposable, AO.IAIState
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class UnitPathMoveComponent extends ET.Entity implements ET.IAwake, AO.IBsonIgnore, System.ComponentModel.ISupportInitialize, ET.IUpdate, ET.IDestroy, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Unit(): AO.IMapUnit;
            public set Unit(value: AO.IMapUnit);
            public get PathPoints(): System.Collections.Generic.List$1<Unity.Mathematics.float3>;
            public set PathPoints(value: System.Collections.Generic.List$1<Unity.Mathematics.float3>);
            public get Speed(): number;
            public set Speed(value: number);
            public constructor ()
        }
        interface IBsonIgnore
        {
        }
        class UnitTranslateComponent extends ET.Entity implements ET.IAwake, AO.IBsonIgnore, System.ComponentModel.ISupportInitialize, ET.IUpdate, ET.IDestroy, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Unit(): AO.IMapUnit;
            public set Unit(value: AO.IMapUnit);
            public get TargetPosition(): Unity.Mathematics.float3;
            public set TargetPosition(value: Unity.Mathematics.float3);
            public get Speed(): number;
            public set Speed(value: number);
            public get PreTime(): bigint;
            public set PreTime(value: bigint);
            public get DeltaTime(): number;
            public set DeltaTime(value: number);
            public get TranslateFinish(): boolean;
            public set TranslateFinish(value: boolean);
            public get TranslateTask(): ET.ETTask;
            public set TranslateTask(value: ET.ETTask);
            public constructor ()
        }
        class AttributeMPComponent extends ET.Entity implements ET.IAwake, AO.IUnitDBComponent, System.ComponentModel.ISupportInitialize, System.IDisposable, AO.IUnitAttribute
        {
            protected [__keep_incompatibility]: never;
            public get AttributeValue(): number;
            public set AttributeValue(value: number);
            public get AvailableValue(): number;
            public set AvailableValue(value: number);
            public constructor ()
        }
        class AttributeSpellWillpowerComponent extends ET.Entity implements ET.IAwake, AO.IUnitDBComponent, System.ComponentModel.ISupportInitialize, System.IDisposable, AO.IUnitAttribute
        {
            protected [__keep_incompatibility]: never;
            public get AttributeValue(): number;
            public set AttributeValue(value: number);
            public get AvailableValue(): number;
            public set AvailableValue(value: number);
            public constructor ()
        }
        class CombatUnitComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get CombatUnit(): ET.Entity;
            public set CombatUnit(value: ET.Entity);
            public constructor ()
        }
        class UnitCombatComponent extends ET.Entity implements ET.IAwake, AO.IBsonIgnore, System.ComponentModel.ISupportInitialize, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get CombatEntity(): EGamePlay.Combat.CombatEntity;
            public set CombatEntity(value: EGamePlay.Combat.CombatEntity);
            public constructor ()
        }
        enum CollisionShape
        { Sphere = 0, Box = 1, Sector = 2, Custom = 3 }
        class UnitCollisionComponent extends ET.Entity implements ET.IAwake, AO.IBsonIgnore, System.ComponentModel.ISupportInitialize, ET.IUpdate, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get StayUnits(): System.Collections.Generic.HashSet$1<bigint>;
            public set StayUnits(value: System.Collections.Generic.HashSet$1<bigint>);
            public get CollisionShape(): AO.CollisionShape;
            public set CollisionShape(value: AO.CollisionShape);
            public get Radius(): number;
            public set Radius(value: number);
            public constructor ()
        }
        interface UnitCollisionComponent {
            OnEnterCollision ($otherUnit: AO.IMapUnit) : void;
            OnStayCollision ($otherUnit: AO.IMapUnit) : void;
            OnLeaveCollision ($otherUnit: AO.IMapUnit) : void;
        }
        class UnitLevelComponent extends ET.Entity implements ET.IAwake, AO.IUnitDBComponent, System.ComponentModel.ISupportInitialize, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Level(): number;
            public set Level(value: number);
            public constructor ()
        }
        interface UnitLevelComponent {
            Level_Changed () : void;
        }
        class UnitLifeTimeComponent extends ET.Entity implements AO.IBsonIgnore, ET.IAwake$1<number>, System.ComponentModel.ISupportInitialize, ET.IDestroy, ET.IUpdate, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get LifeTimer(): GameUtils.GameTimer;
            public set LifeTimer(value: GameUtils.GameTimer);
            public constructor ()
        }
        interface UnitLifeTimeComponent {
            DestroyEntity () : void;
        }
        class BattleState extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, AO.IUnitState, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        interface IUnitState
        {
        }
        class DeadState extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, AO.IUnitState, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class IdleState extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, ET.IDestroy, AO.IUnitState, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class LostControlState extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, AO.IUnitState, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class RunState extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, AO.IUnitState, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class UnitStateMachine extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get ActiveStates(): System.Collections.Generic.List$1<AO.IUnitState>;
            public set ActiveStates(value: System.Collections.Generic.List$1<AO.IUnitState>);
            public constructor ()
        }
        interface IUnit
        {
            Name : string
            ConfigId : number
        }
        enum UnitType
        { Actor = 1, ItemUnit = 2, Scene = 3 }
        class CfgTables extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get Tables(): cfg.Tables;
            public static set Tables(value: cfg.Tables);
            public static get TbItems(): cfg.Item.TbItems;
            public static get TbUnits(): cfg.Unit.TbUnits;
            public static get TbMaps(): cfg.Map.TbMaps;
            public constructor ()
        }
        class ActorCall extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static C2M_PathfindingResult ($request: ET.C2M_PathfindingResult) : void
            public static C2M_Stop ($request: ET.C2M_Stop) : void
            public static C2M_TestRobotCase ($request: ET.C2M_TestRobotCase) : ET.ETTask$1<ET.M2C_TestRobotCase>
            public static C2M_TestRequest ($request: ET.C2M_TestRequest) : ET.ETTask$1<ET.M2C_TestResponse>
            public static Actor_TransferRequest ($request: ET.Actor_TransferRequest) : ET.ETTask$1<ET.Actor_TransferResponse>
            public static C2M_TransferMap ($request: ET.C2M_TransferMap) : ET.ETTask$1<ET.M2C_TransferMap>
            public static C2M_SpellRequest ($request: ET.C2M_SpellRequest) : ET.ETTask$1<ET.M2C_SpellResponse>
        }
        class ActorCallTs extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static C2M_TestRobotCase ($request: ET.C2M_TestRobotCase) : System.Threading.Tasks.Task$1<ET.M2C_TestRobotCase>
            public static C2M_TestRequest ($request: ET.C2M_TestRequest) : System.Threading.Tasks.Task$1<ET.M2C_TestResponse>
            public static Actor_TransferRequest ($request: ET.Actor_TransferRequest) : System.Threading.Tasks.Task$1<ET.Actor_TransferResponse>
            public static C2M_TransferMap ($request: ET.C2M_TransferMap) : System.Threading.Tasks.Task$1<ET.M2C_TransferMap>
            public static C2M_SpellRequest ($request: ET.C2M_SpellRequest) : System.Threading.Tasks.Task$1<ET.M2C_SpellResponse>
        }
        class AvatarCall extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static C2M_PathfindingResult ($request: ET.C2M_PathfindingResult) : void
            public static C2M_Stop ($request: ET.C2M_Stop) : void
            public static C2M_TestRobotCase ($request: ET.C2M_TestRobotCase) : ET.ETTask$1<ET.M2C_TestRobotCase>
            public static C2M_TestRequest ($request: ET.C2M_TestRequest) : ET.ETTask$1<ET.M2C_TestResponse>
            public static Actor_TransferRequest ($request: ET.Actor_TransferRequest) : ET.ETTask$1<ET.Actor_TransferResponse>
            public static C2M_TransferMap ($request: ET.C2M_TransferMap) : ET.ETTask$1<ET.M2C_TransferMap>
            public static C2M_SpellRequest ($request: ET.C2M_SpellRequest) : ET.ETTask$1<ET.M2C_SpellResponse>
        }
        class AvatarCallTs extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static C2M_TestRobotCase ($request: ET.C2M_TestRobotCase) : System.Threading.Tasks.Task$1<ET.M2C_TestRobotCase>
            public static C2M_TestRequest ($request: ET.C2M_TestRequest) : System.Threading.Tasks.Task$1<ET.M2C_TestResponse>
            public static Actor_TransferRequest ($request: ET.Actor_TransferRequest) : System.Threading.Tasks.Task$1<ET.Actor_TransferResponse>
            public static C2M_TransferMap ($request: ET.C2M_TransferMap) : System.Threading.Tasks.Task$1<ET.M2C_TransferMap>
            public static C2M_SpellRequest ($request: ET.C2M_SpellRequest) : System.Threading.Tasks.Task$1<ET.M2C_SpellResponse>
        }
        class PlayerCall extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static C2G_EnterMap ($request: ET.C2G_EnterMap) : ET.ETTask$1<ET.G2C_EnterMap>
        }
        class PlayerCallTs extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static C2G_EnterMap ($request: ET.C2G_EnterMap) : System.Threading.Tasks.Task$1<ET.G2C_EnterMap>
        }
        class ServerCall extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static C2G_Ping ($request: ET.C2G_Ping) : ET.ETTask$1<ET.G2C_Ping>
            public static C2M_Reload ($request: ET.C2M_Reload) : ET.ETTask$1<ET.M2C_Reload>
            public static C2R_Login ($request: ET.C2R_Login) : ET.ETTask$1<ET.R2C_Login>
            public static C2G_LoginGate ($request: ET.C2G_LoginGate) : ET.ETTask$1<ET.G2C_LoginGate>
            public static C2G_Benchmark ($request: ET.C2G_Benchmark) : ET.ETTask$1<ET.G2C_Benchmark>
        }
        class ServerCallTs extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static C2G_Ping ($request: ET.C2G_Ping) : System.Threading.Tasks.Task$1<ET.G2C_Ping>
            public static C2M_Reload ($request: ET.C2M_Reload) : System.Threading.Tasks.Task$1<ET.M2C_Reload>
            public static C2R_Login ($request: ET.C2R_Login) : System.Threading.Tasks.Task$1<ET.R2C_Login>
            public static C2G_LoginGate ($request: ET.C2G_LoginGate) : System.Threading.Tasks.Task$1<ET.G2C_LoginGate>
            public static C2G_Benchmark ($request: ET.C2G_Benchmark) : System.Threading.Tasks.Task$1<ET.G2C_Benchmark>
        }
        class CommandAttribute extends ET.BaseAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        interface ICommandHandler
        {
            Type : System.Type
            HandleCmd ($cmd: AO.ICommand) : ET.ETTask
        }
        class EventComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, ET.IUpdate, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get RunningEvents(): System.Collections.Generic.List$1<AO.IEventRun>;
            public set RunningEvents(value: System.Collections.Generic.List$1<AO.IEventRun>);
            public get DispatchCommands(): System.Collections.Generic.Queue$1<AO.ICommand>;
            public set DispatchCommands(value: System.Collections.Generic.Queue$1<AO.ICommand>);
            public get ExecuteCommands(): System.Collections.Generic.Queue$1<AO.IExecuteCommand>;
            public set ExecuteCommands(value: System.Collections.Generic.Queue$1<AO.IExecuteCommand>);
            public get CommandHandlers(): System.Collections.Generic.Dictionary$2<System.Type, System.Collections.Generic.List$1<AO.ICommandHandler>>;
            public set CommandHandlers(value: System.Collections.Generic.Dictionary$2<System.Type, System.Collections.Generic.List$1<AO.ICommandHandler>>);
            public constructor ()
        }
        interface IEventRun
        {
        }
        class AEventRun extends System.Object implements AO.IEventRun
        {
            protected [__keep_incompatibility]: never;
            public Handle () : ET.ETTask
        }
        interface ISignal
        {
        }
        class SignalData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get StartTime(): bigint;
            public set StartTime(value: bigint);
            public get EndTime(): bigint;
            public set EndTime(value: bigint);
            public get Level(): number;
            public set Level(value: number);
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public constructor ()
        }
        class SignalComponent extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, ET.IUpdate, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Signals(): System.Collections.Generic.Dictionary$2<AO.ISignal, AO.SignalData>;
            public set Signals(value: System.Collections.Generic.Dictionary$2<AO.ISignal, AO.SignalData>);
            public constructor ()
        }
        class ClientReceiveMessages extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static M2C_OnEnterMap ($message: ET.M2C_OnEnterMap) : ET.ETTask
            public static M2C_OnLeaveMap ($message: ET.M2C_OnLeaveMap) : ET.ETTask
            public static M2C_CreateUnits ($message: ET.M2C_CreateUnits) : ET.ETTask
            public static M2C_CreateMyUnit ($message: ET.M2C_CreateMyUnit) : ET.ETTask
            public static M2C_RemoveUnits ($message: ET.M2C_RemoveUnits) : ET.ETTask
            public static M2C_ComponentPropertyNotify ($message: ET.M2C_ComponentPropertyNotify) : ET.ETTask
            public static M2C_StartSceneChange ($message: ET.M2C_StartSceneChange) : ET.ETTask
            public static M2C_PathfindingResult ($message: ET.M2C_PathfindingResult) : ET.ETTask
            public static M2C_Stop ($message: ET.M2C_Stop) : ET.ETTask
            public static M2C_SpellStart ($message: ET.M2C_SpellStart) : ET.ETTask
            public static M2C_SpellStep ($message: ET.M2C_SpellStep) : ET.ETTask
            public static M2C_SpellEnd ($message: ET.M2C_SpellEnd) : ET.ETTask
        }
        class ClientAppSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class ExecutionEditorModeSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class LoadingModeSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static SetProgressValue ($self: AO.LoadingModeComponent, $progress: number) : void
        }
        class LobbyModeSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static EnterMap ($self: AO.LobbyModeComponent) : $Task<any>
        }
        class LoginModeSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Login ($self: AO.LoginModeComponent, $account: string, $password: string) : $Task<any>
        }
        class MapModeSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ChangeMapScene ($self: AO.MapModeComponent, $map: string) : $Task<any>
            public static RemoveCurrentScene ($self: AO.MapModeComponent) : void
            public static CreateMapScene ($self: AO.MapModeComponent, $map: string) : ET.Scene
        }
        class PlayerComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Add ($self: AO.PlayerComponent, $player: AO.Player) : void
            public static Get ($self: AO.PlayerComponent, $id: bigint) : AO.Player
            public static Remove ($self: AO.PlayerComponent, $id: bigint) : void
            public static GetAll ($self: AO.PlayerComponent) : System.Array$1<AO.Player>
        }
        class ItemUnitSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class MapSceneComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Add ($self: AO.MapSceneComponent, $scene: ET.Scene) : void
            public static Get ($self: AO.MapSceneComponent, $id: bigint) : ET.Scene
            public static GetScene ($self: AO.MapSceneComponent, $type: string) : ET.Scene
            public static Remove ($self: AO.MapSceneComponent, $id: bigint) : void
            public static GetAll ($self: AO.MapSceneComponent) : System.Array$1<ET.Scene>
        }
        class SceneSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class SceneUnitComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Add ($self: AO.SceneUnitComponent, $unit: ET.Entity) : void
            public static Get ($self: AO.SceneUnitComponent, $id: bigint) : ET.Entity
            public static Remove ($self: AO.SceneUnitComponent, $id: bigint) : void
            public static GetAll ($self: AO.SceneUnitComponent) : System.Array$1<ET.Entity>
            public static GetAllAvatars ($self: AO.SceneUnitComponent) : System.Array$1<ET.Entity>
        }
        class MapUnitSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static SetMapUnitComponents ($unit: AO.IMapUnit) : void
            public static AddAOI ($unit: AO.IMapUnit) : void
            public static CreateUnitInfo ($unit: AO.IMapUnit) : ET.UnitInfo
            public static CheckIsCombatUnit ($unit: ET.Entity) : boolean
            public static CheckIsCombatUnit ($unit: AO.IMapUnit) : boolean
            public static IsPlayer ($unit: AO.Actor) : boolean
            public static IsPlayerActor ($unit: ET.Entity) : boolean
            public static IsPlayerActor ($unit: AO.IMapUnit) : boolean
        }
        class UnitPathMoveComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static MoveToAsync ($unit: AO.IMapUnit, $pathPoint: Unity.Mathematics.float3) : ET.ETTask
            public static MovePathAsync ($unit: AO.IMapUnit, $pathPoints: System.Array$1<Unity.Mathematics.float3>) : ET.ETTask
        }
        class UnitTranslateComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Translate ($unit: AO.IMapUnit, $point: Unity.Mathematics.float3) : void
            public static TranslateAsync ($unit: AO.IMapUnit, $point: Unity.Mathematics.float3) : ET.ETTask
        }
        class UnitCollisionComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static OnEnterCollision ($self: AO.UnitCollisionComponent, $otherUnit: AO.IMapUnit) : void
            public static OnStayCollision ($self: AO.UnitCollisionComponent, $otherUnit: AO.IMapUnit) : void
            public static OnLeaveCollision ($self: AO.UnitCollisionComponent, $otherUnit: AO.IMapUnit) : void
        }
        class UnitLevelComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Level_Changed ($self: AO.UnitLevelComponent) : void
        }
        class UnitLifeTimeComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static DestroyEntity ($self: AO.UnitLifeTimeComponent) : void
        }
        class UnitPathMoveEvent_Move extends ET.AEvent$1<ET.EventType.UnitPathMoveEvent> implements ET.IEvent
        {
            protected [__keep_incompatibility]: never;
            public get Type(): System.Type;
            public constructor ()
        }
        class AOCmd extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class AOEvent extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class AEventRun$1<A> extends System.Object implements AO.IEventRun
        {
            protected [__keep_incompatibility]: never;
        }
        class AEventRun$2<A1, A2> extends System.Object implements AO.IEventRun
        {
            protected [__keep_incompatibility]: never;
        }
        class EventComponentSystem extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class AssetUtils extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ReleaseWith ($asset: AssetFile.Asset, $parent: ET.Entity) : AssetFile.Asset
            public static LoadAssetWithParent ($path: string, $releaseWithParent: ET.Entity) : AssetFile.Asset
            public static LoadAssetWithParentAsync ($path: string, $releaseWithParent: ET.Entity) : AssetFile.Asset
            public static LoadSceneAsync ($asset: AssetFile.Asset, $loadSceneMode?: UnityEngine.SceneManagement.LoadSceneMode) : UnityEngine.AsyncOperation
        }
        class UIUtils extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static RemovePackage ($packageName: string) : void
            public static LoadPackage ($name: string) : AssetFile.Asset
            public static LoadPackageAsync ($name: string) : ET.ETTask$1<AssetFile.Asset>
        }
    }
    namespace AssetFile {
        class Asset extends ET.Entity implements ET.IAwake, System.ComponentModel.ISupportInitialize, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static BinaryFileList : BundleFile.BinaryFileList
            public static AssetName2Paths : System.Collections.Generic.Dictionary$2<string, string>
            public static Path2BundleNames : System.Collections.Generic.Dictionary$2<string, string>
            public static BundleName2Bundles : System.Collections.Generic.Dictionary$2<string, UnityEngine.AssetBundle>
            public static Bundle2RefCounters : System.Collections.Generic.Dictionary$2<string, number>
            public BundleName : string
            public AssetPath : string
            public static AssetLoadType : AssetFile.AssetLoadType
            public get Task(): ET.ETTask$1<AssetFile.Asset>;
            public get OnComplete(): System.Action$1<AssetFile.Asset>;
            public set OnComplete(value: System.Action$1<AssetFile.Asset>);
            public get Object(): UnityEngine.Object;
            public set Object(value: UnityEngine.Object);
            public get GameObjectPrefab(): UnityEngine.GameObject;
            public static get ArtDataPath(): string;
            public static set ArtDataPath(value: string);
            public static get StreamingDataPath(): string;
            public static set StreamingDataPath(value: string);
            public static get StreamingArtDataBinFilePath(): string;
            public static set StreamingArtDataBinFilePath(value: string);
            public GetAssetBundle () : UnityEngine.AssetBundle
            public static AddRefCounter ($bundleName: string, $counter: number) : number
            public static LoadAsset ($path: string) : AssetFile.Asset
            public static LoadAssetAsync ($path: string) : AssetFile.Asset
            public static LoadSceneAsync ($asset: AssetFile.Asset, $loadSceneMode?: UnityEngine.SceneManagement.LoadSceneMode) : UnityEngine.AsyncOperation
            public constructor ()
        }
        interface Asset {
            ReleaseWith ($parent: ET.Entity) : AssetFile.Asset;
            LoadSceneAsync ($loadSceneMode?: UnityEngine.SceneManagement.LoadSceneMode) : UnityEngine.AsyncOperation;
        }
        class AssetTimer extends ET.ATimer$1<AssetFile.Asset> implements ET.IInvoke
        {
            protected [__keep_incompatibility]: never;
            public get Type(): System.Type;
            public constructor ()
        }
        enum AssetLoadType
        { Editor = 0, LocalData = 1 }
    }
    namespace BundleFile {
        class BinaryFileList extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Runtime.CompilerServices {
        interface INotifyCompletion
        {
        }
        interface ICriticalNotifyCompletion extends System.Runtime.CompilerServices.INotifyCompletion
        {
        }
        interface ITuple
        {
        }
        interface IAsyncStateMachine
        {
        }
    }
    namespace UnityEngine.Networking {
        /** Responsible for rejecting or accepting certificates received on https requests.
        */
        class CertificateHandler extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace Puerts {
        interface ILoader
        {
            FileExists ($filepath: string) : boolean
            ReadFile ($filepath: string, $debugpath: $Ref<string>) : string
        }
        interface IModuleChecker
        {
        }
        class JsEnv extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public static jsEnvs : System.Collections.Generic.List$1<Puerts.JsEnv>
            public Backend : Puerts.Backend
            public get Index(): number;
            public ExecuteModule ($filename: string) : void
            public Eval ($chunk: string, $chunkName?: string) : void
            public ClearModuleCache () : void
            public static ClearAllModuleCaches () : void
            public AddLazyStaticWrapLoader ($type: System.Type, $lazyStaticWrapLoader: System.Func$1<Puerts.TypeRegisterInfo>) : void
            public AddLazyStaticWrapLoaderGenericDefinition ($typeDefinition: System.Type, $genericArgumentsType: System.Array$1<System.Type>, $wrapperDefinition: System.Type) : void
            public RegisterGeneralGetSet ($type: System.Type, $getter: Puerts.GeneralGetter, $setter: Puerts.GeneralSetter) : void
            public GetTypeId ($type: System.Type) : number
            public Tick () : void
            public WaitDebugger () : void
            public WaitDebuggerAsync () : $Task<any>
            public Dispose () : void
            public constructor ()
            public constructor ($loader: Puerts.ILoader, $debugPort?: number)
            public constructor ($loader: Puerts.ILoader, $externalRuntime: System.IntPtr, $externalContext: System.IntPtr)
            public constructor ($loader: Puerts.ILoader, $debugPort: number, $externalRuntime: System.IntPtr, $externalContext: System.IntPtr)
        }
        class Backend extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class TypeRegisterInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        interface GeneralGetter
        { 
        (jsEnvIdx: number, isolate: System.IntPtr, getValueApi: Puerts.IGetValueFromJs, value: System.IntPtr, isByRef: boolean) : any; 
        Invoke?: (jsEnvIdx: number, isolate: System.IntPtr, getValueApi: Puerts.IGetValueFromJs, value: System.IntPtr, isByRef: boolean) => any;
        }
        var GeneralGetter: { new (func: (jsEnvIdx: number, isolate: System.IntPtr, getValueApi: Puerts.IGetValueFromJs, value: System.IntPtr, isByRef: boolean) => any): GeneralGetter; }
        interface IGetValueFromJs
        {
        }
        interface GeneralSetter
        { 
        (jsEnvIdx: number, isolate: System.IntPtr, setValueApi: Puerts.ISetValueToJs, holder: System.IntPtr, obj: any) : void; 
        Invoke?: (jsEnvIdx: number, isolate: System.IntPtr, setValueApi: Puerts.ISetValueToJs, holder: System.IntPtr, obj: any) => void;
        }
        var GeneralSetter: { new (func: (jsEnvIdx: number, isolate: System.IntPtr, setValueApi: Puerts.ISetValueToJs, holder: System.IntPtr, obj: any) => void): GeneralSetter; }
        interface ISetValueToJs
        {
        }
    }
    namespace UnityEditorInternal {
        class AssemblyDefinitionAsset extends UnityEngine.TextAsset
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace ET.EventType {
        class ChangePosition extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Unit : ET.Entity
            public OldPos : Unity.Mathematics.float3
        }
        class CreateUnit extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Unit : ET.UnitInfo
            public MapUnit : AO.IMapUnit
            public IsMainAvatar : boolean
        }
        class PropertyChangedEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Instance : any
            public PropertyName : string
        }
        class SpellStart extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Unit : ET.Entity
            public SkillId : number
        }
        class UnitMove extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Unit : ET.Entity
            public Type : number
            public static MoveStart : number
            public static MoveEnd : number
        }
        class UnitPathMoveEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Unit : AO.IMapUnit
            public PathPoints : System.Array$1<Unity.Mathematics.float3>
            public ArriveTime : bigint
        }
        class EntryEvent1 extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class EntryEvent2 extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class EntryEvent3 extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ChangeRotation extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Unit : ET.Entity
        }
        class SpellActionEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public SpellAction : EGamePlay.Combat.SpellAction
            public Type : number
            public SkillId : number
            public static SpellStart : number
            public static SpellEnd : number
        }
        class PublishNewUnitEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Unit : AO.IMapUnit
        }
        class UnitAttributeNumericChanged extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Unit : ET.Entity
            public AttributeNumeric : EGamePlay.Combat.FloatNumeric
        }
    }
        interface IUIWindow extends IUI
        {
        }
        interface IUI
        {
        }
        enum CollisionShape
        { Sphere = 0, Box = 1, Sector = 2, Custom = 3 }
        enum CollisionMoveType
        { SelectedPosition = 0, SelectedDirection = 1, TargetFly = 2, ForwardFly = 3, PathFly = 4, SelectedDirectionPathFly = 5 }
        enum EffectApplyType
        { AllEffects = 0, Effect1 = 1, Effect2 = 2, Effect3 = 3, Other = 100 }
        enum ExecutionEventType
        { TriggerApplyEffect = 0, TriggerSpawnCollider = 1 }
        class WorkFlow extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get FlowSource(): WorkFlowSource;
            public set FlowSource(value: WorkFlowSource);
            public get PreWorkFlow(): WorkFlow;
            public set PreWorkFlow(value: WorkFlow);
            public get PostWorkFlow(): WorkFlow;
            public set PostWorkFlow(value: WorkFlow);
            public Startup () : void
            public Finish () : void
            public ToRestart () : void
            public ToEnd () : void
            public constructor ()
        }
        class WorkEndFlow extends WorkFlow
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class WorkFlowSource extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get CurrentWorkFlow(): WorkFlow;
            public get PostWorkFlow(): WorkFlow;
            public Startup () : void
            public OnFlowFinish () : void
            public constructor ()
        }
        class WorkRestartFlow extends WorkFlow
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class RaycastUtils extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CastMapPoint ($hitPoint: $Ref<UnityEngine.Vector3>) : boolean
        }
        namespace AO.ActorControlComponentSystem {
        class AwakeHandler extends ET.AwakeSystem$1<AO.ActorControlComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        class UpdateHandler extends ET.UpdateSystem$1<AO.ActorControlComponent> implements ET.ISystemType, ET.IUpdateSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.ActorSystem {
        class AwakeHandler extends ET.AwakeSystem$1<AO.Actor> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.UnitAnimationComponentSystem {
        class UnitAnimationComponentAwakeSystem extends ET.AwakeSystem$1<AO.UnitAnimationComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.UnitPanelComponentSystem {
        class AwakeSystemObject extends ET.AwakeSystem$1<AO.UnitPanelComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        class DestroySystemObject extends ET.DestroySystem$1<AO.UnitPanelComponent> implements ET.ISystemType, ET.IDestroySystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        class UpdateSystemObject extends ET.UpdateSystem$1<AO.UnitPanelComponent> implements ET.ISystemType, ET.IUpdateSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.UnitViewComponentSystem {
        class AwakeSystemObject extends ET.AwakeSystem$1<AO.UnitViewComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        class DestroySystemObject extends ET.DestroySystem$1<AO.UnitViewComponent> implements ET.ISystemType, ET.IDestroySystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace ET.ClientApp {
        interface ModuleCallback
        { 
        (type: string, arg: any) : void; 
        Invoke?: (type: string, arg: any) => void;
        }
        var ModuleCallback: { new (func: (type: string, arg: any) => void): ModuleCallback; }
    }
    namespace Unity.Mathematics {
        class float3 extends System.ValueType implements System.IFormattable, System.IEquatable$1<Unity.Mathematics.float3>
        {
            protected [__keep_incompatibility]: never;
        }
        class quaternion extends System.ValueType implements System.IFormattable, System.IEquatable$1<Unity.Mathematics.quaternion>
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace ET.DisposeActionComponent {
        interface DisposeCallback
        { 
        () : void; 
        Invoke?: () => void;
        }
        var DisposeCallback: { new (func: () => void): DisposeCallback; }
    }
    namespace ET.DisposeActionComponentSystem {
        class DisposeActionComponentAwakeSystem extends ET.AwakeSystem$1<ET.DisposeActionComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        class DisposeActionComponentDestroySystem extends ET.DestroySystem$1<ET.DisposeActionComponent> implements ET.ISystemType, ET.IDestroySystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace ITnnovative.AOP.Attributes.Property {
        interface IPropertyAspect
        {
        }
        interface IPropertySetAspect extends ITnnovative.AOP.Attributes.Property.IPropertyAspect
        {
        }
        interface IPropertySetExitAspect extends ITnnovative.AOP.Attributes.Property.IPropertyAspect, ITnnovative.AOP.Attributes.Property.IPropertySetAspect
        {
        }
    }
    namespace ITnnovative.AOP.Processing.Execution.Arguments {
        class BaseExecutionArgs extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class PropertyExecutionArguments extends ITnnovative.AOP.Processing.Execution.Arguments.BaseExecutionArgs
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace EGamePlay {
        class Entity extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get Master(): EGamePlay.MasterEntity;
            public static get EnableLog(): boolean;
            public static set EnableLog(value: boolean);
            public get Id(): bigint;
            public set Id(value: bigint);
            public get Name(): string;
            public set Name(value: string);
            public get InstanceId(): bigint;
            public set InstanceId(value: bigint);
            public get Parent(): EGamePlay.Entity;
            public get IsDisposed(): boolean;
            public get Children(): System.Collections.Generic.List$1<EGamePlay.Entity>;
            public get Id2Children(): System.Collections.Generic.Dictionary$2<bigint, EGamePlay.Entity>;
            public get Type2Children(): System.Collections.Generic.Dictionary$2<System.Type, System.Collections.Generic.List$1<EGamePlay.Entity>>;
            public get Components(): System.Collections.Generic.Dictionary$2<System.Type, EGamePlay.Component>;
            public set Components(value: System.Collections.Generic.Dictionary$2<System.Type, EGamePlay.Component>);
            public static NewEntity ($entityType: System.Type, $id?: bigint) : EGamePlay.Entity
            public static Create ($entityType: System.Type) : EGamePlay.Entity
            public static Create ($entityType: System.Type, $initData: any) : EGamePlay.Entity
            public static Destroy ($entity: EGamePlay.Entity) : void
            public Awake () : void
            public Awake ($initData: any) : void
            public Start () : void
            public Start ($initData: any) : void
            public OnSetParent ($preParent: EGamePlay.Entity, $nowParent: EGamePlay.Entity) : void
            public Update () : void
            public OnDestroy () : void
            public GetComponent ($componentType: System.Type) : EGamePlay.Component
            public Get ($componentType: System.Type) : EGamePlay.Component
            public SetChild ($child: EGamePlay.Entity) : void
            public RemoveChild ($child: EGamePlay.Entity) : void
            public AddChild ($entityType: System.Type) : EGamePlay.Entity
            public AddChild ($entityType: System.Type, $initData: any) : EGamePlay.Entity
            public GetIdChild ($id: bigint) : EGamePlay.Entity
            public GetChildren () : System.Array$1<EGamePlay.Entity>
            public Find ($name: string) : EGamePlay.Entity
            public FireEvent ($eventType: string) : void
            public FireEvent ($eventType: string, $entity: EGamePlay.Entity) : void
            public OnEvent ($eventType: string, $action: System.Action$1<EGamePlay.Entity>) : void
            public OffEvent ($eventType: string, $action: System.Action$1<EGamePlay.Entity>) : void
        }
        interface IPosition
        {
            Position : Unity.Mathematics.float3
        }
        class Component extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Entity(): EGamePlay.Entity;
            public set Entity(value: EGamePlay.Entity);
            public get IsDisposed(): boolean;
            public set IsDisposed(value: boolean);
            public get Id2Children(): System.Collections.Generic.Dictionary$2<bigint, EGamePlay.Entity>;
            public get DefaultEnable(): boolean;
            public set DefaultEnable(value: boolean);
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public get Disable(): boolean;
            public Awake () : void
            public Awake ($initData: any) : void
            public Setup () : void
            public Setup ($initData: any) : void
            public OnEnable () : void
            public OnDisable () : void
            public Update () : void
            public OnDestroy () : void
            public static Destroy ($entity: EGamePlay.Component) : void
            public constructor ()
        }
        class ExecuteClipData extends UnityEngine.ScriptableObject
        {
            protected [__keep_incompatibility]: never;
            public StartTime : number
            public EndTime : number
            public ExecuteClipType : EGamePlay.ExecuteClipType
            public ActionEventData : EGamePlay.ActionEventData
            public CollisionExecuteData : EGamePlay.CollisionExecuteData
            public AnimationData : EGamePlay.AnimationData
            public AudioData : EGamePlay.AudioData
            public ParticleEffectData : EGamePlay.ParticleEffectData
            public get TotalTime(): number;
            public set TotalTime(value: number);
            public get Name(): string;
            public set Name(value: string);
            public get Duration(): number;
            public GetClipTime () : EGamePlay.ExecuteClipData
            public constructor ()
        }
        enum ExecuteClipType
        { CollisionExecute = 0, ActionEvent = 1, Animation = 2, Audio = 3, ParticleEffect = 4 }
        class ActionEventData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public FireType : EGamePlay.FireType
            public ActionEventType : EGamePlay.FireEventType
            public EffectApply : EffectApplyType
            public NewExecution : string
            public constructor ()
        }
        class CollisionExecuteData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public ExecuteType : EGamePlay.CollisionExecuteType
            public ActionData : EGamePlay.ActionEventData
            public Shape : CollisionShape
            public Radius : number
            public Center : Unity.Mathematics.float3
            public Size : Unity.Mathematics.float3
            public MoveType : CollisionMoveType
            public ObjAsset : UnityEngine.GameObject
            public Speed : number
            public BezierCurve : NaughtyBezierCurves.BezierCurve3D
            public get ShowSpeed(): boolean;
            public get ShowPoints(): boolean;
            public GetCtrlPoints () : System.Collections.Generic.List$1<NaughtyBezierCurves.BezierPoint3D>
            public constructor ()
        }
        class AnimationData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public AnimationClip : UnityEngine.AnimationClip
            public constructor ()
        }
        class AudioData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public AudioClip : UnityEngine.AudioClip
            public constructor ()
        }
        class ParticleEffectData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public ParticleEffect : UnityEngine.GameObject
            public constructor ()
        }
        enum ExecutionTargetInputType
        { None = 0, Target = 1, Point = 2 }
        enum FireEventType
        { AssignEffect = 0, TriggerNewExecution = 1 }
        enum FireType
        { None = 0, CollisionTrigger = 2, EndTrigger = 4 }
        enum CollisionExecuteType
        { OutOfHand = 0, InHand = 1 }
        class LifeTimeComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public set DefaultEnable(value: boolean);
            public get LifeTimer(): GameUtils.GameTimer;
            public set LifeTimer(value: GameUtils.GameTimer);
            public constructor ()
        }
        class MasterEntity extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get Entities(): System.Collections.Generic.Dictionary$2<System.Type, System.Collections.Generic.List$1<EGamePlay.Entity>>;
            public get AllComponents(): System.Collections.Generic.List$1<EGamePlay.Component>;
            public get UpdateComponents(): System.Collections.Generic.List$1<EGamePlay.UpdateComponent>;
            public static get Instance(): EGamePlay.MasterEntity;
            public static Create () : EGamePlay.MasterEntity
            public static Destroy () : void
            public static Create ($entityType: System.Type) : EGamePlay.Entity
            public static Create ($entityType: System.Type, $initData: any) : EGamePlay.Entity
            public static Destroy ($entity: EGamePlay.Entity) : void
        }
        class SubscribeSubject extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public DisposeWith ($entity: EGamePlay.Entity) : EGamePlay.SubscribeSubject
            public constructor ()
        }
        class EventComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public set DefaultEnable(value: boolean);
            public static get DebugLog(): boolean;
            public static set DebugLog(value: boolean);
            public FireEvent ($eventType: string, $entity: EGamePlay.Entity) : void
            public OnEvent ($eventType: string, $action: System.Action$1<EGamePlay.Entity>) : void
            public OffEvent ($eventType: string, $action: System.Action$1<EGamePlay.Entity>) : void
            public constructor ()
        }
        class IdFactory extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get BaseRevertTicks(): bigint;
            public static set BaseRevertTicks(value: bigint);
            public static NewInstanceId () : bigint
        }
        class UpdateComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public set DefaultEnable(value: boolean);
            public constructor ()
        }
        class AbilityData extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get UniqueId(): bigint;
            public set UniqueId(value: bigint);
            public get ConfigId(): number;
            public set ConfigId(value: number);
            public get Level(): number;
            public set Level(value: number);
            public constructor ()
        }
        class AbilityHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetAbilityData ($uid: number) : EGamePlay.AbilityData
        }
        class AbilityList extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get Datas(): System.Collections.Generic.List$1<EGamePlay.AbilityData>;
            public set Datas(value: System.Collections.Generic.List$1<EGamePlay.AbilityData>);
            public constructor ()
        }
        class ItemData extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get UniqueId(): bigint;
            public set UniqueId(value: bigint);
            public get ConfigId(): number;
            public set ConfigId(value: number);
            public get Amount(): number;
            public set Amount(value: number);
            public constructor ()
        }
        class ItemHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetItemAmout ($itemConfigId: number) : number
            public static GetItemData ($itemUID: number) : EGamePlay.ItemData
        }
        class ItemList extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get Datas(): System.Collections.Generic.List$1<EGamePlay.ItemData>;
            public set Datas(value: System.Collections.Generic.List$1<EGamePlay.ItemData>);
            public constructor ()
        }
        class LevelData extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get ConfigId(): number;
            public set ConfigId(value: number);
            public get State(): number;
            public set State(value: number);
            public constructor ()
        }
        class LevelHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetLevelData ($levelId: number) : EGamePlay.LevelData
        }
        class LevelList extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get Datas(): System.Collections.Generic.Dictionary$2<number, EGamePlay.LevelData>;
            public set Datas(value: System.Collections.Generic.Dictionary$2<number, EGamePlay.LevelData>);
            public constructor ()
        }
        class PetData extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get UniqueId(): bigint;
            public set UniqueId(value: bigint);
            public get ConfigId(): number;
            public set ConfigId(value: number);
            public constructor ()
        }
        class PetHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetPetData ($petUID: number) : EGamePlay.PetData
        }
        class PetList extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get Datas(): System.Collections.Generic.List$1<EGamePlay.PetData>;
            public set Datas(value: System.Collections.Generic.List$1<EGamePlay.PetData>);
            public constructor ()
        }
        enum BezierPointType
        { corner = 0, smooth = 1, bezierCorner = 2 }
        class CtrlPoint extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public type : EGamePlay.BezierPointType
            public position : Unity.Mathematics.float3
            public get InTangent(): Unity.Mathematics.float3;
            public set InTangent(value: Unity.Mathematics.float3);
            public get OutTangent(): Unity.Mathematics.float3;
            public set OutTangent(value: Unity.Mathematics.float3);
            public constructor ()
        }
        class ExpressionHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get ExpressionParser(): B83.ExpressionParser.ExpressionParser;
            public static set ExpressionParser(value: B83.ExpressionParser.ExpressionParser);
            public static TryEvaluate ($expressionStr: string) : B83.ExpressionParser.Expression
        }
        class Log extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Debug ($log: string) : void
            public static Error ($log: string) : void
            public static Error ($e: System.Exception) : void
        }
        class ComponentView extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public Type : string
            public get Component(): any;
            public set Component(value: any);
            public constructor ()
        }
        class GameObjectComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get GameObject(): UnityEngine.GameObject;
            public OnNameChanged ($name: string) : void
            public OnAddComponent ($component: EGamePlay.Component) : void
            public OnRemoveComponent ($component: EGamePlay.Component) : void
            public OnAddChild ($child: EGamePlay.Entity) : void
            public constructor ()
        }
    }
    namespace EGamePlay.Combat {
        class AbilityItem extends EGamePlay.Entity implements EGamePlay.IPosition
        {
            protected [__keep_incompatibility]: never;
            public get ItemUnit(): ET.Entity;
            public set ItemUnit(value: ET.Entity);
            public get AbilityEntity(): EGamePlay.Entity;
            public get AbilityExecution(): EGamePlay.Combat.IAbilityExecution;
            public set AbilityExecution(value: EGamePlay.Combat.IAbilityExecution);
            public get EffectApplyType(): EffectApplyType;
            public set EffectApplyType(value: EffectApplyType);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get Rotation(): Unity.Mathematics.float3;
            public set Rotation(value: Unity.Mathematics.float3);
            public get AbilityItemTrans(): UnityEngine.Transform;
            public set AbilityItemTrans(value: UnityEngine.Transform);
            public get TargetEntity(): EGamePlay.Combat.CombatEntity;
            public set TargetEntity(value: EGamePlay.Combat.CombatEntity);
            public DestroyItem () : void
            public OnCollision ($otherCombatEntity: EGamePlay.Combat.CombatEntity) : void
            public OnTriggerNewExecution ($ActionEventData: EGamePlay.ActionEventData) : void
            public TargetFlyProcess ($InputTarget: EGamePlay.Combat.CombatEntity) : void
            public ForwardFlyProcess ($InputDirection: number) : void
            public PathFlyProcess () : void
            public DirectionPathFlyProcess () : void
            public FixedPositionProcess ($InputPoint: Unity.Mathematics.float3) : void
            public FixedDirectionProcess () : void
            public AddCollisionComponent () : AO.ItemUnit
            public CreateAbilityItemProxyObj () : UnityEngine.GameObject
            public constructor ()
        }
        class CombatEntity extends EGamePlay.Entity implements EGamePlay.IPosition
        {
            protected [__keep_incompatibility]: never;
            public get Unit(): ET.Entity;
            public set Unit(value: ET.Entity);
            public get HeroObject(): UnityEngine.GameObject;
            public set HeroObject(value: UnityEngine.GameObject);
            public get ModelTrans(): UnityEngine.Transform;
            public set ModelTrans(value: UnityEngine.Transform);
            public get CurrentHealth(): EGamePlay.Combat.HealthPoint;
            public get EffectAssignAbility(): EGamePlay.Combat.EffectAssignAbility;
            public get SpellAbility(): EGamePlay.Combat.SpellActionAbility;
            public get MotionAbility(): EGamePlay.Combat.MotionActionAbility;
            public get DamageAbility(): EGamePlay.Combat.DamageActionAbility;
            public get CureAbility(): EGamePlay.Combat.CureActionAbility;
            public get AddStatusAbility(): EGamePlay.Combat.AddStatusActionAbility;
            public get AttackSpellAbility(): EGamePlay.Combat.AttackActionAbility;
            public get RoundAbility(): EGamePlay.Combat.RoundActionAbility;
            public get JumpToAbility(): EGamePlay.Combat.JumpToActionAbility;
            public get AttackAbility(): EGamePlay.Combat.AttackAbility;
            public set AttackAbility(value: EGamePlay.Combat.AttackAbility);
            public get AttackBlockAbility(): EGamePlay.Combat.AttackBlockActionAbility;
            public set AttackBlockAbility(value: EGamePlay.Combat.AttackBlockActionAbility);
            public get SpellingExecution(): EGamePlay.Combat.SkillExecution;
            public set SpellingExecution(value: EGamePlay.Combat.SkillExecution);
            public get NameSkills(): System.Collections.Generic.Dictionary$2<string, EGamePlay.Combat.SkillAbility>;
            public set NameSkills(value: System.Collections.Generic.Dictionary$2<string, EGamePlay.Combat.SkillAbility>);
            public get IdSkills(): System.Collections.Generic.Dictionary$2<number, EGamePlay.Combat.SkillAbility>;
            public set IdSkills(value: System.Collections.Generic.Dictionary$2<number, EGamePlay.Combat.SkillAbility>);
            public get InputSkills(): System.Collections.Generic.Dictionary$2<UnityEngine.KeyCode, EGamePlay.Combat.SkillAbility>;
            public set InputSkills(value: System.Collections.Generic.Dictionary$2<UnityEngine.KeyCode, EGamePlay.Combat.SkillAbility>);
            public get TypeIdStatuses(): System.Collections.Generic.Dictionary$2<string, System.Collections.Generic.List$1<EGamePlay.Combat.StatusAbility>>;
            public set TypeIdStatuses(value: System.Collections.Generic.Dictionary$2<string, System.Collections.Generic.List$1<EGamePlay.Combat.StatusAbility>>);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get Rotation(): Unity.Mathematics.float3;
            public set Rotation(value: Unity.Mathematics.float3);
            public get ActionControlType(): EGamePlay.Combat.ActionControlType;
            public set ActionControlType(value: EGamePlay.Combat.ActionControlType);
            public get ActionControlImmuneType(): EGamePlay.Combat.ActionControlType;
            public set ActionControlImmuneType(value: EGamePlay.Combat.ActionControlType);
            public get SeatNumber(): number;
            public set SeatNumber(value: number);
            public get JumpToTime(): number;
            public set JumpToTime(value: number);
            public get IsHero(): boolean;
            public set IsHero(value: boolean);
            public get IsMonster(): boolean;
            public ListenActionPoint ($actionPointType: EGamePlay.Combat.ActionPointType, $action: System.Action$1<EGamePlay.Entity>) : void
            public UnListenActionPoint ($actionPointType: EGamePlay.Combat.ActionPointType, $action: System.Action$1<EGamePlay.Entity>) : void
            public TriggerActionPoint ($actionPointType: EGamePlay.Combat.ActionPointType, $action: EGamePlay.Entity) : void
            public ListenerCondition ($conditionType: EGamePlay.Combat.ConditionEventType, $action: System.Action, $paramObj?: any) : void
            public UnListenCondition ($conditionType: EGamePlay.Combat.ConditionEventType, $action: System.Action) : void
            public CheckDead () : boolean
            public AttachSkill ($configObject: any) : EGamePlay.Combat.SkillAbility
            public AttachStatus ($configObject: any) : EGamePlay.Combat.StatusAbility
            public OnStatusRemove ($statusAbility: EGamePlay.Combat.StatusAbility) : void
            public BindSkillInput ($abilityEntity: EGamePlay.Combat.SkillAbility, $keyCode: UnityEngine.KeyCode) : void
            public HasStatus ($statusTypeId: string) : boolean
            public GetStatus ($statusTypeId: string) : EGamePlay.Combat.StatusAbility
            public GetEnemy ($seat: number) : EGamePlay.Combat.CombatEntity
            public GetTeammate ($seat: number) : EGamePlay.Combat.CombatEntity
            public constructor ()
        }
        class AbilityLevelComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get Level(): number;
            public set Level(value: number);
            public constructor ()
        }
        interface IAbilityEntity
        {
            OwnerEntity : EGamePlay.Combat.CombatEntity
            ParentEntity : EGamePlay.Combat.CombatEntity
            Enable : boolean
            TryActivateAbility () : void
            ActivateAbility () : void
            DeactivateAbility () : void
            EndAbility () : void
            CreateExecution () : EGamePlay.Entity
        }
        interface IAbilityExecution
        {
            AbilityEntity : EGamePlay.Entity
            OwnerEntity : EGamePlay.Combat.CombatEntity
            BeginExecute () : void
            EndExecute () : void
        }
        class ApplyEffectEvent extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public AbilityEffect : EGamePlay.Combat.AbilityEffect
            public constructor ()
        }
        class AbilityEffect extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public get OwnerAbility(): EGamePlay.Entity;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public get EffectConfig(): EGamePlay.Combat.Effect;
            public set EffectConfig(value: EGamePlay.Combat.Effect);
            public get EffectSourceType(): EGamePlay.Combat.EffectSourceType;
            public set EffectSourceType(value: EGamePlay.Combat.EffectSourceType);
            public get TriggerEventBind(): EGamePlay.Combat.EffectTriggerEventBind;
            public set TriggerEventBind(value: EGamePlay.Combat.EffectTriggerEventBind);
            public EnableEffect () : void
            public DisableEffect () : void
            public CreateAssignAction ($targetEntity: EGamePlay.Entity) : EGamePlay.Combat.EffectAssignAction
            public constructor ()
        }
        enum EffectSourceType
        { Ability = 0, Execution = 1 }
        interface IEffectTriggerSystem
        {
            OnTriggerApplyEffect ($effectAssign: EGamePlay.Entity) : void
        }
        class Effect extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public IsSkillEffect : boolean
            public IsExecutionEffect : boolean
            public Enabled : boolean
            public AddSkillEffectTargetType : EGamePlay.Combat.AddSkillEffetTargetType
            public EffectTriggerType : EGamePlay.Combat.EffectTriggerType
            public ActionPointType : EGamePlay.Combat.ActionPointType
            public ConditionType : EGamePlay.Combat.ConditionEventType
            public Interval : string
            public ConditionParam : string
            public TriggerProbability : string
            public Decorators : System.Collections.Generic.List$1<EGamePlay.Combat.EffectDecorator>
            public EffectTypeName : string
            public static EffectTypeNameStr : string
            public get HideTriggerType(): boolean;
            public get Label(): string;
            public EffectTypeSelect () : System.Collections.Generic.IEnumerable$1<string>
        }
        class EffectTriggerEventBind extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public get OwnerAbility(): EGamePlay.Combat.IAbilityEntity;
            public get SkillAbility(): EGamePlay.Combat.SkillAbility;
            public get AffectCheck(): string;
            public set AffectCheck(value: string);
            public get ConditionChecks(): System.Collections.Generic.List$1<EGamePlay.Combat.IConditionCheckSystem>;
            public set ConditionChecks(value: System.Collections.Generic.List$1<EGamePlay.Combat.IConditionCheckSystem>);
            public get ActionPointBinds(): System.Collections.Generic.List$1<EGamePlay.Entity>;
            public set ActionPointBinds(value: System.Collections.Generic.List$1<EGamePlay.Entity>);
            public EnableTriggerBind () : void
            public TriggerEffectCheck ($skillExecution: EGamePlay.Combat.SkillExecution) : void
            public TriggerEffectCheckWithTarget ($target: EGamePlay.Entity) : void
            public TriggerEffectToParent () : void
            public constructor ()
        }
        class EffectAssignAction extends EGamePlay.Entity implements EGamePlay.Combat.IActionExecution
        {
            protected [__keep_incompatibility]: never;
            public get SourceAbility(): EGamePlay.Entity;
            public set SourceAbility(value: EGamePlay.Entity);
            public get TargetAction(): EGamePlay.Combat.IActionExecution;
            public set TargetAction(value: EGamePlay.Combat.IActionExecution);
            public get AbilityEffect(): EGamePlay.Combat.AbilityEffect;
            public set AbilityEffect(value: EGamePlay.Combat.AbilityEffect);
            public get AbilityItem(): EGamePlay.Combat.AbilityItem;
            public set AbilityItem(value: EGamePlay.Combat.AbilityItem);
            public get EffectConfig(): EGamePlay.Combat.Effect;
            public get ActionAbility(): EGamePlay.Entity;
            public set ActionAbility(value: EGamePlay.Entity);
            public get SourceAssignAction(): EGamePlay.Combat.EffectAssignAction;
            public set SourceAssignAction(value: EGamePlay.Combat.EffectAssignAction);
            public get Creator(): EGamePlay.Combat.CombatEntity;
            public set Creator(value: EGamePlay.Combat.CombatEntity);
            public get Target(): EGamePlay.Combat.CombatEntity;
            public set Target(value: EGamePlay.Combat.CombatEntity);
            public get AssignTarget(): EGamePlay.Entity;
            public set AssignTarget(value: EGamePlay.Entity);
            public AssignEffect () : void
            public FinishAction () : void
            public constructor ()
        }
        interface IActionExecution
        {
            ActionAbility : EGamePlay.Entity
            SourceAssignAction : EGamePlay.Combat.EffectAssignAction
            Creator : EGamePlay.Combat.CombatEntity
            Target : EGamePlay.Combat.CombatEntity
            FinishAction () : void
        }
        class AbilityEffectComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public set DefaultEnable(value: boolean);
            public get AbilityEffects(): System.Collections.Generic.List$1<EGamePlay.Combat.AbilityEffect>;
            public get DamageAbilityEffect(): EGamePlay.Combat.AbilityEffect;
            public set DamageAbilityEffect(value: EGamePlay.Combat.AbilityEffect);
            public get CureAbilityEffect(): EGamePlay.Combat.AbilityEffect;
            public set CureAbilityEffect(value: EGamePlay.Combat.AbilityEffect);
            public AddEffect ($abilityEffect: EGamePlay.Combat.AbilityEffect) : void
            public GetEffect ($index?: number) : EGamePlay.Combat.AbilityEffect
            public CreateAssignActionByIndex ($targetEntity: EGamePlay.Entity, $index: number) : EGamePlay.Combat.EffectAssignAction
            public CreateAssignActions ($targetEntity: EGamePlay.Entity) : System.Collections.Generic.List$1<EGamePlay.Combat.EffectAssignAction>
            public constructor ()
        }
        class EffectActionControlComponent extends EGamePlay.Component implements EGamePlay.Combat.IEffectTriggerSystem
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public get ActionControlEffect(): EGamePlay.Combat.ActionControlEffect;
            public set ActionControlEffect(value: EGamePlay.Combat.ActionControlEffect);
            public get ActionControlType(): EGamePlay.Combat.ActionControlType;
            public set ActionControlType(value: EGamePlay.Combat.ActionControlType);
            public OnTriggerApplyEffect ($effectAssign: EGamePlay.Entity) : void
            public constructor ()
        }
        class ActionControlEffect extends EGamePlay.Combat.Effect
        {
            protected [__keep_incompatibility]: never;
            public ActionControlType : EGamePlay.Combat.ActionControlType
            public get Label(): string;
            public constructor ()
        }
        enum ActionControlType
        { None = 0, MoveForbid = 2, SkillForbid = 4, AttackForbid = 8, MoveControl = 16, AttackControl = 32 }
        class EffectAddStatusComponent extends EGamePlay.Component implements EGamePlay.Combat.IEffectTriggerSystem
        {
            protected [__keep_incompatibility]: never;
            public get AddStatusEffect(): EGamePlay.Combat.AddStatusEffect;
            public set AddStatusEffect(value: EGamePlay.Combat.AddStatusEffect);
            public get Duration(): number;
            public set Duration(value: number);
            public get NumericValueProperty(): string;
            public set NumericValueProperty(value: string);
            public GetNumericValue () : number
            public OnTriggerApplyEffect ($effectAssign: EGamePlay.Entity) : void
            public constructor ()
        }
        class AddStatusEffect extends EGamePlay.Combat.Effect
        {
            protected [__keep_incompatibility]: never;
            public AddStatus : EGamePlay.Combat.StatusConfigObject
            public Duration : number
            public Params : System.Collections.Generic.Dictionary$2<string, string>
            public get Label(): string;
            public get AddStatusId(): string;
            public set AddStatusId(value: string);
            public constructor ()
        }
        class EffectAttributeModifyComponent extends EGamePlay.Component implements EGamePlay.Combat.IEffectTriggerSystem
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public get AttributeModifyEffect(): EGamePlay.Combat.AttributeModifyEffect;
            public set AttributeModifyEffect(value: EGamePlay.Combat.AttributeModifyEffect);
            public get AttributeModifier(): EGamePlay.Combat.FloatModifier;
            public set AttributeModifier(value: EGamePlay.Combat.FloatModifier);
            public get ModifyValueFormula(): string;
            public set ModifyValueFormula(value: string);
            public OnTriggerApplyEffect ($effectAssign: EGamePlay.Entity) : void
            public constructor ()
        }
        class AttributeModifyEffect extends EGamePlay.Combat.Effect
        {
            protected [__keep_incompatibility]: never;
            public AttributeType : EGamePlay.Combat.AttributeType
            public NumericValue : string
            public ModifyType : EGamePlay.Combat.ModifyType
            public get Label(): string;
            public constructor ()
        }
        class FloatModifier extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Value : number
            public constructor ()
        }
        class EffectCureComponent extends EGamePlay.Component implements EGamePlay.Combat.IEffectTriggerSystem
        {
            protected [__keep_incompatibility]: never;
            public get CureEffect(): EGamePlay.Combat.CureEffect;
            public set CureEffect(value: EGamePlay.Combat.CureEffect);
            public get CureValueProperty(): string;
            public set CureValueProperty(value: string);
            public GetCureValue () : number
            public OnTriggerApplyEffect ($effectAssign: EGamePlay.Entity) : void
            public constructor ()
        }
        class CureEffect extends EGamePlay.Combat.Effect
        {
            protected [__keep_incompatibility]: never;
            public CureValueFormula : string
            public get Label(): string;
            public get CureValueProperty(): string;
            public set CureValueProperty(value: string);
            public constructor ()
        }
        class EffectCustomComponent extends EGamePlay.Component implements EGamePlay.Combat.IEffectTriggerSystem
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public OnTriggerApplyEffect ($effectAssign: EGamePlay.Entity) : void
            public constructor ()
        }
        class EffectDamageComponent extends EGamePlay.Component implements EGamePlay.Combat.IEffectTriggerSystem
        {
            protected [__keep_incompatibility]: never;
            public get DamageEffect(): EGamePlay.Combat.DamageEffect;
            public set DamageEffect(value: EGamePlay.Combat.DamageEffect);
            public get DamageValueFormula(): string;
            public set DamageValueFormula(value: string);
            public GetDamageValue () : number
            public OnTriggerApplyEffect ($effectAssign: EGamePlay.Entity) : void
            public constructor ()
        }
        class DamageEffect extends EGamePlay.Combat.Effect
        {
            protected [__keep_incompatibility]: never;
            public DamageType : EGamePlay.Combat.DamageType
            public DamageValueFormula : string
            public CanCrit : boolean
            public get Label(): string;
            public constructor ()
        }
        class EffectDamageReduceWithTargetCountComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get ReducePercent(): number;
            public set ReducePercent(value: number);
            public get MinPercent(): number;
            public set MinPercent(value: number);
            public GetDamagePercent ($TargetCounter: number) : number
            public constructor ()
        }
        class EffectDecoratosComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ConditionTargetStateCheck extends EGamePlay.Entity implements EGamePlay.Combat.IConditionCheckSystem
        {
            protected [__keep_incompatibility]: never;
            public get OwnerBattler(): EGamePlay.Combat.CombatEntity;
            public get AffectCheck(): string;
            public set AffectCheck(value: string);
            public get IsInvert(): boolean;
            public CheckCondition ($target: EGamePlay.Entity) : boolean
            public constructor ()
        }
        interface IConditionCheckSystem
        {
            IsInvert : boolean
            CheckCondition ($target: EGamePlay.Entity) : boolean
        }
        class EffectActionPointTriggerComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public set DefaultEnable(value: boolean);
            public constructor ()
        }
        class EffectConditionEventTriggerComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public set DefaultEnable(value: boolean);
            public get ConditionParamValue(): string;
            public set ConditionParamValue(value: string);
            public constructor ()
        }
        class SkillAbility extends EGamePlay.Entity implements EGamePlay.Combat.IAbilityEntity
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get ParentEntity(): EGamePlay.Combat.CombatEntity;
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public get SkillConfig(): EGamePlay.Combat.SkillConfigObject;
            public set SkillConfig(value: EGamePlay.Combat.SkillConfigObject);
            public get Spelling(): boolean;
            public set Spelling(value: boolean);
            public get CooldownTimer(): GameUtils.GameTimer;
            public get ExecutionObject(): EGamePlay.Combat.ExecutionObject;
            public set ExecutionObject(value: EGamePlay.Combat.ExecutionObject);
            public LoadExecution () : void
            public TryActivateAbility () : void
            public DeactivateAbility () : void
            public ActivateAbility () : void
            public EndAbility () : void
            public CreateExecution () : EGamePlay.Entity
            public constructor ()
        }
        class SkillExecution extends EGamePlay.Entity implements EGamePlay.Combat.IAbilityExecution
        {
            protected [__keep_incompatibility]: never;
            public get AbilityEntity(): EGamePlay.Entity;
            public set AbilityEntity(value: EGamePlay.Entity);
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get SkillAbility(): EGamePlay.Combat.SkillAbility;
            public get ExecutionObject(): EGamePlay.Combat.ExecutionObject;
            public set ExecutionObject(value: EGamePlay.Combat.ExecutionObject);
            public get SkillTargets(): System.Collections.Generic.List$1<EGamePlay.Combat.CombatEntity>;
            public set SkillTargets(value: System.Collections.Generic.List$1<EGamePlay.Combat.CombatEntity>);
            public get InputTarget(): EGamePlay.Combat.CombatEntity;
            public set InputTarget(value: EGamePlay.Combat.CombatEntity);
            public get InputPoint(): Unity.Mathematics.float3;
            public set InputPoint(value: Unity.Mathematics.float3);
            public get InputDirection(): number;
            public set InputDirection(value: number);
            public get OriginTime(): bigint;
            public set OriginTime(value: bigint);
            public get ActionOccupy(): boolean;
            public set ActionOccupy(value: boolean);
            public LoadExecutionEffects () : void
            public BeginExecute () : void
            public EndExecute () : void
            public constructor ()
        }
        class EffectTargetSelection extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get TargetSelect(): string;
            public set TargetSelect(value: string);
            public get OwnerBattler(): EGamePlay.Combat.CombatEntity;
            public get OwnerAbility(): EGamePlay.Combat.IAbilityEntity;
            public GetTargets () : System.Array$1<EGamePlay.Combat.CombatEntity>
            public constructor ()
        }
        class ExecuteAnimationComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get AnimationClip(): UnityEngine.AnimationClip;
            public set AnimationClip(value: UnityEngine.AnimationClip);
            public OnTriggerExecutionEffect ($entity: EGamePlay.Entity) : void
            public constructor ()
        }
        class ExecuteAssignEffectToTargetComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public set DefaultEnable(value: boolean);
            public get EffectApplyType(): EffectApplyType;
            public set EffectApplyType(value: EffectApplyType);
            public OnTriggerExecuteEffect ($evnt: EGamePlay.Combat.ExecuteEffectEvent) : void
            public constructor ()
        }
        class ExecuteEffectEvent extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public ExecutionEffect : EGamePlay.Combat.ExecuteClip
            public constructor ()
        }
        class ExecuteCollisionItemComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get CollisionExecuteData(): EGamePlay.CollisionExecuteData;
            public set CollisionExecuteData(value: EGamePlay.CollisionExecuteData);
            public OnTriggerExecutionEffect ($entity: EGamePlay.Entity) : void
            public SpawnCollisionItem ($clipData: EGamePlay.ExecuteClipData) : void
            public OnTriggerEnd ($entity: EGamePlay.Entity) : void
            public constructor ()
        }
        class ExecuteParticleEffectComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get ParticleEffectPrefab(): UnityEngine.GameObject;
            public set ParticleEffectPrefab(value: UnityEngine.GameObject);
            public get ParticleEffectObj(): UnityEngine.GameObject;
            public set ParticleEffectObj(value: UnityEngine.GameObject);
            public OnTriggerStart ($entity: EGamePlay.Entity) : void
            public OnTriggerEnd ($entity: EGamePlay.Entity) : void
            public constructor ()
        }
        class ExecuteTriggerNewExecutionComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get ActionEventData(): EGamePlay.ActionEventData;
            public set ActionEventData(value: EGamePlay.ActionEventData);
            public OnTriggerExecutionEffect ($evnt: EGamePlay.Combat.ExecuteEffectEvent) : void
            public constructor ()
        }
        class ExecuteTimeTriggerComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public set DefaultEnable(value: boolean);
            public get StartTime(): number;
            public set StartTime(value: number);
            public get EndTime(): number;
            public set EndTime(value: number);
            public get TimeValueExpression(): string;
            public set TimeValueExpression(value: string);
            public get StartTimer(): GameUtils.GameTimer;
            public set StartTimer(value: GameUtils.GameTimer);
            public get EndTimer(): GameUtils.GameTimer;
            public set EndTimer(value: GameUtils.GameTimer);
            public constructor ()
        }
        class ExecuteClip extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get ExecutionEffectConfig(): EGamePlay.ExecuteClipData;
            public set ExecutionEffectConfig(value: EGamePlay.ExecuteClipData);
            public get ParentExecution(): EGamePlay.Combat.SkillExecution;
            public BeginExecute () : void
            public TriggerEffect () : void
            public EndEffect () : void
            public constructor ()
        }
        class ExecutionClipComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get ExecuteClips(): System.Collections.Generic.List$1<EGamePlay.Combat.ExecuteClip>;
            public AddEffect ($executionEffect: EGamePlay.Combat.ExecuteClip) : void
            public BeginExecute () : void
            public constructor ()
        }
        class AbilityItemCollisionExecuteComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get ExecuteClipData(): EGamePlay.ExecuteClipData;
            public get CollisionExecuteData(): EGamePlay.CollisionExecuteData;
            public constructor ()
        }
        class AbilityItemPathMoveComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get PositionEntity(): EGamePlay.IPosition;
            public set PositionEntity(value: EGamePlay.IPosition);
            public get RotateAgree(): number;
            public set RotateAgree(value: number);
            public get Duration(): number;
            public set Duration(value: number);
            public get Speed(): number;
            public set Speed(value: number);
            public get Progress(): number;
            public set Progress(value: number);
            public get BezierCurve(): NaughtyBezierCurves.BezierCurve3D;
            public set BezierCurve(value: NaughtyBezierCurves.BezierCurve3D);
            public GetPathPoints () : System.Array$1<Unity.Mathematics.float3>
            public constructor ()
        }
        class AbilityItemTargetCounterComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get TargetCounter(): number;
            public set TargetCounter(value: number);
            public constructor ()
        }
        class ActionPoint extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Listeners(): System.Collections.Generic.List$1<System.Action$1<EGamePlay.Entity>>;
            public set Listeners(value: System.Collections.Generic.List$1<System.Action$1<EGamePlay.Entity>>);
            public AddListener ($action: System.Action$1<EGamePlay.Entity>) : void
            public RemoveListener ($action: System.Action$1<EGamePlay.Entity>) : void
            public TriggerAllActions ($actionExecution: EGamePlay.Entity) : void
            public constructor ()
        }
        enum ActionPointType
        { None = 0, PreCauseDamage = 2, PreReceiveDamage = 4, PostCauseDamage = 8, PostReceiveDamage = 16, PostGiveCure = 32, PostReceiveCure = 64, AssignEffect = 128, ReceiveEffect = 256, PostGiveStatus = 512, PostReceiveStatus = 1024, PreGiveAttack = 2048, PostGiveAttack = 4096, PreReceiveAttack = 8192, PostReceiveAttack = 16384, PreJumpTo = 32768, PostJumpTo = 65536, PreSpell = 131072, PostSpell = 262144, PreGiveAttackEffect = 524288, PostGiveAttackEffect = 1048576, PreReceiveAttackEffect = 2097152, PostReceiveAttackEffect = 4194304, Max = 4194305 }
        class AddStatusActionAbility extends EGamePlay.Entity implements EGamePlay.Combat.IActionAbility
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public TryMakeAction ($action: $Ref<EGamePlay.Combat.AddStatusAction>) : boolean
            public constructor ()
        }
        interface IActionAbility
        {
            OwnerEntity : EGamePlay.Combat.CombatEntity
            Enable : boolean
        }
        class AddStatusAction extends EGamePlay.Entity implements EGamePlay.Combat.IActionExecution
        {
            protected [__keep_incompatibility]: never;
            public get SourceAbility(): EGamePlay.Entity;
            public set SourceAbility(value: EGamePlay.Entity);
            public get AddStatusEffect(): EGamePlay.Combat.AddStatusEffect;
            public get Status(): EGamePlay.Combat.StatusAbility;
            public set Status(value: EGamePlay.Combat.StatusAbility);
            public get ActionAbility(): EGamePlay.Entity;
            public set ActionAbility(value: EGamePlay.Entity);
            public get SourceAssignAction(): EGamePlay.Combat.EffectAssignAction;
            public set SourceAssignAction(value: EGamePlay.Combat.EffectAssignAction);
            public get Creator(): EGamePlay.Combat.CombatEntity;
            public set Creator(value: EGamePlay.Combat.CombatEntity);
            public get Target(): EGamePlay.Combat.CombatEntity;
            public set Target(value: EGamePlay.Combat.CombatEntity);
            public FinishAction () : void
            public ApplyAddStatus () : void
            public constructor ()
        }
        class StatusAbility extends EGamePlay.Entity implements EGamePlay.Combat.IAbilityEntity
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get ParentEntity(): EGamePlay.Combat.CombatEntity;
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public get StatusConfig(): EGamePlay.Combat.StatusConfigObject;
            public set StatusConfig(value: EGamePlay.Combat.StatusConfigObject);
            public get ActionControlType(): EGamePlay.Combat.ActionControlType;
            public set ActionControlType(value: EGamePlay.Combat.ActionControlType);
            public get AddModifiers(): System.Collections.Generic.Dictionary$2<string, EGamePlay.Combat.FloatModifier>;
            public set AddModifiers(value: System.Collections.Generic.Dictionary$2<string, EGamePlay.Combat.FloatModifier>);
            public get PctAddModifiers(): System.Collections.Generic.Dictionary$2<string, EGamePlay.Combat.FloatModifier>;
            public set PctAddModifiers(value: System.Collections.Generic.Dictionary$2<string, EGamePlay.Combat.FloatModifier>);
            public get IsChildStatus(): boolean;
            public set IsChildStatus(value: boolean);
            public get Duration(): number;
            public set Duration(value: number);
            public get ChildStatusData(): EGamePlay.Combat.ChildStatus;
            public set ChildStatusData(value: EGamePlay.Combat.ChildStatus);
            public ActivateAbility () : void
            public EndAbility () : void
            public GetDuration () : number
            public CreateExecution () : EGamePlay.Entity
            public TryActivateAbility () : void
            public DeactivateAbility () : void
            public ProcessInputKVParams ($Params: System.Collections.Generic.Dictionary$2<string, string>) : void
            public constructor ()
        }
        class AttackActionAbility extends EGamePlay.Entity implements EGamePlay.Combat.IActionAbility
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public TryMakeAction ($action: $Ref<EGamePlay.Combat.AttackAction>) : boolean
            public constructor ()
        }
        class AttackAction extends EGamePlay.Entity implements EGamePlay.Combat.IActionExecution
        {
            protected [__keep_incompatibility]: never;
            public get ActionAbility(): EGamePlay.Entity;
            public set ActionAbility(value: EGamePlay.Entity);
            public get SourceAssignAction(): EGamePlay.Combat.EffectAssignAction;
            public set SourceAssignAction(value: EGamePlay.Combat.EffectAssignAction);
            public get Creator(): EGamePlay.Combat.CombatEntity;
            public set Creator(value: EGamePlay.Combat.CombatEntity);
            public get Target(): EGamePlay.Combat.CombatEntity;
            public set Target(value: EGamePlay.Combat.CombatEntity);
            public get AttackExecution(): EGamePlay.Combat.AttackExecution;
            public set AttackExecution(value: EGamePlay.Combat.AttackExecution);
            public FinishAction () : void
            public ApplyAttackAwait () : ET.ETTask
            public ApplyAttack () : void
            public constructor ()
        }
        class AttackExecution extends EGamePlay.Entity implements EGamePlay.Combat.IAbilityExecution
        {
            protected [__keep_incompatibility]: never;
            public get AttackAction(): EGamePlay.Combat.AttackAction;
            public set AttackAction(value: EGamePlay.Combat.AttackAction);
            public get AbilityEntity(): EGamePlay.Entity;
            public set AbilityEntity(value: EGamePlay.Entity);
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public SetBlocked () : void
            public BeginExecute () : void
            public EndExecute () : void
            public constructor ()
        }
        class AttackBlockActionAbility extends EGamePlay.Entity implements EGamePlay.Combat.IActionAbility
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public TryMakeAction ($action: $Ref<EGamePlay.Combat.AttackBlockAction>) : boolean
            public TryBlock ($action: EGamePlay.Entity) : void
            public constructor ()
        }
        class AttackBlockAction extends EGamePlay.Entity implements EGamePlay.Combat.IActionExecution
        {
            protected [__keep_incompatibility]: never;
            public get ActionAbility(): EGamePlay.Entity;
            public set ActionAbility(value: EGamePlay.Entity);
            public get SourceAssignAction(): EGamePlay.Combat.EffectAssignAction;
            public set SourceAssignAction(value: EGamePlay.Combat.EffectAssignAction);
            public get Creator(): EGamePlay.Combat.CombatEntity;
            public set Creator(value: EGamePlay.Combat.CombatEntity);
            public get Target(): EGamePlay.Combat.CombatEntity;
            public set Target(value: EGamePlay.Combat.CombatEntity);
            public get AttackExecution(): EGamePlay.Combat.AttackExecution;
            public set AttackExecution(value: EGamePlay.Combat.AttackExecution);
            public FinishAction () : void
            public ApplyBlock () : void
            public constructor ()
        }
        class AbilityProbabilityTriggerComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get Probability(): number;
            public set Probability(value: number);
            public constructor ()
        }
        class ActionComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class CureActionAbility extends EGamePlay.Entity implements EGamePlay.Combat.IActionAbility
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public TryMakeAction ($action: $Ref<EGamePlay.Combat.CureAction>) : boolean
            public constructor ()
        }
        class CureAction extends EGamePlay.Entity implements EGamePlay.Combat.IActionExecution
        {
            protected [__keep_incompatibility]: never;
            public get CureEffect(): EGamePlay.Combat.CureEffect;
            public get CureValue(): number;
            public set CureValue(value: number);
            public get ActionAbility(): EGamePlay.Entity;
            public set ActionAbility(value: EGamePlay.Entity);
            public get SourceAssignAction(): EGamePlay.Combat.EffectAssignAction;
            public set SourceAssignAction(value: EGamePlay.Combat.EffectAssignAction);
            public get Creator(): EGamePlay.Combat.CombatEntity;
            public set Creator(value: EGamePlay.Combat.CombatEntity);
            public get Target(): EGamePlay.Combat.CombatEntity;
            public set Target(value: EGamePlay.Combat.CombatEntity);
            public FinishAction () : void
            public ApplyCure () : void
            public constructor ()
        }
        class DamageBloodSuckComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class DamageActionAbility extends EGamePlay.Entity implements EGamePlay.Combat.IActionAbility
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public TryMakeAction ($action: $Ref<EGamePlay.Combat.DamageAction>) : boolean
            public constructor ()
        }
        class DamageAction extends EGamePlay.Entity implements EGamePlay.Combat.IActionExecution
        {
            protected [__keep_incompatibility]: never;
            public get DamageAbility(): EGamePlay.Combat.DamageActionAbility;
            public get DamageEffect(): EGamePlay.Combat.DamageEffect;
            public get DamageSource(): EGamePlay.Combat.DamageSource;
            public set DamageSource(value: EGamePlay.Combat.DamageSource);
            public get DamagePotential(): number;
            public set DamagePotential(value: number);
            public get DefensePosture(): number;
            public set DefensePosture(value: number);
            public get DamageValue(): number;
            public set DamageValue(value: number);
            public get IsCritical(): boolean;
            public set IsCritical(value: boolean);
            public get ActionAbility(): EGamePlay.Entity;
            public set ActionAbility(value: EGamePlay.Entity);
            public get SourceAssignAction(): EGamePlay.Combat.EffectAssignAction;
            public set SourceAssignAction(value: EGamePlay.Combat.EffectAssignAction);
            public get Creator(): EGamePlay.Combat.CombatEntity;
            public set Creator(value: EGamePlay.Combat.CombatEntity);
            public get Target(): EGamePlay.Combat.CombatEntity;
            public set Target(value: EGamePlay.Combat.CombatEntity);
            public FinishAction () : void
            public ApplyDamage () : void
            public constructor ()
        }
        enum DamageSource
        { Attack = 0, Skill = 1, Buff = 2 }
        class EffectAssignAbility extends EGamePlay.Entity implements EGamePlay.Combat.IActionAbility
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public TryMakeAction ($action: $Ref<EGamePlay.Combat.EffectAssignAction>) : boolean
            public constructor ()
        }
        class MotionActionAbility extends EGamePlay.Entity implements EGamePlay.Combat.IActionAbility
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public TryMakeAction ($action: $Ref<EGamePlay.Combat.MotionAction>) : boolean
            public constructor ()
        }
        class MotionAction extends EGamePlay.Entity implements EGamePlay.Combat.IActionExecution
        {
            protected [__keep_incompatibility]: never;
            public get MotionType(): number;
            public set MotionType(value: number);
            public get ActionAbility(): EGamePlay.Entity;
            public set ActionAbility(value: EGamePlay.Entity);
            public get SourceAssignAction(): EGamePlay.Combat.EffectAssignAction;
            public set SourceAssignAction(value: EGamePlay.Combat.EffectAssignAction);
            public get Creator(): EGamePlay.Combat.CombatEntity;
            public set Creator(value: EGamePlay.Combat.CombatEntity);
            public get Target(): EGamePlay.Combat.CombatEntity;
            public set Target(value: EGamePlay.Combat.CombatEntity);
            public FinishAction () : void
            public ApplyMotion () : void
            public constructor ()
        }
        class SpellActionAbility extends EGamePlay.Entity implements EGamePlay.Combat.IActionAbility
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public TryMakeAction ($action: $Ref<EGamePlay.Combat.SpellAction>) : boolean
            public constructor ()
        }
        class SpellAction extends EGamePlay.Entity implements EGamePlay.Combat.IActionExecution
        {
            protected [__keep_incompatibility]: never;
            public get SkillAbility(): EGamePlay.Combat.SkillAbility;
            public set SkillAbility(value: EGamePlay.Combat.SkillAbility);
            public get SkillExecution(): EGamePlay.Combat.SkillExecution;
            public set SkillExecution(value: EGamePlay.Combat.SkillExecution);
            public get SkillTargets(): System.Collections.Generic.List$1<EGamePlay.Combat.CombatEntity>;
            public set SkillTargets(value: System.Collections.Generic.List$1<EGamePlay.Combat.CombatEntity>);
            public get InputTarget(): EGamePlay.Combat.CombatEntity;
            public set InputTarget(value: EGamePlay.Combat.CombatEntity);
            public get InputPoint(): Unity.Mathematics.float3;
            public set InputPoint(value: Unity.Mathematics.float3);
            public get InputDirection(): number;
            public set InputDirection(value: number);
            public get Task(): ET.ETTask;
            public set Task(value: ET.ETTask);
            public get ActionAbility(): EGamePlay.Entity;
            public set ActionAbility(value: EGamePlay.Entity);
            public get SourceAssignAction(): EGamePlay.Combat.EffectAssignAction;
            public set SourceAssignAction(value: EGamePlay.Combat.EffectAssignAction);
            public get Creator(): EGamePlay.Combat.CombatEntity;
            public set Creator(value: EGamePlay.Combat.CombatEntity);
            public get Target(): EGamePlay.Combat.CombatEntity;
            public set Target(value: EGamePlay.Combat.CombatEntity);
            public FinishAction () : void
            public SpellSkill ($actionOccupy?: boolean) : void
            public constructor ()
        }
        enum ActionType
        { SpellSkill = 0, CauseDamage = 1, GiveCure = 2, AssignEffect = 3 }
        class JumpToActionAbility extends EGamePlay.Entity implements EGamePlay.Combat.IActionAbility
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public TryMakeAction ($action: $Ref<EGamePlay.Combat.JumpToAction>) : boolean
            public constructor ()
        }
        class JumpToAction extends EGamePlay.Entity implements EGamePlay.Combat.IActionExecution
        {
            protected [__keep_incompatibility]: never;
            public get ActionAbility(): EGamePlay.Entity;
            public set ActionAbility(value: EGamePlay.Entity);
            public get SourceAssignAction(): EGamePlay.Combat.EffectAssignAction;
            public set SourceAssignAction(value: EGamePlay.Combat.EffectAssignAction);
            public get Creator(): EGamePlay.Combat.CombatEntity;
            public set Creator(value: EGamePlay.Combat.CombatEntity);
            public get Target(): EGamePlay.Combat.CombatEntity;
            public set Target(value: EGamePlay.Combat.CombatEntity);
            public FinishAction () : void
            public ApplyJumpTo () : ET.ETTask
            public constructor ()
        }
        class RoundActionAbility extends EGamePlay.Entity implements EGamePlay.Combat.IActionAbility
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public TryMakeAction ($action: $Ref<EGamePlay.Combat.RoundAction>) : boolean
            public constructor ()
        }
        class RoundAction extends EGamePlay.Entity implements EGamePlay.Combat.IActionExecution
        {
            protected [__keep_incompatibility]: never;
            public get RoundActionType(): number;
            public set RoundActionType(value: number);
            public get ActionAbility(): EGamePlay.Entity;
            public set ActionAbility(value: EGamePlay.Entity);
            public get SourceAssignAction(): EGamePlay.Combat.EffectAssignAction;
            public set SourceAssignAction(value: EGamePlay.Combat.EffectAssignAction);
            public get Creator(): EGamePlay.Combat.CombatEntity;
            public set Creator(value: EGamePlay.Combat.CombatEntity);
            public get Target(): EGamePlay.Combat.CombatEntity;
            public set Target(value: EGamePlay.Combat.CombatEntity);
            public FinishAction () : void
            public ApplyRound () : ET.ETTask
            public constructor ()
        }
        class FloatModifierCollection extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get TotalValue(): number;
            public AddModifier ($modifier: EGamePlay.Combat.FloatModifier) : number
            public RemoveModifier ($modifier: EGamePlay.Combat.FloatModifier) : number
            public Update () : void
            public constructor ()
        }
        enum ModifierType
        { Add = 0, PctAdd = 1, FinalAdd = 2, FinalPctAdd = 3 }
        class FloatNumeric extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public get Value(): number;
            public get baseValue(): number;
            public get add(): number;
            public get pctAdd(): number;
            public get finalAdd(): number;
            public get finalPctAdd(): number;
            public get AttributeType(): EGamePlay.Combat.AttributeType;
            public set AttributeType(value: EGamePlay.Combat.AttributeType);
            public SetBase ($value: number) : number
            public AddBase ($value: number) : number
            public MinusBase ($value: number) : number
            public AddModifier ($modifierType: EGamePlay.Combat.ModifierType, $modifier: EGamePlay.Combat.FloatModifier) : void
            public RemoveModifier ($modifierType: EGamePlay.Combat.ModifierType, $modifier: EGamePlay.Combat.FloatModifier) : void
            public Update () : void
            public constructor ()
        }
        enum AttributeType
        { None = 0, HealthPointMax = 999, HealthPoint = 1000, Attack = 1001, Defense = 1002, AbilityPower = 1003, InsideDefense = 1004, SuckBlood = 1005, CriticalProbability = 2001, MoveSpeed = 2002, AttackSpeed = 2003, ShieldValue = 3001, CauseDamage = 4001 }
        class HealthPoint extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public HealthPointNumeric : EGamePlay.Combat.FloatNumeric
            public HealthPointMaxNumeric : EGamePlay.Combat.FloatNumeric
            public get Value(): number;
            public get MaxValue(): number;
            public Reset () : void
            public SetMaxValue ($value: number) : void
            public Minus ($value: number) : void
            public Add ($value: number) : void
            public Percent () : number
            public PercentHealth ($pct: number) : number
            public IsFull () : boolean
            public constructor ()
        }
        class CombatActionManageComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public ClearAllActions () : void
            public constructor ()
        }
        class CombatContext extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public static get Instance(): EGamePlay.Combat.CombatContext;
            public get Object2Entities(): System.Collections.Generic.Dictionary$2<UnityEngine.GameObject, EGamePlay.Combat.CombatEntity>;
            public set Object2Entities(value: System.Collections.Generic.Dictionary$2<UnityEngine.GameObject, EGamePlay.Combat.CombatEntity>);
            public get HeroEntities(): System.Collections.Generic.Dictionary$2<number, EGamePlay.Combat.CombatEntity>;
            public set HeroEntities(value: System.Collections.Generic.Dictionary$2<number, EGamePlay.Combat.CombatEntity>);
            public get EnemyEntities(): System.Collections.Generic.Dictionary$2<number, EGamePlay.Combat.CombatEntity>;
            public set EnemyEntities(value: System.Collections.Generic.Dictionary$2<number, EGamePlay.Combat.CombatEntity>);
            public get RoundActions(): System.Collections.Generic.List$1<EGamePlay.Combat.RoundAction>;
            public set RoundActions(value: System.Collections.Generic.List$1<EGamePlay.Combat.RoundAction>);
            public AddHeroEntity ($seat: number) : EGamePlay.Combat.CombatEntity
            public AddMonsterEntity ($seat: number) : EGamePlay.Combat.CombatEntity
            public GetHero ($seat: number) : EGamePlay.Combat.CombatEntity
            public GetMonster ($seat: number) : EGamePlay.Combat.CombatEntity
            public OnEntityDead ($evnt: EGamePlay.Combat.EntityDeadEvent) : void
            public StartCombat () : void
            public RefreshRoundActions () : void
            public constructor ()
        }
        class EntityDeadEvent extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public DeadEntity : EGamePlay.Combat.CombatEntity
            public constructor ()
        }
        class CombatEndEvent extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum ConditionEventType
        { CustomCondition = 0, WhenHPLower = 1, WhenHPPctLower = 2, WhenInTimeNoDamage = 3, WhenIntervalTime = 4 }
        class ConditionTimeInterval extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public StartListen ($whenNoDamageInTimeCallback: System.Action) : void
            public constructor ()
        }
        class ConditionWhenInTimeNoDamage extends EGamePlay.Entity
        {
            protected [__keep_incompatibility]: never;
            public StartListen ($whenNoDamageInTimeCallback: System.Action) : void
            public constructor ()
        }
        class AttributeConfigObject extends Sirenix.OdinInspector.SerializedScriptableObject implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public AttributeConfigs : System.Collections.Generic.List$1<EGamePlay.Combat.AttributeConfig>
            public StateConfigs : System.Collections.Generic.List$1<EGamePlay.Combat.StateConfig>
            public StateMutexTable : System.Collections.Generic.List$1<System.Collections.Generic.List$1<boolean>>
            public constructor ()
        }
        class AttributeConfig extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Enable : boolean
            public AttributeName : string
            public AliasName : string
            public Guid : string
            public constructor ()
        }
        class StateConfig extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Enable : boolean
            public StateName : string
            public AliasName : string
            public Guid : string
            public constructor ()
        }
        class StatusConfigObject extends Sirenix.OdinInspector.SerializedScriptableObject implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public ID : string
            public Name : string
            public StatusType : EGamePlay.Combat.StatusType
            public Duration : number
            public ShowInStatusSlots : boolean
            public CanStack : boolean
            public MaxStack : number
            public EnableChildrenStatuses : boolean
            public ChildrenStatuses : System.Collections.Generic.List$1<EGamePlay.Combat.ChildStatus>
            public StatusDescription : string
            public Effects : System.Collections.Generic.List$1<EGamePlay.Combat.Effect>
            public EffectTypeName : string
            public static AutoRenameStatic : boolean
            public get AutoRename(): boolean;
            public set AutoRename(value: boolean);
            public EffectTypeSelect () : System.Collections.Generic.IEnumerable$1<string>
            public constructor ()
        }
        enum ModifyType
        { Add = 0, PercentAdd = 1 }
        class ClearAllStatusEffect extends EGamePlay.Combat.Effect
        {
            protected [__keep_incompatibility]: never;
            public get Label(): string;
            public constructor ()
        }
        class EffectDecorator extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Enabled : boolean
            public get Label(): string;
        }
        class DamageReduceWithTargetCountDecorator extends EGamePlay.Combat.EffectDecorator
        {
            protected [__keep_incompatibility]: never;
            public ReducePercent : number
            public MinPercent : number
            public get Label(): string;
            public constructor ()
        }
        class CustomEffect extends EGamePlay.Combat.Effect
        {
            protected [__keep_incompatibility]: never;
            public CustomEffectType : string
            public Params : System.Collections.Generic.Dictionary$2<string, string>
            public get Label(): string;
            public constructor ()
        }
        enum DamageType
        { Physic = 0, Magic = 1, Real = 2 }
        enum AddSkillEffetTargetType
        { SkillTarget = 0, Self = 1, Other = 2 }
        enum EffectTriggerType
        { None = 0, Instant = 1, Condition = 2, Action = 3, Interval = 4, ActionCondition = 5 }
        class RemoveStatusEffect extends EGamePlay.Combat.Effect
        {
            protected [__keep_incompatibility]: never;
            public RemoveStatus : EGamePlay.Combat.StatusConfigObject
            public get Label(): string;
            public constructor ()
        }
        class ExecutionObject extends UnityEngine.ScriptableObject
        {
            protected [__keep_incompatibility]: never;
            public AbilityId : number
            public TotalTime : number
            public ObjAsset : UnityEngine.GameObject
            public TargetInputType : EGamePlay.ExecutionTargetInputType
            public RangeIndicatorObjAsset : UnityEngine.GameObject
            public PointIndicatorObjAsset : UnityEngine.GameObject
            public DirectionIndicatorObjAsset : UnityEngine.GameObject
            public ExecuteClips : System.Collections.Generic.List$1<EGamePlay.ExecuteClipData>
            public Description : string
            public get Name(): string;
            public set Name(value: string);
            public constructor ()
        }
        class SkillConfigObject extends Sirenix.OdinInspector.SerializedScriptableObject implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public Id : number
            public Name : string
            public SkillSpellType : EGamePlay.Combat.SkillSpellType
            public AffectTargetType : EGamePlay.Combat.SkillAffectTargetType
            public TargetSelectType : EGamePlay.Combat.SkillTargetSelectType
            public ColdTime : number
            public EnableChildrenStatuses : boolean
            public ChildrenStatuses : System.Collections.Generic.List$1<EGamePlay.Combat.ChildStatus>
            public SkillDescription : string
            public Effects : System.Collections.Generic.List$1<EGamePlay.Combat.Effect>
            public EffectTypeName : string
            public get AutoRename(): boolean;
            public set AutoRename(value: boolean);
            public EffectTypeSelect () : System.Collections.Generic.IEnumerable$1<string>
            public constructor ()
        }
        enum SkillSpellType
        { Initiative = 0, Passive = 1 }
        enum SkillAffectTargetType
        { Self = 0, SelfTeam = 1, EnemyTeam = 2 }
        enum SkillTargetSelectType
        { PlayerSelect = 0, CollisionSelect = 1, ConditionSelect = 2, Custom = 3 }
        class ChildStatus extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public StatusConfigObject : EGamePlay.Combat.StatusConfigObject
            public Params : System.Collections.Generic.Dictionary$2<string, string>
            public constructor ()
        }
        enum ShieldType
        { Shield = 0, PhysicShield = 1, MagicShield = 2, SkillShield = 3 }
        enum TagType
        { Power = 0 }
        enum StatusType
        { Buff = 0, Debuff = 1, Other = 2 }
        class AttackAbility extends EGamePlay.Entity implements EGamePlay.Combat.IAbilityEntity
        {
            protected [__keep_incompatibility]: never;
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public get ParentEntity(): EGamePlay.Combat.CombatEntity;
            public get Enable(): boolean;
            public set Enable(value: boolean);
            public DeactivateAbility () : void
            public EndAbility () : void
            public TryActivateAbility () : void
            public ActivateAbility () : void
            public CreateExecution () : EGamePlay.Entity
            public constructor ()
        }
        enum SkillTargetType
        { Single = 0, Multiple = 1 }
        enum SkillEffectType
        { None = 0, CauseDamage = 1, CureHero = 2, AddStatus = 3, RemoveStatus = 4, NumericModify = 6, AddShield = 7, StackTag = 8 }
        class StatusLifeTimeComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public set DefaultEnable(value: boolean);
            public get LifeTimer(): GameUtils.GameTimer;
            public set LifeTimer(value: GameUtils.GameTimer);
            public constructor ()
        }
        class StatusExecution extends EGamePlay.Entity implements EGamePlay.Combat.IAbilityExecution
        {
            protected [__keep_incompatibility]: never;
            public get InputCombatEntity(): EGamePlay.Combat.CombatEntity;
            public set InputCombatEntity(value: EGamePlay.Combat.CombatEntity);
            public get InputPoint(): Unity.Mathematics.float3;
            public set InputPoint(value: Unity.Mathematics.float3);
            public get InputDirection(): number;
            public set InputDirection(value: number);
            public get AbilityEntity(): EGamePlay.Entity;
            public set AbilityEntity(value: EGamePlay.Entity);
            public get OwnerEntity(): EGamePlay.Combat.CombatEntity;
            public set OwnerEntity(value: EGamePlay.Combat.CombatEntity);
            public BeginExecute () : void
            public EndExecute () : void
        }
        class RemoveStatusEvent extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get CombatEntity(): EGamePlay.Combat.CombatEntity;
            public set CombatEntity(value: EGamePlay.Combat.CombatEntity);
            public get Status(): EGamePlay.Combat.StatusAbility;
            public set Status(value: EGamePlay.Combat.StatusAbility);
            public get StatusId(): bigint;
            public set StatusId(value: bigint);
            public constructor ()
        }
        class ActionAbilityComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ActionPointComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public AddListener ($actionPointType: EGamePlay.Combat.ActionPointType, $action: System.Action$1<EGamePlay.Entity>) : void
            public RemoveListener ($actionPointType: EGamePlay.Combat.ActionPointType, $action: System.Action$1<EGamePlay.Entity>) : void
            public GetActionPoint ($actionPointType: EGamePlay.Combat.ActionPointType) : EGamePlay.Combat.ActionPoint
            public TriggerActionPoint ($actionPointType: EGamePlay.Combat.ActionPointType, $actionExecution: EGamePlay.Entity) : void
            public constructor ()
        }
        class AttributeUpdateEvent extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Numeric : EGamePlay.Combat.FloatNumeric
            public constructor ()
        }
        class AttributeComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get MoveSpeed(): EGamePlay.Combat.FloatNumeric;
            public get HealthPoint(): EGamePlay.Combat.FloatNumeric;
            public get HealthPointMax(): EGamePlay.Combat.FloatNumeric;
            public get Attack(): EGamePlay.Combat.FloatNumeric;
            public get Defense(): EGamePlay.Combat.FloatNumeric;
            public get CriticalProbability(): EGamePlay.Combat.FloatNumeric;
            public get CauseDamage(): EGamePlay.Combat.FloatNumeric;
            public Initialize () : void
            public AddNumeric ($attributeType: EGamePlay.Combat.AttributeType, $baseValue: number) : EGamePlay.Combat.FloatNumeric
            public GetNumeric ($attributeName: string) : EGamePlay.Combat.FloatNumeric
            public OnNumericUpdate ($numeric: EGamePlay.Combat.FloatNumeric) : void
            public constructor ()
        }
        class ConditionEventComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public AddListener ($conditionType: EGamePlay.Combat.ConditionEventType, $action: System.Action, $paramObj?: any) : void
            public RemoveListener ($conditionType: EGamePlay.Combat.ConditionEventType, $action: System.Action) : void
            public constructor ()
        }
        class MotionComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get DefaultEnable(): boolean;
            public set DefaultEnable(value: boolean);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get Rotation(): Unity.Mathematics.float3;
            public set Rotation(value: Unity.Mathematics.float3);
            public get CanMove(): boolean;
            public set CanMove(value: boolean);
            public get IdleTimer(): GameUtils.GameTimer;
            public set IdleTimer(value: GameUtils.GameTimer);
            public get MoveTimer(): GameUtils.GameTimer;
            public set MoveTimer(value: GameUtils.GameTimer);
            public get MoveVector(): Unity.Mathematics.float3;
            public set MoveVector(value: Unity.Mathematics.float3);
            public RunAI () : void
            public constructor ()
        }
        class SkillComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class SpellComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public ExecutionObjects : System.Collections.Generic.Dictionary$2<number, EGamePlay.Combat.ExecutionObject>
            public get DefaultEnable(): boolean;
            public set DefaultEnable(value: boolean);
            public LoadExecutionObjects () : void
            public SpellWithTarget ($spellSkill: EGamePlay.Combat.SkillAbility, $targetEntity: EGamePlay.Combat.CombatEntity) : void
            public SpellWithPoint ($spellSkill: EGamePlay.Combat.SkillAbility, $point: Unity.Mathematics.float3) : void
            public constructor ()
        }
        class StatusComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get CombatEntity(): EGamePlay.Combat.CombatEntity;
            public get Statuses(): System.Collections.Generic.List$1<EGamePlay.Combat.StatusAbility>;
            public set Statuses(value: System.Collections.Generic.List$1<EGamePlay.Combat.StatusAbility>);
            public get TypeIdStatuses(): System.Collections.Generic.Dictionary$2<string, System.Collections.Generic.List$1<EGamePlay.Combat.StatusAbility>>;
            public set TypeIdStatuses(value: System.Collections.Generic.Dictionary$2<string, System.Collections.Generic.List$1<EGamePlay.Combat.StatusAbility>>);
            public AttachStatus ($configObject: any) : EGamePlay.Combat.StatusAbility
            public OnStatusRemove ($statusAbility: EGamePlay.Combat.StatusAbility) : void
            public OnAddStatus ($statusAbility: EGamePlay.Combat.StatusAbility) : void
            public OnRemoveStatus ($statusAbility: EGamePlay.Combat.StatusAbility) : void
            public OnStatusesChanged ($statusAbility: EGamePlay.Combat.StatusAbility) : void
            public constructor ()
        }
        class AbilityItemViewComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get AbilityItem(): EGamePlay.Combat.AbilityItem;
            public set AbilityItem(value: EGamePlay.Combat.AbilityItem);
            public get AbilityItemTrans(): UnityEngine.Transform;
            public set AbilityItemTrans(value: UnityEngine.Transform);
            public get DefaultEnable(): boolean;
            public constructor ()
        }
        enum MoveType
        { TargetMove = 0, PathMove = 1 }
        enum SpeedType
        { Speed = 0, Duration = 1 }
        class MoveWithDotweenComponent extends EGamePlay.Component
        {
            protected [__keep_incompatibility]: never;
            public get SpeedType(): EGamePlay.Combat.SpeedType;
            public set SpeedType(value: EGamePlay.Combat.SpeedType);
            public get Speed(): number;
            public set Speed(value: number);
            public get Duration(): number;
            public set Duration(value: number);
            public get PositionEntity(): EGamePlay.IPosition;
            public set PositionEntity(value: EGamePlay.IPosition);
            public get TargetPositionEntity(): EGamePlay.IPosition;
            public set TargetPositionEntity(value: EGamePlay.IPosition);
            public get Destination(): UnityEngine.Vector3;
            public set Destination(value: UnityEngine.Vector3);
            public get MoveTweener(): DG.Tweening.Tweener;
            public set MoveTweener(value: DG.Tweening.Tweener);
            public DoMoveTo ($destination: UnityEngine.Vector3, $duration: number) : EGamePlay.Combat.MoveWithDotweenComponent
            public DoMoveToWithSpeed ($targetPositionEntity: EGamePlay.IPosition, $speed?: number) : void
            public DoMoveToWithTime ($targetPositionEntity: EGamePlay.IPosition, $time?: number) : void
            public OnMoveFinish ($action: System.Action) : void
            public constructor ()
        }
    }
    namespace GameUtils {
        class GameTimer extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get IsFinished(): boolean;
            public get IsRunning(): boolean;
            public get Time(): number;
            public get MaxTime(): number;
            public set MaxTime(value: number);
            public Reset () : void
            public UpdateAsFinish ($delta: number, $onFinish: System.Action) : GameUtils.GameTimer
            public UpdateAsFinish ($delta: number) : GameUtils.GameTimer
            public UpdateAsRepeat ($delta: number, $onRepeat?: System.Action) : void
            public OnFinish ($onFinish: System.Action) : void
            public OnRepeat ($onRepeat: System.Action) : void
            public constructor ($maxTime: number)
            public constructor ()
        }
        class AssetUtils extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class GenericTypeHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static HasImplementedRawGeneric ($type: System.Type, $generic: System.Type) : boolean
        }
        class RandomHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static RandomNumber ($lower: number, $upper: number) : number
            public static RandomRate () : number
        }
        class RaycastHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CastMapPoint ($hitPoint: $Ref<UnityEngine.Vector3>) : boolean
            public static CastUnitObj ($castObj: $Ref<UnityEngine.GameObject>) : boolean
            public static CastEnemyObj ($castObj: $Ref<UnityEngine.GameObject>) : boolean
            public static CastHeroObj ($castObj: $Ref<UnityEngine.GameObject>) : boolean
        }
    }
    namespace cfg {
        class Tables extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get TbItems(): cfg.Item.TbItems;
            public get TbUnits(): cfg.Unit.TbUnits;
            public get TbMaps(): cfg.Map.TbMaps;
            public TranslateText ($translator: System.Func$3<string, string, string>) : void
            public constructor ($loader: System.Func$2<string, SimpleJSON.JSONNode>)
            public constructor ()
        }
    }
    namespace cfg.Item {
        class TbItems extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get DataMap(): System.Collections.Generic.Dictionary$2<number, cfg.Item.ItemCfg>;
            public get DataList(): System.Collections.Generic.List$1<cfg.Item.ItemCfg>;
            public GetOrDefault ($key: number) : cfg.Item.ItemCfg
            public Get ($key: number) : cfg.Item.ItemCfg
            public get_Item ($key: number) : cfg.Item.ItemCfg
            public Resolve ($_tables: System.Collections.Generic.Dictionary$2<string, any>) : void
            public TranslateText ($translator: System.Func$3<string, string, string>) : void
            public constructor ($_json: SimpleJSON.JSONNode)
            public constructor ()
        }
        class ItemCfg extends Bright.Config.BeanBase implements Bright.Serialization.ITypeId
        {
            protected [__keep_incompatibility]: never;
            public static __ID__ : number
            public get Id(): number;
            public get Name(): string;
            public get Desc(): string;
            public get Price(): number;
            public static DeserializeItemCfg ($_json: SimpleJSON.JSONNode) : cfg.Item.ItemCfg
            public Resolve ($_tables: System.Collections.Generic.Dictionary$2<string, any>) : void
            public TranslateText ($translator: System.Func$3<string, string, string>) : void
            public constructor ($_json: SimpleJSON.JSONNode)
            public constructor ($id: number, $name: string, $desc: string, $price: number)
            public constructor ()
        }
    }
    namespace cfg.Unit {
        class TbUnits extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get DataMap(): System.Collections.Generic.Dictionary$2<number, cfg.Unit.UnitCfg>;
            public get DataList(): System.Collections.Generic.List$1<cfg.Unit.UnitCfg>;
            public GetOrDefault ($key: number) : cfg.Unit.UnitCfg
            public Get ($key: number) : cfg.Unit.UnitCfg
            public get_Item ($key: number) : cfg.Unit.UnitCfg
            public Resolve ($_tables: System.Collections.Generic.Dictionary$2<string, any>) : void
            public TranslateText ($translator: System.Func$3<string, string, string>) : void
            public constructor ($_json: SimpleJSON.JSONNode)
            public constructor ()
        }
        class UnitCfg extends Bright.Config.BeanBase implements Bright.Serialization.ITypeId
        {
            protected [__keep_incompatibility]: never;
            public static __ID__ : number
            public get Id(): number;
            public get Type(): number;
            public get Name(): string;
            public get Desc(): string;
            public get Position(): number;
            public get Height(): number;
            public get Weight(): number;
            public static DeserializeUnitCfg ($_json: SimpleJSON.JSONNode) : cfg.Unit.UnitCfg
            public Resolve ($_tables: System.Collections.Generic.Dictionary$2<string, any>) : void
            public TranslateText ($translator: System.Func$3<string, string, string>) : void
            public constructor ($_json: SimpleJSON.JSONNode)
            public constructor ($Id: number, $Type: number, $Name: string, $Desc: string, $Position: number, $Height: number, $Weight: number)
            public constructor ()
        }
    }
    namespace cfg.Map {
        class TbMaps extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get DataMap(): System.Collections.Generic.Dictionary$2<number, cfg.Map.MapCfg>;
            public get DataList(): System.Collections.Generic.List$1<cfg.Map.MapCfg>;
            public GetOrDefault ($key: number) : cfg.Map.MapCfg
            public Get ($key: number) : cfg.Map.MapCfg
            public get_Item ($key: number) : cfg.Map.MapCfg
            public Resolve ($_tables: System.Collections.Generic.Dictionary$2<string, any>) : void
            public TranslateText ($translator: System.Func$3<string, string, string>) : void
            public constructor ($_json: SimpleJSON.JSONNode)
            public constructor ()
        }
        class MapCfg extends Bright.Config.BeanBase implements Bright.Serialization.ITypeId
        {
            protected [__keep_incompatibility]: never;
            public static __ID__ : number
            public get Id(): number;
            public get Name(): string;
            public get Type(): string;
            public get IsCopyMap(): number;
            public get Desc(): string;
            public static DeserializeMapCfg ($_json: SimpleJSON.JSONNode) : cfg.Map.MapCfg
            public Resolve ($_tables: System.Collections.Generic.Dictionary$2<string, any>) : void
            public TranslateText ($translator: System.Func$3<string, string, string>) : void
            public constructor ($_json: SimpleJSON.JSONNode)
            public constructor ($id: number, $name: string, $type: string, $isCopyMap: number, $desc: string)
            public constructor ()
        }
    }
    namespace FairyGUI {
        class UIPanel extends UnityEngine.MonoBehaviour implements FairyGUI.EMRenderTarget
        {
            protected [__keep_incompatibility]: never;
            public packageName : string
            public componentName : string
            public fitScreen : FairyGUI.FitScreen
            public sortingOrder : number
            public get container(): FairyGUI.Container;
            public get ui(): FairyGUI.GComponent;
            public get EM_sortingOrder(): number;
            public CreateUI () : void
            public SetSortingOrder ($value: number, $apply: boolean) : void
            public SetHitTestMode ($value: FairyGUI.HitTestMode) : void
            public CacheNativeChildrenRenderers () : void
            public ApplyModifiedProperties ($sortingOrderChanged: boolean, $fitScreenChanged: boolean) : void
            public MoveUI ($delta: UnityEngine.Vector3) : void
            public GetUIWorldPosition () : UnityEngine.Vector3
            public EM_BeforeUpdate () : void
            public EM_Update ($context: FairyGUI.UpdateContext) : void
            public EM_Reload () : void
            public constructor ()
        }
        interface EMRenderTarget
        {
            EM_sortingOrder : number
            EM_BeforeUpdate () : void
            EM_Update ($context: FairyGUI.UpdateContext) : void
            EM_Reload () : void
        }
        enum BlendMode
        { Normal = 0, None = 1, Add = 2, Multiply = 3, Screen = 4, Erase = 5, Mask = 6, Below = 7, Off = 8, One_OneMinusSrcAlpha = 9, Custom1 = 10, Custom2 = 11, Custom3 = 12 }
        class BlendModeUtils extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Factors : System.Array$1<FairyGUI.BlendModeUtils.BlendFactor>
            public static Apply ($mat: UnityEngine.Material, $blendMode: FairyGUI.BlendMode) : void
            public static Override ($blendMode: FairyGUI.BlendMode, $srcFactor: UnityEngine.Rendering.BlendMode, $dstFactor: UnityEngine.Rendering.BlendMode) : void
            public constructor ()
        }
        class CaptureCamera extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public cachedTransform : UnityEngine.Transform
            public cachedCamera : UnityEngine.Camera
            public static Name : string
            public static LayerName : string
            public static HiddenLayerName : string
            public static get layer(): number;
            public static get hiddenLayer(): number;
            public static CheckMain () : void
            public static CreateRenderTexture ($width: number, $height: number, $stencilSupport: boolean) : UnityEngine.RenderTexture
            public static Capture ($target: FairyGUI.DisplayObject, $texture: UnityEngine.RenderTexture, $contentHeight: number, $offset: UnityEngine.Vector2) : void
            public constructor ()
        }
        class EventDispatcher extends System.Object implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public AddEventListener ($strType: string, $callback: FairyGUI.EventCallback1) : void
            public AddEventListener ($strType: string, $callback: FairyGUI.EventCallback0) : void
            public RemoveEventListener ($strType: string, $callback: FairyGUI.EventCallback1) : void
            public RemoveEventListener ($strType: string, $callback: FairyGUI.EventCallback0) : void
            public AddCapture ($strType: string, $callback: FairyGUI.EventCallback1) : void
            public RemoveCapture ($strType: string, $callback: FairyGUI.EventCallback1) : void
            public RemoveEventListeners () : void
            public RemoveEventListeners ($strType: string) : void
            public hasEventListeners ($strType: string) : boolean
            public isDispatching ($strType: string) : boolean
            public DispatchEvent ($strType: string) : boolean
            public DispatchEvent ($strType: string, $data: any) : boolean
            public DispatchEvent ($strType: string, $data: any, $initiator: any) : boolean
            public DispatchEvent ($context: FairyGUI.EventContext) : boolean
            public BubbleEvent ($strType: string, $data: any) : boolean
            public BroadcastEvent ($strType: string, $data: any) : boolean
            public constructor ()
        }
        interface IEventDispatcher
        {
            AddEventListener ($strType: string, $callback: FairyGUI.EventCallback0) : void
            AddEventListener ($strType: string, $callback: FairyGUI.EventCallback1) : void
            RemoveEventListener ($strType: string, $callback: FairyGUI.EventCallback0) : void
            RemoveEventListener ($strType: string, $callback: FairyGUI.EventCallback1) : void
            DispatchEvent ($context: FairyGUI.EventContext) : boolean
            DispatchEvent ($strType: string) : boolean
            DispatchEvent ($strType: string, $data: any) : boolean
            DispatchEvent ($strType: string, $data: any, $initiator: any) : boolean
        }
        class DisplayObject extends FairyGUI.EventDispatcher implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public name : string
            public gOwner : FairyGUI.GObject
            public id : number
            public get parent(): FairyGUI.Container;
            public get gameObject(): UnityEngine.GameObject;
            public get cachedTransform(): UnityEngine.Transform;
            public get graphics(): FairyGUI.NGraphics;
            public get paintingGraphics(): FairyGUI.NGraphics;
            public get onClick(): FairyGUI.EventListener;
            public get onRightClick(): FairyGUI.EventListener;
            public get onTouchBegin(): FairyGUI.EventListener;
            public get onTouchMove(): FairyGUI.EventListener;
            public get onTouchEnd(): FairyGUI.EventListener;
            public get onRollOver(): FairyGUI.EventListener;
            public get onRollOut(): FairyGUI.EventListener;
            public get onMouseWheel(): FairyGUI.EventListener;
            public get onAddedToStage(): FairyGUI.EventListener;
            public get onRemovedFromStage(): FairyGUI.EventListener;
            public get onKeyDown(): FairyGUI.EventListener;
            public get onClickLink(): FairyGUI.EventListener;
            public get onFocusIn(): FairyGUI.EventListener;
            public get onFocusOut(): FairyGUI.EventListener;
            public get alpha(): number;
            public set alpha(value: number);
            public get grayed(): boolean;
            public set grayed(value: boolean);
            public get visible(): boolean;
            public set visible(value: boolean);
            public get x(): number;
            public set x(value: number);
            public get y(): number;
            public set y(value: number);
            public get z(): number;
            public set z(value: number);
            public get xy(): UnityEngine.Vector2;
            public set xy(value: UnityEngine.Vector2);
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            public get pixelPerfect(): boolean;
            public set pixelPerfect(value: boolean);
            public get width(): number;
            public set width(value: number);
            public get height(): number;
            public set height(value: number);
            public get size(): UnityEngine.Vector2;
            public set size(value: UnityEngine.Vector2);
            public get scaleX(): number;
            public set scaleX(value: number);
            public get scaleY(): number;
            public set scaleY(value: number);
            public get scale(): UnityEngine.Vector2;
            public set scale(value: UnityEngine.Vector2);
            public get rotation(): number;
            public set rotation(value: number);
            public get rotationX(): number;
            public set rotationX(value: number);
            public get rotationY(): number;
            public set rotationY(value: number);
            public get skew(): UnityEngine.Vector2;
            public set skew(value: UnityEngine.Vector2);
            public get perspective(): boolean;
            public set perspective(value: boolean);
            public get focalLength(): number;
            public set focalLength(value: number);
            public get pivot(): UnityEngine.Vector2;
            public set pivot(value: UnityEngine.Vector2);
            public get location(): UnityEngine.Vector3;
            public set location(value: UnityEngine.Vector3);
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get shader(): string;
            public set shader(value: string);
            public get renderingOrder(): number;
            public set renderingOrder(value: number);
            public get layer(): number;
            public set layer(value: number);
            public get focusable(): boolean;
            public set focusable(value: boolean);
            public get tabStop(): boolean;
            public set tabStop(value: boolean);
            public get focused(): boolean;
            public get cursor(): string;
            public set cursor(value: string);
            public get isDisposed(): boolean;
            public get topmost(): FairyGUI.Container;
            public get stage(): FairyGUI.Stage;
            public get worldSpaceContainer(): FairyGUI.Container;
            public get touchable(): boolean;
            public set touchable(value: boolean);
            public get touchDisabled(): boolean;
            public get paintingMode(): boolean;
            public get cacheAsBitmap(): boolean;
            public set cacheAsBitmap(value: boolean);
            public get filter(): FairyGUI.IFilter;
            public set filter(value: FairyGUI.IFilter);
            public get blendMode(): FairyGUI.BlendMode;
            public set blendMode(value: FairyGUI.BlendMode);
            public get home(): UnityEngine.Transform;
            public set home(value: UnityEngine.Transform);
            public add_onPaint ($value: System.Action) : void
            public remove_onPaint ($value: System.Action) : void
            public SetXY ($xv: number, $yv: number) : void
            public SetPosition ($xv: number, $yv: number, $zv: number) : void
            public SetSize ($wv: number, $hv: number) : void
            public EnsureSizeCorrect () : void
            public SetScale ($xv: number, $yv: number) : void
            public EnterPaintingMode () : void
            public EnterPaintingMode ($requestorId: number, $extend: FairyGUI.Margin | null) : void
            public EnterPaintingMode ($requestorId: number, $extend: FairyGUI.Margin | null, $scale: number) : void
            public LeavePaintingMode ($requestorId: number) : void
            public GetScreenShot ($extend: FairyGUI.Margin | null, $scale: number) : UnityEngine.Texture2D
            public GetBounds ($targetSpace: FairyGUI.DisplayObject) : UnityEngine.Rect
            public GlobalToLocal ($point: UnityEngine.Vector2) : UnityEngine.Vector2
            public LocalToGlobal ($point: UnityEngine.Vector2) : UnityEngine.Vector2
            public WorldToLocal ($worldPoint: UnityEngine.Vector3, $direction: UnityEngine.Vector3) : UnityEngine.Vector3
            public LocalToWorld ($localPoint: UnityEngine.Vector3) : UnityEngine.Vector3
            public TransformPoint ($point: UnityEngine.Vector2, $targetSpace: FairyGUI.DisplayObject) : UnityEngine.Vector2
            public TransformRect ($rect: UnityEngine.Rect, $targetSpace: FairyGUI.DisplayObject) : UnityEngine.Rect
            public RemoveFromParent () : void
            public InvalidateBatchingState () : void
            public Update ($context: FairyGUI.UpdateContext) : void
            public Dispose () : void
            public constructor ()
        }
        class Container extends FairyGUI.DisplayObject implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public renderMode : UnityEngine.RenderMode
            public renderCamera : UnityEngine.Camera
            public opaque : boolean
            public clipSoftness : UnityEngine.Vector4 | null
            public hitArea : FairyGUI.IHitTest
            public touchChildren : boolean
            public reversedMask : boolean
            public get numChildren(): number;
            public get clipRect(): UnityEngine.Rect | null;
            public set clipRect(value: UnityEngine.Rect | null);
            public get mask(): FairyGUI.DisplayObject;
            public set mask(value: FairyGUI.DisplayObject);
            public get fairyBatching(): boolean;
            public set fairyBatching(value: boolean);
            public get tabStopChildren(): boolean;
            public set tabStopChildren(value: boolean);
            public add_onUpdate ($value: System.Action) : void
            public remove_onUpdate ($value: System.Action) : void
            public AddChild ($child: FairyGUI.DisplayObject) : FairyGUI.DisplayObject
            public AddChildAt ($child: FairyGUI.DisplayObject, $index: number) : FairyGUI.DisplayObject
            public Contains ($child: FairyGUI.DisplayObject) : boolean
            public GetChildAt ($index: number) : FairyGUI.DisplayObject
            public GetChild ($name: string) : FairyGUI.DisplayObject
            public GetChildren () : System.Array$1<FairyGUI.DisplayObject>
            public GetChildIndex ($child: FairyGUI.DisplayObject) : number
            public RemoveChild ($child: FairyGUI.DisplayObject) : FairyGUI.DisplayObject
            public RemoveChild ($child: FairyGUI.DisplayObject, $dispose: boolean) : FairyGUI.DisplayObject
            public RemoveChildAt ($index: number) : FairyGUI.DisplayObject
            public RemoveChildAt ($index: number, $dispose: boolean) : FairyGUI.DisplayObject
            public RemoveChildren () : void
            public RemoveChildren ($beginIndex: number, $endIndex: number, $dispose: boolean) : void
            public SetChildIndex ($child: FairyGUI.DisplayObject, $index: number) : void
            public SwapChildren ($child1: FairyGUI.DisplayObject, $child2: FairyGUI.DisplayObject) : void
            public SwapChildrenAt ($index1: number, $index2: number) : void
            public ChangeChildrenOrder ($indice: System.Collections.Generic.IList$1<number>, $objs: System.Collections.Generic.IList$1<FairyGUI.DisplayObject>) : void
            public GetDescendants ($backward: boolean) : System.Collections.Generic.IEnumerator$1<FairyGUI.DisplayObject>
            public CreateGraphics () : void
            public GetRenderCamera () : UnityEngine.Camera
            public HitTest ($stagePoint: UnityEngine.Vector2, $forTouch: boolean) : FairyGUI.DisplayObject
            public IsAncestorOf ($obj: FairyGUI.DisplayObject) : boolean
            public InvalidateBatchingState ($childrenChanged: boolean) : void
            public SetChildrenLayer ($value: number) : void
            public constructor ()
            public constructor ($gameObjectName: string)
            public constructor ($attachTarget: UnityEngine.GameObject)
            public InvalidateBatchingState () : void
        }
        interface IHitTest
        {
            HitTest ($contentRect: UnityEngine.Rect, $localPoint: UnityEngine.Vector2) : boolean
        }
        class UpdateContext extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public clipped : boolean
            public clipInfo : FairyGUI.UpdateContext.ClipInfo
            public renderingOrder : number
            public batchingDepth : number
            public rectMaskDepth : number
            public stencilReferenceValue : number
            public stencilCompareValue : number
            public alpha : number
            public grayed : boolean
            public static current : FairyGUI.UpdateContext
            public static working : boolean
            public static add_OnBegin ($value: System.Action) : void
            public static remove_OnBegin ($value: System.Action) : void
            public static add_OnEnd ($value: System.Action) : void
            public static remove_OnEnd ($value: System.Action) : void
            public Begin () : void
            public End () : void
            public EnterClipping ($clipId: number, $clipRect: UnityEngine.Rect, $softness: UnityEngine.Vector4 | null) : void
            public EnterClipping ($clipId: number, $reversedMask: boolean) : void
            public LeaveClipping () : void
            public EnterPaintingMode () : void
            public LeavePaintingMode () : void
            public ApplyClippingProperties ($mat: UnityEngine.Material, $isStdMaterial: boolean) : void
            public ApplyAlphaMaskProperties ($mat: UnityEngine.Material, $erasing: boolean) : void
            public constructor ()
        }
        class GObject extends FairyGUI.EventDispatcher implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public name : string
            public data : any
            public sourceWidth : number
            public sourceHeight : number
            public initWidth : number
            public initHeight : number
            public minWidth : number
            public maxWidth : number
            public minHeight : number
            public maxHeight : number
            public dragBounds : UnityEngine.Rect | null
            public packageItem : FairyGUI.PackageItem
            public get id(): string;
            public get relations(): FairyGUI.Relations;
            public get parent(): FairyGUI.GComponent;
            public get displayObject(): FairyGUI.DisplayObject;
            public static get draggingObject(): FairyGUI.GObject;
            public get onClick(): FairyGUI.EventListener;
            public get onRightClick(): FairyGUI.EventListener;
            public get onTouchBegin(): FairyGUI.EventListener;
            public get onTouchMove(): FairyGUI.EventListener;
            public get onTouchEnd(): FairyGUI.EventListener;
            public get onRollOver(): FairyGUI.EventListener;
            public get onRollOut(): FairyGUI.EventListener;
            public get onAddedToStage(): FairyGUI.EventListener;
            public get onRemovedFromStage(): FairyGUI.EventListener;
            public get onKeyDown(): FairyGUI.EventListener;
            public get onClickLink(): FairyGUI.EventListener;
            public get onPositionChanged(): FairyGUI.EventListener;
            public get onSizeChanged(): FairyGUI.EventListener;
            public get onDragStart(): FairyGUI.EventListener;
            public get onDragMove(): FairyGUI.EventListener;
            public get onDragEnd(): FairyGUI.EventListener;
            public get onGearStop(): FairyGUI.EventListener;
            public get onFocusIn(): FairyGUI.EventListener;
            public get onFocusOut(): FairyGUI.EventListener;
            public get x(): number;
            public set x(value: number);
            public get y(): number;
            public set y(value: number);
            public get z(): number;
            public set z(value: number);
            public get xy(): UnityEngine.Vector2;
            public set xy(value: UnityEngine.Vector2);
            public get position(): UnityEngine.Vector3;
            public set position(value: UnityEngine.Vector3);
            public get width(): number;
            public set width(value: number);
            public get height(): number;
            public set height(value: number);
            public get size(): UnityEngine.Vector2;
            public set size(value: UnityEngine.Vector2);
            public get actualWidth(): number;
            public get actualHeight(): number;
            public get xMin(): number;
            public set xMin(value: number);
            public get yMin(): number;
            public set yMin(value: number);
            public get scaleX(): number;
            public set scaleX(value: number);
            public get scaleY(): number;
            public set scaleY(value: number);
            public get scale(): UnityEngine.Vector2;
            public set scale(value: UnityEngine.Vector2);
            public get skew(): UnityEngine.Vector2;
            public set skew(value: UnityEngine.Vector2);
            public get pivotX(): number;
            public set pivotX(value: number);
            public get pivotY(): number;
            public set pivotY(value: number);
            public get pivot(): UnityEngine.Vector2;
            public set pivot(value: UnityEngine.Vector2);
            public get pivotAsAnchor(): boolean;
            public set pivotAsAnchor(value: boolean);
            public get touchable(): boolean;
            public set touchable(value: boolean);
            public get grayed(): boolean;
            public set grayed(value: boolean);
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get rotation(): number;
            public set rotation(value: number);
            public get rotationX(): number;
            public set rotationX(value: number);
            public get rotationY(): number;
            public set rotationY(value: number);
            public get alpha(): number;
            public set alpha(value: number);
            public get visible(): boolean;
            public set visible(value: boolean);
            public get sortingOrder(): number;
            public set sortingOrder(value: number);
            public get focusable(): boolean;
            public set focusable(value: boolean);
            public get tabStop(): boolean;
            public set tabStop(value: boolean);
            public get focused(): boolean;
            public get tooltips(): string;
            public set tooltips(value: string);
            public get cursor(): string;
            public set cursor(value: string);
            public get filter(): FairyGUI.IFilter;
            public set filter(value: FairyGUI.IFilter);
            public get blendMode(): FairyGUI.BlendMode;
            public set blendMode(value: FairyGUI.BlendMode);
            public get gameObjectName(): string;
            public set gameObjectName(value: string);
            public get inContainer(): boolean;
            public get onStage(): boolean;
            public get resourceURL(): string;
            public get gearXY(): FairyGUI.GearXY;
            public get gearSize(): FairyGUI.GearSize;
            public get gearLook(): FairyGUI.GearLook;
            public get group(): FairyGUI.GGroup;
            public set group(value: FairyGUI.GGroup);
            public get root(): FairyGUI.GRoot;
            public get text(): string;
            public set text(value: string);
            public get icon(): string;
            public set icon(value: string);
            public get draggable(): boolean;
            public set draggable(value: boolean);
            public get dragging(): boolean;
            public get isDisposed(): boolean;
            public get asImage(): FairyGUI.GImage;
            public get asCom(): FairyGUI.GComponent;
            public get asButton(): FairyGUI.GButton;
            public get asLabel(): FairyGUI.GLabel;
            public get asProgress(): FairyGUI.GProgressBar;
            public get asSlider(): FairyGUI.GSlider;
            public get asComboBox(): FairyGUI.GComboBox;
            public get asTextField(): FairyGUI.GTextField;
            public get asRichTextField(): FairyGUI.GRichTextField;
            public get asTextInput(): FairyGUI.GTextInput;
            public get asLoader(): FairyGUI.GLoader;
            public get asLoader3D(): FairyGUI.GLoader3D;
            public get asList(): FairyGUI.GList;
            public get asGraph(): FairyGUI.GGraph;
            public get asGroup(): FairyGUI.GGroup;
            public get asMovieClip(): FairyGUI.GMovieClip;
            public get asTree(): FairyGUI.GTree;
            public get treeNode(): FairyGUI.GTreeNode;
            public SetXY ($xv: number, $yv: number) : void
            public SetXY ($xv: number, $yv: number, $topLeftValue: boolean) : void
            public SetPosition ($xv: number, $yv: number, $zv: number) : void
            public Center () : void
            public Center ($restraint: boolean) : void
            public MakeFullScreen () : void
            public SetSize ($wv: number, $hv: number) : void
            public SetSize ($wv: number, $hv: number, $ignorePivot: boolean) : void
            public SetScale ($wv: number, $hv: number) : void
            public SetPivot ($xv: number, $yv: number) : void
            public SetPivot ($xv: number, $yv: number, $asAnchor: boolean) : void
            public RequestFocus () : void
            public RequestFocus ($byKey: boolean) : void
            public SetHome ($obj: FairyGUI.GObject) : void
            public GetGear ($index: number) : FairyGUI.GearBase
            public InvalidateBatchingState () : void
            public HandleControllerChanged ($c: FairyGUI.Controller) : void
            public AddRelation ($target: FairyGUI.GObject, $relationType: FairyGUI.RelationType) : void
            public AddRelation ($target: FairyGUI.GObject, $relationType: FairyGUI.RelationType, $usePercent: boolean) : void
            public RemoveRelation ($target: FairyGUI.GObject, $relationType: FairyGUI.RelationType) : void
            public RemoveFromParent () : void
            public StartDrag () : void
            public StartDrag ($touchId: number) : void
            public StopDrag () : void
            public LocalToGlobal ($pt: UnityEngine.Vector2) : UnityEngine.Vector2
            public GlobalToLocal ($pt: UnityEngine.Vector2) : UnityEngine.Vector2
            public LocalToGlobal ($rect: UnityEngine.Rect) : UnityEngine.Rect
            public GlobalToLocal ($rect: UnityEngine.Rect) : UnityEngine.Rect
            public LocalToRoot ($pt: UnityEngine.Vector2, $r: FairyGUI.GRoot) : UnityEngine.Vector2
            public RootToLocal ($pt: UnityEngine.Vector2, $r: FairyGUI.GRoot) : UnityEngine.Vector2
            public WorldToLocal ($pt: UnityEngine.Vector3) : UnityEngine.Vector2
            public WorldToLocal ($pt: UnityEngine.Vector3, $camera: UnityEngine.Camera) : UnityEngine.Vector2
            public TransformPoint ($pt: UnityEngine.Vector2, $targetSpace: FairyGUI.GObject) : UnityEngine.Vector2
            public TransformRect ($rect: UnityEngine.Rect, $targetSpace: FairyGUI.GObject) : UnityEngine.Rect
            public Dispose () : void
            public ConstructFromResource () : void
            public Setup_BeforeAdd ($buffer: FairyGUI.Utils.ByteBuffer, $beginPos: number) : void
            public Setup_AfterAdd ($buffer: FairyGUI.Utils.ByteBuffer, $beginPos: number) : void
            public TweenMove ($endValue: UnityEngine.Vector2, $duration: number) : FairyGUI.GTweener
            public TweenMoveX ($endValue: number, $duration: number) : FairyGUI.GTweener
            public TweenMoveY ($endValue: number, $duration: number) : FairyGUI.GTweener
            public TweenScale ($endValue: UnityEngine.Vector2, $duration: number) : FairyGUI.GTweener
            public TweenScaleX ($endValue: number, $duration: number) : FairyGUI.GTweener
            public TweenScaleY ($endValue: number, $duration: number) : FairyGUI.GTweener
            public TweenResize ($endValue: UnityEngine.Vector2, $duration: number) : FairyGUI.GTweener
            public TweenFade ($endValue: number, $duration: number) : FairyGUI.GTweener
            public TweenRotate ($endValue: number, $duration: number) : FairyGUI.GTweener
            public constructor ()
        }
        class NGraphics extends System.Object implements FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public blendMode : FairyGUI.BlendMode
            public dontClip : boolean
            public get gameObject(): UnityEngine.GameObject;
            public get meshFilter(): UnityEngine.MeshFilter;
            public get meshRenderer(): UnityEngine.MeshRenderer;
            public get mesh(): UnityEngine.Mesh;
            public get meshFactory(): FairyGUI.IMeshFactory;
            public set meshFactory(value: FairyGUI.IMeshFactory);
            public get contentRect(): UnityEngine.Rect;
            public set contentRect(value: UnityEngine.Rect);
            public get flip(): FairyGUI.FlipType;
            public set flip(value: FairyGUI.FlipType);
            public get texture(): FairyGUI.NTexture;
            public set texture(value: FairyGUI.NTexture);
            public get shader(): string;
            public set shader(value: string);
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get materialKeywords(): System.Array$1<string>;
            public set materialKeywords(value: System.Array$1<string>);
            public get enabled(): boolean;
            public set enabled(value: boolean);
            public get sortingOrder(): number;
            public set sortingOrder(value: number);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get vertexMatrix(): FairyGUI.NGraphics.VertexMatrix;
            public set vertexMatrix(value: FairyGUI.NGraphics.VertexMatrix);
            public get materialPropertyBlock(): UnityEngine.MaterialPropertyBlock;
            public add_meshModifier ($value: System.Action) : void
            public remove_meshModifier ($value: System.Action) : void
            public SetShaderAndTexture ($shader: string, $texture: FairyGUI.NTexture) : void
            public SetMaterial ($material: UnityEngine.Material) : void
            public ToggleKeyword ($keyword: string, $enabled: boolean) : void
            public Tint () : void
            public SetMeshDirty () : void
            public UpdateMesh () : boolean
            public Dispose () : void
            public Update ($context: FairyGUI.UpdateContext, $alpha: number, $grayed: boolean) : void
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public constructor ($gameObject: UnityEngine.GameObject)
            public constructor ()
        }
        interface IMeshFactory
        {
            OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
        }
        class EventListener extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get type(): string;
            public get isEmpty(): boolean;
            public get isDispatching(): boolean;
            public AddCapture ($callback: FairyGUI.EventCallback1) : void
            public RemoveCapture ($callback: FairyGUI.EventCallback1) : void
            public Add ($callback: FairyGUI.EventCallback1) : void
            public Remove ($callback: FairyGUI.EventCallback1) : void
            public Add ($callback: FairyGUI.EventCallback0) : void
            public Remove ($callback: FairyGUI.EventCallback0) : void
            public Set ($callback: FairyGUI.EventCallback1) : void
            public Set ($callback: FairyGUI.EventCallback0) : void
            public Clear () : void
            public Call () : boolean
            public Call ($data: any) : boolean
            public BubbleCall ($data: any) : boolean
            public BubbleCall () : boolean
            public BroadcastCall ($data: any) : boolean
            public BroadcastCall () : boolean
            public constructor ($owner: FairyGUI.EventDispatcher, $type: string)
            public constructor ()
        }
        class Stage extends FairyGUI.Container implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public get soundVolume(): number;
            public set soundVolume(value: number);
            public static get inst(): FairyGUI.Stage;
            public static get touchScreen(): boolean;
            public static set touchScreen(value: boolean);
            public static get keyboardInput(): boolean;
            public static set keyboardInput(value: boolean);
            public static get isTouchOnUI(): boolean;
            public static get devicePixelRatio(): number;
            public static set devicePixelRatio(value: number);
            public get onStageResized(): FairyGUI.EventListener;
            public get touchTarget(): FairyGUI.DisplayObject;
            public get focus(): FairyGUI.DisplayObject;
            public set focus(value: FairyGUI.DisplayObject);
            public get touchPosition(): UnityEngine.Vector2;
            public get touchCount(): number;
            public get keyboard(): FairyGUI.IKeyboard;
            public set keyboard(value: FairyGUI.IKeyboard);
            public get activeCursor(): string;
            public add_beforeUpdate ($value: System.Action) : void
            public remove_beforeUpdate ($value: System.Action) : void
            public add_afterUpdate ($value: System.Action) : void
            public remove_afterUpdate ($value: System.Action) : void
            public static Instantiate () : void
            public SetFocus ($newFocus: FairyGUI.DisplayObject, $byKey?: boolean) : void
            public DoKeyNavigate ($backward: boolean) : void
            public GetTouchPosition ($touchId: number) : UnityEngine.Vector2
            public GetTouchTarget ($touchId: number) : FairyGUI.DisplayObject
            public GetAllTouch ($result: System.Array$1<number>) : System.Array$1<number>
            public ResetInputState () : void
            public CancelClick ($touchId: number) : void
            public EnableSound () : void
            public DisableSound () : void
            public PlayOneShotSound ($clip: UnityEngine.AudioClip, $volumeScale: number) : void
            public PlayOneShotSound ($clip: UnityEngine.AudioClip) : void
            public OpenKeyboard ($text: string, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $keyboardType: number, $hideInput: boolean) : void
            public CloseKeyboard () : void
            public InputString ($value: string) : void
            public SetCustomInput ($screenPos: UnityEngine.Vector2, $buttonDown: boolean) : void
            public SetCustomInput ($screenPos: UnityEngine.Vector2, $buttonDown: boolean, $buttonUp: boolean) : void
            public SetCustomInput ($hit: $Ref<UnityEngine.RaycastHit>, $buttonDown: boolean) : void
            public SetCustomInput ($hit: $Ref<UnityEngine.RaycastHit>, $buttonDown: boolean, $buttonUp: boolean) : void
            public ForceUpdate () : void
            public ApplyPanelOrder ($target: FairyGUI.Container) : void
            public SortWorldSpacePanelsByZOrder ($panelSortingOrder: number) : void
            public MonitorTexture ($texture: FairyGUI.NTexture) : void
            public AddTouchMonitor ($touchId: number, $target: FairyGUI.EventDispatcher) : void
            public RemoveTouchMonitor ($target: FairyGUI.EventDispatcher) : void
            public IsTouchMonitoring ($target: FairyGUI.EventDispatcher) : boolean
            public RegisterCursor ($cursorName: string, $texture: UnityEngine.Texture2D, $hotspot: UnityEngine.Vector2) : void
            public constructor ()
        }
        class Margin extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public left : number
            public right : number
            public top : number
            public bottom : number
        }
        interface IFilter
        {
            target : FairyGUI.DisplayObject
            Update () : void
            Dispose () : void
        }
        class DisplayObjectInfo extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public displayObject : FairyGUI.DisplayObject
            public constructor ()
        }
        class GoWrapper extends FairyGUI.DisplayObject implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public customCloneMaterials : System.Action$1<System.Collections.Generic.Dictionary$2<UnityEngine.Material, UnityEngine.Material>>
            public customRecoverMaterials : System.Action
            public get wrapTarget(): UnityEngine.GameObject;
            public set wrapTarget(value: UnityEngine.GameObject);
            public get renderingOrder(): number;
            public set renderingOrder(value: number);
            public add_onUpdate ($value: System.Action$1<FairyGUI.UpdateContext>) : void
            public remove_onUpdate ($value: System.Action$1<FairyGUI.UpdateContext>) : void
            public SetWrapTarget ($target: UnityEngine.GameObject, $cloneMaterial: boolean) : void
            public CacheRenderers () : void
            public constructor ()
            public constructor ($go: UnityEngine.GameObject)
        }
        class ColliderHitTest extends System.Object implements FairyGUI.IHitTest
        {
            protected [__keep_incompatibility]: never;
            public collider : UnityEngine.Collider
            public HitTest ($contentRect: UnityEngine.Rect, $localPoint: UnityEngine.Vector2) : boolean
            public constructor ()
        }
        class HitTestContext extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static screenPoint : UnityEngine.Vector3
            public static worldPoint : UnityEngine.Vector3
            public static direction : UnityEngine.Vector3
            public static forTouch : boolean
            public static camera : UnityEngine.Camera
            public static layerMask : number
            public static maxDistance : number
            public static cachedMainCamera : UnityEngine.Camera
            public static GetRaycastHitFromCache ($camera: UnityEngine.Camera, $hit: $Ref<UnityEngine.RaycastHit>) : boolean
            public static CacheRaycastHit ($camera: UnityEngine.Camera, $hit: $Ref<UnityEngine.RaycastHit>) : void
            public static ClearRaycastHitCache () : void
            public constructor ()
        }
        enum HitTestMode
        { Default = 0, Raycast = 1 }
        class MeshColliderHitTest extends FairyGUI.ColliderHitTest implements FairyGUI.IHitTest
        {
            protected [__keep_incompatibility]: never;
            public lastHit : UnityEngine.Vector2
            public constructor ($collider: UnityEngine.MeshCollider)
            public constructor ()
        }
        class PixelHitTestData extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public pixelWidth : number
            public scale : number
            public pixels : System.Array$1<number>
            public pixelsLength : number
            public pixelsOffset : number
            public Load ($ba: FairyGUI.Utils.ByteBuffer) : void
            public constructor ()
        }
        class PixelHitTest extends System.Object implements FairyGUI.IHitTest
        {
            protected [__keep_incompatibility]: never;
            public offsetX : number
            public offsetY : number
            public sourceWidth : number
            public sourceHeight : number
            public HitTest ($contentRect: UnityEngine.Rect, $localPoint: UnityEngine.Vector2) : boolean
            public constructor ($data: FairyGUI.PixelHitTestData, $offsetX: number, $offsetY: number, $sourceWidth: number, $sourceHeight: number)
            public constructor ()
        }
        class RectHitTest extends System.Object implements FairyGUI.IHitTest
        {
            protected [__keep_incompatibility]: never;
            public rect : UnityEngine.Rect
            public HitTest ($contentRect: UnityEngine.Rect, $localPoint: UnityEngine.Vector2) : boolean
            public constructor ()
        }
        class ShapeHitTest extends System.Object implements FairyGUI.IHitTest
        {
            protected [__keep_incompatibility]: never;
            public shape : FairyGUI.DisplayObject
            public HitTest ($contentRect: UnityEngine.Rect, $localPoint: UnityEngine.Vector2) : boolean
            public constructor ($obj: FairyGUI.DisplayObject)
            public constructor ()
        }
        class Image extends FairyGUI.DisplayObject implements FairyGUI.IEventDispatcher, FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public get texture(): FairyGUI.NTexture;
            public set texture(value: FairyGUI.NTexture);
            public get textureScale(): UnityEngine.Vector2;
            public set textureScale(value: UnityEngine.Vector2);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get fillMethod(): FairyGUI.FillMethod;
            public set fillMethod(value: FairyGUI.FillMethod);
            public get fillOrigin(): number;
            public set fillOrigin(value: number);
            public get fillClockwise(): boolean;
            public set fillClockwise(value: boolean);
            public get fillAmount(): number;
            public set fillAmount(value: number);
            public get scale9Grid(): UnityEngine.Rect | null;
            public set scale9Grid(value: UnityEngine.Rect | null);
            public get scaleByTile(): boolean;
            public set scaleByTile(value: boolean);
            public get tileGridIndice(): number;
            public set tileGridIndice(value: number);
            public SetNativeSize () : void
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public SliceFill ($vb: FairyGUI.VertexBuffer) : void
            public constructor ()
            public constructor ($texture: FairyGUI.NTexture)
        }
        class NTexture extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public uvRect : UnityEngine.Rect
            public rotated : boolean
            public refCount : number
            public lastActive : number
            public destroyMethod : FairyGUI.DestroyMethod
            public static get Empty(): FairyGUI.NTexture;
            public get width(): number;
            public get height(): number;
            public get offset(): UnityEngine.Vector2;
            public set offset(value: UnityEngine.Vector2);
            public get originalSize(): UnityEngine.Vector2;
            public set originalSize(value: UnityEngine.Vector2);
            public get root(): FairyGUI.NTexture;
            public get disposed(): boolean;
            public get nativeTexture(): UnityEngine.Texture;
            public get alphaTexture(): UnityEngine.Texture;
            public static add_CustomDestroyMethod ($value: System.Action$1<UnityEngine.Texture>) : void
            public static remove_CustomDestroyMethod ($value: System.Action$1<UnityEngine.Texture>) : void
            public add_onSizeChanged ($value: System.Action$1<FairyGUI.NTexture>) : void
            public remove_onSizeChanged ($value: System.Action$1<FairyGUI.NTexture>) : void
            public add_onRelease ($value: System.Action$1<FairyGUI.NTexture>) : void
            public remove_onRelease ($value: System.Action$1<FairyGUI.NTexture>) : void
            public static DisposeEmpty () : void
            public GetDrawRect ($drawRect: UnityEngine.Rect) : UnityEngine.Rect
            public GetUV ($uv: System.Array$1<UnityEngine.Vector2>) : void
            public GetMaterialManager ($shaderName: string) : FairyGUI.MaterialManager
            public Unload () : void
            public Unload ($destroyMaterials: boolean) : void
            public Reload ($nativeTexture: UnityEngine.Texture, $alphaTexture: UnityEngine.Texture) : void
            public AddRef () : void
            public ReleaseRef () : void
            public Dispose () : void
            public constructor ($texture: UnityEngine.Texture)
            public constructor ($texture: UnityEngine.Texture, $alphaTexture: UnityEngine.Texture, $xScale: number, $yScale: number)
            public constructor ($texture: UnityEngine.Texture, $region: UnityEngine.Rect)
            public constructor ($root: FairyGUI.NTexture, $region: UnityEngine.Rect, $rotated: boolean)
            public constructor ($root: FairyGUI.NTexture, $region: UnityEngine.Rect, $rotated: boolean, $originalSize: UnityEngine.Vector2, $offset: UnityEngine.Vector2)
            public constructor ($sprite: UnityEngine.Sprite)
            public constructor ()
        }
        enum FillMethod
        { None = 0, Horizontal = 1, Vertical = 2, Radial90 = 3, Radial180 = 4, Radial360 = 5 }
        class VertexBuffer extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public contentRect : UnityEngine.Rect
            public uvRect : UnityEngine.Rect
            public vertexColor : UnityEngine.Color32
            public textureSize : UnityEngine.Vector2
            public vertices : System.Collections.Generic.List$1<UnityEngine.Vector3>
            public colors : System.Collections.Generic.List$1<UnityEngine.Color32>
            public uvs : System.Collections.Generic.List$1<UnityEngine.Vector2>
            public uvs2 : System.Collections.Generic.List$1<UnityEngine.Vector2>
            public triangles : System.Collections.Generic.List$1<number>
            public static NormalizedUV : System.Array$1<UnityEngine.Vector2>
            public static NormalizedPosition : System.Array$1<UnityEngine.Vector2>
            public get currentVertCount(): number;
            public static Begin () : FairyGUI.VertexBuffer
            public static Begin ($source: FairyGUI.VertexBuffer) : FairyGUI.VertexBuffer
            public End () : void
            public Clear () : void
            public AddVert ($position: UnityEngine.Vector3) : void
            public AddVert ($position: UnityEngine.Vector3, $color: UnityEngine.Color32) : void
            public AddVert ($position: UnityEngine.Vector3, $color: UnityEngine.Color32, $uv: UnityEngine.Vector2) : void
            public AddQuad ($vertRect: UnityEngine.Rect) : void
            public AddQuad ($vertRect: UnityEngine.Rect, $color: UnityEngine.Color32) : void
            public AddQuad ($vertRect: UnityEngine.Rect, $color: UnityEngine.Color32, $uvRect: UnityEngine.Rect) : void
            public RepeatColors ($value: System.Array$1<UnityEngine.Color32>, $startIndex: number, $count: number) : void
            public AddTriangle ($idx0: number, $idx1: number, $idx2: number) : void
            public AddTriangles ($idxList: System.Array$1<number>, $startVertexIndex?: number) : void
            public AddTriangles ($startVertexIndex?: number) : void
            public GetPosition ($index: number) : UnityEngine.Vector3
            public GetUVAtPosition ($position: UnityEngine.Vector2, $usePercent: boolean) : UnityEngine.Vector2
            public Append ($vb: FairyGUI.VertexBuffer) : void
            public Insert ($vb: FairyGUI.VertexBuffer) : void
        }
        enum MaterialFlags
        { Clipped = 1, SoftClipped = 2, StencilTest = 4, AlphaMask = 8, Grayed = 16, ColorFilter = 32 }
        class MaterialManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public firstMaterialInFrame : boolean
            public add_onCreateNewMaterial ($value: System.Action$1<UnityEngine.Material>) : void
            public remove_onCreateNewMaterial ($value: System.Action$1<UnityEngine.Material>) : void
            public GetFlagsByKeywords ($keywords: System.Collections.Generic.IList$1<string>) : number
            public GetMaterial ($flags: number, $blendMode: FairyGUI.BlendMode, $group: number) : UnityEngine.Material
            public DestroyMaterials () : void
            public RefreshMaterials () : void
        }
        class CompositeMesh extends System.Object implements FairyGUI.IHitTest, FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public elements : System.Collections.Generic.List$1<FairyGUI.IMeshFactory>
            public activeIndex : number
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public HitTest ($contentRect: UnityEngine.Rect, $point: UnityEngine.Vector2) : boolean
            public constructor ()
            public HitTest ($contentRect: UnityEngine.Rect, $localPoint: UnityEngine.Vector2) : boolean
        }
        class EllipseMesh extends System.Object implements FairyGUI.IHitTest, FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public drawRect : UnityEngine.Rect | null
            public lineWidth : number
            public lineColor : UnityEngine.Color32
            public centerColor : UnityEngine.Color32 | null
            public fillColor : UnityEngine.Color32 | null
            public startDegree : number
            public endDegreee : number
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public HitTest ($contentRect: UnityEngine.Rect, $point: UnityEngine.Vector2) : boolean
            public constructor ()
            public HitTest ($contentRect: UnityEngine.Rect, $localPoint: UnityEngine.Vector2) : boolean
        }
        class FillMesh extends System.Object implements FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public method : FairyGUI.FillMethod
            public origin : number
            public amount : number
            public clockwise : boolean
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public constructor ()
        }
        class LineMesh extends System.Object implements FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public path : FairyGUI.GPath
            public lineWidth : number
            public lineWidthCurve : UnityEngine.AnimationCurve
            public gradient : UnityEngine.Gradient
            public roundEdge : boolean
            public fillStart : number
            public fillEnd : number
            public pointDensity : number
            public repeatFill : boolean
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public constructor ()
        }
        class GPath extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get length(): number;
            public get segmentCount(): number;
            public Create ($pt1: FairyGUI.GPathPoint, $pt2: FairyGUI.GPathPoint) : void
            public Create ($pt1: FairyGUI.GPathPoint, $pt2: FairyGUI.GPathPoint, $pt3: FairyGUI.GPathPoint) : void
            public Create ($pt1: FairyGUI.GPathPoint, $pt2: FairyGUI.GPathPoint, $pt3: FairyGUI.GPathPoint, $pt4: FairyGUI.GPathPoint) : void
            public Create ($points: System.Collections.Generic.IEnumerable$1<FairyGUI.GPathPoint>) : void
            public Clear () : void
            public GetPointAt ($t: number) : UnityEngine.Vector3
            public GetSegmentLength ($segmentIndex: number) : number
            public GetPointsInSegment ($segmentIndex: number, $t0: number, $t1: number, $points: System.Collections.Generic.List$1<UnityEngine.Vector3>, $ts?: System.Collections.Generic.List$1<number>, $pointDensity?: number) : void
            public GetAllPoints ($points: System.Collections.Generic.List$1<UnityEngine.Vector3>, $pointDensity?: number) : void
            public constructor ()
        }
        class PlaneMesh extends System.Object implements FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public gridSize : number
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public constructor ()
        }
        class PolygonMesh extends System.Object implements FairyGUI.IHitTest, FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public points : System.Collections.Generic.List$1<UnityEngine.Vector2>
            public texcoords : System.Collections.Generic.List$1<UnityEngine.Vector2>
            public lineWidth : number
            public lineColor : UnityEngine.Color32
            public fillColor : UnityEngine.Color32 | null
            public colors : System.Array$1<UnityEngine.Color32>
            public usePercentPositions : boolean
            public Add ($point: UnityEngine.Vector2) : void
            public Add ($point: UnityEngine.Vector2, $texcoord: UnityEngine.Vector2) : void
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public HitTest ($contentRect: UnityEngine.Rect, $point: UnityEngine.Vector2) : boolean
            public constructor ()
            public HitTest ($contentRect: UnityEngine.Rect, $localPoint: UnityEngine.Vector2) : boolean
        }
        class RectMesh extends System.Object implements FairyGUI.IHitTest, FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public drawRect : UnityEngine.Rect | null
            public lineWidth : number
            public lineColor : UnityEngine.Color32
            public fillColor : UnityEngine.Color32 | null
            public colors : System.Array$1<UnityEngine.Color32>
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public HitTest ($contentRect: UnityEngine.Rect, $point: UnityEngine.Vector2) : boolean
            public constructor ()
            public HitTest ($contentRect: UnityEngine.Rect, $localPoint: UnityEngine.Vector2) : boolean
        }
        class RegularPolygonMesh extends System.Object implements FairyGUI.IHitTest, FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public drawRect : UnityEngine.Rect | null
            public sides : number
            public lineWidth : number
            public lineColor : UnityEngine.Color32
            public centerColor : UnityEngine.Color32 | null
            public fillColor : UnityEngine.Color32 | null
            public distances : System.Array$1<number>
            public rotation : number
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public HitTest ($contentRect: UnityEngine.Rect, $point: UnityEngine.Vector2) : boolean
            public constructor ()
            public HitTest ($contentRect: UnityEngine.Rect, $localPoint: UnityEngine.Vector2) : boolean
        }
        class RoundedRectMesh extends System.Object implements FairyGUI.IHitTest, FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public drawRect : UnityEngine.Rect | null
            public lineWidth : number
            public lineColor : UnityEngine.Color32
            public fillColor : UnityEngine.Color32 | null
            public topLeftRadius : number
            public topRightRadius : number
            public bottomLeftRadius : number
            public bottomRightRadius : number
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public HitTest ($contentRect: UnityEngine.Rect, $point: UnityEngine.Vector2) : boolean
            public constructor ()
            public HitTest ($contentRect: UnityEngine.Rect, $localPoint: UnityEngine.Vector2) : boolean
        }
        class StraightLineMesh extends System.Object implements FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public color : UnityEngine.Color
            public origin : UnityEngine.Vector3
            public end : UnityEngine.Vector3
            public lineWidth : number
            public repeatFill : boolean
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public constructor ()
            public constructor ($lineWidth: number, $color: UnityEngine.Color, $repeatFill: boolean)
        }
        class MovieClip extends FairyGUI.Image implements FairyGUI.IEventDispatcher, FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public interval : number
            public swing : boolean
            public repeatDelay : number
            public timeScale : number
            public ignoreEngineTimeScale : boolean
            public get onPlayEnd(): FairyGUI.EventListener;
            public get frames(): System.Array$1<FairyGUI.MovieClip.Frame>;
            public set frames(value: System.Array$1<FairyGUI.MovieClip.Frame>);
            public get playing(): boolean;
            public set playing(value: boolean);
            public get frame(): number;
            public set frame(value: number);
            public Rewind () : void
            public SyncStatus ($anotherMc: FairyGUI.MovieClip) : void
            public Advance ($time: number) : void
            public SetPlaySettings () : void
            public SetPlaySettings ($start: number, $end: number, $times: number, $endAt: number) : void
            public constructor ()
        }
        class NAudioClip extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CustomDestroyMethod : System.Action$1<UnityEngine.AudioClip>
            public destroyMethod : FairyGUI.DestroyMethod
            public nativeClip : UnityEngine.AudioClip
            public Unload () : void
            public Reload ($audioClip: UnityEngine.AudioClip) : void
            public constructor ($audioClip: UnityEngine.AudioClip)
            public constructor ()
        }
        enum DestroyMethod
        { Destroy = 0, Unload = 1, None = 2, ReleaseTemp = 3, Custom = 4 }
        enum FlipType
        { None = 0, Horizontal = 1, Vertical = 2, Both = 3 }
        class ShaderConfig extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Get : FairyGUI.ShaderConfig.GetFunction
            public static imageShader : string
            public static textShader : string
            public static bmFontShader : string
            public static TMPFontShader : string
            public static ID_ClipBox : number
            public static ID_ClipSoftness : number
            public static ID_AlphaTex : number
            public static ID_StencilComp : number
            public static ID_Stencil : number
            public static ID_StencilOp : number
            public static ID_StencilReadMask : number
            public static ID_ColorMask : number
            public static ID_ColorMatrix : number
            public static ID_ColorOffset : number
            public static ID_BlendSrcFactor : number
            public static ID_BlendDstFactor : number
            public static ID_ColorOption : number
            public static ID_Stencil2 : number
            public static GetShader ($name: string) : UnityEngine.Shader
        }
        class Shape extends FairyGUI.DisplayObject implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get isEmpty(): boolean;
            public DrawRect ($lineSize: number, $lineColor: UnityEngine.Color, $fillColor: UnityEngine.Color) : void
            public DrawRect ($lineSize: number, $colors: System.Array$1<UnityEngine.Color32>) : void
            public DrawRoundRect ($lineSize: number, $lineColor: UnityEngine.Color, $fillColor: UnityEngine.Color, $topLeftRadius: number, $topRightRadius: number, $bottomLeftRadius: number, $bottomRightRadius: number) : void
            public DrawEllipse ($fillColor: UnityEngine.Color) : void
            public DrawEllipse ($lineSize: number, $centerColor: UnityEngine.Color, $lineColor: UnityEngine.Color, $fillColor: UnityEngine.Color, $startDegree: number, $endDegree: number) : void
            public DrawPolygon ($points: System.Collections.Generic.IList$1<UnityEngine.Vector2>, $fillColor: UnityEngine.Color) : void
            public DrawPolygon ($points: System.Collections.Generic.IList$1<UnityEngine.Vector2>, $colors: System.Array$1<UnityEngine.Color32>) : void
            public DrawPolygon ($points: System.Collections.Generic.IList$1<UnityEngine.Vector2>, $fillColor: UnityEngine.Color, $lineSize: number, $lineColor: UnityEngine.Color) : void
            public DrawRegularPolygon ($sides: number, $lineSize: number, $centerColor: UnityEngine.Color, $lineColor: UnityEngine.Color, $fillColor: UnityEngine.Color, $rotation: number, $distances: System.Array$1<number>) : void
            public Clear () : void
            public constructor ()
        }
        interface IKeyboard
        {
            done : boolean
            supportsCaret : boolean
            GetInput () : string
            Open ($text: string, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $keyboardType: number, $hideInput: boolean) : void
            Close () : void
        }
        class StageCamera extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public constantSize : boolean
            public unitsPerPixel : number
            public cachedTransform : UnityEngine.Transform
            public cachedCamera : UnityEngine.Camera
            public static main : UnityEngine.Camera
            public static screenSizeVer : number
            public static Name : string
            public static LayerName : string
            public static DefaultCameraSize : number
            public static DefaultUnitsPerPixel : number
            public ApplyModifiedProperties () : void
            public static CheckMainCamera () : void
            public static CheckCaptureCamera () : void
            public static CreateCamera ($name: string, $cullingMask: number) : UnityEngine.Camera
            public constructor ()
        }
        class StageEngine extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public ObjectsOnStage : number
            public GraphicsOnStage : number
            public static beingQuit : boolean
            public constructor ()
        }
        class Stats extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ObjectCount : number
            public static GraphicsCount : number
            public static LatestObjectCreation : number
            public static LatestGraphicsCreation : number
            public constructor ()
        }
        class BaseFont extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public name : string
            public mainTexture : FairyGUI.NTexture
            public canTint : boolean
            public customBold : boolean
            public customBoldAndItalic : boolean
            public customOutline : boolean
            public shader : string
            public keepCrisp : boolean
            public version : number
            public UpdateGraphics ($graphics: FairyGUI.NGraphics) : void
            public SetFormat ($format: FairyGUI.TextFormat, $fontSizeScale: number) : void
            public PrepareCharacters ($text: string) : void
            public GetGlyph ($ch: number, $width: $Ref<number>, $height: $Ref<number>, $baseline: $Ref<number>) : boolean
            public DrawGlyph ($x: number, $y: number, $vertList: System.Collections.Generic.List$1<UnityEngine.Vector3>, $uvList: System.Collections.Generic.List$1<UnityEngine.Vector2>, $uv2List: System.Collections.Generic.List$1<UnityEngine.Vector2>, $colList: System.Collections.Generic.List$1<UnityEngine.Color32>) : number
            public DrawLine ($x: number, $y: number, $width: number, $fontSize: number, $type: number, $vertList: System.Collections.Generic.List$1<UnityEngine.Vector3>, $uvList: System.Collections.Generic.List$1<UnityEngine.Vector2>, $uv2List: System.Collections.Generic.List$1<UnityEngine.Vector2>, $colList: System.Collections.Generic.List$1<UnityEngine.Color32>) : number
            public HasCharacter ($ch: number) : boolean
            public GetLineHeight ($size: number) : number
            public Dispose () : void
            public constructor ()
        }
        class TextFormat extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public size : number
            public font : string
            public color : UnityEngine.Color
            public lineSpacing : number
            public letterSpacing : number
            public bold : boolean
            public underline : boolean
            public italic : boolean
            public strikethrough : boolean
            public gradientColor : System.Array$1<UnityEngine.Color32>
            public align : FairyGUI.AlignType
            public specialStyle : FairyGUI.TextFormat.SpecialStyle
            public outline : number
            public outlineColor : UnityEngine.Color
            public shadowOffset : UnityEngine.Vector2
            public shadowColor : UnityEngine.Color
            public SetColor ($value: number) : void
            public EqualStyle ($aFormat: FairyGUI.TextFormat) : boolean
            public CopyFrom ($source: FairyGUI.TextFormat) : void
            public FillVertexColors ($vertexColors: System.Array$1<UnityEngine.Color32>) : void
            public constructor ()
        }
        class BitmapFont extends FairyGUI.BaseFont
        {
            protected [__keep_incompatibility]: never;
            public size : number
            public resizable : boolean
            public hasChannel : boolean
            public AddChar ($ch: number, $glyph: FairyGUI.BitmapFont.BMGlyph) : void
            public constructor ()
        }
        class DynamicFont extends FairyGUI.BaseFont
        {
            protected [__keep_incompatibility]: never;
            public get nativeFont(): UnityEngine.Font;
            public set nativeFont(value: UnityEngine.Font);
            public constructor ()
            public constructor ($name: string, $font: UnityEngine.Font)
        }
        class Emoji extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public url : string
            public width : number
            public height : number
            public constructor ($url: string, $width: number, $height: number)
            public constructor ($url: string)
            public constructor ()
        }
        class FontManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static sFontFactory : System.Collections.Generic.Dictionary$2<string, FairyGUI.BaseFont>
            public static RegisterFont ($font: FairyGUI.BaseFont, $alias?: string) : void
            public static UnregisterFont ($font: FairyGUI.BaseFont) : void
            public static GetFont ($name: string) : FairyGUI.BaseFont
            public static Clear () : void
            public constructor ()
        }
        class RichTextField extends FairyGUI.Container implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public get htmlPageContext(): FairyGUI.Utils.IHtmlPageContext;
            public set htmlPageContext(value: FairyGUI.Utils.IHtmlPageContext);
            public get htmlParseOptions(): FairyGUI.Utils.HtmlParseOptions;
            public get emojies(): System.Collections.Generic.Dictionary$2<number, FairyGUI.Emoji>;
            public set emojies(value: System.Collections.Generic.Dictionary$2<number, FairyGUI.Emoji>);
            public get textField(): FairyGUI.TextField;
            public get text(): string;
            public set text(value: string);
            public get htmlText(): string;
            public set htmlText(value: string);
            public get textFormat(): FairyGUI.TextFormat;
            public set textFormat(value: FairyGUI.TextFormat);
            public get htmlElementCount(): number;
            public GetHtmlElement ($name: string) : FairyGUI.Utils.HtmlElement
            public GetHtmlElementAt ($index: number) : FairyGUI.Utils.HtmlElement
            public ShowHtmlObject ($index: number, $show: boolean) : void
            public constructor ()
        }
        class InputTextField extends FairyGUI.RichTextField implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public static onCopy : System.Action$2<FairyGUI.InputTextField, string>
            public static onPaste : System.Action$1<FairyGUI.InputTextField>
            public static contextMenu : FairyGUI.PopupMenu
            public get maxLength(): number;
            public set maxLength(value: number);
            public get keyboardInput(): boolean;
            public set keyboardInput(value: boolean);
            public get keyboardType(): number;
            public set keyboardType(value: number);
            public get hideInput(): boolean;
            public set hideInput(value: boolean);
            public get disableIME(): boolean;
            public set disableIME(value: boolean);
            public get mouseWheelEnabled(): boolean;
            public set mouseWheelEnabled(value: boolean);
            public get onChanged(): FairyGUI.EventListener;
            public get onSubmit(): FairyGUI.EventListener;
            public get text(): string;
            public set text(value: string);
            public get textFormat(): FairyGUI.TextFormat;
            public set textFormat(value: FairyGUI.TextFormat);
            public get restrict(): string;
            public set restrict(value: string);
            public get caretPosition(): number;
            public set caretPosition(value: number);
            public get selectionBeginIndex(): number;
            public get selectionEndIndex(): number;
            public get promptText(): string;
            public set promptText(value: string);
            public get displayAsPassword(): boolean;
            public set displayAsPassword(value: boolean);
            public get editable(): boolean;
            public set editable(value: boolean);
            public get border(): number;
            public set border(value: number);
            public get corner(): number;
            public set corner(value: number);
            public get borderColor(): UnityEngine.Color;
            public set borderColor(value: UnityEngine.Color);
            public get backgroundColor(): UnityEngine.Color;
            public set backgroundColor(value: UnityEngine.Color);
            public SetSelection ($start: number, $length: number) : void
            public ReplaceSelection ($value: string) : void
            public ReplaceText ($value: string) : void
            public GetSelection () : string
            public constructor ()
        }
        class PopupMenu extends FairyGUI.EventDispatcher implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public visibleItemCount : number
            public hideOnClickItem : boolean
            public autoSize : boolean
            public get onPopup(): FairyGUI.EventListener;
            public get onClose(): FairyGUI.EventListener;
            public get itemCount(): number;
            public get contentPane(): FairyGUI.GComponent;
            public get list(): FairyGUI.GList;
            public AddItem ($caption: string, $callback: FairyGUI.EventCallback0) : FairyGUI.GButton
            public AddItem ($caption: string, $callback: FairyGUI.EventCallback1) : FairyGUI.GButton
            public AddItemAt ($caption: string, $index: number, $callback: FairyGUI.EventCallback1) : FairyGUI.GButton
            public AddItemAt ($caption: string, $index: number, $callback: FairyGUI.EventCallback0) : FairyGUI.GButton
            public AddSeperator () : void
            public AddSeperator ($index: number) : void
            public GetItemName ($index: number) : string
            public SetItemText ($name: string, $caption: string) : void
            public SetItemVisible ($name: string, $visible: boolean) : void
            public SetItemGrayed ($name: string, $grayed: boolean) : void
            public SetItemCheckable ($name: string, $checkable: boolean) : void
            public SetItemChecked ($name: string, $check: boolean) : void
            public IsItemChecked ($name: string) : boolean
            public RemoveItem ($name: string) : void
            public ClearItems () : void
            public Dispose () : void
            public Show () : void
            public Show ($target: FairyGUI.GObject) : void
            public Show ($target: FairyGUI.GObject, $dir: FairyGUI.PopupDirection) : void
            public Show ($target: FairyGUI.GObject, $dir: FairyGUI.PopupDirection, $parentMenu: FairyGUI.PopupMenu) : void
            public Hide () : void
            public constructor ()
            public constructor ($resourceURL: string)
        }
        class TextField extends FairyGUI.DisplayObject implements FairyGUI.IEventDispatcher, FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public get textFormat(): FairyGUI.TextFormat;
            public set textFormat(value: FairyGUI.TextFormat);
            public get align(): FairyGUI.AlignType;
            public set align(value: FairyGUI.AlignType);
            public get verticalAlign(): FairyGUI.VertAlignType;
            public set verticalAlign(value: FairyGUI.VertAlignType);
            public get text(): string;
            public set text(value: string);
            public get htmlText(): string;
            public set htmlText(value: string);
            public get parsedText(): string;
            public get autoSize(): FairyGUI.AutoSizeType;
            public set autoSize(value: FairyGUI.AutoSizeType);
            public get wordWrap(): boolean;
            public set wordWrap(value: boolean);
            public get singleLine(): boolean;
            public set singleLine(value: boolean);
            public get stroke(): number;
            public set stroke(value: number);
            public get strokeColor(): UnityEngine.Color;
            public set strokeColor(value: UnityEngine.Color);
            public get shadowOffset(): UnityEngine.Vector2;
            public set shadowOffset(value: UnityEngine.Vector2);
            public get textWidth(): number;
            public get textHeight(): number;
            public get maxWidth(): number;
            public set maxWidth(value: number);
            public get htmlElements(): System.Collections.Generic.List$1<FairyGUI.Utils.HtmlElement>;
            public get lines(): System.Collections.Generic.List$1<FairyGUI.TextField.LineInfo>;
            public get charPositions(): System.Collections.Generic.List$1<FairyGUI.TextField.CharPosition>;
            public get richTextField(): FairyGUI.RichTextField;
            public EnableCharPositionSupport () : void
            public ApplyFormat () : void
            public Redraw () : boolean
            public HasCharacter ($ch: number) : boolean
            public GetLinesShape ($startLine: number, $startCharX: number, $endLine: number, $endCharX: number, $clipped: boolean, $resultRects: System.Collections.Generic.List$1<UnityEngine.Rect>) : void
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public constructor ()
        }
        class RTLSupport extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static BaseDirection : FairyGUI.RTLSupport.DirectionType
            public static IsArabicLetter ($ch: number) : boolean
            public static ConvertNumber ($strNumber: string) : string
            public static ContainsArabicLetters ($text: string) : boolean
            public static DetectTextDirection ($text: string) : FairyGUI.RTLSupport.DirectionType
            public static DoMapping ($input: string) : string
            public static ConvertLineL ($source: string) : string
            public static ConvertLineR ($source: string) : string
            public constructor ()
        }
        class SelectionShape extends FairyGUI.DisplayObject implements FairyGUI.IEventDispatcher, FairyGUI.IMeshFactory
        {
            protected [__keep_incompatibility]: never;
            public rects : System.Collections.Generic.List$1<UnityEngine.Rect>
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public Refresh () : void
            public Clear () : void
            public OnPopulateMesh ($vb: FairyGUI.VertexBuffer) : void
            public constructor ()
        }
        enum AlignType
        { Left = 0, Center = 1, Right = 2 }
        enum VertAlignType
        { Top = 0, Middle = 1, Bottom = 2 }
        enum AutoSizeType
        { None = 0, Both = 1, Height = 2, Shrink = 3, Ellipsis = 4 }
        class TouchScreenKeyboard extends System.Object implements FairyGUI.IKeyboard
        {
            protected [__keep_incompatibility]: never;
            public get done(): boolean;
            public get supportsCaret(): boolean;
            public GetInput () : string
            public Open ($text: string, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $keyboardType: number, $hideInput: boolean) : void
            public Close () : void
            public constructor ()
        }
        class TypingEffect extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get totalTimes(): number;
            public Start () : void
            public Print () : boolean
            public Print ($interval: number) : System.Collections.IEnumerator
            public PrintAll ($interval: number) : void
            public Cancel () : void
            public constructor ($textField: FairyGUI.TextField)
            public constructor ($textField: FairyGUI.GTextField)
            public constructor ()
        }
        class GTextField extends FairyGUI.GObject implements FairyGUI.IEventDispatcher, FairyGUI.IColorGear, FairyGUI.ITextColorGear
        {
            protected [__keep_incompatibility]: never;
            public get text(): string;
            public set text(value: string);
            public get templateVars(): System.Collections.Generic.Dictionary$2<string, string>;
            public set templateVars(value: System.Collections.Generic.Dictionary$2<string, string>);
            public get textFormat(): FairyGUI.TextFormat;
            public set textFormat(value: FairyGUI.TextFormat);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get align(): FairyGUI.AlignType;
            public set align(value: FairyGUI.AlignType);
            public get verticalAlign(): FairyGUI.VertAlignType;
            public set verticalAlign(value: FairyGUI.VertAlignType);
            public get singleLine(): boolean;
            public set singleLine(value: boolean);
            public get stroke(): number;
            public set stroke(value: number);
            public get strokeColor(): UnityEngine.Color;
            public set strokeColor(value: UnityEngine.Color);
            public get shadowOffset(): UnityEngine.Vector2;
            public set shadowOffset(value: UnityEngine.Vector2);
            public get UBBEnabled(): boolean;
            public set UBBEnabled(value: boolean);
            public get autoSize(): FairyGUI.AutoSizeType;
            public set autoSize(value: FairyGUI.AutoSizeType);
            public get textWidth(): number;
            public get textHeight(): number;
            public SetVar ($name: string, $value: string) : FairyGUI.GTextField
            public FlushVars () : void
            public HasCharacter ($ch: number) : boolean
            public constructor ()
        }
        interface IColorGear
        {
            color : UnityEngine.Color
        }
        interface ITextColorGear extends FairyGUI.IColorGear
        {
            strokeColor : UnityEngine.Color
            color : UnityEngine.Color
        }
        class EventContext extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public type : string
            public data : any
            public get sender(): FairyGUI.EventDispatcher;
            public get initiator(): any;
            public get inputEvent(): FairyGUI.InputEvent;
            public get isDefaultPrevented(): boolean;
            public StopPropagation () : void
            public PreventDefault () : void
            public CaptureTouch () : void
            public constructor ()
        }
        class InputEvent extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get x(): number;
            public get y(): number;
            public get keyCode(): UnityEngine.KeyCode;
            public get character(): number;
            public get modifiers(): UnityEngine.EventModifiers;
            public get mouseWheelDelta(): number;
            public get touchId(): number;
            public get button(): number;
            public get clickCount(): number;
            public get holdTime(): number;
            public get position(): UnityEngine.Vector2;
            public get isDoubleClick(): boolean;
            public get ctrlOrCmd(): boolean;
            public get ctrl(): boolean;
            public get shift(): boolean;
            public get alt(): boolean;
            public get command(): boolean;
            public constructor ()
        }
        interface EventCallback0
        { 
        () : void; 
        Invoke?: () => void;
        }
        var EventCallback0: { new (func: () => void): EventCallback0; }
        interface EventCallback1
        { 
        (context: FairyGUI.EventContext) : void; 
        Invoke?: (context: FairyGUI.EventContext) => void;
        }
        var EventCallback1: { new (func: (context: FairyGUI.EventContext) => void): EventCallback1; }
        class BlurFilter extends System.Object implements FairyGUI.IFilter
        {
            protected [__keep_incompatibility]: never;
            public blurSize : number
            public get target(): FairyGUI.DisplayObject;
            public set target(value: FairyGUI.DisplayObject);
            public Dispose () : void
            public Update () : void
            public constructor ()
        }
        class ColorFilter extends System.Object implements FairyGUI.IFilter
        {
            protected [__keep_incompatibility]: never;
            public get target(): FairyGUI.DisplayObject;
            public set target(value: FairyGUI.DisplayObject);
            public Dispose () : void
            public Update () : void
            public Invert () : void
            public AdjustSaturation ($sat: number) : void
            public AdjustContrast ($value: number) : void
            public AdjustBrightness ($value: number) : void
            public AdjustHue ($value: number) : void
            public Tint ($color: UnityEngine.Color, $amount?: number) : void
            public Reset () : void
            public ConcatValues (...values: number[]) : void
            public constructor ()
        }
        class LongPressGesture extends FairyGUI.EventDispatcher implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public trigger : number
            public interval : number
            public once : boolean
            public holdRangeRadius : number
            public static TRIGGER : number
            public static INTERVAL : number
            public get host(): FairyGUI.GObject;
            public get onBegin(): FairyGUI.EventListener;
            public get onEnd(): FairyGUI.EventListener;
            public get onAction(): FairyGUI.EventListener;
            public Dispose () : void
            public Enable ($value: boolean) : void
            public Cancel () : void
            public constructor ($host: FairyGUI.GObject)
            public constructor ()
        }
        class PinchGesture extends FairyGUI.EventDispatcher implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public scale : number
            public delta : number
            public get host(): FairyGUI.GObject;
            public get onBegin(): FairyGUI.EventListener;
            public get onEnd(): FairyGUI.EventListener;
            public get onAction(): FairyGUI.EventListener;
            public Dispose () : void
            public Enable ($value: boolean) : void
            public constructor ($host: FairyGUI.GObject)
            public constructor ()
        }
        class RotationGesture extends FairyGUI.EventDispatcher implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public rotation : number
            public delta : number
            public snapping : boolean
            public get host(): FairyGUI.GObject;
            public get onBegin(): FairyGUI.EventListener;
            public get onEnd(): FairyGUI.EventListener;
            public get onAction(): FairyGUI.EventListener;
            public Dispose () : void
            public Enable ($value: boolean) : void
            public constructor ($host: FairyGUI.GObject)
            public constructor ()
        }
        class SwipeGesture extends FairyGUI.EventDispatcher implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public velocity : UnityEngine.Vector2
            public position : UnityEngine.Vector2
            public delta : UnityEngine.Vector2
            public actionDistance : number
            public snapping : boolean
            public static ACTION_DISTANCE : number
            public get host(): FairyGUI.GObject;
            public get onBegin(): FairyGUI.EventListener;
            public get onEnd(): FairyGUI.EventListener;
            public get onMove(): FairyGUI.EventListener;
            public get onAction(): FairyGUI.EventListener;
            public Dispose () : void
            public Enable ($value: boolean) : void
            public constructor ($host: FairyGUI.GObject)
            public constructor ()
        }
        class EaseManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Evaluate ($easeType: FairyGUI.EaseType, $time: number, $duration: number, $overshootOrAmplitude?: number, $period?: number, $customEase?: FairyGUI.CustomEase) : number
        }
        enum EaseType
        { Linear = 0, SineIn = 1, SineOut = 2, SineInOut = 3, QuadIn = 4, QuadOut = 5, QuadInOut = 6, CubicIn = 7, CubicOut = 8, CubicInOut = 9, QuartIn = 10, QuartOut = 11, QuartInOut = 12, QuintIn = 13, QuintOut = 14, QuintInOut = 15, ExpoIn = 16, ExpoOut = 17, ExpoInOut = 18, CircIn = 19, CircOut = 20, CircInOut = 21, ElasticIn = 22, ElasticOut = 23, ElasticInOut = 24, BackIn = 25, BackOut = 26, BackInOut = 27, BounceIn = 28, BounceOut = 29, BounceInOut = 30, Custom = 31 }
        class CustomEase extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public Create ($pathPoints: System.Collections.Generic.IEnumerable$1<FairyGUI.GPathPoint>) : void
            public Evaluate ($time: number) : number
            public constructor ($pointDensity?: number)
            public constructor ()
        }
        class GPathPoint extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public pos : UnityEngine.Vector3
            public control1 : UnityEngine.Vector3
            public control2 : UnityEngine.Vector3
            public curveType : FairyGUI.GPathPoint.CurveType
            public smooth : boolean
            public constructor ($pos: UnityEngine.Vector3)
            public constructor ($pos: UnityEngine.Vector3, $control: UnityEngine.Vector3)
            public constructor ($pos: UnityEngine.Vector3, $control1: UnityEngine.Vector3, $control2: UnityEngine.Vector3)
            public constructor ($pos: UnityEngine.Vector3, $curveType: FairyGUI.GPathPoint.CurveType)
            public constructor ()
        }
        class GTween extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static catchCallbackExceptions : boolean
            public static To ($startValue: number, $endValue: number, $duration: number) : FairyGUI.GTweener
            public static To ($startValue: UnityEngine.Vector2, $endValue: UnityEngine.Vector2, $duration: number) : FairyGUI.GTweener
            public static To ($startValue: UnityEngine.Vector3, $endValue: UnityEngine.Vector3, $duration: number) : FairyGUI.GTweener
            public static To ($startValue: UnityEngine.Vector4, $endValue: UnityEngine.Vector4, $duration: number) : FairyGUI.GTweener
            public static To ($startValue: UnityEngine.Color, $endValue: UnityEngine.Color, $duration: number) : FairyGUI.GTweener
            public static ToDouble ($startValue: number, $endValue: number, $duration: number) : FairyGUI.GTweener
            public static DelayedCall ($delay: number) : FairyGUI.GTweener
            public static Shake ($startValue: UnityEngine.Vector3, $amplitude: number, $duration: number) : FairyGUI.GTweener
            public static IsTweening ($target: any) : boolean
            public static IsTweening ($target: any, $propType: FairyGUI.TweenPropType) : boolean
            public static Kill ($target: any) : void
            public static Kill ($target: any, $complete: boolean) : void
            public static Kill ($target: any, $propType: FairyGUI.TweenPropType, $complete: boolean) : void
            public static GetTween ($target: any) : FairyGUI.GTweener
            public static GetTween ($target: any, $propType: FairyGUI.TweenPropType) : FairyGUI.GTweener
            public static Clean () : void
            public constructor ()
        }
        class GTweener extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get delay(): number;
            public get duration(): number;
            public get repeat(): number;
            public get target(): any;
            public get userData(): any;
            public get startValue(): FairyGUI.TweenValue;
            public get endValue(): FairyGUI.TweenValue;
            public get value(): FairyGUI.TweenValue;
            public get deltaValue(): FairyGUI.TweenValue;
            public get normalizedTime(): number;
            public get completed(): boolean;
            public get allCompleted(): boolean;
            public SetDelay ($value: number) : FairyGUI.GTweener
            public SetDuration ($value: number) : FairyGUI.GTweener
            public SetBreakpoint ($value: number) : FairyGUI.GTweener
            public SetEase ($value: FairyGUI.EaseType) : FairyGUI.GTweener
            public SetEase ($value: FairyGUI.EaseType, $customEase: FairyGUI.CustomEase) : FairyGUI.GTweener
            public SetEasePeriod ($value: number) : FairyGUI.GTweener
            public SetEaseOvershootOrAmplitude ($value: number) : FairyGUI.GTweener
            public SetRepeat ($times: number, $yoyo?: boolean) : FairyGUI.GTweener
            public SetTimeScale ($value: number) : FairyGUI.GTweener
            public SetIgnoreEngineTimeScale ($value: boolean) : FairyGUI.GTweener
            public SetSnapping ($value: boolean) : FairyGUI.GTweener
            public SetPath ($value: FairyGUI.GPath) : FairyGUI.GTweener
            public SetTarget ($value: any) : FairyGUI.GTweener
            public SetTarget ($value: any, $propType: FairyGUI.TweenPropType) : FairyGUI.GTweener
            public SetUserData ($value: any) : FairyGUI.GTweener
            public OnUpdate ($callback: FairyGUI.GTweenCallback) : FairyGUI.GTweener
            public OnStart ($callback: FairyGUI.GTweenCallback) : FairyGUI.GTweener
            public OnComplete ($callback: FairyGUI.GTweenCallback) : FairyGUI.GTweener
            public OnUpdate ($callback: FairyGUI.GTweenCallback1) : FairyGUI.GTweener
            public OnStart ($callback: FairyGUI.GTweenCallback1) : FairyGUI.GTweener
            public OnComplete ($callback: FairyGUI.GTweenCallback1) : FairyGUI.GTweener
            public SetListener ($value: FairyGUI.ITweenListener) : FairyGUI.GTweener
            public SetPaused ($paused: boolean) : FairyGUI.GTweener
            public Seek ($time: number) : void
            public Kill ($complete?: boolean) : void
            public constructor ()
        }
        enum TweenPropType
        { None = 0, X = 1, Y = 2, Z = 3, XY = 4, Position = 5, Width = 6, Height = 7, Size = 8, ScaleX = 9, ScaleY = 10, Scale = 11, Rotation = 12, RotationX = 13, RotationY = 14, Alpha = 15, Progress = 16 }
        interface GTweenCallback
        { 
        () : void; 
        Invoke?: () => void;
        }
        var GTweenCallback: { new (func: () => void): GTweenCallback; }
        interface GTweenCallback1
        { 
        (tweener: FairyGUI.GTweener) : void; 
        Invoke?: (tweener: FairyGUI.GTweener) => void;
        }
        var GTweenCallback1: { new (func: (tweener: FairyGUI.GTweener) => void): GTweenCallback1; }
        interface ITweenListener
        {
            OnTweenStart ($tweener: FairyGUI.GTweener) : void
            OnTweenUpdate ($tweener: FairyGUI.GTweener) : void
            OnTweenComplete ($tweener: FairyGUI.GTweener) : void
        }
        class TweenValue extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public x : number
            public y : number
            public z : number
            public w : number
            public d : number
            public get vec2(): UnityEngine.Vector2;
            public set vec2(value: UnityEngine.Vector2);
            public get vec3(): UnityEngine.Vector3;
            public set vec3(value: UnityEngine.Vector3);
            public get vec4(): UnityEngine.Vector4;
            public set vec4(value: UnityEngine.Vector4);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get_Item ($index: number) : number
            public set_Item ($index: number, $value: number) : void
            public SetZero () : void
            public constructor ()
        }
        class ControllerAction extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public fromPage : System.Array$1<string>
            public toPage : System.Array$1<string>
            public static CreateAction ($type: FairyGUI.ControllerAction.ActionType) : FairyGUI.ControllerAction
            public Run ($controller: FairyGUI.Controller, $prevPage: string, $curPage: string) : void
            public Setup ($buffer: FairyGUI.Utils.ByteBuffer) : void
            public constructor ()
        }
        class ChangePageAction extends FairyGUI.ControllerAction
        {
            protected [__keep_incompatibility]: never;
            public objectId : string
            public controllerName : string
            public targetPage : string
            public constructor ()
        }
        class Controller extends FairyGUI.EventDispatcher implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public name : string
            public get onChanged(): FairyGUI.EventListener;
            public get selectedIndex(): number;
            public set selectedIndex(value: number);
            public get selectedPage(): string;
            public set selectedPage(value: string);
            public get previousIndex(): number;
            public get previousPage(): string;
            public get pageCount(): number;
            public Dispose () : void
            public SetSelectedIndex ($value: number) : void
            public SetSelectedPage ($value: string) : void
            public GetPageName ($index: number) : string
            public GetPageId ($index: number) : string
            public GetPageIdByName ($aName: string) : string
            public AddPage ($name: string) : void
            public AddPageAt ($name: string, $index: number) : void
            public RemovePage ($name: string) : void
            public RemovePageAt ($index: number) : void
            public ClearPages () : void
            public HasPage ($aName: string) : boolean
            public RunActions () : void
            public Setup ($buffer: FairyGUI.Utils.ByteBuffer) : void
            public constructor ()
        }
        class PlayTransitionAction extends FairyGUI.ControllerAction
        {
            protected [__keep_incompatibility]: never;
            public transitionName : string
            public playTimes : number
            public delay : number
            public stopOnExit : boolean
            public constructor ()
        }
        class AsyncCreationHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CreateObject ($item: FairyGUI.PackageItem, $callback: FairyGUI.UIPackage.CreateObjectCallback) : void
            public constructor ()
        }
        class PackageItem extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public owner : FairyGUI.UIPackage
            public type : FairyGUI.PackageItemType
            public objectType : FairyGUI.ObjectType
            public id : string
            public name : string
            public width : number
            public height : number
            public file : string
            public exported : boolean
            public texture : FairyGUI.NTexture
            public rawData : FairyGUI.Utils.ByteBuffer
            public branches : System.Array$1<string>
            public highResolution : System.Array$1<string>
            public scale9Grid : UnityEngine.Rect | null
            public scaleByTile : boolean
            public tileGridIndice : number
            public pixelHitTestData : FairyGUI.PixelHitTestData
            public interval : number
            public repeatDelay : number
            public swing : boolean
            public frames : System.Array$1<FairyGUI.MovieClip.Frame>
            public translated : boolean
            public extensionCreator : FairyGUI.UIObjectFactory.GComponentCreator
            public bitmapFont : FairyGUI.BitmapFont
            public audioClip : FairyGUI.NAudioClip
            public skeletonAnchor : UnityEngine.Vector2
            public skeletonAsset : any
            public Load () : any
            public getBranch () : FairyGUI.PackageItem
            public getHighResolution () : FairyGUI.PackageItem
            public constructor ()
        }
        class DragDropManager extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static get inst(): FairyGUI.DragDropManager;
            public get dragAgent(): FairyGUI.GLoader;
            public get dragging(): boolean;
            public StartDrag ($source: FairyGUI.GObject, $icon: string, $sourceData: any, $touchPointID?: number) : void
            public Cancel () : void
            public constructor ()
        }
        class GLoader extends FairyGUI.GObject implements FairyGUI.IEventDispatcher, FairyGUI.IAnimationGear, FairyGUI.IColorGear
        {
            protected [__keep_incompatibility]: never;
            public showErrorSign : boolean
            public __loadExternal : System.Action
            public __freeExternal : System.Action$1<FairyGUI.NTexture>
            public get url(): string;
            public set url(value: string);
            public get icon(): string;
            public set icon(value: string);
            public get align(): FairyGUI.AlignType;
            public set align(value: FairyGUI.AlignType);
            public get verticalAlign(): FairyGUI.VertAlignType;
            public set verticalAlign(value: FairyGUI.VertAlignType);
            public get fill(): FairyGUI.FillType;
            public set fill(value: FairyGUI.FillType);
            public get shrinkOnly(): boolean;
            public set shrinkOnly(value: boolean);
            public get autoSize(): boolean;
            public set autoSize(value: boolean);
            public get playing(): boolean;
            public set playing(value: boolean);
            public get frame(): number;
            public set frame(value: number);
            public get timeScale(): number;
            public set timeScale(value: number);
            public get ignoreEngineTimeScale(): boolean;
            public set ignoreEngineTimeScale(value: boolean);
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get shader(): string;
            public set shader(value: string);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get fillMethod(): FairyGUI.FillMethod;
            public set fillMethod(value: FairyGUI.FillMethod);
            public get fillOrigin(): number;
            public set fillOrigin(value: number);
            public get fillClockwise(): boolean;
            public set fillClockwise(value: boolean);
            public get fillAmount(): number;
            public set fillAmount(value: number);
            public get image(): FairyGUI.Image;
            public get movieClip(): FairyGUI.MovieClip;
            public get component(): FairyGUI.GComponent;
            public get texture(): FairyGUI.NTexture;
            public set texture(value: FairyGUI.NTexture);
            public get filter(): FairyGUI.IFilter;
            public set filter(value: FairyGUI.IFilter);
            public get blendMode(): FairyGUI.BlendMode;
            public set blendMode(value: FairyGUI.BlendMode);
            public Advance ($time: number) : void
            public onExternalLoadSuccess ($texture: FairyGUI.NTexture) : void
            public onExternalLoadFailed () : void
            public constructor ()
        }
        interface IAnimationGear
        {
            playing : boolean
            frame : number
            timeScale : number
            ignoreEngineTimeScale : boolean
            Advance ($time: number) : void
        }
        class EMRenderSupport extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static orderChanged : boolean
            public static get packageListReady(): boolean;
            public static get hasTarget(): boolean;
            public static Add ($value: FairyGUI.EMRenderTarget) : void
            public static Remove ($value: FairyGUI.EMRenderTarget) : void
            public static Update () : void
            public static Reload () : void
            public constructor ()
        }
        enum PackageItemType
        { Image = 0, MovieClip = 1, Sound = 2, Component = 3, Atlas = 4, Font = 5, Swf = 6, Misc = 7, Unknown = 8, Spine = 9, DragoneBones = 10 }
        enum ObjectType
        { Image = 0, MovieClip = 1, Swf = 2, Graph = 3, Loader = 4, Group = 5, Text = 6, RichText = 7, InputText = 8, Component = 9, List = 10, Label = 11, Button = 12, ComboBox = 13, ProgressBar = 14, Slider = 15, ScrollBar = 16, Tree = 17, Loader3D = 18 }
        enum OverflowType
        { Visible = 0, Hidden = 1, Scroll = 2 }
        enum FillType
        { None = 0, Scale = 1, ScaleMatchHeight = 2, ScaleMatchWidth = 3, ScaleFree = 4, ScaleNoBorder = 5 }
        enum ScrollType
        { Horizontal = 0, Vertical = 1, Both = 2 }
        enum ScrollBarDisplayType
        { Default = 0, Visible = 1, Auto = 2, Hidden = 3 }
        enum RelationType
        { Left_Left = 0, Left_Center = 1, Left_Right = 2, Center_Center = 3, Right_Left = 4, Right_Center = 5, Right_Right = 6, Top_Top = 7, Top_Middle = 8, Top_Bottom = 9, Middle_Middle = 10, Bottom_Top = 11, Bottom_Middle = 12, Bottom_Bottom = 13, Width = 14, Height = 15, LeftExt_Left = 16, LeftExt_Right = 17, RightExt_Left = 18, RightExt_Right = 19, TopExt_Top = 20, TopExt_Bottom = 21, BottomExt_Top = 22, BottomExt_Bottom = 23, Size = 24 }
        enum ListLayoutType
        { SingleColumn = 0, SingleRow = 1, FlowHorizontal = 2, FlowVertical = 3, Pagination = 4 }
        enum ListSelectionMode
        { Single = 0, Multiple = 1, Multiple_SingleClick = 2, None = 3 }
        enum ProgressTitleType
        { Percent = 0, ValueAndMax = 1, Value = 2, Max = 3 }
        enum ButtonMode
        { Common = 0, Check = 1, Radio = 2 }
        enum TransitionActionType
        { XY = 0, Size = 1, Scale = 2, Pivot = 3, Alpha = 4, Rotation = 5, Color = 6, Animation = 7, Visible = 8, Sound = 9, Transition = 10, Shake = 11, ColorFilter = 12, Skew = 13, Text = 14, Icon = 15, Unknown = 16 }
        enum GroupLayoutType
        { None = 0, Horizontal = 1, Vertical = 2 }
        enum ChildrenRenderOrder
        { Ascent = 0, Descent = 1, Arch = 2 }
        enum PopupDirection
        { Auto = 0, Up = 1, Down = 2 }
        enum OriginHorizontal
        { Left = 0, Right = 1 }
        enum OriginVertical
        { Top = 0, Bottom = 1 }
        enum Origin90
        { TopLeft = 0, TopRight = 1, BottomLeft = 2, BottomRight = 3 }
        enum Origin180
        { Top = 0, Bottom = 1, Left = 2, Right = 3 }
        enum Origin360
        { Top = 0, Bottom = 1, Left = 2, Right = 3 }
        enum FocusRule
        { NotFocusable = 0, Focusable = 1, NavigationBase = 2 }
        class GComponent extends FairyGUI.GObject implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public __onConstruct : System.Action
            public __onDispose : System.Action
            public get rootContainer(): FairyGUI.Container;
            public get container(): FairyGUI.Container;
            public get scrollPane(): FairyGUI.ScrollPane;
            public get onDrop(): FairyGUI.EventListener;
            public get fairyBatching(): boolean;
            public set fairyBatching(value: boolean);
            public get opaque(): boolean;
            public set opaque(value: boolean);
            public get margin(): FairyGUI.Margin;
            public set margin(value: FairyGUI.Margin);
            public get childrenRenderOrder(): FairyGUI.ChildrenRenderOrder;
            public set childrenRenderOrder(value: FairyGUI.ChildrenRenderOrder);
            public get apexIndex(): number;
            public set apexIndex(value: number);
            public get tabStopChildren(): boolean;
            public set tabStopChildren(value: boolean);
            public get numChildren(): number;
            public get Controllers(): System.Collections.Generic.List$1<FairyGUI.Controller>;
            public get Transitions(): System.Collections.Generic.List$1<FairyGUI.Transition>;
            public get clipSoftness(): UnityEngine.Vector2;
            public set clipSoftness(value: UnityEngine.Vector2);
            public get mask(): FairyGUI.DisplayObject;
            public set mask(value: FairyGUI.DisplayObject);
            public get reversedMask(): boolean;
            public set reversedMask(value: boolean);
            public get baseUserData(): string;
            public get viewWidth(): number;
            public set viewWidth(value: number);
            public get viewHeight(): number;
            public set viewHeight(value: number);
            public InvalidateBatchingState ($childChanged: boolean) : void
            public ShowWindow ($win: FairyGUI.Window) : void
            public AddChild ($child: FairyGUI.GObject) : FairyGUI.GObject
            public AddChildAt ($child: FairyGUI.GObject, $index: number) : FairyGUI.GObject
            public RemoveChild ($child: FairyGUI.GObject) : FairyGUI.GObject
            public RemoveChild ($child: FairyGUI.GObject, $dispose: boolean) : FairyGUI.GObject
            public RemoveChildAt ($index: number) : FairyGUI.GObject
            public RemoveChildAt ($index: number, $dispose: boolean) : FairyGUI.GObject
            public RemoveChildren () : void
            public RemoveChildren ($beginIndex: number, $endIndex: number, $dispose: boolean) : void
            public GetChildAt ($index: number) : FairyGUI.GObject
            public GetChild ($name: string) : FairyGUI.GObject
            public GetChildByPath ($path: string) : FairyGUI.GObject
            public GetVisibleChild ($name: string) : FairyGUI.GObject
            public GetChildInGroup ($group: FairyGUI.GGroup, $name: string) : FairyGUI.GObject
            public GetChildren () : System.Array$1<FairyGUI.GObject>
            public GetChildIndex ($child: FairyGUI.GObject) : number
            public SetChildIndex ($child: FairyGUI.GObject, $index: number) : void
            public SetChildIndexBefore ($child: FairyGUI.GObject, $index: number) : number
            public SwapChildren ($child1: FairyGUI.GObject, $child2: FairyGUI.GObject) : void
            public SwapChildrenAt ($index1: number, $index2: number) : void
            public IsAncestorOf ($obj: FairyGUI.GObject) : boolean
            public ChangeChildrenOrder ($objs: System.Collections.Generic.IList$1<FairyGUI.GObject>) : void
            public AddController ($controller: FairyGUI.Controller) : void
            public GetControllerAt ($index: number) : FairyGUI.Controller
            public GetController ($name: string) : FairyGUI.Controller
            public RemoveController ($c: FairyGUI.Controller) : void
            public GetTransitionAt ($index: number) : FairyGUI.Transition
            public GetTransition ($name: string) : FairyGUI.Transition
            public IsChildInView ($child: FairyGUI.GObject) : boolean
            public GetFirstChildInView () : number
            public SetBoundsChangedFlag () : void
            public EnsureBoundsCorrect () : void
            public GetSnappingPosition ($xValue: $Ref<number>, $yValue: $Ref<number>) : void
            public GetSnappingPositionWithDir ($xValue: $Ref<number>, $yValue: $Ref<number>, $xDir: number, $yDir: number) : void
            public ConstructFromXML ($xml: FairyGUI.Utils.XML) : void
            public constructor ()
            public InvalidateBatchingState () : void
        }
        class GButton extends FairyGUI.GComponent implements FairyGUI.IEventDispatcher, FairyGUI.IColorGear
        {
            protected [__keep_incompatibility]: never;
            public sound : FairyGUI.NAudioClip
            public soundVolumeScale : number
            public changeStateOnClick : boolean
            public linkedPopup : FairyGUI.GObject
            public static UP : string
            public static DOWN : string
            public static OVER : string
            public static SELECTED_OVER : string
            public static DISABLED : string
            public static SELECTED_DISABLED : string
            public get onChanged(): FairyGUI.EventListener;
            public get icon(): string;
            public set icon(value: string);
            public get title(): string;
            public set title(value: string);
            public get text(): string;
            public set text(value: string);
            public get selectedIcon(): string;
            public set selectedIcon(value: string);
            public get selectedTitle(): string;
            public set selectedTitle(value: string);
            public get titleColor(): UnityEngine.Color;
            public set titleColor(value: UnityEngine.Color);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get titleFontSize(): number;
            public set titleFontSize(value: number);
            public get selected(): boolean;
            public set selected(value: boolean);
            public get mode(): FairyGUI.ButtonMode;
            public set mode(value: FairyGUI.ButtonMode);
            public get relatedController(): FairyGUI.Controller;
            public set relatedController(value: FairyGUI.Controller);
            public get relatedPageId(): string;
            public set relatedPageId(value: string);
            public FireClick ($downEffect: boolean, $clickCall?: boolean) : void
            public GetTextField () : FairyGUI.GTextField
            public constructor ()
        }
        class GComboBox extends FairyGUI.GComponent implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public visibleItemCount : number
            public dropdown : FairyGUI.GComponent
            public sound : FairyGUI.NAudioClip
            public soundVolumeScale : number
            public get onChanged(): FairyGUI.EventListener;
            public get icon(): string;
            public set icon(value: string);
            public get title(): string;
            public set title(value: string);
            public get text(): string;
            public set text(value: string);
            public get titleColor(): UnityEngine.Color;
            public set titleColor(value: UnityEngine.Color);
            public get titleFontSize(): number;
            public set titleFontSize(value: number);
            public get items(): System.Array$1<string>;
            public set items(value: System.Array$1<string>);
            public get icons(): System.Array$1<string>;
            public set icons(value: System.Array$1<string>);
            public get values(): System.Array$1<string>;
            public set values(value: System.Array$1<string>);
            public get itemList(): System.Collections.Generic.List$1<string>;
            public get valueList(): System.Collections.Generic.List$1<string>;
            public get iconList(): System.Collections.Generic.List$1<string>;
            public get selectedIndex(): number;
            public set selectedIndex(value: number);
            public get selectionController(): FairyGUI.Controller;
            public set selectionController(value: FairyGUI.Controller);
            public get value(): string;
            public set value(value: string);
            public get popupDirection(): FairyGUI.PopupDirection;
            public set popupDirection(value: FairyGUI.PopupDirection);
            public ApplyListChange () : void
            public GetTextField () : FairyGUI.GTextField
            public UpdateDropdownList () : void
            public constructor ()
        }
        class ScrollPane extends FairyGUI.EventDispatcher implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public static TWEEN_TIME_GO : number
            public static TWEEN_TIME_DEFAULT : number
            public static PULL_RATIO : number
            public static get draggingPane(): FairyGUI.ScrollPane;
            public get onScroll(): FairyGUI.EventListener;
            public get onScrollEnd(): FairyGUI.EventListener;
            public get onPullDownRelease(): FairyGUI.EventListener;
            public get onPullUpRelease(): FairyGUI.EventListener;
            public get owner(): FairyGUI.GComponent;
            public get hzScrollBar(): FairyGUI.GScrollBar;
            public get vtScrollBar(): FairyGUI.GScrollBar;
            public get header(): FairyGUI.GComponent;
            public get footer(): FairyGUI.GComponent;
            public get bouncebackEffect(): boolean;
            public set bouncebackEffect(value: boolean);
            public get touchEffect(): boolean;
            public set touchEffect(value: boolean);
            public get inertiaDisabled(): boolean;
            public set inertiaDisabled(value: boolean);
            public get softnessOnTopOrLeftSide(): boolean;
            public set softnessOnTopOrLeftSide(value: boolean);
            public get scrollStep(): number;
            public set scrollStep(value: number);
            public get snapToItem(): boolean;
            public set snapToItem(value: boolean);
            public get pageMode(): boolean;
            public set pageMode(value: boolean);
            public get pageController(): FairyGUI.Controller;
            public set pageController(value: FairyGUI.Controller);
            public get mouseWheelEnabled(): boolean;
            public set mouseWheelEnabled(value: boolean);
            public get decelerationRate(): number;
            public set decelerationRate(value: number);
            public get isDragged(): boolean;
            public get percX(): number;
            public set percX(value: number);
            public get percY(): number;
            public set percY(value: number);
            public get posX(): number;
            public set posX(value: number);
            public get posY(): number;
            public set posY(value: number);
            public get isBottomMost(): boolean;
            public get isRightMost(): boolean;
            public get currentPageX(): number;
            public set currentPageX(value: number);
            public get currentPageY(): number;
            public set currentPageY(value: number);
            public get scrollingPosX(): number;
            public get scrollingPosY(): number;
            public get contentWidth(): number;
            public get contentHeight(): number;
            public get viewWidth(): number;
            public set viewWidth(value: number);
            public get viewHeight(): number;
            public set viewHeight(value: number);
            public Setup ($buffer: FairyGUI.Utils.ByteBuffer) : void
            public Dispose () : void
            public SetPercX ($value: number, $ani: boolean) : void
            public SetPercY ($value: number, $ani: boolean) : void
            public SetPosX ($value: number, $ani: boolean) : void
            public SetPosY ($value: number, $ani: boolean) : void
            public SetCurrentPageX ($value: number, $ani: boolean) : void
            public SetCurrentPageY ($value: number, $ani: boolean) : void
            public ScrollTop () : void
            public ScrollTop ($ani: boolean) : void
            public ScrollBottom () : void
            public ScrollBottom ($ani: boolean) : void
            public ScrollUp () : void
            public ScrollUp ($ratio: number, $ani: boolean) : void
            public ScrollDown () : void
            public ScrollDown ($ratio: number, $ani: boolean) : void
            public ScrollLeft () : void
            public ScrollLeft ($ratio: number, $ani: boolean) : void
            public ScrollRight () : void
            public ScrollRight ($ratio: number, $ani: boolean) : void
            public ScrollToView ($obj: FairyGUI.GObject) : void
            public ScrollToView ($obj: FairyGUI.GObject, $ani: boolean) : void
            public ScrollToView ($obj: FairyGUI.GObject, $ani: boolean, $setFirst: boolean) : void
            public ScrollToView ($rect: UnityEngine.Rect, $ani: boolean, $setFirst: boolean) : void
            public IsChildInView ($obj: FairyGUI.GObject) : boolean
            public CancelDragging () : void
            public LockHeader ($size: number) : void
            public LockFooter ($size: number) : void
            public UpdateScrollBarVisible () : void
            public constructor ($owner: FairyGUI.GComponent)
            public constructor ()
        }
        class Window extends FairyGUI.GComponent implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public bringToFontOnClick : boolean
            public __onInit : System.Action
            public __onShown : System.Action
            public __onHide : System.Action
            public __doShowAnimation : System.Action
            public __doHideAnimation : System.Action
            public get contentPane(): FairyGUI.GComponent;
            public set contentPane(value: FairyGUI.GComponent);
            public get frame(): FairyGUI.GComponent;
            public get closeButton(): FairyGUI.GObject;
            public set closeButton(value: FairyGUI.GObject);
            public get dragArea(): FairyGUI.GObject;
            public set dragArea(value: FairyGUI.GObject);
            public get contentArea(): FairyGUI.GObject;
            public set contentArea(value: FairyGUI.GObject);
            public get modalWaitingPane(): FairyGUI.GObject;
            public get isShowing(): boolean;
            public get isTop(): boolean;
            public get modal(): boolean;
            public set modal(value: boolean);
            public get modalWaiting(): boolean;
            public AddUISource ($source: FairyGUI.IUISource) : void
            public Show () : void
            public ShowOn ($r: FairyGUI.GRoot) : void
            public Hide () : void
            public HideImmediately () : void
            public CenterOn ($r: FairyGUI.GRoot, $restraint: boolean) : void
            public ToggleStatus () : void
            public BringToFront () : void
            public ShowModalWait () : void
            public ShowModalWait ($requestingCmd: number) : void
            public CloseModalWait () : boolean
            public CloseModalWait ($requestingCmd: number) : boolean
            public Init () : void
            public constructor ()
        }
        class GGroup extends FairyGUI.GObject implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public get layout(): FairyGUI.GroupLayoutType;
            public set layout(value: FairyGUI.GroupLayoutType);
            public get lineGap(): number;
            public set lineGap(value: number);
            public get columnGap(): number;
            public set columnGap(value: number);
            public get excludeInvisibles(): boolean;
            public set excludeInvisibles(value: boolean);
            public get autoSizeDisabled(): boolean;
            public set autoSizeDisabled(value: boolean);
            public get mainGridMinSize(): number;
            public set mainGridMinSize(value: number);
            public get mainGridIndex(): number;
            public set mainGridIndex(value: number);
            public SetBoundsChangedFlag ($positionChangedOnly?: boolean) : void
            public EnsureBoundsCorrect () : void
            public constructor ()
        }
        class Transition extends System.Object implements FairyGUI.ITweenListener
        {
            protected [__keep_incompatibility]: never;
            public invalidateBatchingEveryFrame : boolean
            public get name(): string;
            public get playing(): boolean;
            public get totalDuration(): number;
            public get timeScale(): number;
            public set timeScale(value: number);
            public get ignoreEngineTimeScale(): boolean;
            public set ignoreEngineTimeScale(value: boolean);
            public Play () : void
            public Play ($onComplete: FairyGUI.PlayCompleteCallback) : void
            public Play ($times: number, $delay: number, $onComplete: FairyGUI.PlayCompleteCallback) : void
            public Play ($times: number, $delay: number, $startTime: number, $endTime: number, $onComplete: FairyGUI.PlayCompleteCallback) : void
            public PlayReverse () : void
            public PlayReverse ($onComplete: FairyGUI.PlayCompleteCallback) : void
            public PlayReverse ($times: number, $delay: number, $onComplete: FairyGUI.PlayCompleteCallback) : void
            public ChangePlayTimes ($value: number) : void
            public SetAutoPlay ($autoPlay: boolean, $times: number, $delay: number) : void
            public Stop () : void
            public Stop ($setToComplete: boolean, $processCallback: boolean) : void
            public SetPaused ($paused: boolean) : void
            public Dispose () : void
            public SetValue ($label: string, ...aParams: any[]) : void
            public SetHook ($label: string, $callback: FairyGUI.TransitionHook) : void
            public ClearHooks () : void
            public SetTarget ($label: string, $newTarget: FairyGUI.GObject) : void
            public SetDuration ($label: string, $value: number) : void
            public GetLabelTime ($label: string) : number
            public OnTweenStart ($tweener: FairyGUI.GTweener) : void
            public OnTweenUpdate ($tweener: FairyGUI.GTweener) : void
            public OnTweenComplete ($tweener: FairyGUI.GTweener) : void
            public Setup ($buffer: FairyGUI.Utils.ByteBuffer) : void
            public constructor ($owner: FairyGUI.GComponent)
            public constructor ()
        }
        class GearBase extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static disableAllTweenEffect : boolean
            public get controller(): FairyGUI.Controller;
            public set controller(value: FairyGUI.Controller);
            public get tweenConfig(): FairyGUI.GearTweenConfig;
            public Dispose () : void
            public Setup ($buffer: FairyGUI.Utils.ByteBuffer) : void
            public UpdateFromRelations ($dx: number, $dy: number) : void
            public Apply () : void
            public UpdateState () : void
        }
        class GearAnimation extends FairyGUI.GearBase
        {
            protected [__keep_incompatibility]: never;
            public AddExtStatus ($pageId: string, $buffer: FairyGUI.Utils.ByteBuffer) : void
            public constructor ($owner: FairyGUI.GObject)
            public constructor ()
        }
        class GearTweenConfig extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public tween : boolean
            public easeType : FairyGUI.EaseType
            public customEase : FairyGUI.CustomEase
            public duration : number
            public delay : number
            public constructor ()
        }
        class GearColor extends FairyGUI.GearBase implements FairyGUI.ITweenListener
        {
            protected [__keep_incompatibility]: never;
            public OnTweenStart ($tweener: FairyGUI.GTweener) : void
            public OnTweenUpdate ($tweener: FairyGUI.GTweener) : void
            public OnTweenComplete ($tweener: FairyGUI.GTweener) : void
            public constructor ($owner: FairyGUI.GObject)
            public constructor ()
        }
        class GearDisplay extends FairyGUI.GearBase
        {
            protected [__keep_incompatibility]: never;
            public get pages(): System.Array$1<string>;
            public set pages(value: System.Array$1<string>);
            public get connected(): boolean;
            public AddLock () : number
            public ReleaseLock ($token: number) : void
            public constructor ($owner: FairyGUI.GObject)
            public constructor ()
        }
        class GearDisplay2 extends FairyGUI.GearBase
        {
            protected [__keep_incompatibility]: never;
            public condition : number
            public get pages(): System.Array$1<string>;
            public set pages(value: System.Array$1<string>);
            public Evaluate ($connected: boolean) : boolean
            public constructor ($owner: FairyGUI.GObject)
            public constructor ()
        }
        class GearFontSize extends FairyGUI.GearBase
        {
            protected [__keep_incompatibility]: never;
            public constructor ($owner: FairyGUI.GObject)
            public constructor ()
        }
        class GearIcon extends FairyGUI.GearBase
        {
            protected [__keep_incompatibility]: never;
            public constructor ($owner: FairyGUI.GObject)
            public constructor ()
        }
        class GearLook extends FairyGUI.GearBase implements FairyGUI.ITweenListener
        {
            protected [__keep_incompatibility]: never;
            public OnTweenStart ($tweener: FairyGUI.GTweener) : void
            public OnTweenUpdate ($tweener: FairyGUI.GTweener) : void
            public OnTweenComplete ($tweener: FairyGUI.GTweener) : void
            public constructor ($owner: FairyGUI.GObject)
            public constructor ()
        }
        class GearSize extends FairyGUI.GearBase implements FairyGUI.ITweenListener
        {
            protected [__keep_incompatibility]: never;
            public OnTweenStart ($tweener: FairyGUI.GTweener) : void
            public OnTweenUpdate ($tweener: FairyGUI.GTweener) : void
            public OnTweenComplete ($tweener: FairyGUI.GTweener) : void
            public constructor ($owner: FairyGUI.GObject)
            public constructor ()
        }
        class GearText extends FairyGUI.GearBase
        {
            protected [__keep_incompatibility]: never;
            public constructor ($owner: FairyGUI.GObject)
            public constructor ()
        }
        class GearXY extends FairyGUI.GearBase implements FairyGUI.ITweenListener
        {
            protected [__keep_incompatibility]: never;
            public positionsInPercent : boolean
            public AddExtStatus ($pageId: string, $buffer: FairyGUI.Utils.ByteBuffer) : void
            public OnTweenStart ($tweener: FairyGUI.GTweener) : void
            public OnTweenUpdate ($tweener: FairyGUI.GTweener) : void
            public OnTweenComplete ($tweener: FairyGUI.GTweener) : void
            public constructor ($owner: FairyGUI.GObject)
            public constructor ()
        }
        class GGraph extends FairyGUI.GObject implements FairyGUI.IEventDispatcher, FairyGUI.IColorGear
        {
            protected [__keep_incompatibility]: never;
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get shape(): FairyGUI.Shape;
            public ReplaceMe ($target: FairyGUI.GObject) : void
            public AddBeforeMe ($target: FairyGUI.GObject) : void
            public AddAfterMe ($target: FairyGUI.GObject) : void
            public SetNativeObject ($obj: FairyGUI.DisplayObject) : void
            public DrawRect ($aWidth: number, $aHeight: number, $lineSize: number, $lineColor: UnityEngine.Color, $fillColor: UnityEngine.Color) : void
            public DrawRoundRect ($aWidth: number, $aHeight: number, $fillColor: UnityEngine.Color, $corner: System.Array$1<number>) : void
            public DrawEllipse ($aWidth: number, $aHeight: number, $fillColor: UnityEngine.Color) : void
            public DrawPolygon ($aWidth: number, $aHeight: number, $points: System.Collections.Generic.IList$1<UnityEngine.Vector2>, $fillColor: UnityEngine.Color) : void
            public DrawPolygon ($aWidth: number, $aHeight: number, $points: System.Collections.Generic.IList$1<UnityEngine.Vector2>, $fillColor: UnityEngine.Color, $lineSize: number, $lineColor: UnityEngine.Color) : void
            public constructor ()
        }
        class GImage extends FairyGUI.GObject implements FairyGUI.IEventDispatcher, FairyGUI.IColorGear
        {
            protected [__keep_incompatibility]: never;
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get flip(): FairyGUI.FlipType;
            public set flip(value: FairyGUI.FlipType);
            public get fillMethod(): FairyGUI.FillMethod;
            public set fillMethod(value: FairyGUI.FillMethod);
            public get fillOrigin(): number;
            public set fillOrigin(value: number);
            public get fillClockwise(): boolean;
            public set fillClockwise(value: boolean);
            public get fillAmount(): number;
            public set fillAmount(value: number);
            public get texture(): FairyGUI.NTexture;
            public set texture(value: FairyGUI.NTexture);
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get shader(): string;
            public set shader(value: string);
            public constructor ()
        }
        class GLabel extends FairyGUI.GComponent implements FairyGUI.IEventDispatcher, FairyGUI.IColorGear
        {
            protected [__keep_incompatibility]: never;
            public get icon(): string;
            public set icon(value: string);
            public get title(): string;
            public set title(value: string);
            public get text(): string;
            public set text(value: string);
            public get editable(): boolean;
            public set editable(value: boolean);
            public get titleColor(): UnityEngine.Color;
            public set titleColor(value: UnityEngine.Color);
            public get titleFontSize(): number;
            public set titleFontSize(value: number);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public GetTextField () : FairyGUI.GTextField
            public constructor ()
        }
        interface ListItemRenderer
        { 
        (index: number, item: FairyGUI.GObject) : void; 
        Invoke?: (index: number, item: FairyGUI.GObject) => void;
        }
        var ListItemRenderer: { new (func: (index: number, item: FairyGUI.GObject) => void): ListItemRenderer; }
        interface ListItemProvider
        { 
        (index: number) : string; 
        Invoke?: (index: number) => string;
        }
        var ListItemProvider: { new (func: (index: number) => string): ListItemProvider; }
        class GList extends FairyGUI.GComponent implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public foldInvisibleItems : boolean
            public selectionMode : FairyGUI.ListSelectionMode
            public itemRenderer : FairyGUI.ListItemRenderer
            public itemProvider : FairyGUI.ListItemProvider
            public scrollItemToViewOnClick : boolean
            public get onClickItem(): FairyGUI.EventListener;
            public get onRightClickItem(): FairyGUI.EventListener;
            public get defaultItem(): string;
            public set defaultItem(value: string);
            public get layout(): FairyGUI.ListLayoutType;
            public set layout(value: FairyGUI.ListLayoutType);
            public get lineCount(): number;
            public set lineCount(value: number);
            public get columnCount(): number;
            public set columnCount(value: number);
            public get lineGap(): number;
            public set lineGap(value: number);
            public get columnGap(): number;
            public set columnGap(value: number);
            public get align(): FairyGUI.AlignType;
            public set align(value: FairyGUI.AlignType);
            public get verticalAlign(): FairyGUI.VertAlignType;
            public set verticalAlign(value: FairyGUI.VertAlignType);
            public get autoResizeItem(): boolean;
            public set autoResizeItem(value: boolean);
            public get defaultItemSize(): UnityEngine.Vector2;
            public set defaultItemSize(value: UnityEngine.Vector2);
            public get itemPool(): FairyGUI.GObjectPool;
            public get selectedIndex(): number;
            public set selectedIndex(value: number);
            public get selectionController(): FairyGUI.Controller;
            public set selectionController(value: FairyGUI.Controller);
            public get touchItem(): FairyGUI.GObject;
            public get isVirtual(): boolean;
            public get numItems(): number;
            public set numItems(value: number);
            public GetFromPool ($url: string) : FairyGUI.GObject
            public AddItemFromPool () : FairyGUI.GObject
            public AddItemFromPool ($url: string) : FairyGUI.GObject
            public RemoveChildToPoolAt ($index: number) : void
            public RemoveChildToPool ($child: FairyGUI.GObject) : void
            public RemoveChildrenToPool () : void
            public RemoveChildrenToPool ($beginIndex: number, $endIndex: number) : void
            public GetSelection () : System.Collections.Generic.List$1<number>
            public GetSelection ($result: System.Collections.Generic.List$1<number>) : System.Collections.Generic.List$1<number>
            public AddSelection ($index: number, $scrollItToView: boolean) : void
            public RemoveSelection ($index: number) : void
            public ClearSelection () : void
            public SelectAll () : void
            public SelectNone () : void
            public SelectReverse () : void
            public EnableSelectionFocusEvents ($enabled: boolean) : void
            public EnableArrowKeyNavigation ($enabled: boolean) : void
            public HandleArrowKey ($dir: number) : number
            public ResizeToFit () : void
            public ResizeToFit ($itemCount: number) : void
            public ResizeToFit ($itemCount: number, $minSize: number) : void
            public ScrollToView ($index: number) : void
            public ScrollToView ($index: number, $ani: boolean) : void
            public ScrollToView ($index: number, $ani: boolean, $setFirst: boolean) : void
            public ChildIndexToItemIndex ($index: number) : number
            public ItemIndexToChildIndex ($index: number) : number
            public SetVirtual () : void
            public SetVirtualAndLoop () : void
            public RefreshVirtualList () : void
            public constructor ()
        }
        class GObjectPool extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public initCallback : FairyGUI.GObjectPool.InitCallbackDelegate
            public get count(): number;
            public Clear () : void
            public GetObject ($url: string) : FairyGUI.GObject
            public ReturnObject ($obj: FairyGUI.GObject) : void
            public constructor ($manager: UnityEngine.Transform)
            public constructor ()
        }
        class GLoader3D extends FairyGUI.GObject implements FairyGUI.IEventDispatcher, FairyGUI.IAnimationGear, FairyGUI.IColorGear
        {
            protected [__keep_incompatibility]: never;
            public get url(): string;
            public set url(value: string);
            public get icon(): string;
            public set icon(value: string);
            public get align(): FairyGUI.AlignType;
            public set align(value: FairyGUI.AlignType);
            public get verticalAlign(): FairyGUI.VertAlignType;
            public set verticalAlign(value: FairyGUI.VertAlignType);
            public get fill(): FairyGUI.FillType;
            public set fill(value: FairyGUI.FillType);
            public get shrinkOnly(): boolean;
            public set shrinkOnly(value: boolean);
            public get autoSize(): boolean;
            public set autoSize(value: boolean);
            public get playing(): boolean;
            public set playing(value: boolean);
            public get frame(): number;
            public set frame(value: number);
            public get timeScale(): number;
            public set timeScale(value: number);
            public get ignoreEngineTimeScale(): boolean;
            public set ignoreEngineTimeScale(value: boolean);
            public get loop(): boolean;
            public set loop(value: boolean);
            public get animationName(): string;
            public set animationName(value: string);
            public get skinName(): string;
            public set skinName(value: string);
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get shader(): string;
            public set shader(value: string);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get wrapTarget(): UnityEngine.GameObject;
            public get filter(): FairyGUI.IFilter;
            public set filter(value: FairyGUI.IFilter);
            public get blendMode(): FairyGUI.BlendMode;
            public set blendMode(value: FairyGUI.BlendMode);
            public Advance ($time: number) : void
            public SetWrapTarget ($gameObject: UnityEngine.GameObject, $cloneMaterial: boolean, $width: number, $height: number) : void
            public constructor ()
        }
        class GMovieClip extends FairyGUI.GObject implements FairyGUI.IEventDispatcher, FairyGUI.IAnimationGear, FairyGUI.IColorGear
        {
            protected [__keep_incompatibility]: never;
            public get onPlayEnd(): FairyGUI.EventListener;
            public get playing(): boolean;
            public set playing(value: boolean);
            public get frame(): number;
            public set frame(value: number);
            public get color(): UnityEngine.Color;
            public set color(value: UnityEngine.Color);
            public get flip(): FairyGUI.FlipType;
            public set flip(value: FairyGUI.FlipType);
            public get material(): UnityEngine.Material;
            public set material(value: UnityEngine.Material);
            public get shader(): string;
            public set shader(value: string);
            public get timeScale(): number;
            public set timeScale(value: number);
            public get ignoreEngineTimeScale(): boolean;
            public set ignoreEngineTimeScale(value: boolean);
            public Rewind () : void
            public SyncStatus ($anotherMc: FairyGUI.GMovieClip) : void
            public Advance ($time: number) : void
            public SetPlaySettings ($start: number, $end: number, $times: number, $endAt: number) : void
            public constructor ()
        }
        class Relations extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public handling : FairyGUI.GObject
            public get isEmpty(): boolean;
            public Add ($target: FairyGUI.GObject, $relationType: FairyGUI.RelationType) : void
            public Add ($target: FairyGUI.GObject, $relationType: FairyGUI.RelationType, $usePercent: boolean) : void
            public Remove ($target: FairyGUI.GObject, $relationType: FairyGUI.RelationType) : void
            public Contains ($target: FairyGUI.GObject) : boolean
            public ClearFor ($target: FairyGUI.GObject) : void
            public ClearAll () : void
            public CopyFrom ($source: FairyGUI.Relations) : void
            public Dispose () : void
            public OnOwnerSizeChanged ($dWidth: number, $dHeight: number, $applyPivot: boolean) : void
            public Setup ($buffer: FairyGUI.Utils.ByteBuffer, $parentToChild: boolean) : void
            public constructor ($owner: FairyGUI.GObject)
            public constructor ()
        }
        class GRoot extends FairyGUI.GComponent implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public static get contentScaleFactor(): number;
            public static get contentScaleLevel(): number;
            public static get inst(): FairyGUI.GRoot;
            public get modalLayer(): FairyGUI.GGraph;
            public get hasModalWindow(): boolean;
            public get modalWaiting(): boolean;
            public get touchTarget(): FairyGUI.GObject;
            public get hasAnyPopup(): boolean;
            public get focus(): FairyGUI.GObject;
            public set focus(value: FairyGUI.GObject);
            public get soundVolume(): number;
            public set soundVolume(value: number);
            public SetContentScaleFactor ($designResolutionX: number, $designResolutionY: number) : void
            public SetContentScaleFactor ($designResolutionX: number, $designResolutionY: number, $screenMatchMode: FairyGUI.UIContentScaler.ScreenMatchMode) : void
            public SetContentScaleFactor ($constantScaleFactor: number) : void
            public ApplyContentScaleFactor () : void
            public ShowWindow ($win: FairyGUI.Window) : void
            public HideWindow ($win: FairyGUI.Window) : void
            public HideWindowImmediately ($win: FairyGUI.Window) : void
            public HideWindowImmediately ($win: FairyGUI.Window, $dispose: boolean) : void
            public BringToFront ($win: FairyGUI.Window) : void
            public ShowModalWait () : void
            public CloseModalWait () : void
            public CloseAllExceptModals () : void
            public CloseAllWindows () : void
            public GetTopWindow () : FairyGUI.Window
            public DisplayObjectToGObject ($obj: FairyGUI.DisplayObject) : FairyGUI.GObject
            public ShowPopup ($popup: FairyGUI.GObject) : void
            public ShowPopup ($popup: FairyGUI.GObject, $target: FairyGUI.GObject) : void
            public ShowPopup ($popup: FairyGUI.GObject, $target: FairyGUI.GObject, $dir: FairyGUI.PopupDirection) : void
            public ShowPopup ($popup: FairyGUI.GObject, $target: FairyGUI.GObject, $dir: FairyGUI.PopupDirection, $closeUntilUpEvent: boolean) : void
            public GetPoupPosition ($popup: FairyGUI.GObject, $target: FairyGUI.GObject, $dir: FairyGUI.PopupDirection) : UnityEngine.Vector2
            public TogglePopup ($popup: FairyGUI.GObject) : void
            public TogglePopup ($popup: FairyGUI.GObject, $target: FairyGUI.GObject) : void
            public TogglePopup ($popup: FairyGUI.GObject, $target: FairyGUI.GObject, $dir: FairyGUI.PopupDirection) : void
            public TogglePopup ($popup: FairyGUI.GObject, $target: FairyGUI.GObject, $dir: FairyGUI.PopupDirection, $closeUntilUpEvent: boolean) : void
            public HidePopup () : void
            public HidePopup ($popup: FairyGUI.GObject) : void
            public ShowTooltips ($msg: string) : void
            public ShowTooltips ($msg: string, $delay: number) : void
            public ShowTooltipsWin ($tooltipWin: FairyGUI.GObject) : void
            public ShowTooltipsWin ($tooltipWin: FairyGUI.GObject, $delay: number) : void
            public HideTooltips () : void
            public EnableSound () : void
            public DisableSound () : void
            public PlayOneShotSound ($clip: UnityEngine.AudioClip, $volumeScale: number) : void
            public PlayOneShotSound ($clip: UnityEngine.AudioClip) : void
            public constructor ()
        }
        class GProgressBar extends FairyGUI.GComponent implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public get titleType(): FairyGUI.ProgressTitleType;
            public set titleType(value: FairyGUI.ProgressTitleType);
            public get min(): number;
            public set min(value: number);
            public get max(): number;
            public set max(value: number);
            public get value(): number;
            public set value(value: number);
            public get reverse(): boolean;
            public set reverse(value: boolean);
            public TweenValue ($value: number, $duration: number) : FairyGUI.GTweener
            public Update ($newValue: number) : void
            public constructor ()
        }
        class GSlider extends FairyGUI.GComponent implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public changeOnClick : boolean
            public canDrag : boolean
            public get onChanged(): FairyGUI.EventListener;
            public get onGripTouchEnd(): FairyGUI.EventListener;
            public get titleType(): FairyGUI.ProgressTitleType;
            public set titleType(value: FairyGUI.ProgressTitleType);
            public get min(): number;
            public set min(value: number);
            public get max(): number;
            public set max(value: number);
            public get value(): number;
            public set value(value: number);
            public get wholeNumbers(): boolean;
            public set wholeNumbers(value: boolean);
            public constructor ()
        }
        class GRichTextField extends FairyGUI.GTextField implements FairyGUI.IEventDispatcher, FairyGUI.IColorGear, FairyGUI.ITextColorGear
        {
            protected [__keep_incompatibility]: never;
            public get richTextField(): FairyGUI.RichTextField;
            public get emojies(): System.Collections.Generic.Dictionary$2<number, FairyGUI.Emoji>;
            public set emojies(value: System.Collections.Generic.Dictionary$2<number, FairyGUI.Emoji>);
            public constructor ()
        }
        class GTextInput extends FairyGUI.GTextField implements FairyGUI.IEventDispatcher, FairyGUI.IColorGear, FairyGUI.ITextColorGear
        {
            protected [__keep_incompatibility]: never;
            public get inputTextField(): FairyGUI.InputTextField;
            public get onChanged(): FairyGUI.EventListener;
            public get onSubmit(): FairyGUI.EventListener;
            public get editable(): boolean;
            public set editable(value: boolean);
            public get hideInput(): boolean;
            public set hideInput(value: boolean);
            public get maxLength(): number;
            public set maxLength(value: number);
            public get restrict(): string;
            public set restrict(value: string);
            public get displayAsPassword(): boolean;
            public set displayAsPassword(value: boolean);
            public get caretPosition(): number;
            public set caretPosition(value: number);
            public get promptText(): string;
            public set promptText(value: string);
            public get keyboardInput(): boolean;
            public set keyboardInput(value: boolean);
            public get keyboardType(): number;
            public set keyboardType(value: number);
            public get disableIME(): boolean;
            public set disableIME(value: boolean);
            public get emojies(): System.Collections.Generic.Dictionary$2<number, FairyGUI.Emoji>;
            public set emojies(value: System.Collections.Generic.Dictionary$2<number, FairyGUI.Emoji>);
            public get border(): number;
            public set border(value: number);
            public get corner(): number;
            public set corner(value: number);
            public get borderColor(): UnityEngine.Color;
            public set borderColor(value: UnityEngine.Color);
            public get backgroundColor(): UnityEngine.Color;
            public set backgroundColor(value: UnityEngine.Color);
            public get mouseWheelEnabled(): boolean;
            public set mouseWheelEnabled(value: boolean);
            public SetSelection ($start: number, $length: number) : void
            public ReplaceSelection ($value: string) : void
            public constructor ()
        }
        class GTree extends FairyGUI.GList implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public treeNodeRender : FairyGUI.GTree.TreeNodeRenderDelegate
            public treeNodeWillExpand : FairyGUI.GTree.TreeNodeWillExpandDelegate
            public get rootNode(): FairyGUI.GTreeNode;
            public get indent(): number;
            public set indent(value: number);
            public get clickToExpand(): number;
            public set clickToExpand(value: number);
            public GetSelectedNode () : FairyGUI.GTreeNode
            public GetSelectedNodes () : System.Collections.Generic.List$1<FairyGUI.GTreeNode>
            public GetSelectedNodes ($result: System.Collections.Generic.List$1<FairyGUI.GTreeNode>) : System.Collections.Generic.List$1<FairyGUI.GTreeNode>
            public SelectNode ($node: FairyGUI.GTreeNode) : void
            public SelectNode ($node: FairyGUI.GTreeNode, $scrollItToView: boolean) : void
            public UnselectNode ($node: FairyGUI.GTreeNode) : void
            public ExpandAll () : void
            public ExpandAll ($folderNode: FairyGUI.GTreeNode) : void
            public CollapseAll () : void
            public CollapseAll ($folderNode: FairyGUI.GTreeNode) : void
            public constructor ()
        }
        class GTreeNode extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public data : any
            public get parent(): FairyGUI.GTreeNode;
            public get tree(): FairyGUI.GTree;
            public get cell(): FairyGUI.GComponent;
            public get level(): number;
            public get expanded(): boolean;
            public set expanded(value: boolean);
            public get isFolder(): boolean;
            public get text(): string;
            public set text(value: string);
            public get icon(): string;
            public set icon(value: string);
            public get numChildren(): number;
            public ExpandToRoot () : void
            public AddChild ($child: FairyGUI.GTreeNode) : FairyGUI.GTreeNode
            public AddChildAt ($child: FairyGUI.GTreeNode, $index: number) : FairyGUI.GTreeNode
            public RemoveChild ($child: FairyGUI.GTreeNode) : FairyGUI.GTreeNode
            public RemoveChildAt ($index: number) : FairyGUI.GTreeNode
            public RemoveChildren ($beginIndex?: number, $endIndex?: number) : void
            public GetChildAt ($index: number) : FairyGUI.GTreeNode
            public GetChildIndex ($child: FairyGUI.GTreeNode) : number
            public GetPrevSibling () : FairyGUI.GTreeNode
            public GetNextSibling () : FairyGUI.GTreeNode
            public SetChildIndex ($child: FairyGUI.GTreeNode, $index: number) : void
            public SwapChildren ($child1: FairyGUI.GTreeNode, $child2: FairyGUI.GTreeNode) : void
            public SwapChildrenAt ($index1: number, $index2: number) : void
            public constructor ($hasChild: boolean)
            public constructor ($hasChild: boolean, $resURL: string)
            public constructor ()
        }
        class GScrollBar extends FairyGUI.GComponent implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public get minSize(): number;
            public get gripDragging(): boolean;
            public SetScrollPane ($target: FairyGUI.ScrollPane, $vertical: boolean) : void
            public SetDisplayPerc ($value: number) : void
            public setScrollPerc ($value: number) : void
            public constructor ()
        }
        interface UILoadCallback
        { 
        () : void; 
        Invoke?: () => void;
        }
        var UILoadCallback: { new (func: () => void): UILoadCallback; }
        interface IUISource
        {
            fileName : string
            loaded : boolean
            Load ($callback: FairyGUI.UILoadCallback) : void
            Cancel () : void
        }
        class UIPackage extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static unloadBundleByFGUI : boolean
            public static URL_PREFIX : string
            public get id(): string;
            public get name(): string;
            public static get branch(): string;
            public static set branch(value: string);
            public get assetPath(): string;
            public get customId(): string;
            public set customId(value: string);
            public get resBundle(): UnityEngine.AssetBundle;
            public get dependencies(): System.Array$1<System.Collections.Generic.Dictionary$2<string, string>>;
            public static add_onReleaseResource ($value: System.Action$1<FairyGUI.PackageItem>) : void
            public static remove_onReleaseResource ($value: System.Action$1<FairyGUI.PackageItem>) : void
            public static GetVar ($key: string) : string
            public static SetVar ($key: string, $value: string) : void
            public static GetById ($id: string) : FairyGUI.UIPackage
            public static GetByName ($name: string) : FairyGUI.UIPackage
            public static AddPackage ($bundle: UnityEngine.AssetBundle) : FairyGUI.UIPackage
            public static AddPackage ($desc: UnityEngine.AssetBundle, $res: UnityEngine.AssetBundle) : FairyGUI.UIPackage
            public static AddPackage ($desc: UnityEngine.AssetBundle, $res: UnityEngine.AssetBundle, $mainAssetName: string) : FairyGUI.UIPackage
            public static AddPackage ($descFilePath: string) : FairyGUI.UIPackage
            public static AddPackage ($assetPath: string, $loadFunc: FairyGUI.UIPackage.LoadResource) : FairyGUI.UIPackage
            public static AddPackage ($descData: System.Array$1<number>, $assetNamePrefix: string, $loadFunc: FairyGUI.UIPackage.LoadResource) : FairyGUI.UIPackage
            public static AddPackage ($descData: System.Array$1<number>, $assetNamePrefix: string, $loadFunc: FairyGUI.UIPackage.LoadResourceAsync) : FairyGUI.UIPackage
            public static RemovePackage ($packageIdOrName: string) : void
            public static RemoveAllPackages () : void
            public static GetPackages () : System.Collections.Generic.List$1<FairyGUI.UIPackage>
            public static CreateObject ($pkgName: string, $resName: string) : FairyGUI.GObject
            public static CreateObject ($pkgName: string, $resName: string, $userClass: System.Type) : FairyGUI.GObject
            public static CreateObjectFromURL ($url: string) : FairyGUI.GObject
            public static CreateObjectFromURL ($url: string, $userClass: System.Type) : FairyGUI.GObject
            public static CreateObjectAsync ($pkgName: string, $resName: string, $callback: FairyGUI.UIPackage.CreateObjectCallback) : void
            public static CreateObjectFromURL ($url: string, $callback: FairyGUI.UIPackage.CreateObjectCallback) : void
            public static GetItemAsset ($pkgName: string, $resName: string) : any
            public static GetItemAssetByURL ($url: string) : any
            public static GetItemURL ($pkgName: string, $resName: string) : string
            public static GetItemByURL ($url: string) : FairyGUI.PackageItem
            public static NormalizeURL ($url: string) : string
            public static SetStringsSource ($source: FairyGUI.Utils.XML) : void
            public LoadAllAssets () : void
            public UnloadAssets () : void
            public ReloadAssets () : void
            public ReloadAssets ($resBundle: UnityEngine.AssetBundle) : void
            public CreateObject ($resName: string) : FairyGUI.GObject
            public CreateObject ($resName: string, $userClass: System.Type) : FairyGUI.GObject
            public CreateObjectAsync ($resName: string, $callback: FairyGUI.UIPackage.CreateObjectCallback) : void
            public GetItemAsset ($resName: string) : any
            public GetItems () : System.Collections.Generic.List$1<FairyGUI.PackageItem>
            public GetItem ($itemId: string) : FairyGUI.PackageItem
            public GetItemByName ($itemName: string) : FairyGUI.PackageItem
            public GetItemAsset ($item: FairyGUI.PackageItem) : any
            public SetItemAsset ($item: FairyGUI.PackageItem, $asset: any, $destroyMethod: FairyGUI.DestroyMethod) : void
            public constructor ()
        }
        interface PlayCompleteCallback
        { 
        () : void; 
        Invoke?: () => void;
        }
        var PlayCompleteCallback: { new (func: () => void): PlayCompleteCallback; }
        interface TransitionHook
        { 
        () : void; 
        Invoke?: () => void;
        }
        var TransitionHook: { new (func: () => void): TransitionHook; }
        class TranslationHelper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static strings : System.Collections.Generic.Dictionary$2<string, System.Collections.Generic.Dictionary$2<string, string>>
            public static LoadFromXML ($source: FairyGUI.Utils.XML) : void
            public static TranslateComponent ($item: FairyGUI.PackageItem) : void
            public constructor ()
        }
        class TreeNode extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public data : any
            public get parent(): FairyGUI.TreeNode;
            public get tree(): FairyGUI.TreeView;
            public get cell(): FairyGUI.GComponent;
            public get level(): number;
            public get expanded(): boolean;
            public set expanded(value: boolean);
            public get isFolder(): boolean;
            public get text(): string;
            public get numChildren(): number;
            public AddChild ($child: FairyGUI.TreeNode) : FairyGUI.TreeNode
            public AddChildAt ($child: FairyGUI.TreeNode, $index: number) : FairyGUI.TreeNode
            public RemoveChild ($child: FairyGUI.TreeNode) : FairyGUI.TreeNode
            public RemoveChildAt ($index: number) : FairyGUI.TreeNode
            public RemoveChildren ($beginIndex?: number, $endIndex?: number) : void
            public GetChildAt ($index: number) : FairyGUI.TreeNode
            public GetChildIndex ($child: FairyGUI.TreeNode) : number
            public GetPrevSibling () : FairyGUI.TreeNode
            public GetNextSibling () : FairyGUI.TreeNode
            public SetChildIndex ($child: FairyGUI.TreeNode, $index: number) : void
            public SwapChildren ($child1: FairyGUI.TreeNode, $child2: FairyGUI.TreeNode) : void
            public SwapChildrenAt ($index1: number, $index2: number) : void
            public constructor ($hasChild: boolean)
            public constructor ()
        }
        class TreeView extends FairyGUI.EventDispatcher implements FairyGUI.IEventDispatcher
        {
            protected [__keep_incompatibility]: never;
            public indent : number
            public treeNodeCreateCell : FairyGUI.TreeView.TreeNodeCreateCellDelegate
            public treeNodeRender : FairyGUI.TreeView.TreeNodeRenderDelegate
            public treeNodeWillExpand : FairyGUI.TreeView.TreeNodeWillExpandDelegate
            public get list(): FairyGUI.GList;
            public get root(): FairyGUI.TreeNode;
            public get onClickNode(): FairyGUI.EventListener;
            public get onRightClickNode(): FairyGUI.EventListener;
            public GetSelectedNode () : FairyGUI.TreeNode
            public GetSelection () : System.Collections.Generic.List$1<FairyGUI.TreeNode>
            public AddSelection ($node: FairyGUI.TreeNode, $scrollItToView?: boolean) : void
            public RemoveSelection ($node: FairyGUI.TreeNode) : void
            public ClearSelection () : void
            public GetNodeIndex ($node: FairyGUI.TreeNode) : number
            public UpdateNode ($node: FairyGUI.TreeNode) : void
            public UpdateNodes ($nodes: System.Collections.Generic.List$1<FairyGUI.TreeNode>) : void
            public ExpandAll ($folderNode: FairyGUI.TreeNode) : void
            public CollapseAll ($folderNode: FairyGUI.TreeNode) : void
            public constructor ($list: FairyGUI.GList)
            public constructor ()
        }
        class UIConfig extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public static defaultFont : string
            public static windowModalWaiting : string
            public static globalModalWaiting : string
            public static modalLayerColor : UnityEngine.Color
            public static buttonSound : FairyGUI.NAudioClip
            public static buttonSoundVolumeScale : number
            public static horizontalScrollBar : string
            public static verticalScrollBar : string
            public static defaultScrollStep : number
            public static defaultScrollDecelerationRate : number
            public static defaultScrollBarDisplay : FairyGUI.ScrollBarDisplayType
            public static defaultScrollTouchEffect : boolean
            public static defaultScrollBounceEffect : boolean
            public static defaultScrollSnappingThreshold : number
            public static defaultScrollPagingThreshold : number
            public static popupMenu : string
            public static popupMenu_seperator : string
            public static loaderErrorSign : string
            public static tooltipsWin : string
            public static defaultComboBoxVisibleItemCount : number
            public static touchScrollSensitivity : number
            public static touchDragSensitivity : number
            public static clickDragSensitivity : number
            public static allowSoftnessOnTopOrLeftSide : boolean
            public static bringWindowToFrontOnClick : boolean
            public static inputCaretSize : number
            public static inputHighlightColor : UnityEngine.Color
            public static frameTimeForAsyncUIConstruction : number
            public static depthSupportForPaintingMode : boolean
            public static enhancedTextOutlineEffect : boolean
            public static makePixelPerfect : boolean
            public Items : System.Collections.Generic.List$1<FairyGUI.UIConfig.ConfigValue>
            public PreloadPackages : System.Collections.Generic.List$1<string>
            public static soundLoader : FairyGUI.UIConfig.SoundLoader
            public Load () : void
            public static SetDefaultValue ($key: FairyGUI.UIConfig.ConfigKey, $value: FairyGUI.UIConfig.ConfigValue) : void
            public static ClearResourceRefs () : void
            public ApplyModifiedProperties () : void
            public constructor ()
        }
        class UIContentScaler extends UnityEngine.MonoBehaviour
        {
            protected [__keep_incompatibility]: never;
            public scaleMode : FairyGUI.UIContentScaler.ScaleMode
            public screenMatchMode : FairyGUI.UIContentScaler.ScreenMatchMode
            public designResolutionX : number
            public designResolutionY : number
            public fallbackScreenDPI : number
            public defaultSpriteDPI : number
            public constantScaleFactor : number
            public ignoreOrientation : boolean
            public static scaleFactor : number
            public static scaleLevel : number
            public ApplyModifiedProperties () : void
            public ApplyChange () : void
            public constructor ()
        }
        class UIObjectFactory extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static SetPackageItemExtension ($url: string, $type: System.Type) : void
            public static SetPackageItemExtension ($url: string, $creator: FairyGUI.UIObjectFactory.GComponentCreator) : void
            public static SetLoaderExtension ($type: System.Type) : void
            public static SetLoaderExtension ($creator: FairyGUI.UIObjectFactory.GLoaderCreator) : void
            public static Clear () : void
            public static NewObject ($pi: FairyGUI.PackageItem, $userClass?: System.Type) : FairyGUI.GObject
            public static NewObject ($type: FairyGUI.ObjectType) : FairyGUI.GObject
            public constructor ()
        }
        class UIPainter extends UnityEngine.MonoBehaviour implements FairyGUI.EMRenderTarget
        {
            protected [__keep_incompatibility]: never;
            public packageName : string
            public componentName : string
            public sortingOrder : number
            public get container(): FairyGUI.Container;
            public get ui(): FairyGUI.GComponent;
            public get EM_sortingOrder(): number;
            public SetSortingOrder ($value: number, $apply: boolean) : void
            public CreateUI () : void
            public ApplyModifiedProperties ($sortingOrderChanged: boolean) : void
            public OnUpdateSource ($data: System.Array$1<any>) : void
            public EM_BeforeUpdate () : void
            public EM_Update ($context: FairyGUI.UpdateContext) : void
            public EM_Reload () : void
            public constructor ()
        }
        enum FitScreen
        { None = 0, FitSize = 1, FitWidthAndSetMiddle = 2, FitHeightAndSetCenter = 3 }
        interface TimerCallback
        { 
        (param: any) : void; 
        Invoke?: (param: any) => void;
        }
        var TimerCallback: { new (func: (param: any) => void): TimerCallback; }
        class Timers extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static repeat : number
            public static time : number
            public static catchCallbackExceptions : boolean
            public static get inst(): FairyGUI.Timers;
            public Add ($interval: number, $repeat: number, $callback: FairyGUI.TimerCallback) : void
            public Add ($interval: number, $repeat: number, $callback: FairyGUI.TimerCallback, $callbackParam: any) : void
            public CallLater ($callback: FairyGUI.TimerCallback) : void
            public CallLater ($callback: FairyGUI.TimerCallback, $callbackParam: any) : void
            public AddUpdate ($callback: FairyGUI.TimerCallback) : void
            public AddUpdate ($callback: FairyGUI.TimerCallback, $callbackParam: any) : void
            public StartCoroutine ($routine: System.Collections.IEnumerator) : void
            public Exists ($callback: FairyGUI.TimerCallback) : boolean
            public Remove ($callback: FairyGUI.TimerCallback) : void
            public Update () : void
            public constructor ()
        }
    }
    namespace System.Threading.Tasks {
        class Task extends System.Object implements System.IAsyncResult, System.Threading.IThreadPoolWorkItem, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
        class Task$1<TResult> extends System.Threading.Tasks.Task implements System.IAsyncResult, System.Threading.IThreadPoolWorkItem, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Threading {
        interface IThreadPoolWorkItem
        {
        }
        class SynchronizationContext extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        interface SendOrPostCallback
        { 
        (state: any) : void; 
        Invoke?: (state: any) => void;
        }
        var SendOrPostCallback: { new (func: (state: any) => void): SendOrPostCallback; }
    }
    namespace System.Net {
        class IPAddress extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class EndPoint extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class IPEndPoint extends System.Net.EndPoint
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Diagnostics {
        class Process extends System.ComponentModel.Component implements System.IDisposable, System.ComponentModel.IComponent
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace ET.EventSystem {
        class EventInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get IEvent(): ET.IEvent;
            public get SceneType(): ET.SceneType;
            public constructor ($iEvent: ET.IEvent, $sceneType: ET.SceneType)
            public constructor ()
        }
    }
    namespace System.Net.Sockets {
        class Socket extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
        enum AddressFamily
        { Unknown = -1, Unspecified = 0, Unix = 1, InterNetwork = 2, ImpLink = 3, Pup = 4, Chaos = 5, NS = 6, Ipx = 6, Iso = 7, Osi = 7, Ecma = 8, DataKit = 9, Ccitt = 10, Sna = 11, DecNet = 12, DataLink = 13, Lat = 14, HyperChannel = 15, AppleTalk = 16, NetBios = 17, VoiceView = 18, FireFox = 19, Banyan = 21, Atm = 22, InterNetworkV6 = 23, Cluster = 24, Ieee12844 = 25, Irda = 26, NetworkDesigners = 28, Max = 29 }
        class SocketAsyncEventArgs extends System.EventArgs implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace System.Collections.Concurrent {
        class ConcurrentQueue$1<T> extends System.Object implements System.Collections.ICollection, System.Collections.Concurrent.IProducerConsumerCollection$1<T>, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection$1<T>
        {
            protected [__keep_incompatibility]: never;
        }
        interface IProducerConsumerCollection$1<T> extends System.Collections.ICollection, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable
        {
        }
    }
    namespace System.Net.WebSockets {
        class WebSocketContext extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class HttpListenerWebSocketContext extends System.Net.WebSockets.WebSocketContext
        {
            protected [__keep_incompatibility]: never;
        }
        class WebSocket extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace MongoDB.Bson.IO {
        class BsonWriterSettings extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
        class JsonWriterSettings extends MongoDB.Bson.IO.BsonWriterSettings
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace ET.ConfigComponent {
        class GetAllConfigBytes extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class GetOneConfigBytes extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public ConfigName : string
        }
    }
    namespace AO.ClientReceiveMessages {
        class M2C_OnEnterMapHandler extends ET.AMHandler$1<ET.M2C_OnEnterMap> implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
        class M2C_OnLeaveMapHandler extends ET.AMHandler$1<ET.M2C_OnLeaveMap> implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
        class M2C_CreateUnitsHandler extends ET.AMHandler$1<ET.M2C_CreateUnits> implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
        class M2C_CreateMyUnitHandler extends ET.AMHandler$1<ET.M2C_CreateMyUnit> implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
        class M2C_RemoveUnitsHandler extends ET.AMHandler$1<ET.M2C_RemoveUnits> implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
        class M2C_ComponentPropertyNotifyHandler extends ET.AMHandler$1<ET.M2C_ComponentPropertyNotify> implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
        class M2C_StartSceneChangeHandler extends ET.AMHandler$1<ET.M2C_StartSceneChange> implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
        class M2C_PathfindingResultHandler extends ET.AMHandler$1<ET.M2C_PathfindingResult> implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
        class M2C_StopHandler extends ET.AMHandler$1<ET.M2C_Stop> implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
        class M2C_SpellStartHandler extends ET.AMHandler$1<ET.M2C_SpellStart> implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
        class M2C_SpellStepHandler extends ET.AMHandler$1<ET.M2C_SpellStep> implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
        class M2C_SpellEndHandler extends ET.AMHandler$1<ET.M2C_SpellEnd> implements ET.IMHandler
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Handle ($message: any) : void
            public GetMessageType () : System.Type
            public GetResponseType () : System.Type
        }
    }
    namespace AO.ClientAppSystem {
        class ClientAppAwakeSystem extends ET.AwakeSystem$1<ET.ClientApp> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        class ClientAppUpdateSystem extends ET.UpdateSystem$1<ET.ClientApp> implements ET.ISystemType, ET.IUpdateSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        class ClientAppDestroySystem extends ET.DestroySystem$1<ET.ClientApp> implements ET.ISystemType, ET.IDestroySystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        class ClientAppAddComponentSystem extends ET.AddComponentSystem$1<ET.ClientApp> implements ET.ISystemType, ET.IAddComponentSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity, $component: ET.Entity) : void
        }
    }
    namespace AO.ExecutionEditorModeSystem {
        class ExecutionEditorModeAwakeSystem extends ET.AwakeSystem$1<AO.ExecutionEditorModeComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.LoadingModeSystem {
        class AwakeHandler extends ET.AwakeSystem$1<AO.LoadingModeComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.LobbyModeSystem {
        class LobbyModeComponentAwakeSystem extends ET.AwakeSystem$1<AO.LobbyModeComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.LoginModeSystem {
        class LoginModeComponentAwakeSystem extends ET.AwakeSystem$1<AO.LoginModeComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.MapModeSystem {
        class MapModeComponentAwakeSystem extends ET.AwakeSystem$1<AO.MapModeComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.ItemUnitSystem {
        class AwakeSystemObject extends ET.AwakeSystem$1<AO.ItemUnit> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.SceneSystem {
        class SceneAwakeSystem extends ET.AwakeSystem$2<ET.Scene, string> implements ET.ISystemType, ET.IAwakeSystem$1<string>
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
    }
    namespace AO.SceneUnitComponentSystem {
        class UpdateSystemObject extends ET.UpdateSystem$1<AO.SceneUnitComponent> implements ET.ISystemType, ET.IUpdateSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.UnitTranslateComponentSystem {
        class UnitTranslateComponentAwakeSystem extends ET.AwakeSystem$1<AO.UnitTranslateComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        class UnitTranslateComponentUpdateSystem extends ET.UpdateSystem$1<AO.UnitTranslateComponent> implements ET.ISystemType, ET.IUpdateSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.UnitCollisionComponentSystem {
        class UnitCollisionComponentAwakeSystem extends ET.AwakeSystem$1<AO.UnitCollisionComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        class UnitCollisionComponentUpdateSystem extends ET.UpdateSystem$1<AO.UnitCollisionComponent> implements ET.ISystemType, ET.IUpdateSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.UnitLifeTimeComponentSystem {
        class AwakeSystemObject extends ET.AwakeSystem$2<AO.UnitLifeTimeComponent, number> implements ET.ISystemType, ET.IAwakeSystem$1<number>
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
        }
        class UpdateSystemObject extends ET.UpdateSystem$1<AO.UnitLifeTimeComponent> implements ET.ISystemType, ET.IUpdateSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace AO.EventComponentSystem {
        class EventComponentAwakeSystem extends ET.AwakeSystem$1<AO.EventComponent> implements ET.ISystemType, ET.IAwakeSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
        class EventComponentUpdateSystem extends ET.UpdateSystem$1<AO.EventComponent> implements ET.ISystemType, ET.IUpdateSystem
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public Type () : System.Type
            public SystemType () : System.Type
            public GetInstanceQueueIndex () : ET.InstanceQueueIndex
            public Run ($o: ET.Entity) : void
        }
    }
    namespace FairyGUI.BlendModeUtils {
        class BlendFactor extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public srcFactor : UnityEngine.Rendering.BlendMode
            public dstFactor : UnityEngine.Rendering.BlendMode
            public pma : boolean
            public constructor ($srcFactor: UnityEngine.Rendering.BlendMode, $dstFactor: UnityEngine.Rendering.BlendMode, $pma?: boolean)
            public constructor ()
        }
    }
    namespace FairyGUI.Utils {
        class ByteBuffer extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public littleEndian : boolean
            public stringTable : System.Array$1<string>
            public version : number
            public get position(): number;
            public set position(value: number);
            public get length(): number;
            public get bytesAvailable(): boolean;
            public get buffer(): System.Array$1<number>;
            public set buffer(value: System.Array$1<number>);
            public Skip ($count: number) : number
            public ReadByte () : number
            public ReadBytes ($output: System.Array$1<number>, $destIndex: number, $count: number) : System.Array$1<number>
            public ReadBytes ($count: number) : System.Array$1<number>
            public ReadBuffer () : FairyGUI.Utils.ByteBuffer
            public ReadChar () : number
            public ReadBool () : boolean
            public ReadShort () : number
            public ReadUshort () : number
            public ReadInt () : number
            public ReadUint () : number
            public ReadFloat () : number
            public ReadLong () : bigint
            public ReadDouble () : number
            public ReadString () : string
            public ReadString ($len: number) : string
            public ReadS () : string
            public ReadSArray ($cnt: number) : System.Array$1<string>
            public ReadPath () : System.Collections.Generic.List$1<FairyGUI.GPathPoint>
            public WriteS ($value: string) : void
            public ReadColor () : UnityEngine.Color
            public Seek ($indexTablePos: number, $blockIndex: number) : boolean
            public constructor ($data: System.Array$1<number>, $offset?: number, $length?: number)
            public constructor ()
        }
        interface IHtmlPageContext
        {
            CreateObject ($owner: FairyGUI.RichTextField, $element: FairyGUI.Utils.HtmlElement) : FairyGUI.Utils.IHtmlObject
            FreeObject ($obj: FairyGUI.Utils.IHtmlObject) : void
            GetImageTexture ($image: FairyGUI.Utils.HtmlImage) : FairyGUI.NTexture
            FreeImageTexture ($image: FairyGUI.Utils.HtmlImage, $texture: FairyGUI.NTexture) : void
        }
        class HtmlParseOptions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public linkUnderline : boolean
            public linkColor : UnityEngine.Color
            public linkBgColor : UnityEngine.Color
            public linkHoverBgColor : UnityEngine.Color
            public ignoreWhiteSpace : boolean
            public static DefaultLinkUnderline : boolean
            public static DefaultLinkColor : UnityEngine.Color
            public static DefaultLinkBgColor : UnityEngine.Color
            public static DefaultLinkHoverBgColor : UnityEngine.Color
            public constructor ()
        }
        class HtmlElement extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public type : FairyGUI.Utils.HtmlElementType
            public name : string
            public text : string
            public format : FairyGUI.TextFormat
            public charIndex : number
            public htmlObject : FairyGUI.Utils.IHtmlObject
            public status : number
            public space : number
            public position : UnityEngine.Vector2
            public get isEntity(): boolean;
            public Get ($attrName: string) : any
            public Set ($attrName: string, $attrValue: any) : void
            public GetString ($attrName: string) : string
            public GetString ($attrName: string, $defValue: string) : string
            public GetInt ($attrName: string) : number
            public GetInt ($attrName: string, $defValue: number) : number
            public GetFloat ($attrName: string) : number
            public GetFloat ($attrName: string, $defValue: number) : number
            public GetBool ($attrName: string) : boolean
            public GetBool ($attrName: string, $defValue: boolean) : boolean
            public GetColor ($attrName: string, $defValue: UnityEngine.Color) : UnityEngine.Color
            public FetchAttributes () : void
            public static GetElement ($type: FairyGUI.Utils.HtmlElementType) : FairyGUI.Utils.HtmlElement
            public static ReturnElement ($element: FairyGUI.Utils.HtmlElement) : void
            public static ReturnElements ($elements: System.Collections.Generic.List$1<FairyGUI.Utils.HtmlElement>) : void
            public constructor ()
        }
        class XML extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public name : string
            public text : string
            public get attributes(): System.Collections.Generic.Dictionary$2<string, string>;
            public get elements(): FairyGUI.Utils.XMLList;
            public static Create ($tag: string) : FairyGUI.Utils.XML
            public HasAttribute ($attrName: string) : boolean
            public GetAttribute ($attrName: string) : string
            public GetAttribute ($attrName: string, $defValue: string) : string
            public GetAttributeInt ($attrName: string) : number
            public GetAttributeInt ($attrName: string, $defValue: number) : number
            public GetAttributeFloat ($attrName: string) : number
            public GetAttributeFloat ($attrName: string, $defValue: number) : number
            public GetAttributeBool ($attrName: string) : boolean
            public GetAttributeBool ($attrName: string, $defValue: boolean) : boolean
            public GetAttributeArray ($attrName: string) : System.Array$1<string>
            public GetAttributeArray ($attrName: string, $seperator: number) : System.Array$1<string>
            public GetAttributeColor ($attrName: string, $defValue: UnityEngine.Color) : UnityEngine.Color
            public GetAttributeVector ($attrName: string) : UnityEngine.Vector2
            public SetAttribute ($attrName: string, $attrValue: string) : void
            public SetAttribute ($attrName: string, $attrValue: boolean) : void
            public SetAttribute ($attrName: string, $attrValue: number) : void
            public RemoveAttribute ($attrName: string) : void
            public GetNode ($selector: string) : FairyGUI.Utils.XML
            public Elements () : FairyGUI.Utils.XMLList
            public Elements ($selector: string) : FairyGUI.Utils.XMLList
            public GetEnumerator () : FairyGUI.Utils.XMLList.Enumerator
            public GetEnumerator ($selector: string) : FairyGUI.Utils.XMLList.Enumerator
            public AppendChild ($child: FairyGUI.Utils.XML) : void
            public RemoveChild ($child: FairyGUI.Utils.XML) : void
            public RemoveChildren ($selector: string) : void
            public Parse ($aSource: string) : void
            public Reset () : void
            public ToXMLString ($includeHeader: boolean) : string
            public constructor ($XmlString: string)
            public constructor ()
        }
        class HtmlButton extends System.Object implements FairyGUI.Utils.IHtmlObject
        {
            protected [__keep_incompatibility]: never;
            public static CLICK_EVENT : string
            public static resource : string
            public get button(): FairyGUI.GComponent;
            public get displayObject(): FairyGUI.DisplayObject;
            public get element(): FairyGUI.Utils.HtmlElement;
            public get width(): number;
            public get height(): number;
            public Create ($owner: FairyGUI.RichTextField, $element: FairyGUI.Utils.HtmlElement) : void
            public SetPosition ($x: number, $y: number) : void
            public Add () : void
            public Remove () : void
            public Release () : void
            public Dispose () : void
            public constructor ()
        }
        interface IHtmlObject
        {
            width : number
            height : number
            displayObject : FairyGUI.DisplayObject
            element : FairyGUI.Utils.HtmlElement
            Create ($owner: FairyGUI.RichTextField, $element: FairyGUI.Utils.HtmlElement) : void
            SetPosition ($x: number, $y: number) : void
            Add () : void
            Remove () : void
            Release () : void
            Dispose () : void
        }
        enum HtmlElementType
        { Text = 0, Link = 1, Image = 2, Input = 3, Select = 4, Object = 5, LinkEnd = 6 }
        class HtmlImage extends System.Object implements FairyGUI.Utils.IHtmlObject
        {
            protected [__keep_incompatibility]: never;
            public get loader(): FairyGUI.GLoader;
            public get displayObject(): FairyGUI.DisplayObject;
            public get element(): FairyGUI.Utils.HtmlElement;
            public get width(): number;
            public get height(): number;
            public Create ($owner: FairyGUI.RichTextField, $element: FairyGUI.Utils.HtmlElement) : void
            public SetPosition ($x: number, $y: number) : void
            public Add () : void
            public Remove () : void
            public Release () : void
            public Dispose () : void
            public constructor ()
        }
        class HtmlInput extends System.Object implements FairyGUI.Utils.IHtmlObject
        {
            protected [__keep_incompatibility]: never;
            public static defaultBorderSize : number
            public static defaultBorderColor : UnityEngine.Color
            public static defaultBackgroundColor : UnityEngine.Color
            public get textInput(): FairyGUI.GTextInput;
            public get displayObject(): FairyGUI.DisplayObject;
            public get element(): FairyGUI.Utils.HtmlElement;
            public get width(): number;
            public get height(): number;
            public Create ($owner: FairyGUI.RichTextField, $element: FairyGUI.Utils.HtmlElement) : void
            public SetPosition ($x: number, $y: number) : void
            public Add () : void
            public Remove () : void
            public Release () : void
            public Dispose () : void
            public constructor ()
        }
        class HtmlLink extends System.Object implements FairyGUI.Utils.IHtmlObject
        {
            protected [__keep_incompatibility]: never;
            public get displayObject(): FairyGUI.DisplayObject;
            public get element(): FairyGUI.Utils.HtmlElement;
            public get width(): number;
            public get height(): number;
            public Create ($owner: FairyGUI.RichTextField, $element: FairyGUI.Utils.HtmlElement) : void
            public SetArea ($startLine: number, $startCharX: number, $endLine: number, $endCharX: number) : void
            public SetPosition ($x: number, $y: number) : void
            public Add () : void
            public Remove () : void
            public Release () : void
            public Dispose () : void
            public constructor ()
        }
        class HtmlPageContext extends System.Object implements FairyGUI.Utils.IHtmlPageContext
        {
            protected [__keep_incompatibility]: never;
            public static inst : FairyGUI.Utils.HtmlPageContext
            public CreateObject ($owner: FairyGUI.RichTextField, $element: FairyGUI.Utils.HtmlElement) : FairyGUI.Utils.IHtmlObject
            public FreeObject ($obj: FairyGUI.Utils.IHtmlObject) : void
            public GetImageTexture ($image: FairyGUI.Utils.HtmlImage) : FairyGUI.NTexture
            public FreeImageTexture ($image: FairyGUI.Utils.HtmlImage, $texture: FairyGUI.NTexture) : void
            public constructor ()
        }
        class HtmlParser extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static inst : FairyGUI.Utils.HtmlParser
            public Parse ($aSource: string, $defaultFormat: FairyGUI.TextFormat, $elements: System.Collections.Generic.List$1<FairyGUI.Utils.HtmlElement>, $parseOptions: FairyGUI.Utils.HtmlParseOptions) : void
            public constructor ()
        }
        class HtmlSelect extends System.Object implements FairyGUI.Utils.IHtmlObject
        {
            protected [__keep_incompatibility]: never;
            public static CHANGED_EVENT : string
            public static resource : string
            public get comboBox(): FairyGUI.GComboBox;
            public get displayObject(): FairyGUI.DisplayObject;
            public get element(): FairyGUI.Utils.HtmlElement;
            public get width(): number;
            public get height(): number;
            public Create ($owner: FairyGUI.RichTextField, $element: FairyGUI.Utils.HtmlElement) : void
            public SetPosition ($x: number, $y: number) : void
            public Add () : void
            public Remove () : void
            public Release () : void
            public Dispose () : void
            public constructor ()
        }
        class ToolSet extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ConvertFromHtmlColor ($str: string) : UnityEngine.Color
            public static ColorFromRGB ($value: number) : UnityEngine.Color
            public static ColorFromRGBA ($value: number) : UnityEngine.Color
            public static CharToHex ($c: number) : number
            public static Intersection ($rect1: $Ref<UnityEngine.Rect>, $rect2: $Ref<UnityEngine.Rect>) : UnityEngine.Rect
            public static Union ($rect1: $Ref<UnityEngine.Rect>, $rect2: $Ref<UnityEngine.Rect>) : UnityEngine.Rect
            public static SkewMatrix ($matrix: $Ref<UnityEngine.Matrix4x4>, $skewX: number, $skewY: number) : void
            public static RotateUV ($uv: System.Array$1<UnityEngine.Vector2>, $baseUVRect: $Ref<UnityEngine.Rect>) : void
        }
        class UBBParser extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static inst : FairyGUI.Utils.UBBParser
            public defaultTagHandler : FairyGUI.Utils.UBBParser.TagHandler
            public handlers : System.Collections.Generic.Dictionary$2<string, FairyGUI.Utils.UBBParser.TagHandler>
            public defaultImgWidth : number
            public defaultImgHeight : number
            public GetTagText ($remove: boolean) : string
            public Parse ($text: string) : string
            public constructor ()
        }
        class XMLList extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public rawList : System.Collections.Generic.List$1<FairyGUI.Utils.XML>
            public get Count(): number;
            public Add ($xml: FairyGUI.Utils.XML) : void
            public Clear () : void
            public get_Item ($index: number) : FairyGUI.Utils.XML
            public GetEnumerator () : FairyGUI.Utils.XMLList.Enumerator
            public GetEnumerator ($selector: string) : FairyGUI.Utils.XMLList.Enumerator
            public Filter ($selector: string) : FairyGUI.Utils.XMLList
            public Find ($selector: string) : FairyGUI.Utils.XML
            public RemoveAll ($selector: string) : void
            public constructor ()
            public constructor ($list: System.Collections.Generic.List$1<FairyGUI.Utils.XML>)
        }
        enum XMLTagType
        { Start = 0, End = 1, Void = 2, CDATA = 3, Comment = 4, Instruction = 5 }
        class XMLIterator extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static tagName : string
            public static tagType : FairyGUI.Utils.XMLTagType
            public static lastTagName : string
            public static Begin ($source: string, $lowerCaseName?: boolean) : void
            public static NextTag () : boolean
            public static GetTagSource () : string
            public static GetRawText ($trim?: boolean) : string
            public static GetText ($trim?: boolean) : string
            public static HasAttribute ($attrName: string) : boolean
            public static GetAttribute ($attrName: string) : string
            public static GetAttribute ($attrName: string, $defValue: string) : string
            public static GetAttributeInt ($attrName: string) : number
            public static GetAttributeInt ($attrName: string, $defValue: number) : number
            public static GetAttributeFloat ($attrName: string) : number
            public static GetAttributeFloat ($attrName: string, $defValue: number) : number
            public static GetAttributeBool ($attrName: string) : boolean
            public static GetAttributeBool ($attrName: string, $defValue: boolean) : boolean
            public static GetAttributes ($result: System.Collections.Generic.Dictionary$2<string, string>) : System.Collections.Generic.Dictionary$2<string, string>
            public static GetAttributes ($result: System.Collections.Hashtable) : System.Collections.Hashtable
            public constructor ()
        }
        class XMLUtils extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static DecodeString ($aSource: string) : string
            public static EncodeString ($sb: System.Text.StringBuilder, $start: number, $isAttribute?: boolean) : void
            public static EncodeString ($str: string, $isAttribute?: boolean) : string
            public constructor ()
        }
        class ZipReader extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get entryCount(): number;
            public GetNextEntry ($entry: FairyGUI.Utils.ZipReader.ZipEntry) : boolean
            public GetEntryData ($entry: FairyGUI.Utils.ZipReader.ZipEntry) : System.Array$1<number>
            public constructor ($data: System.Array$1<number>)
            public constructor ()
        }
    }
    namespace FairyGUI.MovieClip {
        class Frame extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public texture : FairyGUI.NTexture
            public addDelay : number
            public constructor ()
        }
    }
    namespace FairyGUI.NGraphics {
        class VertexMatrix extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public cameraPos : UnityEngine.Vector3
            public matrix : UnityEngine.Matrix4x4
            public constructor ()
        }
    }
    namespace FairyGUI.ShaderConfig {
        interface GetFunction
        { 
        (name: string) : UnityEngine.Shader; 
        Invoke?: (name: string) => UnityEngine.Shader;
        }
        var GetFunction: { new (func: (name: string) => UnityEngine.Shader): GetFunction; }
    }
    namespace FairyGUI.BitmapFont {
        class BMGlyph extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public x : number
            public y : number
            public width : number
            public height : number
            public advance : number
            public lineHeight : number
            public uv : System.Array$1<UnityEngine.Vector2>
            public channel : number
            public constructor ()
        }
    }
    namespace FairyGUI.RTLSupport {
        enum DirectionType
        { UNKNOW = 0, LTR = 1, RTL = 2, NEUTRAL = 3 }
    }
    namespace FairyGUI.TextField {
        class LineInfo extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public width : number
            public height : number
            public baseline : number
            public charIndex : number
            public charCount : number
            public y : number
            public static Borrow () : FairyGUI.TextField.LineInfo
            public static Return ($value: FairyGUI.TextField.LineInfo) : void
            public static Return ($values: System.Collections.Generic.List$1<FairyGUI.TextField.LineInfo>) : void
            public constructor ()
        }
        class CharPosition extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public charIndex : number
            public lineIndex : number
            public offsetX : number
            public vertCount : number
            public width : number
            public imgIndex : number
        }
        class LineCharInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public width : number
            public height : number
            public baseline : number
        }
    }
    namespace FairyGUI.TextFormat {
        enum SpecialStyle
        { None = 0, Superscript = 1, Subscript = 2 }
    }
    namespace FairyGUI.UpdateContext {
        class ClipInfo extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public rect : UnityEngine.Rect
            public clipBox : UnityEngine.Vector4
            public soft : boolean
            public softness : UnityEngine.Vector4
            public clipId : number
            public rectMaskDepth : number
            public referenceValue : number
            public reversed : boolean
        }
    }
    namespace FairyGUI.GPathPoint {
        enum CurveType
        { CRSpline = 0, Bezier = 1, CubicBezier = 2, Straight = 3 }
    }
    namespace FairyGUI.ControllerAction {
        enum ActionType
        { PlayTransition = 0, ChangePage = 1 }
    }
    namespace FairyGUI.UIPackage {
        interface CreateObjectCallback
        { 
        (result: FairyGUI.GObject) : void; 
        Invoke?: (result: FairyGUI.GObject) => void;
        }
        var CreateObjectCallback: { new (func: (result: FairyGUI.GObject) => void): CreateObjectCallback; }
        interface LoadResource
        { 
        (name: string, extension: string, type: System.Type, destroyMethod: $Ref<FairyGUI.DestroyMethod>) : any; 
        Invoke?: (name: string, extension: string, type: System.Type, destroyMethod: $Ref<FairyGUI.DestroyMethod>) => any;
        }
        var LoadResource: { new (func: (name: string, extension: string, type: System.Type, destroyMethod: $Ref<FairyGUI.DestroyMethod>) => any): LoadResource; }
        interface LoadResourceAsync
        { 
        (name: string, extension: string, type: System.Type, item: FairyGUI.PackageItem) : void; 
        Invoke?: (name: string, extension: string, type: System.Type, item: FairyGUI.PackageItem) => void;
        }
        var LoadResourceAsync: { new (func: (name: string, extension: string, type: System.Type, item: FairyGUI.PackageItem) => void): LoadResourceAsync; }
    }
    namespace FairyGUI.GObjectPool {
        interface InitCallbackDelegate
        { 
        (obj: FairyGUI.GObject) : void; 
        Invoke?: (obj: FairyGUI.GObject) => void;
        }
        var InitCallbackDelegate: { new (func: (obj: FairyGUI.GObject) => void): InitCallbackDelegate; }
    }
    namespace FairyGUI.UIContentScaler {
        enum ScreenMatchMode
        { MatchWidthOrHeight = 0, MatchWidth = 1, MatchHeight = 2 }
        enum ScaleMode
        { ConstantPixelSize = 0, ScaleWithScreenSize = 1, ConstantPhysicalSize = 2 }
    }
    namespace FairyGUI.GTree {
        interface TreeNodeRenderDelegate
        { 
        (node: FairyGUI.GTreeNode, obj: FairyGUI.GComponent) : void; 
        Invoke?: (node: FairyGUI.GTreeNode, obj: FairyGUI.GComponent) => void;
        }
        var TreeNodeRenderDelegate: { new (func: (node: FairyGUI.GTreeNode, obj: FairyGUI.GComponent) => void): TreeNodeRenderDelegate; }
        interface TreeNodeWillExpandDelegate
        { 
        (node: FairyGUI.GTreeNode, expand: boolean) : void; 
        Invoke?: (node: FairyGUI.GTreeNode, expand: boolean) => void;
        }
        var TreeNodeWillExpandDelegate: { new (func: (node: FairyGUI.GTreeNode, expand: boolean) => void): TreeNodeWillExpandDelegate; }
    }
    namespace FairyGUI.UIObjectFactory {
        interface GComponentCreator
        { 
        () : FairyGUI.GComponent; 
        Invoke?: () => FairyGUI.GComponent;
        }
        var GComponentCreator: { new (func: () => FairyGUI.GComponent): GComponentCreator; }
        interface GLoaderCreator
        { 
        () : FairyGUI.GLoader; 
        Invoke?: () => FairyGUI.GLoader;
        }
        var GLoaderCreator: { new (func: () => FairyGUI.GLoader): GLoaderCreator; }
    }
    namespace FairyGUI.TreeView {
        interface TreeNodeCreateCellDelegate
        { 
        (node: FairyGUI.TreeNode) : FairyGUI.GComponent; 
        Invoke?: (node: FairyGUI.TreeNode) => FairyGUI.GComponent;
        }
        var TreeNodeCreateCellDelegate: { new (func: (node: FairyGUI.TreeNode) => FairyGUI.GComponent): TreeNodeCreateCellDelegate; }
        interface TreeNodeRenderDelegate
        { 
        (node: FairyGUI.TreeNode) : void; 
        Invoke?: (node: FairyGUI.TreeNode) => void;
        }
        var TreeNodeRenderDelegate: { new (func: (node: FairyGUI.TreeNode) => void): TreeNodeRenderDelegate; }
        interface TreeNodeWillExpandDelegate
        { 
        (node: FairyGUI.TreeNode, expand: boolean) : void; 
        Invoke?: (node: FairyGUI.TreeNode, expand: boolean) => void;
        }
        var TreeNodeWillExpandDelegate: { new (func: (node: FairyGUI.TreeNode, expand: boolean) => void): TreeNodeWillExpandDelegate; }
    }
    namespace FairyGUI.UIConfig {
        class ConfigValue extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public valid : boolean
            public s : string
            public i : number
            public f : number
            public b : boolean
            public c : UnityEngine.Color
            public Reset () : void
            public constructor ()
        }
        interface SoundLoader
        { 
        (url: string) : FairyGUI.NAudioClip; 
        Invoke?: (url: string) => FairyGUI.NAudioClip;
        }
        var SoundLoader: { new (func: (url: string) => FairyGUI.NAudioClip): SoundLoader; }
        enum ConfigKey
        { DefaultFont = 0, ButtonSound = 1, ButtonSoundVolumeScale = 2, HorizontalScrollBar = 3, VerticalScrollBar = 4, DefaultScrollStep = 5, DefaultScrollBarDisplay = 6, DefaultScrollTouchEffect = 7, DefaultScrollBounceEffect = 8, TouchScrollSensitivity = 9, WindowModalWaiting = 10, GlobalModalWaiting = 11, PopupMenu = 12, PopupMenu_seperator = 13, LoaderErrorSign = 14, TooltipsWin = 15, DefaultComboBoxVisibleItemCount = 16, TouchDragSensitivity = 17, ClickDragSensitivity = 18, ModalLayerColor = 19, RenderingTextBrighterOnDesktop = 20, AllowSoftnessOnTopOrLeftSide = 21, InputCaretSize = 22, InputHighlightColor = 23, EnhancedTextOutlineEffect = 24, DepthSupportForPaintingMode = 25, RichTextRowVerticalAlign = 26, Branch = 27, PleaseSelect = 100 }
    }
    namespace FairyGUI.Utils.UBBParser {
        interface TagHandler
        { 
        (tagName: string, end: boolean, attr: string) : string; 
        Invoke?: (tagName: string, end: boolean, attr: string) => string;
        }
        var TagHandler: { new (func: (tagName: string, end: boolean, attr: string) => string): TagHandler; }
    }
    namespace FairyGUI.Utils.XMLList {
        class Enumerator extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Current(): FairyGUI.Utils.XML;
            public MoveNext () : boolean
            public Erase () : void
            public Reset () : void
            public constructor ($source: System.Collections.Generic.List$1<FairyGUI.Utils.XML>, $selector: string)
            public constructor ()
        }
    }
    namespace FairyGUI.Utils.ZipReader {
        class ZipEntry extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public name : string
            public compress : number
            public crc : number
            public size : number
            public sourceSize : number
            public offset : number
            public isDirectory : boolean
            public constructor ()
        }
    }
    namespace ProtoBuf {
        class BclHelpers extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static GetUninitializedObject ($type: System.Type) : any
            public static WriteTimeSpan ($timeSpan: System.TimeSpan, $dest: ProtoBuf.ProtoWriter) : void
            public static ReadTimeSpan ($source: ProtoBuf.ProtoReader) : System.TimeSpan
            public static ReadDuration ($source: ProtoBuf.ProtoReader) : System.TimeSpan
            public static WriteDuration ($value: System.TimeSpan, $dest: ProtoBuf.ProtoWriter) : void
            public static ReadTimestamp ($source: ProtoBuf.ProtoReader) : Date
            public static WriteTimestamp ($value: Date, $dest: ProtoBuf.ProtoWriter) : void
            public static ReadDateTime ($source: ProtoBuf.ProtoReader) : Date
            public static WriteDateTime ($value: Date, $dest: ProtoBuf.ProtoWriter) : void
            public static WriteDateTimeWithKind ($value: Date, $dest: ProtoBuf.ProtoWriter) : void
            public static ReadDecimal ($reader: ProtoBuf.ProtoReader) : System.Decimal
            public static WriteDecimal ($value: System.Decimal, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteGuid ($value: System.Guid, $dest: ProtoBuf.ProtoWriter) : void
            public static ReadGuid ($source: ProtoBuf.ProtoReader) : System.Guid
            public static ReadNetObject ($value: any, $source: ProtoBuf.ProtoReader, $key: number, $type: System.Type, $options: ProtoBuf.BclHelpers.NetObjectOptions) : any
            public static WriteNetObject ($value: any, $dest: ProtoBuf.ProtoWriter, $key: number, $options: ProtoBuf.BclHelpers.NetObjectOptions) : void
        }
        class ProtoWriter extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Context(): ProtoBuf.SerializationContext;
            public get Model(): ProtoBuf.Meta.TypeModel;
            public static WriteObject ($value: any, $key: number, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteRecursionSafeObject ($value: any, $key: number, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteFieldHeader ($fieldNumber: number, $wireType: ProtoBuf.WireType, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteBytes ($data: System.Array$1<number>, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteBytes ($data: System.Array$1<number>, $offset: number, $length: number, $writer: ProtoBuf.ProtoWriter) : void
            public static StartSubItem ($instance: any, $writer: ProtoBuf.ProtoWriter) : ProtoBuf.SubItemToken
            public static EndSubItem ($token: ProtoBuf.SubItemToken, $writer: ProtoBuf.ProtoWriter) : void
            public static Create ($dest: System.IO.Stream, $model: ProtoBuf.Meta.TypeModel, $context?: ProtoBuf.SerializationContext) : ProtoBuf.ProtoWriter
            public Close () : void
            public static WriteString ($value: string, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteUInt64 ($value: bigint, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteInt64 ($value: bigint, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteUInt32 ($value: number, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteInt16 ($value: number, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteUInt16 ($value: number, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteByte ($value: number, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteSByte ($value: number, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteInt32 ($value: number, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteDouble ($value: number, $writer: ProtoBuf.ProtoWriter) : void
            public static WriteSingle ($value: number, $writer: ProtoBuf.ProtoWriter) : void
            public static ThrowEnumException ($writer: ProtoBuf.ProtoWriter, $enumValue: any) : void
            public static WriteBoolean ($value: boolean, $writer: ProtoBuf.ProtoWriter) : void
            public static AppendExtensionData ($instance: ProtoBuf.IExtensible, $writer: ProtoBuf.ProtoWriter) : void
            public static SetPackedField ($fieldNumber: number, $writer: ProtoBuf.ProtoWriter) : void
            public static ClearPackedField ($fieldNumber: number, $writer: ProtoBuf.ProtoWriter) : void
            public static WritePackedPrefix ($elementCount: number, $wireType: ProtoBuf.WireType, $writer: ProtoBuf.ProtoWriter) : void
            public SetRootObject ($value: any) : void
            public static WriteType ($value: System.Type, $writer: ProtoBuf.ProtoWriter) : void
        }
        class ProtoReader extends System.Object implements System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get FieldNumber(): number;
            public get WireType(): ProtoBuf.WireType;
            public get InternStrings(): boolean;
            public set InternStrings(value: boolean);
            public get Context(): ProtoBuf.SerializationContext;
            public get Position(): number;
            public get LongPosition(): bigint;
            public get Model(): ProtoBuf.Meta.TypeModel;
            public Dispose () : void
            public ReadUInt32 () : number
            public ReadInt16 () : number
            public ReadUInt16 () : number
            public ReadByte () : number
            public ReadSByte () : number
            public ReadInt32 () : number
            public ReadInt64 () : bigint
            public ReadString () : string
            public ThrowEnumException ($type: System.Type, $value: number) : void
            public ReadDouble () : number
            public static ReadObject ($value: any, $key: number, $reader: ProtoBuf.ProtoReader) : any
            public static EndSubItem ($token: ProtoBuf.SubItemToken, $reader: ProtoBuf.ProtoReader) : void
            public static StartSubItem ($reader: ProtoBuf.ProtoReader) : ProtoBuf.SubItemToken
            public ReadFieldHeader () : number
            public TryReadFieldHeader ($field: number) : boolean
            public Hint ($wireType: ProtoBuf.WireType) : void
            public Assert ($wireType: ProtoBuf.WireType) : void
            public SkipField () : void
            public ReadUInt64 () : bigint
            public ReadSingle () : number
            public ReadBoolean () : boolean
            public static AppendBytes ($value: System.Array$1<number>, $reader: ProtoBuf.ProtoReader) : System.Array$1<number>
            public static ReadLengthPrefix ($source: System.IO.Stream, $expectHeader: boolean, $style: ProtoBuf.PrefixStyle, $fieldNumber: $Ref<number>) : number
            public static DirectReadLittleEndianInt32 ($source: System.IO.Stream) : number
            public static DirectReadBigEndianInt32 ($source: System.IO.Stream) : number
            public static DirectReadVarintInt32 ($source: System.IO.Stream) : number
            public static DirectReadBytes ($source: System.IO.Stream, $buffer: System.Array$1<number>, $offset: number, $count: number) : void
            public static DirectReadBytes ($source: System.IO.Stream, $count: number) : System.Array$1<number>
            public static DirectReadString ($source: System.IO.Stream, $length: number) : string
            public static ReadLengthPrefix ($source: System.IO.Stream, $expectHeader: boolean, $style: ProtoBuf.PrefixStyle, $fieldNumber: $Ref<number>, $bytesRead: $Ref<number>) : number
            public static ReadLongLengthPrefix ($source: System.IO.Stream, $expectHeader: boolean, $style: ProtoBuf.PrefixStyle, $fieldNumber: $Ref<number>, $bytesRead: $Ref<number>) : bigint
            public AppendExtensionData ($instance: ProtoBuf.IExtensible) : void
            public static HasSubValue ($wireType: ProtoBuf.WireType, $source: ProtoBuf.ProtoReader) : boolean
            public static NoteObject ($value: any, $reader: ProtoBuf.ProtoReader) : void
            public ReadType () : System.Type
            public static Merge ($parent: ProtoBuf.ProtoReader, $from: any, $to: any) : any
            public static Create ($source: System.IO.Stream, $model: ProtoBuf.Meta.TypeModel, $context?: ProtoBuf.SerializationContext, $length?: bigint) : ProtoBuf.ProtoReader
        }
        class BufferExtension extends System.Object implements ProtoBuf.IExtension, ProtoBuf.IExtensionResettable
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public BeginAppend () : System.IO.Stream
            public EndAppend ($stream: System.IO.Stream, $commit: boolean) : void
            public BeginQuery () : System.IO.Stream
            public EndQuery ($stream: System.IO.Stream) : void
            public GetLength () : number
            public Reset () : void
        }
        interface IExtension
        {
            BeginAppend () : System.IO.Stream
            EndAppend ($stream: System.IO.Stream, $commit: boolean) : void
            BeginQuery () : System.IO.Stream
            EndQuery ($stream: System.IO.Stream) : void
            GetLength () : number
        }
        interface IExtensionResettable extends ProtoBuf.IExtension
        {
            Reset () : void
            BeginAppend () : System.IO.Stream
            EndAppend ($stream: System.IO.Stream, $commit: boolean) : void
            BeginQuery () : System.IO.Stream
            EndQuery ($stream: System.IO.Stream) : void
            GetLength () : number
        }
        class ProtoBeforeSerializationAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ProtoAfterSerializationAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ProtoBeforeDeserializationAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ProtoAfterDeserializationAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        enum DataFormat
        { Default = 0, ZigZag = 1, TwosComplement = 2, FixedSize = 3, Group = 4, WellKnown = 5 }
        class DiscriminatedUnionObject extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Object : any
            public get Discriminator(): number;
            public Is ($discriminator: number) : boolean
            public static Reset ($value: $Ref<ProtoBuf.DiscriminatedUnionObject>, $discriminator: number) : void
            public constructor ($discriminator: number, $value: any)
            public constructor ()
        }
        class DiscriminatedUnion64 extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Int64 : bigint
            public UInt64 : bigint
            public Int32 : number
            public UInt32 : number
            public Boolean : boolean
            public Single : number
            public Double : number
            public DateTime : Date
            public TimeSpan : System.TimeSpan
            public get Discriminator(): number;
            public Is ($discriminator: number) : boolean
            public static Reset ($value: $Ref<ProtoBuf.DiscriminatedUnion64>, $discriminator: number) : void
            public constructor ($discriminator: number, $value: bigint)
            public constructor ($discriminator: number, $value: number)
            public constructor ($discriminator: number, $value: boolean)
            public constructor ($discriminator: number, $value: Date | null)
            public constructor ($discriminator: number, $value: System.TimeSpan | null)
            public constructor ()
        }
        class DiscriminatedUnion128Object extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Int64 : bigint
            public UInt64 : bigint
            public Int32 : number
            public UInt32 : number
            public Boolean : boolean
            public Single : number
            public Double : number
            public DateTime : Date
            public TimeSpan : System.TimeSpan
            public Guid : System.Guid
            public Object : any
            public get Discriminator(): number;
            public Is ($discriminator: number) : boolean
            public static Reset ($value: $Ref<ProtoBuf.DiscriminatedUnion128Object>, $discriminator: number) : void
            public constructor ($discriminator: number, $value: bigint)
            public constructor ($discriminator: number, $value: number)
            public constructor ($discriminator: number, $value: boolean)
            public constructor ($discriminator: number, $value: any)
            public constructor ($discriminator: number, $value: Date | null)
            public constructor ($discriminator: number, $value: System.TimeSpan | null)
            public constructor ($discriminator: number, $value: System.Guid | null)
            public constructor ()
        }
        class DiscriminatedUnion128 extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Int64 : bigint
            public UInt64 : bigint
            public Int32 : number
            public UInt32 : number
            public Boolean : boolean
            public Single : number
            public Double : number
            public DateTime : Date
            public TimeSpan : System.TimeSpan
            public Guid : System.Guid
            public get Discriminator(): number;
            public Is ($discriminator: number) : boolean
            public static Reset ($value: $Ref<ProtoBuf.DiscriminatedUnion128>, $discriminator: number) : void
            public constructor ($discriminator: number, $value: bigint)
            public constructor ($discriminator: number, $value: number)
            public constructor ($discriminator: number, $value: boolean)
            public constructor ($discriminator: number, $value: Date | null)
            public constructor ($discriminator: number, $value: System.TimeSpan | null)
            public constructor ($discriminator: number, $value: System.Guid | null)
            public constructor ()
        }
        class DiscriminatedUnion64Object extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Int64 : bigint
            public UInt64 : bigint
            public Int32 : number
            public UInt32 : number
            public Boolean : boolean
            public Single : number
            public Double : number
            public DateTime : Date
            public TimeSpan : System.TimeSpan
            public Object : any
            public get Discriminator(): number;
            public Is ($discriminator: number) : boolean
            public static Reset ($value: $Ref<ProtoBuf.DiscriminatedUnion64Object>, $discriminator: number) : void
            public constructor ($discriminator: number, $value: bigint)
            public constructor ($discriminator: number, $value: number)
            public constructor ($discriminator: number, $value: boolean)
            public constructor ($discriminator: number, $value: any)
            public constructor ($discriminator: number, $value: Date | null)
            public constructor ($discriminator: number, $value: System.TimeSpan | null)
            public constructor ()
        }
        class DiscriminatedUnion32 extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Int32 : number
            public UInt32 : number
            public Boolean : boolean
            public Single : number
            public get Discriminator(): number;
            public Is ($discriminator: number) : boolean
            public static Reset ($value: $Ref<ProtoBuf.DiscriminatedUnion32>, $discriminator: number) : void
            public constructor ($discriminator: number, $value: number)
            public constructor ($discriminator: number, $value: boolean)
            public constructor ()
        }
        class DiscriminatedUnion32Object extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Int32 : number
            public UInt32 : number
            public Boolean : boolean
            public Single : number
            public Object : any
            public get Discriminator(): number;
            public Is ($discriminator: number) : boolean
            public static Reset ($value: $Ref<ProtoBuf.DiscriminatedUnion32Object>, $discriminator: number) : void
            public constructor ($discriminator: number, $value: number)
            public constructor ($discriminator: number, $value: boolean)
            public constructor ($discriminator: number, $value: any)
            public constructor ()
        }
        class Extensible extends System.Object implements ProtoBuf.IExtensible
        {
            protected [__keep_incompatibility]: never;
            public static GetExtensionObject ($extensionObject: $Ref<ProtoBuf.IExtension>, $createIfMissing: boolean) : ProtoBuf.IExtension
            public static TryGetValue ($model: ProtoBuf.Meta.TypeModel, $type: System.Type, $instance: ProtoBuf.IExtensible, $tag: number, $format: ProtoBuf.DataFormat, $allowDefinedTag: boolean, $value: $Ref<any>) : boolean
            public static GetValues ($model: ProtoBuf.Meta.TypeModel, $type: System.Type, $instance: ProtoBuf.IExtensible, $tag: number, $format: ProtoBuf.DataFormat) : System.Collections.IEnumerable
            public static AppendValue ($model: ProtoBuf.Meta.TypeModel, $instance: ProtoBuf.IExtensible, $tag: number, $format: ProtoBuf.DataFormat, $value: any) : void
            public GetExtensionObject ($createIfMissing: boolean) : ProtoBuf.IExtension
        }
        interface IExtensible
        {
            GetExtensionObject ($createIfMissing: boolean) : ProtoBuf.IExtension
        }
        interface IProtoInput$1<TInput>
        {
        }
        interface IProtoOutput$1<TOutput>
        {
        }
        enum ImplicitFields
        { None = 0, AllPublic = 1, AllFields = 2 }
        enum PrefixStyle
        { None = 0, Base128 = 1, Fixed32 = 2, Fixed32BigEndian = 3 }
        class ProtoContractAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public set Name(value: string);
            public get ImplicitFirstTag(): number;
            public set ImplicitFirstTag(value: number);
            public get UseProtoMembersOnly(): boolean;
            public set UseProtoMembersOnly(value: boolean);
            public get IgnoreListHandling(): boolean;
            public set IgnoreListHandling(value: boolean);
            public get ImplicitFields(): ProtoBuf.ImplicitFields;
            public set ImplicitFields(value: ProtoBuf.ImplicitFields);
            public get InferTagFromName(): boolean;
            public set InferTagFromName(value: boolean);
            public get DataMemberOffset(): number;
            public set DataMemberOffset(value: number);
            public get SkipConstructor(): boolean;
            public set SkipConstructor(value: boolean);
            public get AsReferenceDefault(): boolean;
            public set AsReferenceDefault(value: boolean);
            public get IsGroup(): boolean;
            public set IsGroup(value: boolean);
            public get EnumPassthru(): boolean;
            public set EnumPassthru(value: boolean);
            public get Surrogate(): System.Type;
            public set Surrogate(value: System.Type);
            public constructor ()
        }
        class ProtoConverterAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ProtoEnumAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Value(): number;
            public set Value(value: number);
            public get Name(): string;
            public set Name(value: string);
            public HasValue () : boolean
            public constructor ()
        }
        class ProtoException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class ProtoIgnoreAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
        class ProtoPartialIgnoreAttribute extends ProtoBuf.ProtoIgnoreAttribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get MemberName(): string;
            public constructor ($memberName: string)
            public constructor ()
        }
        class ProtoIncludeAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get Tag(): number;
            public get KnownTypeName(): string;
            public get KnownType(): System.Type;
            public get DataFormat(): ProtoBuf.DataFormat;
            public set DataFormat(value: ProtoBuf.DataFormat);
            public constructor ($tag: number, $knownType: System.Type)
            public constructor ($tag: number, $knownTypeName: string)
            public constructor ()
        }
        class ProtoMapAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public get KeyFormat(): ProtoBuf.DataFormat;
            public set KeyFormat(value: ProtoBuf.DataFormat);
            public get ValueFormat(): ProtoBuf.DataFormat;
            public set ValueFormat(value: ProtoBuf.DataFormat);
            public get DisableMap(): boolean;
            public set DisableMap(value: boolean);
            public constructor ()
        }
        class ProtoMemberAttribute extends System.Attribute implements System.Runtime.InteropServices._Attribute, System.IComparable, System.IComparable$1<ProtoBuf.ProtoMemberAttribute>
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public set Name(value: string);
            public get DataFormat(): ProtoBuf.DataFormat;
            public set DataFormat(value: ProtoBuf.DataFormat);
            public get Tag(): number;
            public get IsRequired(): boolean;
            public set IsRequired(value: boolean);
            public get IsPacked(): boolean;
            public set IsPacked(value: boolean);
            public get OverwriteList(): boolean;
            public set OverwriteList(value: boolean);
            public get AsReference(): boolean;
            public set AsReference(value: boolean);
            public get DynamicType(): boolean;
            public set DynamicType(value: boolean);
            public get Options(): ProtoBuf.MemberSerializationOptions;
            public set Options(value: ProtoBuf.MemberSerializationOptions);
            public CompareTo ($other: any) : number
            public CompareTo ($other: ProtoBuf.ProtoMemberAttribute) : number
            public constructor ($tag: number)
            public constructor ()
        }
        enum MemberSerializationOptions
        { None = 0, Packed = 1, Required = 2, AsReference = 4, DynamicType = 8, OverwriteList = 16, AsReferenceHasValue = 32 }
        class ProtoPartialMemberAttribute extends ProtoBuf.ProtoMemberAttribute implements System.Runtime.InteropServices._Attribute, System.IComparable, System.IComparable$1<ProtoBuf.ProtoMemberAttribute>
        {
            protected [__keep_incompatibility]: never;
            public get MemberName(): string;
            public constructor ($tag: number, $memberName: string)
            public constructor ($tag: number)
            public constructor ()
        }
        enum WireType
        { None = -1, Variant = 0, Fixed64 = 1, String = 2, StartGroup = 3, EndGroup = 4, Fixed32 = 5, SignedVariant = 8 }
        class SerializationContext extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Context(): any;
            public set Context(value: any);
            public constructor ()
        }
        class SubItemToken extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class Serializer extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ListItemTag : number
            public static Deserialize ($type: System.Type, $source: System.IO.Stream) : any
            public static TryReadLengthPrefix ($source: System.IO.Stream, $style: ProtoBuf.PrefixStyle, $length: $Ref<number>) : boolean
            public static TryReadLengthPrefix ($buffer: System.Array$1<number>, $index: number, $count: number, $style: ProtoBuf.PrefixStyle, $length: $Ref<number>) : boolean
            public static FlushPool () : void
        }
    }
    namespace ProtoBuf.BclHelpers {
        enum NetObjectOptions
        { None = 0, AsReference = 1, DynamicType = 2, UseConstructor = 4, LateSet = 8 }
    }
    namespace ProtoBuf.Meta {
        class TypeModel extends System.Object implements ProtoBuf.IProtoInput$1<System.Array$1<number>>, ProtoBuf.IProtoInput$1<System.ArraySegment$1<number>>, ProtoBuf.IProtoInput$1<System.IO.Stream>, ProtoBuf.IProtoOutput$1<System.IO.Stream>
        {
            protected [__keep_incompatibility]: never;
            public get ForwardsOnly(): boolean;
            public set ForwardsOnly(value: boolean);
            public Serialize ($dest: System.IO.Stream, $value: any) : void
            public Serialize ($dest: System.IO.Stream, $value: any, $context: ProtoBuf.SerializationContext) : void
            public Serialize ($dest: ProtoBuf.ProtoWriter, $value: any) : void
            public DeserializeWithLengthPrefix ($source: System.IO.Stream, $value: any, $type: System.Type, $style: ProtoBuf.PrefixStyle, $fieldNumber: number) : any
            public DeserializeWithLengthPrefix ($source: System.IO.Stream, $value: any, $type: System.Type, $style: ProtoBuf.PrefixStyle, $expectedField: number, $resolver: ProtoBuf.Serializer.TypeResolver) : any
            public DeserializeWithLengthPrefix ($source: System.IO.Stream, $value: any, $type: System.Type, $style: ProtoBuf.PrefixStyle, $expectedField: number, $resolver: ProtoBuf.Serializer.TypeResolver, $bytesRead: $Ref<number>) : any
            public DeserializeWithLengthPrefix ($source: System.IO.Stream, $value: any, $type: System.Type, $style: ProtoBuf.PrefixStyle, $expectedField: number, $resolver: ProtoBuf.Serializer.TypeResolver, $bytesRead: $Ref<bigint>) : any
            public DeserializeItems ($source: System.IO.Stream, $type: System.Type, $style: ProtoBuf.PrefixStyle, $expectedField: number, $resolver: ProtoBuf.Serializer.TypeResolver) : System.Collections.IEnumerable
            public DeserializeItems ($source: System.IO.Stream, $type: System.Type, $style: ProtoBuf.PrefixStyle, $expectedField: number, $resolver: ProtoBuf.Serializer.TypeResolver, $context: ProtoBuf.SerializationContext) : System.Collections.IEnumerable
            public SerializeWithLengthPrefix ($dest: System.IO.Stream, $value: any, $type: System.Type, $style: ProtoBuf.PrefixStyle, $fieldNumber: number) : void
            public SerializeWithLengthPrefix ($dest: System.IO.Stream, $value: any, $type: System.Type, $style: ProtoBuf.PrefixStyle, $fieldNumber: number, $context: ProtoBuf.SerializationContext) : void
            public Deserialize ($source: System.IO.Stream, $value: any, $type: System.Type) : any
            public Deserialize ($source: System.IO.Stream, $value: any, $type: System.Type, $context: ProtoBuf.SerializationContext) : any
            public Deserialize ($source: System.IO.Stream, $value: any, $type: System.Type, $length: number) : any
            public Deserialize ($source: System.IO.Stream, $value: any, $type: System.Type, $length: bigint) : any
            public Deserialize ($source: System.IO.Stream, $value: any, $type: System.Type, $length: number, $context: ProtoBuf.SerializationContext) : any
            public Deserialize ($source: System.IO.Stream, $value: any, $type: System.Type, $length: bigint, $context: ProtoBuf.SerializationContext) : any
            public Deserialize ($source: ProtoBuf.ProtoReader, $value: any, $type: System.Type) : any
            public IsDefined ($type: System.Type) : boolean
            public DeepClone ($value: any) : any
            public static ThrowCannotCreateInstance ($type: System.Type) : void
            public CanSerializeContractType ($type: System.Type) : boolean
            public CanSerialize ($type: System.Type) : boolean
            public CanSerializeBasicType ($type: System.Type) : boolean
            public GetSchema ($type: System.Type) : string
            public GetSchema ($type: System.Type, $syntax: ProtoBuf.Meta.ProtoSyntax) : string
            public add_DynamicTypeFormatting ($value: ProtoBuf.Meta.TypeFormatEventHandler) : void
            public remove_DynamicTypeFormatting ($value: ProtoBuf.Meta.TypeFormatEventHandler) : void
        }
        enum ProtoSyntax
        { Proto2 = 0, Proto3 = 1 }
        class CallbackSet extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get BeforeSerialize(): System.Reflection.MethodInfo;
            public set BeforeSerialize(value: System.Reflection.MethodInfo);
            public get BeforeDeserialize(): System.Reflection.MethodInfo;
            public set BeforeDeserialize(value: System.Reflection.MethodInfo);
            public get AfterSerialize(): System.Reflection.MethodInfo;
            public set AfterSerialize(value: System.Reflection.MethodInfo);
            public get AfterDeserialize(): System.Reflection.MethodInfo;
            public set AfterDeserialize(value: System.Reflection.MethodInfo);
            public get NonTrivial(): boolean;
        }
        class MetaType extends System.Object implements ProtoBuf.Serializers.ISerializerProxy
        {
            protected [__keep_incompatibility]: never;
            public get BaseType(): ProtoBuf.Meta.MetaType;
            public get IncludeSerializerMethod(): boolean;
            public set IncludeSerializerMethod(value: boolean);
            public get AsReferenceDefault(): boolean;
            public set AsReferenceDefault(value: boolean);
            public get HasCallbacks(): boolean;
            public get HasSubtypes(): boolean;
            public get Callbacks(): ProtoBuf.Meta.CallbackSet;
            public get Name(): string;
            public set Name(value: string);
            public get Type(): System.Type;
            public get UseConstructor(): boolean;
            public set UseConstructor(value: boolean);
            public get ConstructType(): System.Type;
            public set ConstructType(value: System.Type);
            public get EnumPassthru(): boolean;
            public set EnumPassthru(value: boolean);
            public get IgnoreListHandling(): boolean;
            public set IgnoreListHandling(value: boolean);
            public get IsGroup(): boolean;
            public set IsGroup(value: boolean);
            public AddSubType ($fieldNumber: number, $derivedType: System.Type) : ProtoBuf.Meta.MetaType
            public AddSubType ($fieldNumber: number, $derivedType: System.Type, $dataFormat: ProtoBuf.DataFormat) : ProtoBuf.Meta.MetaType
            public SetCallbacks ($beforeSerialize: System.Reflection.MethodInfo, $afterSerialize: System.Reflection.MethodInfo, $beforeDeserialize: System.Reflection.MethodInfo, $afterDeserialize: System.Reflection.MethodInfo) : ProtoBuf.Meta.MetaType
            public SetCallbacks ($beforeSerialize: string, $afterSerialize: string, $beforeDeserialize: string, $afterDeserialize: string) : ProtoBuf.Meta.MetaType
            public GetSchemaTypeName () : string
            public SetFactory ($factory: System.Reflection.MethodInfo) : ProtoBuf.Meta.MetaType
            public SetFactory ($factory: string) : ProtoBuf.Meta.MetaType
            public Add ($fieldNumber: number, $memberName: string) : ProtoBuf.Meta.MetaType
            public AddField ($fieldNumber: number, $memberName: string) : ProtoBuf.Meta.ValueMember
            public Add ($memberName: string) : ProtoBuf.Meta.MetaType
            public SetSurrogate ($surrogateType: System.Type) : void
            public Add (...memberNames: string[]) : ProtoBuf.Meta.MetaType
            public Add ($fieldNumber: number, $memberName: string, $defaultValue: any) : ProtoBuf.Meta.MetaType
            public Add ($fieldNumber: number, $memberName: string, $itemType: System.Type, $defaultType: System.Type) : ProtoBuf.Meta.MetaType
            public AddField ($fieldNumber: number, $memberName: string, $itemType: System.Type, $defaultType: System.Type) : ProtoBuf.Meta.ValueMember
            public get_Item ($fieldNumber: number) : ProtoBuf.Meta.ValueMember
            public get_Item ($member: System.Reflection.MemberInfo) : ProtoBuf.Meta.ValueMember
            public GetFields () : System.Array$1<ProtoBuf.Meta.ValueMember>
            public GetSubtypes () : System.Array$1<ProtoBuf.Meta.SubType>
            public ApplyFieldOffset ($offset: number) : void
        }
        class ValueMember extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get FieldNumber(): number;
            public get Member(): System.Reflection.MemberInfo;
            public get BackingMember(): System.Reflection.MemberInfo;
            public set BackingMember(value: System.Reflection.MemberInfo);
            public get ItemType(): System.Type;
            public get MemberType(): System.Type;
            public get DefaultType(): System.Type;
            public get ParentType(): System.Type;
            public get DefaultValue(): any;
            public set DefaultValue(value: any);
            public get DataFormat(): ProtoBuf.DataFormat;
            public set DataFormat(value: ProtoBuf.DataFormat);
            public get IsStrict(): boolean;
            public set IsStrict(value: boolean);
            public get IsPacked(): boolean;
            public set IsPacked(value: boolean);
            public get OverwriteList(): boolean;
            public set OverwriteList(value: boolean);
            public get IsRequired(): boolean;
            public set IsRequired(value: boolean);
            public get AsReference(): boolean;
            public set AsReference(value: boolean);
            public get DynamicType(): boolean;
            public set DynamicType(value: boolean);
            public get IsMap(): boolean;
            public set IsMap(value: boolean);
            public get MapKeyFormat(): ProtoBuf.DataFormat;
            public set MapKeyFormat(value: ProtoBuf.DataFormat);
            public get MapValueFormat(): ProtoBuf.DataFormat;
            public set MapValueFormat(value: ProtoBuf.DataFormat);
            public get Name(): string;
            public set Name(value: string);
            public get SupportNull(): boolean;
            public set SupportNull(value: boolean);
            public SetSpecified ($getSpecified: System.Reflection.MethodInfo, $setSpecified: System.Reflection.MethodInfo) : void
            public constructor ($model: ProtoBuf.Meta.RuntimeTypeModel, $parentType: System.Type, $fieldNumber: number, $member: System.Reflection.MemberInfo, $memberType: System.Type, $itemType: System.Type, $defaultType: System.Type, $dataFormat: ProtoBuf.DataFormat, $defaultValue: any)
            public constructor ()
        }
        class SubType extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get FieldNumber(): number;
            public get DerivedType(): ProtoBuf.Meta.MetaType;
            public constructor ($fieldNumber: number, $derivedType: ProtoBuf.Meta.MetaType, $format: ProtoBuf.DataFormat)
            public constructor ()
        }
        class RuntimeTypeModel extends ProtoBuf.Meta.TypeModel implements ProtoBuf.IProtoInput$1<System.Array$1<number>>, ProtoBuf.IProtoInput$1<System.ArraySegment$1<number>>, ProtoBuf.IProtoInput$1<System.IO.Stream>, ProtoBuf.IProtoOutput$1<System.IO.Stream>
        {
            protected [__keep_incompatibility]: never;
            public get InferTagFromNameDefault(): boolean;
            public set InferTagFromNameDefault(value: boolean);
            public get AutoAddProtoContractTypesOnly(): boolean;
            public set AutoAddProtoContractTypesOnly(value: boolean);
            public get UseImplicitZeroDefaults(): boolean;
            public set UseImplicitZeroDefaults(value: boolean);
            public get AllowParseableTypes(): boolean;
            public set AllowParseableTypes(value: boolean);
            public get IncludeDateTimeKind(): boolean;
            public set IncludeDateTimeKind(value: boolean);
            public get InternStrings(): boolean;
            public set InternStrings(value: boolean);
            public static get Default(): ProtoBuf.Meta.RuntimeTypeModel;
            public get AutoAddMissingTypes(): boolean;
            public set AutoAddMissingTypes(value: boolean);
            public get MetadataTimeoutMilliseconds(): number;
            public set MetadataTimeoutMilliseconds(value: number);
            public get LockCount(): number;
            public GetTypes () : System.Collections.IEnumerable
            public static Create ($name?: string) : ProtoBuf.Meta.RuntimeTypeModel
            public get_Item ($type: System.Type) : ProtoBuf.Meta.MetaType
            public Add ($type: System.Type, $applyDefaultBehaviour: boolean) : ProtoBuf.Meta.MetaType
            public Freeze () : void
            public add_LockContended ($value: ProtoBuf.Meta.LockContentedEventHandler) : void
            public remove_LockContended ($value: ProtoBuf.Meta.LockContentedEventHandler) : void
            public SetDefaultFactory ($methodInfo: System.Reflection.MethodInfo) : void
            public add_BeforeApplyDefaultBehaviour ($value: System.EventHandler$1<ProtoBuf.Meta.TypeAddedEventArgs>) : void
            public remove_BeforeApplyDefaultBehaviour ($value: System.EventHandler$1<ProtoBuf.Meta.TypeAddedEventArgs>) : void
            public add_AfterApplyDefaultBehaviour ($value: System.EventHandler$1<ProtoBuf.Meta.TypeAddedEventArgs>) : void
            public remove_AfterApplyDefaultBehaviour ($value: System.EventHandler$1<ProtoBuf.Meta.TypeAddedEventArgs>) : void
        }
        interface LockContentedEventHandler
        { 
        (sender: any, args: ProtoBuf.Meta.LockContentedEventArgs) : void; 
        Invoke?: (sender: any, args: ProtoBuf.Meta.LockContentedEventArgs) => void;
        }
        var LockContentedEventHandler: { new (func: (sender: any, args: ProtoBuf.Meta.LockContentedEventArgs) => void): LockContentedEventHandler; }
        class LockContentedEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get OwnerStackTrace(): string;
        }
        class TypeAddedEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get ApplyDefaultBehaviour(): boolean;
            public set ApplyDefaultBehaviour(value: boolean);
            public get MetaType(): ProtoBuf.Meta.MetaType;
            public get Type(): System.Type;
            public get Model(): ProtoBuf.Meta.RuntimeTypeModel;
        }
        class TypeFormatEventArgs extends System.EventArgs
        {
            protected [__keep_incompatibility]: never;
            public get Type(): System.Type;
            public set Type(value: System.Type);
            public get FormattedName(): string;
            public set FormattedName(value: string);
        }
        interface TypeFormatEventHandler
        { 
        (sender: any, args: ProtoBuf.Meta.TypeFormatEventArgs) : void; 
        Invoke?: (sender: any, args: ProtoBuf.Meta.TypeFormatEventArgs) => void;
        }
        var TypeFormatEventHandler: { new (func: (sender: any, args: ProtoBuf.Meta.TypeFormatEventArgs) => void): TypeFormatEventHandler; }
    }
    namespace ProtoBuf.Serializers {
        interface ISerializerProxy
        {
        }
    }
    namespace ProtoBuf.Serializer {
        interface TypeResolver
        { 
        (fieldNumber: number) : System.Type; 
        Invoke?: (fieldNumber: number) => System.Type;
        }
        var TypeResolver: { new (func: (fieldNumber: number) => System.Type): TypeResolver; }
        class NonGeneric extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static DeepClone ($instance: any) : any
            public static Serialize ($dest: System.IO.Stream, $instance: any) : void
            public static Deserialize ($type: System.Type, $source: System.IO.Stream) : any
            public static Merge ($source: System.IO.Stream, $instance: any) : any
            public static SerializeWithLengthPrefix ($destination: System.IO.Stream, $instance: any, $style: ProtoBuf.PrefixStyle, $fieldNumber: number) : void
            public static TryDeserializeWithLengthPrefix ($source: System.IO.Stream, $style: ProtoBuf.PrefixStyle, $resolver: ProtoBuf.Serializer.TypeResolver, $value: $Ref<any>) : boolean
            public static CanSerialize ($type: System.Type) : boolean
            public static PrepareSerializer ($t: System.Type) : void
        }
        class GlobalOptions extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace SimpleJSON {
        enum JSONNodeType
        { Array = 1, Object = 2, String = 3, Number = 4, NullValue = 5, Boolean = 6, None = 7, Custom = 255 }
        enum JSONTextMode
        { Compact = 0, Indent = 1 }
        class JSONNode extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static forceASCII : boolean
            public static longAsString : boolean
            public static allowLineComments : boolean
            public static Color32DefaultAlpha : number
            public static ColorDefaultAlpha : number
            public static VectorContainerType : SimpleJSON.JSONContainerType
            public static QuaternionContainerType : SimpleJSON.JSONContainerType
            public static RectContainerType : SimpleJSON.JSONContainerType
            public static ColorContainerType : SimpleJSON.JSONContainerType
            public get Tag(): SimpleJSON.JSONNodeType;
            public get Value(): string;
            public set Value(value: string);
            public get Count(): number;
            public get IsNumber(): boolean;
            public get IsString(): boolean;
            public get IsBoolean(): boolean;
            public get IsNull(): boolean;
            public get IsArray(): boolean;
            public get IsObject(): boolean;
            public get Inline(): boolean;
            public set Inline(value: boolean);
            public get Children(): System.Collections.Generic.IEnumerable$1<SimpleJSON.JSONNode>;
            public get DeepChildren(): System.Collections.Generic.IEnumerable$1<SimpleJSON.JSONNode>;
            public get Linq(): System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<string, SimpleJSON.JSONNode>>;
            public get Keys(): SimpleJSON.JSONNode.KeyEnumerator;
            public get Values(): SimpleJSON.JSONNode.ValueEnumerator;
            public get AsDouble(): number;
            public set AsDouble(value: number);
            public get AsInt(): number;
            public set AsInt(value: number);
            public get AsFloat(): number;
            public set AsFloat(value: number);
            public get AsBool(): boolean;
            public set AsBool(value: boolean);
            public get AsLong(): bigint;
            public set AsLong(value: bigint);
            public get AsULong(): bigint;
            public set AsULong(value: bigint);
            public get AsArray(): SimpleJSON.JSONArray;
            public get AsObject(): SimpleJSON.JSONObject;
            public get AsDecimal(): System.Decimal;
            public set AsDecimal(value: System.Decimal);
            public get AsChar(): number;
            public set AsChar(value: number);
            public get AsUInt(): number;
            public set AsUInt(value: number);
            public get AsByte(): number;
            public set AsByte(value: number);
            public get AsSByte(): number;
            public set AsSByte(value: number);
            public get AsShort(): number;
            public set AsShort(value: number);
            public get AsUShort(): number;
            public set AsUShort(value: number);
            public get AsDateTime(): Date;
            public set AsDateTime(value: Date);
            public get AsTimeSpan(): System.TimeSpan;
            public set AsTimeSpan(value: System.TimeSpan);
            public get AsGuid(): System.Guid;
            public set AsGuid(value: System.Guid);
            public get AsByteArray(): System.Array$1<number>;
            public set AsByteArray(value: System.Array$1<number>);
            public get AsByteList(): System.Collections.Generic.List$1<number>;
            public set AsByteList(value: System.Collections.Generic.List$1<number>);
            public get AsStringArray(): System.Array$1<string>;
            public set AsStringArray(value: System.Array$1<string>);
            public get AsStringList(): System.Collections.Generic.List$1<string>;
            public set AsStringList(value: System.Collections.Generic.List$1<string>);
            public get_Item ($aIndex: number) : SimpleJSON.JSONNode
            public set_Item ($aIndex: number, $value: SimpleJSON.JSONNode) : void
            public get_Item ($aKey: string) : SimpleJSON.JSONNode
            public set_Item ($aKey: string, $value: SimpleJSON.JSONNode) : void
            public Add ($aKey: string, $aItem: SimpleJSON.JSONNode) : void
            public Add ($aItem: SimpleJSON.JSONNode) : void
            public Remove ($aKey: string) : SimpleJSON.JSONNode
            public Remove ($aIndex: number) : SimpleJSON.JSONNode
            public Remove ($aNode: SimpleJSON.JSONNode) : SimpleJSON.JSONNode
            public Clear () : void
            public Clone () : SimpleJSON.JSONNode
            public HasKey ($aKey: string) : boolean
            public GetValueOrDefault ($aKey: string, $aDefault: SimpleJSON.JSONNode) : SimpleJSON.JSONNode
            public ToString () : string
            public ToString ($aIndent: number) : string
            public GetEnumerator () : SimpleJSON.JSONNode.Enumerator
            public static op_Implicit ($s: string) : SimpleJSON.JSONNode
            public static op_Implicit ($d: SimpleJSON.JSONNode) : string
            public static op_Implicit ($n: number) : SimpleJSON.JSONNode
            public static op_Implicit ($d: SimpleJSON.JSONNode) : number
            public static op_Implicit ($n: bigint) : SimpleJSON.JSONNode
            public static op_Implicit ($d: SimpleJSON.JSONNode) : bigint
            public static op_Implicit ($b: boolean) : SimpleJSON.JSONNode
            public static op_Implicit ($d: SimpleJSON.JSONNode) : boolean
            public static op_Implicit ($aKeyValue: System.Collections.Generic.KeyValuePair$2<string, SimpleJSON.JSONNode>) : SimpleJSON.JSONNode
            public static op_Equality ($a: SimpleJSON.JSONNode, $b: any) : boolean
            public static op_Inequality ($a: SimpleJSON.JSONNode, $b: any) : boolean
            public static Parse ($aJSON: string) : SimpleJSON.JSONNode
            public SerializeBinary ($aWriter: System.IO.BinaryWriter) : void
            public SaveToBinaryStream ($aData: System.IO.Stream) : void
            public SaveToCompressedStream ($aData: System.IO.Stream) : void
            public SaveToCompressedFile ($aFileName: string) : void
            public SaveToCompressedBase64 () : string
            public SaveToBinaryFile ($aFileName: string) : void
            public SaveToBinaryBase64 () : string
            public static DeserializeBinary ($aReader: System.IO.BinaryReader) : SimpleJSON.JSONNode
            public static LoadFromCompressedFile ($aFileName: string) : SimpleJSON.JSONNode
            public static LoadFromCompressedStream ($aData: System.IO.Stream) : SimpleJSON.JSONNode
            public static LoadFromCompressedBase64 ($aBase64: string) : SimpleJSON.JSONNode
            public static LoadFromBinaryStream ($aData: System.IO.Stream) : SimpleJSON.JSONNode
            public static LoadFromBinaryFile ($aFileName: string) : SimpleJSON.JSONNode
            public static LoadFromBinaryBase64 ($aBase64: string) : SimpleJSON.JSONNode
            public static op_Implicit ($aDecimal: System.Decimal) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : System.Decimal
            public static op_Implicit ($aChar: number) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : number
            public static op_Implicit ($aUInt: number) : SimpleJSON.JSONNode
            public static op_Implicit ($aByte: number) : SimpleJSON.JSONNode
            public static op_Implicit ($aSByte: number) : SimpleJSON.JSONNode
            public static op_Implicit ($aShort: number) : SimpleJSON.JSONNode
            public static op_Implicit ($aUShort: number) : SimpleJSON.JSONNode
            public static op_Implicit ($aDateTime: Date) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : Date
            public static op_Implicit ($aTimeSpan: System.TimeSpan) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : System.TimeSpan
            public static op_Implicit ($aGuid: System.Guid) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : System.Guid
            public static op_Implicit ($aByteArray: System.Array$1<number>) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : System.Array$1<number>
            public static op_Implicit ($aByteList: System.Collections.Generic.List$1<number>) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : System.Collections.Generic.List$1<number>
            public static op_Implicit ($aStringArray: System.Array$1<string>) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : System.Array$1<string>
            public static op_Implicit ($aStringList: System.Collections.Generic.List$1<string>) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : System.Collections.Generic.List$1<string>
            public static op_Implicit ($aValue: number | null) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : number | null
            public static op_Implicit ($aValue: boolean | null) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : boolean | null
            public static op_Implicit ($aValue: bigint | null) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : bigint | null
            public static op_Implicit ($aVec: UnityEngine.Vector2) : SimpleJSON.JSONNode
            public static op_Implicit ($aVec: UnityEngine.Vector3) : SimpleJSON.JSONNode
            public static op_Implicit ($aVec: UnityEngine.Vector4) : SimpleJSON.JSONNode
            public static op_Implicit ($aCol: UnityEngine.Color) : SimpleJSON.JSONNode
            public static op_Implicit ($aCol: UnityEngine.Color32) : SimpleJSON.JSONNode
            public static op_Implicit ($aRot: UnityEngine.Quaternion) : SimpleJSON.JSONNode
            public static op_Implicit ($aRect: UnityEngine.Rect) : SimpleJSON.JSONNode
            public static op_Implicit ($aRect: UnityEngine.RectOffset) : SimpleJSON.JSONNode
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : UnityEngine.Vector2
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : UnityEngine.Vector3
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : UnityEngine.Vector4
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : UnityEngine.Color
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : UnityEngine.Color32
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : UnityEngine.Quaternion
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : UnityEngine.Rect
            public static op_Implicit ($aNode: SimpleJSON.JSONNode) : UnityEngine.RectOffset
            public ReadVector2 ($aDefault: UnityEngine.Vector2) : UnityEngine.Vector2
            public ReadVector2 ($aXName: string, $aYName: string) : UnityEngine.Vector2
            public ReadVector2 () : UnityEngine.Vector2
            public WriteVector2 ($aVec: UnityEngine.Vector2, $aXName?: string, $aYName?: string) : SimpleJSON.JSONNode
            public ReadVector3 ($aDefault: UnityEngine.Vector3) : UnityEngine.Vector3
            public ReadVector3 ($aXName: string, $aYName: string, $aZName: string) : UnityEngine.Vector3
            public ReadVector3 () : UnityEngine.Vector3
            public WriteVector3 ($aVec: UnityEngine.Vector3, $aXName?: string, $aYName?: string, $aZName?: string) : SimpleJSON.JSONNode
            public ReadVector4 ($aDefault: UnityEngine.Vector4) : UnityEngine.Vector4
            public ReadVector4 () : UnityEngine.Vector4
            public WriteVector4 ($aVec: UnityEngine.Vector4) : SimpleJSON.JSONNode
            public ReadColor ($aDefault: UnityEngine.Color) : UnityEngine.Color
            public ReadColor () : UnityEngine.Color
            public WriteColor ($aCol: UnityEngine.Color) : SimpleJSON.JSONNode
            public ReadColor32 ($aDefault: UnityEngine.Color32) : UnityEngine.Color32
            public ReadColor32 () : UnityEngine.Color32
            public WriteColor32 ($aCol: UnityEngine.Color32) : SimpleJSON.JSONNode
            public ReadQuaternion ($aDefault: UnityEngine.Quaternion) : UnityEngine.Quaternion
            public ReadQuaternion () : UnityEngine.Quaternion
            public WriteQuaternion ($aRot: UnityEngine.Quaternion) : SimpleJSON.JSONNode
            public ReadRect ($aDefault: UnityEngine.Rect) : UnityEngine.Rect
            public ReadRect () : UnityEngine.Rect
            public WriteRect ($aRect: UnityEngine.Rect) : SimpleJSON.JSONNode
            public ReadRectOffset ($aDefault: UnityEngine.RectOffset) : UnityEngine.RectOffset
            public ReadRectOffset () : UnityEngine.RectOffset
            public WriteRectOffset ($aRect: UnityEngine.RectOffset) : SimpleJSON.JSONNode
            public ReadMatrix () : UnityEngine.Matrix4x4
            public WriteMatrix ($aMatrix: UnityEngine.Matrix4x4) : SimpleJSON.JSONNode
        }
        enum JSONContainerType
        { Array = 0, Object = 1 }
        class JSONArray extends SimpleJSON.JSONNode
        {
            protected [__keep_incompatibility]: never;
            public get Inline(): boolean;
            public set Inline(value: boolean);
            public get Tag(): SimpleJSON.JSONNodeType;
            public get IsArray(): boolean;
            public get Count(): number;
            public get Children(): System.Collections.Generic.IEnumerable$1<SimpleJSON.JSONNode>;
            public constructor ()
        }
        class JSONObject extends SimpleJSON.JSONNode
        {
            protected [__keep_incompatibility]: never;
            public get Inline(): boolean;
            public set Inline(value: boolean);
            public get Tag(): SimpleJSON.JSONNodeType;
            public get IsObject(): boolean;
            public get Count(): number;
            public get Children(): System.Collections.Generic.IEnumerable$1<SimpleJSON.JSONNode>;
            public constructor ()
        }
        class JSONString extends SimpleJSON.JSONNode
        {
            protected [__keep_incompatibility]: never;
            public get Tag(): SimpleJSON.JSONNodeType;
            public get IsString(): boolean;
            public get Value(): string;
            public set Value(value: string);
            public constructor ($aData: string)
            public constructor ()
        }
        class JSONNumber extends SimpleJSON.JSONNode
        {
            protected [__keep_incompatibility]: never;
            public get Tag(): SimpleJSON.JSONNodeType;
            public get IsNumber(): boolean;
            public get Value(): string;
            public set Value(value: string);
            public get AsDouble(): number;
            public set AsDouble(value: number);
            public get AsLong(): bigint;
            public set AsLong(value: bigint);
            public get AsULong(): bigint;
            public set AsULong(value: bigint);
            public constructor ($aData: number)
            public constructor ($aData: string)
            public constructor ()
        }
        class JSONBool extends SimpleJSON.JSONNode
        {
            protected [__keep_incompatibility]: never;
            public get Tag(): SimpleJSON.JSONNodeType;
            public get IsBoolean(): boolean;
            public get Value(): string;
            public set Value(value: string);
            public get AsBool(): boolean;
            public set AsBool(value: boolean);
            public constructor ($aData: boolean)
            public constructor ($aData: string)
            public constructor ()
        }
        class JSONNull extends SimpleJSON.JSONNode
        {
            protected [__keep_incompatibility]: never;
            public static reuseSameInstance : boolean
            public get Tag(): SimpleJSON.JSONNodeType;
            public get IsNull(): boolean;
            public get Value(): string;
            public set Value(value: string);
            public get AsBool(): boolean;
            public set AsBool(value: boolean);
            public static CreateOrGet () : SimpleJSON.JSONNull
        }
        class JSON extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Parse ($aJSON: string) : SimpleJSON.JSONNode
        }
    }
    namespace SimpleJSON.JSONNode {
        class Enumerator extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get IsValid(): boolean;
            public get Current(): System.Collections.Generic.KeyValuePair$2<string, SimpleJSON.JSONNode>;
            public MoveNext () : boolean
            public constructor ($aArrayEnum: System.Collections.Generic.List$1.Enumerator<SimpleJSON.JSONNode>)
            public constructor ($aDictEnum: System.Collections.Generic.Dictionary$2.Enumerator<string, SimpleJSON.JSONNode>)
            public constructor ()
        }
        class KeyEnumerator extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Current(): string;
            public MoveNext () : boolean
            public GetEnumerator () : SimpleJSON.JSONNode.KeyEnumerator
            public constructor ($aArrayEnum: System.Collections.Generic.List$1.Enumerator<SimpleJSON.JSONNode>)
            public constructor ($aDictEnum: System.Collections.Generic.Dictionary$2.Enumerator<string, SimpleJSON.JSONNode>)
            public constructor ($aEnumerator: SimpleJSON.JSONNode.Enumerator)
            public constructor ()
        }
        class ValueEnumerator extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get Current(): SimpleJSON.JSONNode;
            public MoveNext () : boolean
            public GetEnumerator () : SimpleJSON.JSONNode.ValueEnumerator
            public constructor ($aArrayEnum: System.Collections.Generic.List$1.Enumerator<SimpleJSON.JSONNode>)
            public constructor ($aDictEnum: System.Collections.Generic.Dictionary$2.Enumerator<string, SimpleJSON.JSONNode>)
            public constructor ($aEnumerator: SimpleJSON.JSONNode.Enumerator)
            public constructor ()
        }
        class LinqEnumerator extends System.Object implements System.Collections.Generic.IEnumerable$1<System.Collections.Generic.KeyValuePair$2<string, SimpleJSON.JSONNode>>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator$1<System.Collections.Generic.KeyValuePair$2<string, SimpleJSON.JSONNode>>, System.Collections.IEnumerator, System.IDisposable
        {
            protected [__keep_incompatibility]: never;
            public get Current(): System.Collections.Generic.KeyValuePair$2<string, SimpleJSON.JSONNode>;
            public MoveNext () : boolean
            public Dispose () : void
            public GetEnumerator () : System.Collections.Generic.IEnumerator$1<System.Collections.Generic.KeyValuePair$2<string, SimpleJSON.JSONNode>>
            public Reset () : void
        }
    }
    namespace Bright.Common {
        class StringUtil extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ToStr ($o: any) : string
            public static ToStr ($o: any, $sb: System.Text.StringBuilder) : string
        }
    }
    namespace Bright.Serialization {
        enum EDeserializeError
        { OK = 0, NOT_ENOUGH = 1, EXCEED_SIZE = 2 }
        class SerializationException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($msg: string)
            public constructor ($message: string, $innerException: System.Exception)
        }
        class SegmentSaveState extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public get ReaderIndex(): number;
            public get WriterIndex(): number;
            public constructor ($readerIndex: number, $writerIndex: number)
            public constructor ()
        }
        class ByteBuf extends System.Object implements System.ICloneable, System.IEquatable$1<Bright.Serialization.ByteBuf>
        {
            protected [__keep_incompatibility]: never;
            public get ReaderIndex(): number;
            public set ReaderIndex(value: number);
            public get WriterIndex(): number;
            public set WriterIndex(value: number);
            public get Capacity(): number;
            public get Size(): number;
            public get Empty(): boolean;
            public get NotEmpty(): boolean;
            public get Bytes(): System.Array$1<number>;
            public get Remaining(): number;
            public get NotCompactWritable(): number;
            public static get StringCacheFinder(): System.Func$4<System.Array$1<number>, number, number, string>;
            public static set StringCacheFinder(value: System.Func$4<System.Array$1<number>, number, number, string>);
            public static Wrap ($bytes: System.Array$1<number>) : Bright.Serialization.ByteBuf
            public Replace ($bytes: System.Array$1<number>) : void
            public Replace ($bytes: System.Array$1<number>, $beginPos: number, $endPos: number) : void
            public AddWriteIndex ($add: number) : void
            public AddReadIndex ($add: number) : void
            public CopyData () : System.Array$1<number>
            public DiscardReadBytes () : void
            public WriteBytesWithoutSize ($bs: System.Array$1<number>) : void
            public WriteBytesWithoutSize ($bs: System.Array$1<number>, $offset: number, $len: number) : void
            public Clear () : void
            public EnsureWrite ($size: number) : void
            public Append ($x: number) : void
            public WriteBool ($b: boolean) : void
            public ReadBool () : boolean
            public WriteByte ($x: number) : void
            public ReadByte () : number
            public WriteShort ($x: number) : void
            public ReadShort () : number
            public ReadFshort () : number
            public WriteFshort ($x: number) : void
            public WriteInt ($x: number) : void
            public ReadInt () : number
            public WriteUint ($x: number) : void
            public ReadUint () : number
            public WriteUint_Unsafe ($x: number) : void
            public ReadUint_Unsafe () : number
            public ReadFint () : number
            public WriteFint ($x: number) : void
            public ReadFint_Safe () : number
            public WriteFint_Safe ($x: number) : void
            public WriteLong ($x: bigint) : void
            public ReadLong () : bigint
            public WriteNumberAsLong ($x: number) : void
            public ReadLongAsNumber () : number
            public ReadUlong () : bigint
            public WriteFlong ($x: bigint) : void
            public ReadFlong () : bigint
            public WriteFloat ($x: number) : void
            public ReadFloat () : number
            public WriteDouble ($x: number) : void
            public ReadDouble () : number
            public WriteSize ($n: number) : void
            public ReadSize () : number
            public WriteSint ($x: number) : void
            public ReadSint () : number
            public WriteSlong ($x: bigint) : void
            public ReadSlong () : bigint
            public WriteString ($x: string) : void
            public ReadString () : string
            public WriteBytes ($x: System.Array$1<number>) : void
            public ReadBytes () : System.Array$1<number>
            public WriteComplex ($x: System.Numerics.Complex) : void
            public ReadComplex () : System.Numerics.Complex
            public WriteVector2 ($x: System.Numerics.Vector2) : void
            public ReadVector2 () : System.Numerics.Vector2
            public WriteVector3 ($x: System.Numerics.Vector3) : void
            public ReadVector3 () : System.Numerics.Vector3
            public WriteVector4 ($x: System.Numerics.Vector4) : void
            public ReadVector4 () : System.Numerics.Vector4
            public WriteQuaternion ($x: System.Numerics.Quaternion) : void
            public ReadQuaternion () : System.Numerics.Quaternion
            public WriteMatrix4x4 ($x: System.Numerics.Matrix4x4) : void
            public ReadMatrix4x4 () : System.Numerics.Matrix4x4
            public WriteByteBufWithSize ($o: Bright.Serialization.ByteBuf) : void
            public WriteByteBufWithoutSize ($o: Bright.Serialization.ByteBuf) : void
            public TryReadByte ($x: $Ref<number>) : boolean
            public TryDeserializeInplaceByteBuf ($maxSize: number, $inplaceTempBody: Bright.Serialization.ByteBuf) : Bright.Serialization.EDeserializeError
            public WriteRawTag ($b1: number) : void
            public WriteRawTag ($b1: number, $b2: number) : void
            public WriteRawTag ($b1: number, $b2: number, $b3: number) : void
            public BeginWriteSegment ($oldSize: $Ref<number>) : void
            public EndWriteSegment ($oldSize: number) : void
            public ReadSegment ($startIndex: $Ref<number>, $segmentSize: $Ref<number>) : void
            public ReadSegment ($buf: Bright.Serialization.ByteBuf) : void
            public EnterSegment ($saveState: $Ref<Bright.Serialization.SegmentSaveState>) : void
            public LeaveSegment ($saveState: Bright.Serialization.SegmentSaveState) : void
            public Equals ($obj: any) : boolean
            public Equals ($other: Bright.Serialization.ByteBuf) : boolean
            public Clone () : any
            public static FromString ($value: string) : Bright.Serialization.ByteBuf
            public Release () : void
            public constructor ()
            public constructor ($capacity: number)
            public constructor ($bytes: System.Array$1<number>)
            public constructor ($bytes: System.Array$1<number>, $readIndex: number, $writeIndex: number)
            public constructor ($capacity: number, $releaser: System.Action$1<Bright.Serialization.ByteBuf>)
            public static Equals ($objA: any, $objB: any) : boolean
        }
        interface ITypeId
        {
            GetTypeId () : number
        }
    }
    namespace System.Numerics {
        class Complex extends System.ValueType implements System.IFormattable, System.IEquatable$1<System.Numerics.Complex>
        {
            protected [__keep_incompatibility]: never;
        }
        class Vector2 extends System.ValueType implements System.IFormattable, System.IEquatable$1<System.Numerics.Vector2>
        {
            protected [__keep_incompatibility]: never;
        }
        class Vector3 extends System.ValueType implements System.IFormattable, System.IEquatable$1<System.Numerics.Vector3>
        {
            protected [__keep_incompatibility]: never;
        }
        class Vector4 extends System.ValueType implements System.IFormattable, System.IEquatable$1<System.Numerics.Vector4>
        {
            protected [__keep_incompatibility]: never;
        }
        class Quaternion extends System.ValueType implements System.IEquatable$1<System.Numerics.Quaternion>
        {
            protected [__keep_incompatibility]: never;
        }
        class Matrix4x4 extends System.ValueType implements System.IEquatable$1<System.Numerics.Matrix4x4>
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace Bright.Config {
        class BeanBase extends System.Object implements Bright.Serialization.ITypeId
        {
            protected [__keep_incompatibility]: never;
            public GetTypeId () : number
        }
    }
    namespace NaughtyBezierCurves {
        class BezierCurve3D extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get Sampling(): number;
            public set Sampling(value: number);
            public get KeyPoints(): System.Collections.Generic.List$1<NaughtyBezierCurves.BezierPoint3D>;
            public set KeyPoints(value: System.Collections.Generic.List$1<NaughtyBezierCurves.BezierPoint3D>);
            public get KeyPointsCount(): number;
            public AddKeyPoint () : NaughtyBezierCurves.BezierPoint3D
            public AddKeyPointAt ($index: number) : NaughtyBezierCurves.BezierPoint3D
            public RemoveKeyPointAt ($index: number) : boolean
            public GetPoint ($time: number) : Unity.Mathematics.float3
            public GetRotation ($time: number, $up: Unity.Mathematics.float3) : Unity.Mathematics.quaternion
            public GetTangent ($time: number) : Unity.Mathematics.float3
            public GetBinormal ($time: number, $up: Unity.Mathematics.float3) : Unity.Mathematics.float3
            public GetNormal ($time: number, $up: Unity.Mathematics.float3) : Unity.Mathematics.float3
            public GetApproximateLength () : number
            public GetCubicSegment ($time: number, $startPoint: $Ref<NaughtyBezierCurves.BezierPoint3D>, $endPoint: $Ref<NaughtyBezierCurves.BezierPoint3D>, $timeRelativeToSegment: $Ref<number>) : void
            public static GetPointOnCubicCurve ($time: number, $startPoint: NaughtyBezierCurves.BezierPoint3D, $endPoint: NaughtyBezierCurves.BezierPoint3D) : Unity.Mathematics.float3
            public static GetPointOnCubicCurve ($time: number, $startPosition: Unity.Mathematics.float3, $endPosition: Unity.Mathematics.float3, $startTangent: Unity.Mathematics.float3, $endTangent: Unity.Mathematics.float3) : Unity.Mathematics.float3
            public static GetRotationOnCubicCurve ($time: number, $up: Unity.Mathematics.float3, $startPoint: NaughtyBezierCurves.BezierPoint3D, $endPoint: NaughtyBezierCurves.BezierPoint3D) : Unity.Mathematics.quaternion
            public static GetRotationOnCubicCurve ($time: number, $up: Unity.Mathematics.float3, $startPosition: Unity.Mathematics.float3, $endPosition: Unity.Mathematics.float3, $startTangent: Unity.Mathematics.float3, $endTangent: Unity.Mathematics.float3) : Unity.Mathematics.quaternion
            public static GetTangentOnCubicCurve ($time: number, $startPoint: NaughtyBezierCurves.BezierPoint3D, $endPoint: NaughtyBezierCurves.BezierPoint3D) : Unity.Mathematics.float3
            public static GetTangentOnCubicCurve ($time: number, $startPosition: Unity.Mathematics.float3, $endPosition: Unity.Mathematics.float3, $startTangent: Unity.Mathematics.float3, $endTangent: Unity.Mathematics.float3) : Unity.Mathematics.float3
            public static GetBinormalOnCubicCurve ($time: number, $up: Unity.Mathematics.float3, $startPoint: NaughtyBezierCurves.BezierPoint3D, $endPoint: NaughtyBezierCurves.BezierPoint3D) : Unity.Mathematics.float3
            public static GetBinormalOnCubicCurve ($time: number, $up: Unity.Mathematics.float3, $startPosition: Unity.Mathematics.float3, $endPosition: Unity.Mathematics.float3, $startTangent: Unity.Mathematics.float3, $endTangent: Unity.Mathematics.float3) : Unity.Mathematics.float3
            public static GetNormalOnCubicCurve ($time: number, $up: Unity.Mathematics.float3, $startPoint: NaughtyBezierCurves.BezierPoint3D, $endPoint: NaughtyBezierCurves.BezierPoint3D) : Unity.Mathematics.float3
            public static GetNormalOnCubicCurve ($time: number, $up: Unity.Mathematics.float3, $startPosition: Unity.Mathematics.float3, $endPosition: Unity.Mathematics.float3, $startTangent: Unity.Mathematics.float3, $endTangent: Unity.Mathematics.float3) : Unity.Mathematics.float3
            public static GetApproximateLengthOfCubicCurve ($startPoint: NaughtyBezierCurves.BezierPoint3D, $endPoint: NaughtyBezierCurves.BezierPoint3D, $sampling: number) : number
            public static GetApproximateLengthOfCubicCurve ($startPosition: Unity.Mathematics.float3, $endPosition: Unity.Mathematics.float3, $startTangent: Unity.Mathematics.float3, $endTangent: Unity.Mathematics.float3, $sampling: number) : number
            public constructor ()
        }
        class BezierPoint3D extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public LocalPosition : Unity.Mathematics.float3
            public get Curve(): NaughtyBezierCurves.BezierCurve3D;
            public set Curve(value: NaughtyBezierCurves.BezierCurve3D);
            public get CurvePosition(): Unity.Mathematics.float3;
            public get HandleStyle(): NaughtyBezierCurves.BezierPoint3D.HandleType;
            public set HandleStyle(value: NaughtyBezierCurves.BezierPoint3D.HandleType);
            public get Position(): Unity.Mathematics.float3;
            public set Position(value: Unity.Mathematics.float3);
            public get LeftHandleLocalPosition(): Unity.Mathematics.float3;
            public set LeftHandleLocalPosition(value: Unity.Mathematics.float3);
            public get InTangent(): Unity.Mathematics.float3;
            public set InTangent(value: Unity.Mathematics.float3);
            public get RightHandleLocalPosition(): Unity.Mathematics.float3;
            public set RightHandleLocalPosition(value: Unity.Mathematics.float3);
            public get OutTangent(): Unity.Mathematics.float3;
            public set OutTangent(value: Unity.Mathematics.float3);
            public get LeftHandlePosition(): Unity.Mathematics.float3;
            public get RightHandlePosition(): Unity.Mathematics.float3;
            public constructor ()
        }
    }
    namespace NaughtyBezierCurves.BezierPoint3D {
        enum HandleType
        { Connected = 0, Broken = 1 }
    }
    namespace LitJson {
        enum JsonType
        { None = 0, Object = 1, Array = 2, String = 3, Int = 4, Long = 5, Double = 6, Boolean = 7 }
        interface IJsonWrapper extends System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable, System.Collections.Specialized.IOrderedDictionary, System.Collections.IList
        {
            IsArray : boolean
            IsBoolean : boolean
            IsDouble : boolean
            IsInt : boolean
            IsLong : boolean
            IsObject : boolean
            IsString : boolean
            GetBoolean () : boolean
            GetDouble () : number
            GetInt () : number
            GetJsonType () : LitJson.JsonType
            GetLong () : bigint
            GetString () : string
            SetBoolean ($val: boolean) : void
            SetDouble ($val: number) : void
            SetInt ($val: number) : void
            SetJsonType ($type: LitJson.JsonType) : void
            SetLong ($val: bigint) : void
            SetString ($val: string) : void
            ToJson () : string
            ToJson ($writer: LitJson.JsonWriter) : void
        }
        class JsonWriter extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get IndentValue(): number;
            public set IndentValue(value: number);
            public get PrettyPrint(): boolean;
            public set PrettyPrint(value: boolean);
            public get TextWriter(): System.IO.TextWriter;
            public get Validate(): boolean;
            public set Validate(value: boolean);
            public get LowerCaseProperties(): boolean;
            public set LowerCaseProperties(value: boolean);
            public Reset () : void
            public Write ($boolean: boolean) : void
            public Write ($number: System.Decimal) : void
            public Write ($number: number) : void
            public Write ($number: bigint) : void
            public Write ($str: string) : void
            public WriteArrayEnd () : void
            public WriteArrayStart () : void
            public WriteObjectEnd () : void
            public WriteObjectStart () : void
            public WritePropertyName ($property_name: string) : void
            public constructor ()
            public constructor ($sb: System.Text.StringBuilder)
            public constructor ($writer: System.IO.TextWriter)
        }
        interface JsonWriter {
            WriteProperty ($name: string, $value: bigint) : void;
            WriteProperty ($name: string, $value: string) : void;
            WriteProperty ($name: string, $value: boolean) : void;
            WriteProperty ($name: string, $value: number) : void;
        }
        class JsonData extends System.Object implements LitJson.IJsonWrapper, System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable, System.IEquatable$1<LitJson.JsonData>, System.Collections.Specialized.IOrderedDictionary, System.Collections.IList
        {
            protected [__keep_incompatibility]: never;
            public get Count(): number;
            public get IsArray(): boolean;
            public get IsBoolean(): boolean;
            public get IsDouble(): boolean;
            public get IsInt(): boolean;
            public get IsLong(): boolean;
            public get IsObject(): boolean;
            public get IsString(): boolean;
            public get Keys(): System.Collections.Generic.ICollection$1<string>;
            public ContainsKey ($key: string) : boolean
            public get_Item ($prop_name: string) : LitJson.JsonData
            public set_Item ($prop_name: string, $value: LitJson.JsonData) : void
            public get_Item ($index: number) : LitJson.JsonData
            public set_Item ($index: number, $value: LitJson.JsonData) : void
            public static op_Implicit ($data: boolean) : LitJson.JsonData
            public static op_Implicit ($data: number) : LitJson.JsonData
            public static op_Implicit ($data: bigint) : LitJson.JsonData
            public static op_Implicit ($data: string) : LitJson.JsonData
            public static op_Explicit ($data: LitJson.JsonData) : boolean
            public static op_Explicit ($data: LitJson.JsonData) : number
            public static op_Explicit ($data: LitJson.JsonData) : bigint
            public static op_Explicit ($data: LitJson.JsonData) : string
            public Add ($value: any) : number
            public Remove ($obj: any) : boolean
            public Clear () : void
            public Equals ($x: LitJson.JsonData) : boolean
            public GetJsonType () : LitJson.JsonType
            public SetJsonType ($type: LitJson.JsonType) : void
            public ToJson () : string
            public ToJson ($writer: LitJson.JsonWriter) : void
            public constructor ()
            public constructor ($boolean: boolean)
            public constructor ($number: number)
            public constructor ($number: bigint)
            public constructor ($obj: any)
            public constructor ($str: string)
            public GetBoolean () : boolean
            public GetDouble () : number
            public GetInt () : number
            public GetLong () : bigint
            public GetString () : string
            public SetBoolean ($val: boolean) : void
            public SetDouble ($val: number) : void
            public SetInt ($val: number) : void
            public SetLong ($val: bigint) : void
            public SetString ($val: string) : void
            public Equals ($obj: any) : boolean
            public static Equals ($objA: any, $objB: any) : boolean
        }
        class JsonException extends System.ApplicationException implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
            public constructor ($message: string)
            public constructor ($message: string, $inner_exception: System.Exception)
        }
        interface WrapperFactory
        { 
        () : LitJson.IJsonWrapper; 
        Invoke?: () => LitJson.IJsonWrapper;
        }
        var WrapperFactory: { new (func: () => LitJson.IJsonWrapper): WrapperFactory; }
        class JsonMapper extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static ToJson ($obj: any, $prettyPrint?: boolean) : string
            public static ToJson ($obj: any, $writer: LitJson.JsonWriter) : void
            public static ToObject ($reader: LitJson.JsonReader) : LitJson.JsonData
            public static ToObject ($reader: System.IO.TextReader) : LitJson.JsonData
            public static ToObject ($json: string) : LitJson.JsonData
            public static ToObject ($json: string, $ConvertType: System.Type) : any
            public static ToWrapper ($factory: LitJson.WrapperFactory, $reader: LitJson.JsonReader) : LitJson.IJsonWrapper
            public static ToWrapper ($factory: LitJson.WrapperFactory, $json: string) : LitJson.IJsonWrapper
            public static UnregisterExporters () : void
            public static UnregisterImporters () : void
            public constructor ()
        }
        class JsonReader extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public get AllowComments(): boolean;
            public set AllowComments(value: boolean);
            public get AllowSingleQuotedStrings(): boolean;
            public set AllowSingleQuotedStrings(value: boolean);
            public get SkipNonMembers(): boolean;
            public set SkipNonMembers(value: boolean);
            public get EndOfInput(): boolean;
            public get EndOfJson(): boolean;
            public get Token(): LitJson.JsonToken;
            public get Value(): any;
            public Close () : void
            public Read () : boolean
            public constructor ($json_text: string)
            public constructor ($reader: System.IO.TextReader)
            public constructor ()
        }
        interface ExporterFunc$1<T>
        { 
        (obj: T, writer: LitJson.JsonWriter) : void; 
        Invoke?: (obj: T, writer: LitJson.JsonWriter) => void;
        }
        interface ImporterFunc$2<TJson, TValue>
        { 
        (input: TJson) : TValue; 
        Invoke?: (input: TJson) => TValue;
        }
        class JsonMockWrapper extends System.Object implements LitJson.IJsonWrapper, System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable, System.Collections.Specialized.IOrderedDictionary, System.Collections.IList
        {
            protected [__keep_incompatibility]: never;
            public get IsArray(): boolean;
            public get IsBoolean(): boolean;
            public get IsDouble(): boolean;
            public get IsInt(): boolean;
            public get IsLong(): boolean;
            public get IsObject(): boolean;
            public get IsString(): boolean;
            public GetBoolean () : boolean
            public GetDouble () : number
            public GetInt () : number
            public GetJsonType () : LitJson.JsonType
            public GetLong () : bigint
            public GetString () : string
            public SetBoolean ($val: boolean) : void
            public SetDouble ($val: number) : void
            public SetInt ($val: number) : void
            public SetJsonType ($type: LitJson.JsonType) : void
            public SetLong ($val: bigint) : void
            public SetString ($val: string) : void
            public ToJson () : string
            public ToJson ($writer: LitJson.JsonWriter) : void
            public constructor ()
        }
        enum JsonToken
        { None = 0, ObjectStart = 1, PropertyName = 2, ObjectEnd = 3, ArrayStart = 4, ArrayEnd = 5, Int = 6, Long = 7, Double = 8, String = 9, Boolean = 10, Null = 11 }
        class UnityTypeBindings extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static Register () : void
        }
    }
    namespace System.Collections.Specialized {
        interface IOrderedDictionary extends System.Collections.ICollection, System.Collections.IDictionary, System.Collections.IEnumerable
        {
        }
    }
    namespace LitJson.Extensions {
        class Extensions extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static WriteProperty ($w: LitJson.JsonWriter, $name: string, $value: bigint) : void
            public static WriteProperty ($w: LitJson.JsonWriter, $name: string, $value: string) : void
            public static WriteProperty ($w: LitJson.JsonWriter, $name: string, $value: boolean) : void
            public static WriteProperty ($w: LitJson.JsonWriter, $name: string, $value: number) : void
        }
        class JsonIgnore extends System.Attribute implements System.Runtime.InteropServices._Attribute
        {
            protected [__keep_incompatibility]: never;
            public constructor ()
        }
    }
    namespace B83.ExpressionParser {
        interface IValue
        {
            Value : number
        }
        class Number extends System.Object implements B83.ExpressionParser.IValue
        {
            protected [__keep_incompatibility]: never;
            public get Value(): number;
            public set Value(value: number);
            public constructor ($aValue: number)
            public constructor ()
        }
        class OperationSum extends System.Object implements B83.ExpressionParser.IValue
        {
            protected [__keep_incompatibility]: never;
            public get Value(): number;
            public constructor (...aValues: B83.ExpressionParser.IValue[])
            public constructor ()
        }
        class OperationProduct extends System.Object implements B83.ExpressionParser.IValue
        {
            protected [__keep_incompatibility]: never;
            public get Value(): number;
            public constructor (...aValues: B83.ExpressionParser.IValue[])
            public constructor ()
        }
        class OperationPower extends System.Object implements B83.ExpressionParser.IValue
        {
            protected [__keep_incompatibility]: never;
            public get Value(): number;
            public constructor ($aValue: B83.ExpressionParser.IValue, $aPower: B83.ExpressionParser.IValue)
            public constructor ()
        }
        class OperationNegate extends System.Object implements B83.ExpressionParser.IValue
        {
            protected [__keep_incompatibility]: never;
            public get Value(): number;
            public constructor ($aValue: B83.ExpressionParser.IValue)
            public constructor ()
        }
        class OperationReciprocal extends System.Object implements B83.ExpressionParser.IValue
        {
            protected [__keep_incompatibility]: never;
            public get Value(): number;
            public constructor ($aValue: B83.ExpressionParser.IValue)
            public constructor ()
        }
        class MultiParameterList extends System.Object implements B83.ExpressionParser.IValue
        {
            protected [__keep_incompatibility]: never;
            public get Parameters(): System.Array$1<B83.ExpressionParser.IValue>;
            public get Value(): number;
            public constructor (...aValues: B83.ExpressionParser.IValue[])
            public constructor ()
        }
        class CustomFunction extends System.Object implements B83.ExpressionParser.IValue
        {
            protected [__keep_incompatibility]: never;
            public get Value(): number;
            public constructor ($aName: string, $aDelegate: System.Func$2<System.Array$1<number>, number>, ...aValues: B83.ExpressionParser.IValue[])
            public constructor ()
        }
        class Parameter extends B83.ExpressionParser.Number implements B83.ExpressionParser.IValue
        {
            protected [__keep_incompatibility]: never;
            public get Name(): string;
            public constructor ($aName: string)
            public constructor ($aValue: number)
            public constructor ()
        }
        class Expression extends System.Object implements B83.ExpressionParser.IValue
        {
            protected [__keep_incompatibility]: never;
            public Parameters : System.Collections.Generic.Dictionary$2<string, B83.ExpressionParser.Parameter>
            public get ExpressionTree(): B83.ExpressionParser.IValue;
            public set ExpressionTree(value: B83.ExpressionParser.IValue);
            public get Value(): number;
            public get MultiValue(): System.Array$1<number>;
            public ToDelegate (...aParamOrder: string[]) : B83.ExpressionParser.ExpressionDelegate
            public ToMultiResultDelegate (...aParamOrder: string[]) : B83.ExpressionParser.MultiResultDelegate
            public static Parse ($aExpression: string) : B83.ExpressionParser.Expression
            public constructor ()
        }
        interface ExpressionDelegate
        { 
        (aParams: System.Array$1<number>) : number; 
        Invoke?: (aParams: System.Array$1<number>) => number;
        }
        var ExpressionDelegate: { new (func: (aParams: System.Array$1<number>) => number): ExpressionDelegate; }
        interface MultiResultDelegate
        { 
        (aParams: System.Array$1<number>) : System.Array$1<number>; 
        Invoke?: (aParams: System.Array$1<number>) => System.Array$1<number>;
        }
        var MultiResultDelegate: { new (func: (aParams: System.Array$1<number>) => System.Array$1<number>): MultiResultDelegate; }
        class ExpressionParser extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public AddFunc ($aName: string, $aMethod: System.Func$2<System.Array$1<number>, number>) : void
            public AddConst ($aName: string, $aMethod: System.Func$1<number>) : void
            public RemoveFunc ($aName: string) : void
            public RemoveConst ($aName: string) : void
            public EvaluateExpression ($aExpression: string) : B83.ExpressionParser.Expression
            public Evaluate ($aExpression: string) : number
            public static Eval ($aExpression: string) : number
            public constructor ()
        }
    }
    namespace B83.ExpressionParser.Expression {
        class ParameterException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ($aMessage: string)
            public constructor ()
        }
    }
    namespace B83.ExpressionParser.ExpressionParser {
        class ParseException extends System.Exception implements System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
        {
            protected [__keep_incompatibility]: never;
            public constructor ($aMessage: string)
            public constructor ()
        }
    }
    namespace Sirenix.OdinInspector {
        class SerializedScriptableObject extends UnityEngine.ScriptableObject implements UnityEngine.ISerializationCallbackReceiver
        {
            protected [__keep_incompatibility]: never;
            public OnBeforeSerialize () : void
            public OnAfterDeserialize () : void
        }
    }
    namespace DG.Tweening.Core {
        class ABSSequentiable extends System.Object
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace DG.Tweening {
        /** Indicates either a Tweener or a Sequence
        */
        class Tween extends DG.Tweening.Core.ABSSequentiable
        {
            protected [__keep_incompatibility]: never;
        }
        /** Animates a single value
        */
        class Tweener extends DG.Tweening.Tween
        {
            protected [__keep_incompatibility]: never;
        }
    }
    namespace AO.Events {
        class BeforeRunEventCmd extends System.ValueType implements AO.ICommand
        {
            protected [__keep_incompatibility]: never;
            public EventRun : AO.IEventRun
        }
        class AfterRunEventCmd extends System.ValueType implements AO.ICommand
        {
            protected [__keep_incompatibility]: never;
            public EventRun : AO.IEventRun
        }
    }
    namespace AO.EventType {
        class RequestCall extends System.Object
        {
            protected [__keep_incompatibility]: never;
            public static CallAction : System.Action$1<AO.EventType.RequestCall>
            public static SendAction : System.Action$1<ET.IMessage>
            public Request : ET.IRequest
            public Task : ET.ETTask$1<ET.IResponse>
            public Response : ET.IResponse
            public CallAsync ($request: ET.IRequest) : ET.ETTask$1<ET.IResponse>
            public constructor ()
        }
        class SessionEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Session : ET.Entity
            public Message : ET.IMessage
        }
        class SessionRemoveAcceptTimeoutComponentEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
        }
        class ActorReplyEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public FromProcess : number
            public Message : ET.IActorResponse
        }
        class ActorSendEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public ActorId : bigint
            public Message : ET.IMessage
        }
        class ActorLocationSendEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public EntityId : bigint
            public Message : ET.IActorLocationMessage
        }
        class BroadcastEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Unit : AO.IMapUnit
            public Message : ET.IMessage
        }
        class ActorCallEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Task : ET.ETTask$1<ET.IActorResponse>
            public ActorId : bigint
            public Message : ET.IActorRequest
        }
        class ActorLocationCallEvent extends System.ValueType
        {
            protected [__keep_incompatibility]: never;
            public Task : ET.ETTask$1<ET.IActorResponse>
            public EntityId : bigint
            public Message : ET.IActorLocationRequest
        }
    }
    namespace Puerts.JsEnv {
        interface JsEnvCreateCallback
        { 
        (env: Puerts.JsEnv, loader: Puerts.ILoader, debugPort: number) : void; 
        Invoke?: (env: Puerts.JsEnv, loader: Puerts.ILoader, debugPort: number) => void;
        }
        var JsEnvCreateCallback: { new (func: (env: Puerts.JsEnv, loader: Puerts.ILoader, debugPort: number) => void): JsEnvCreateCallback; }
        interface JsEnvDisposeCallback
        { 
        (env: Puerts.JsEnv) : void; 
        Invoke?: (env: Puerts.JsEnv) => void;
        }
        var JsEnvDisposeCallback: { new (func: (env: Puerts.JsEnv) => void): JsEnvDisposeCallback; }
    }
}
declare module 'csharp' {
export = CS;
}
// ycm
declare namespace CS{
namespace ET{
interface Entity{
GetComponentof: <T extends Entity>($TClass:Function & { prototype : T }) => T;
}
}
}
